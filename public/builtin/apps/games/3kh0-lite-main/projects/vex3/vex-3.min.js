// Made for 3kh0.github.io
//
// Â© Echo, 2022. Unauthorized use and/or duplication of this material without permission from Echo is strictly prohibited.
// Excerpts and links may be used, provided that clear credit is given with a link to the original content.

function x() {
    function a(a, b) { this.x = a || 0, this.y = b || 0 }

    function b(b, c) { this.pos = b || new a, this.r = c || 0 }

    function c(b, c) { this.pos = b || new a, this.angle = 0, this.offset = new a, this.u(c || []) }

    function d(b, c, d) { this.pos = b || new a, this.w = c || 0, this.h = d || 0 }

    function e() { this.b = this.a = null, this.overlapN = new a, this.overlapV = new a, this.clear() }

    function f(a, b, c) {
        for (var d = Number.MAX_VALUE, e = -Number.MAX_VALUE, f = a.length, g = 0; g < f; g++) {
            var h = a[g].f(b);
            h < d && (d = h), h > e && (e = h)
        }
        c[0] = d, c[1] = e
    }

    function g(a, b, c, d, e, g) {
        var h = n.pop(),
            i = n.pop();
        return a = l.pop().c(b).sub(a), b = a.f(e), f(c, e, h), f(d, e, i), i[0] += b, i[1] += b, h[0] > i[1] || i[0] > h[1] ? (l.push(a), n.push(h), n.push(i), !0) : (g && (h[0] < i[0] ? (g.aInB = !1, h[1] < i[1] ? (c = h[1] - i[0], g.bInA = !1) : (c = h[1] - i[0], d = i[1] - h[0], c = c < d ? c : -d)) : (g.bInA = !1, h[1] > i[1] ? (c = h[0] - i[1], g.aInB = !1) : (c = h[1] - i[0], d = i[1] - h[0], c = c < d ? c : -d)), d = Math.abs(c), d < g.overlap && (g.overlap = d, g.overlapN.c(e), 0 > c && g.overlapN.reverse())), l.push(a), n.push(h), n.push(i), !1)
    }

    function h(a, b) {
        var c = a.g(),
            d = b.f(a);
        return 0 > d ? -1 : d > c ? 1 : 0
    }

    function i(a, b, c) {
        for (var d = l.pop().c(b.pos).sub(a.pos), e = b.r, f = e * e, g = a.calcPoints, i = g.length, j = l.pop(), k = l.pop(), m = 0; m < i; m++) {
            var n = m === i - 1 ? 0 : m + 1,
                o = 0 === m ? i - 1 : m - 1,
                p = 0,
                q = null;
            j.c(a.edges[m]), k.c(d).sub(g[m]), c && k.g() > f && (c.aInB = !1);
            var r = h(j, k);
            if (-1 === r) {
                if (j.c(a.edges[o]), n = l.pop().c(d).sub(g[o]), r = h(j, n), 1 === r) {
                    if (r = k.j(), r > e) return l.push(d), l.push(j), l.push(k), l.push(n), !1;
                    c && (c.bInA = !1, q = k.normalize(), p = e - r)
                }
                l.push(n)
            }
            else if (1 === r) {
                if (j.c(a.edges[n]), k.c(d).sub(g[n]), r = h(j, k), -1 === r) {
                    if (r = k.j(), r > e) return l.push(d), l.push(j), l.push(k), !1;
                    c && (c.bInA = !1, q = k.normalize(), p = e - r)
                }
            }
            else {
                if (n = j.m().normalize(), r = k.f(n), o = Math.abs(r), 0 < r && o > e) return l.push(d), l.push(n), l.push(k), !1;
                c && (q = n, p = e - r, 0 <= r || p < 2 * e) && (c.bInA = !1)
            }
            q && c && Math.abs(p) < Math.abs(c.overlap) && (c.overlap = p, c.overlapN.c(q))
        }
        return c && (c.a = a, c.b = b, c.overlapV.c(c.overlapN).scale(c.overlap)), l.push(d), l.push(j), l.push(k), !0
    }

    function j(a, b, c) {
        for (var d = a.calcPoints, e = d.length, f = b.calcPoints, h = f.length, i = 0; i < e; i++)
            if (g(a.pos, b.pos, d, f, a.normals[i], c)) return !1;
        for (i = 0; i < h; i++)
            if (g(a.pos, b.pos, d, f, b.normals[i], c)) return !1;
        return c && (c.a = a, c.b = b, c.overlapV.c(c.overlapN).scale(c.overlap)), !0
    }
    var k = {};
    k.Vector = a, k.V = a, a.prototype.copy = a.prototype.c = function(a) { return this.x = a.x, this.y = a.y, this }, a.prototype.clone = a.prototype.clone = function() { return new a(this.x, this.y) }, a.prototype.perp = a.prototype.m = function() { var a = this.x; return this.x = this.y, this.y = -a, this }, a.prototype.rotate = a.prototype.rotate = function(a) {
        var b = this.x,
            c = this.y;
        return this.x = b * Math.cos(a) - c * Math.sin(a), this.y = b * Math.sin(a) + c * Math.cos(a), this
    }, a.prototype.reverse = a.prototype.reverse = function() { return this.x = -this.x, this.y = -this.y, this }, a.prototype.normalize = a.prototype.normalize = function() { var a = this.j(); return 0 < a && (this.x /= a, this.y /= a), this }, a.prototype.add = a.prototype.add = function(a) { return this.x += a.x, this.y += a.y, this }, a.prototype.sub = a.prototype.sub = function(a) { return this.x -= a.x, this.y -= a.y, this }, a.prototype.scale = a.prototype.scale = function(a, b) { return this.x *= a, this.y *= b || a, this }, a.prototype.project = a.prototype.o = function(a) { var b = this.f(a) / a.g(); return this.x = b * a.x, this.y = b * a.y, this }, a.prototype.projectN = a.prototype.s = function(a) { var b = this.f(a); return this.x = b * a.x, this.y = b * a.y, this }, a.prototype.reflect = function(a) {
        var b = this.x,
            c = this.y;
        return this.o(a).scale(2), this.x -= b, this.y -= c, this
    }, a.prototype.reflectN = function(a) {
        var b = this.x,
            c = this.y;
        return this.s(a).scale(2), this.x -= b, this.y -= c, this
    }, a.prototype.dot = a.prototype.f = function(a) { return this.x * a.x + this.y * a.y }, a.prototype.len2 = a.prototype.g = function() { return this.f(this) }, a.prototype.len = a.prototype.j = function() { return Math.sqrt(this.g()) }, k.Circle = b, b.prototype.getAABB = function() {
        var b = this.r,
            c = this.pos.clone().sub(new a(b, b));
        return new d(c, 2 * b, 2 * b).l()
    }, k.Polygon = c, c.prototype.setPoints = c.prototype.u = function(b) {
        if (!this.points || this.points.length !== b.length) {
            var c, d = this.calcPoints = [],
                e = this.edges = [],
                f = this.normals = [];
            for (c = 0; c < b.length; c++) d.push(new a), e.push(new a), f.push(new a)
        }
        return this.points = b, this.i(), this
    }, c.prototype.setAngle = function(a) { return this.angle = a, this.i(), this }, c.prototype.setOffset = function(a) { return this.offset = a, this.i(), this }, c.prototype.rotate = c.prototype.rotate = function(a) { for (var b = this.points, c = b.length, d = 0; d < c; d++) b[d].rotate(a); return this.i(), this }, c.prototype.translate = c.prototype.translate = function(a, b) { for (var c = this.points, d = c.length, e = 0; e < d; e++) c[e].x += a, c[e].y += b; return this.i(), this }, c.prototype.i = function() {
        var a, b = this.calcPoints,
            c = this.edges,
            d = this.normals,
            e = this.points,
            f = this.offset,
            g = this.angle,
            h = e.length;
        for (a = 0; a < h; a++) {
            var i = b[a].c(e[a]);
            i.x += f.x, i.y += f.y, 0 !== g && i.rotate(g)
        }
        for (a = 0; a < h; a++) e = b[a], e = c[a].c(a < h - 1 ? b[a + 1] : b[0]).sub(e), d[a].c(e).m().normalize()
    }, c.prototype.getAABB = function() {
        for (var b = this.calcPoints, c = b.length, e = b[0].x, f = b[0].y, g = b[0].x, h = b[0].y, i = 1; i < c; i++) {
            var j = b[i];
            j.x < e ? e = j.x : j.x > g && (g = j.x), j.y < f ? f = j.y : j.y > h && (h = j.y)
        }
        return new d(this.pos.clone().add(new a(e, f)), g - e, h - f).l()
    }, k.Box = d, d.prototype.toPolygon = d.prototype.l = function() {
        var b = this.pos,
            d = this.w,
            e = this.h;
        return new c(new a(b.x, b.y), [new a, new a(d, 0), new a(d, e), new a(0, e)])
    }, k.Response = e, e.prototype.clear = e.prototype.clear = function() { return this.bInA = this.aInB = !0, this.overlap = Number.MAX_VALUE, this };
    for (var l = [], m = 0; 10 > m; m++) l.push(new a);
    for (var n = [], m = 0; 5 > m; m++) n.push([]);
    var o = new e,
        p = new d(new a, 1e-6, 1e-6).l();
    return k.isSeparatingAxis = g, k.pointInCircle = function(a, b) {
        var c = l.pop().c(a).sub(b.pos),
            d = b.r * b.r,
            e = c.g();
        return l.push(c), e <= d
    }, k.pointInPolygon = function(a, b) { p.pos.c(a), o.clear(); var c = j(p, b, o); return c && (c = o.aInB), c }, k.testCircleCircle = function(a, b, c) {
        var d = l.pop().c(b.pos).sub(a.pos),
            e = a.r + b.r,
            f = d.g();
        return f > e * e ? (l.push(d), !1) : (c && (f = Math.sqrt(f), c.a = a, c.b = b, c.overlap = e - f, c.overlapN.c(d.normalize()), c.overlapV.c(d).scale(c.overlap), c.aInB = a.r <= b.r && f <= b.r - a.r, c.bInA = b.r <= a.r && f <= a.r - b.r), l.push(d), !0)
    }, k.testPolygonCircle = i, k.testCirclePolygon = function(a, b, c) {
        if ((a = i(b, a, c)) && c) {
            b = c.a;
            var d = c.aInB;
            c.overlapN.reverse(), c.overlapV.reverse(), c.a = c.b, c.b = b, c.aInB = c.bInA, c.bInA = d
        }
        return a
    }, k.testPolygonPolygon = j, k
}

function timeDecorator(a) {
    var b = Math.floor(a / 100 % 10),
        c = b.toString();
    b < 10 && (c = "0" + b);
    var d = Math.floor(a / 1e3 % 60),
        e = d.toString();
    d < 10 && (e = "0" + e);
    var f = Math.floor(a / 1e3 / 60 % 60),
        g = f.toString();
    return f < 10 && (g = "0" + g), g + ":" + e + ":" + c
}

function timeDecoratorHub(a) {
    var b = (Math.floor(a / 100), Math.floor(a / 1e3 % 60)),
        c = b.toString();
    b < 10 && (c = "0" + c);
    var d = Math.floor(a / 1e3 / 60 % 60),
        e = d.toString();
    d < 10 && (e = "0" + e);
    var f = Math.floor(a / 1e3 / 60 / 60 | 0),
        g = f.toString();
    return f < 10 && (g = "0" + g), g + ":" + e + ":" + c
}

function timeDecoratorActBlock(a) {
    var b = Math.floor(a / 1e3 % 60),
        c = b.toString();
    b < 10 && (c = "0" + c);
    var d = Math.floor(a / 1e3 / 60 % 60),
        e = d.toString();
    return d < 10 && (e = "0" + e), e + ":" + c
}

function getDeathText(a) {
    var b, c = "";
    switch (a) {
        case 1:
            c = Math.random() < .5 ? "Splattered!" : "Hard landing!";
            break;
        case 2:
            b = Math.random(), c = b < .33 ? "Shredded!" : b < .66 ? "Buzzkill!" : "Sawed to bits!";
            break;
        case 3:
            b = Math.random(), c = b < .33 ? "Crushed!" : b < .66 ? "Squashed!" : "Too compressed!";
            break;
        case 4:
            b = Math.random(), c = b < .33 ? "Lungs collapsed!" : b < .66 ? "Drowned!" : "Sleeping with no fishes...!";
            break;
        case 5:
            b = Math.random(), c = b < .33 ? "Fell out the world!" : b < .66 ? "Straight to hell.!" : "Fell too far!";
            break;
        case 6:
            c = "No entry!";
            break;
        case 7:
            b = Math.random(), c = b < .33 ? "Squished." : b < .66 ? "Squashed." : "Crushed.";
            break;
        case 8:
            b = Math.random(), c = b < .25 ? "Reaped." : b < .5 ? "Scythed." : b < .75 ? "Grim death." : "Decapitated.";
            break;
        case 9:
            b = Math.random(), c = b < .33 ? "tried shurikenjutsu!" : b < .66 ? "Bad ninja!" : "Sliced and diced!";
            break;
        case 10:
            c = Math.random() < .5 ? "Death four-ways!" : "Sliced and diced!";
            break;
        case 11:
            b = Math.random(), c = b < .33 ? "Electrocuted!" : b < .66 ? "Sparked out!" : "Shocking.";
            break;
        case 12:
            b = Math.random(), c = b < .33 ? "Crushed!" : b < .66 ? "Squashed!" : "Too compressed!";
            break;
        case 13:
            b = Math.random(), c = b < .33 ? "Swiped." : b < .66 ? "Rushed off your feet." : "Ripped to bits";
            break;
        case 14:
            b = Math.random(), c = b < .33 ? "Obliterated!" : b < .66 ? "Splasered!" : "Fried vexman!";
            break;
        case 15:
            c = Math.random() < .5 ? "Surprised spiked!" : "Penetrated!";
            break;
        default:
            c = Math.random() < .5 ? "Spiked!" : "Popped!"
    }
    return c
}! function(a) {
    if ("object" == typeof exports) module.exports = a();
    else if ("function" == typeof define, 1) { var b; "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self), b.p2 = a() }
    else define(a)
}(function() {
    return function a(b, c, d) {
        function e(g, h) {
            if (!c[g]) {
                if (!b[g]) { var i = "function" == typeof require && require; if (!h && i) return i(g, !0); if (f) return f(g, !0); throw new Error("Cannot find module '" + g + "'") }
                var j = c[g] = { exports: {} };
                b[g][0].call(j.exports, function(a) { var c = b[g][1][a]; return e(c ? c : a) }, j, j.exports, a, b, c, d)
            }
            return c[g].exports
        }
        for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
        return e
    }({
        1: [function(a, b, c) {
            function d() {}
            var e = a("./Scalar");
            b.exports = d, d.lineInt = function(a, b, c) { c = c || 0; var d, f, g, h, i, j, k, l = [0, 0]; return d = a[1][1] - a[0][1], f = a[0][0] - a[1][0], g = d * a[0][0] + f * a[0][1], h = b[1][1] - b[0][1], i = b[0][0] - b[1][0], j = h * b[0][0] + i * b[0][1], k = d * i - h * f, e.eq(k, 0, c) || (l[0] = (i * g - f * j) / k, l[1] = (d * j - h * g) / k), l }, d.segmentsIntersect = function(a, b, c, d) {
                var e = b[0] - a[0],
                    f = b[1] - a[1],
                    g = d[0] - c[0],
                    h = d[1] - c[1];
                if (g * f - h * e == 0) return !1;
                var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e),
                    j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
                return i >= 0 && i <= 1 && j >= 0 && j <= 1
            }
        }, { "./Scalar": 4 }],
        2: [function(a, b, c) {
            function d() {} b.exports = d, d.area = function(a, b, c) { return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) }, d.left = function(a, b, c) { return d.area(a, b, c) > 0 }, d.leftOn = function(a, b, c) { return d.area(a, b, c) >= 0 }, d.right = function(a, b, c) { return d.area(a, b, c) < 0 }, d.rightOn = function(a, b, c) { return d.area(a, b, c) <= 0 };
            var e = [],
                f = [];
            d.collinear = function(a, b, c, g) {
                if (g) {
                    var h = e,
                        i = f;
                    h[0] = b[0] - a[0], h[1] = b[1] - a[1], i[0] = c[0] - b[0], i[1] = c[1] - b[1];
                    var j = h[0] * i[0] + h[1] * i[1],
                        k = Math.sqrt(h[0] * h[0] + h[1] * h[1]),
                        l = Math.sqrt(i[0] * i[0] + i[1] * i[1]),
                        m = Math.acos(j / (k * l));
                    return m < g
                }
                return 0 == d.area(a, b, c)
            }, d.sqdist = function(a, b) {
                var c = b[0] - a[0],
                    d = b[1] - a[1];
                return c * c + d * d
            }
        }, {}],
        3: [function(a, b, c) {
            function d() { this.vertices = [] }

            function e(a, b, c, d, e) {
                e = e || 0;
                var f = b[1] - a[1],
                    g = a[0] - b[0],
                    i = f * a[0] + g * a[1],
                    j = d[1] - c[1],
                    k = c[0] - d[0],
                    l = j * c[0] + k * c[1],
                    m = f * k - j * g;
                return h.eq(m, 0, e) ? [0, 0] : [(k * i - g * l) / m, (f * l - j * i) / m]
            }
            var f = a("./Line"),
                g = a("./Point"),
                h = a("./Scalar");
            b.exports = d, d.prototype.at = function(a) {
                var b = this.vertices,
                    c = b.length;
                return b[a < 0 ? a % c + c : a % c]
            }, d.prototype.first = function() { return this.vertices[0] }, d.prototype.last = function() { return this.vertices[this.vertices.length - 1] }, d.prototype.clear = function() { this.vertices.length = 0 }, d.prototype.append = function(a, b, c) { if ("undefined" == typeof b) throw new Error("From is not given!"); if ("undefined" == typeof c) throw new Error("To is not given!"); if (c - 1 < b) throw new Error("lol1"); if (c > a.vertices.length) throw new Error("lol2"); if (b < 0) throw new Error("lol3"); for (var d = b; d < c; d++) this.vertices.push(a.vertices[d]) }, d.prototype.makeCCW = function() {
                for (var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c)(b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) && (a = c);
                g.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse()
            }, d.prototype.reverse = function() {
                for (var a = [], b = 0, c = this.vertices.length; b !== c; b++) a.push(this.vertices.pop());
                this.vertices = a
            }, d.prototype.isReflex = function(a) { return g.right(this.at(a - 1), this.at(a), this.at(a + 1)) };
            var i = [],
                j = [];
            d.prototype.canSee = function(a, b) {
                var c, d, e = i,
                    h = j;
                if (g.leftOn(this.at(a + 1), this.at(a), this.at(b)) && g.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
                d = g.sqdist(this.at(a), this.at(b));
                for (var k = 0; k !== this.vertices.length; ++k)
                    if ((k + 1) % this.vertices.length !== a && k !== a && g.leftOn(this.at(a), this.at(b), this.at(k + 1)) && g.rightOn(this.at(a), this.at(b), this.at(k)) && (e[0] = this.at(a), e[1] = this.at(b), h[0] = this.at(k), h[1] = this.at(k + 1), c = f.lineInt(e, h), g.sqdist(this.at(a), c) < d)) return !1;
                return !0
            }, d.prototype.copy = function(a, b, c) {
                var e = c || new d;
                if (e.clear(), a < b)
                    for (var f = a; f <= b; f++) e.vertices.push(this.vertices[f]);
                else { for (var f = 0; f <= b; f++) e.vertices.push(this.vertices[f]); for (var f = a; f < this.vertices.length; f++) e.vertices.push(this.vertices[f]) }
                return e
            }, d.prototype.getCutEdges = function() {
                for (var a = [], b = [], c = [], e = new d, f = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g)
                    if (this.isReflex(g))
                        for (var h = 0; h < this.vertices.length; ++h)
                            if (this.canSee(g, h)) {
                                b = this.copy(g, h, e).getCutEdges(), c = this.copy(h, g, e).getCutEdges();
                                for (var i = 0; i < c.length; i++) b.push(c[i]);
                                b.length < f && (a = b, f = b.length, a.push([this.at(g), this.at(h)]))
                            }
                return a
            }, d.prototype.decomp = function() { var a = this.getCutEdges(); return a.length > 0 ? this.slice(a) : [this] }, d.prototype.slice = function(a) {
                if (0 == a.length) return [this];
                if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                    for (var b = [this], c = 0; c < a.length; c++)
                        for (var d = a[c], e = 0; e < b.length; e++) {
                            var f = b[e],
                                g = f.slice(d);
                            if (g) { b.splice(e, 1), b.push(g[0], g[1]); break }
                        }
                    return b
                }
                var d = a,
                    c = this.vertices.indexOf(d[0]),
                    e = this.vertices.indexOf(d[1]);
                return c != -1 && e != -1 && [this.copy(c, e), this.copy(e, c)]
            }, d.prototype.isSimple = function() {
                for (var a = this.vertices, b = 0; b < a.length - 1; b++)
                    for (var c = 0; c < b - 1; c++)
                        if (f.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) return !1;
                for (var b = 1; b < a.length - 2; b++)
                    if (f.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
                return !0
            }, d.prototype.quickDecomp = function(a, b, c, f, h, i) {
                h = h || 100, i = i || 0, f = f || 25, a = "undefined" != typeof a ? a : [], b = b || [], c = c || [];
                var j = [0, 0],
                    k = [0, 0],
                    l = [0, 0],
                    m = 0,
                    n = 0,
                    o = 0,
                    p = 0,
                    q = 0,
                    r = 0,
                    s = 0,
                    t = new d,
                    u = new d,
                    v = this,
                    w = this.vertices;
                if (w.length < 3) return a;
                if (i++, i > h) return a;
                for (var x = 0; x < this.vertices.length; ++x)
                    if (v.isReflex(x)) {
                        b.push(v.vertices[x]), m = n = Number.MAX_VALUE;
                        for (var y = 0; y < this.vertices.length; ++y) g.left(v.at(x - 1), v.at(x), v.at(y)) && g.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) && (l = e(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1)), g.right(v.at(x + 1), v.at(x), l) && (o = g.sqdist(v.vertices[x], l), o < n && (n = o, k = l, r = y))), g.left(v.at(x + 1), v.at(x), v.at(y + 1)) && g.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (l = e(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1)), g.left(v.at(x - 1), v.at(x), l) && (o = g.sqdist(v.vertices[x], l), o < m && (m = o, j = l, q = y)));
                        if (r == (q + 1) % this.vertices.length) l[0] = (k[0] + j[0]) / 2, l[1] = (k[1] + j[1]) / 2, c.push(l), x < q ? (t.append(v, x, q + 1), t.vertices.push(l), u.vertices.push(l), 0 != r && u.append(v, r, v.vertices.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, v.vertices.length), t.append(v, 0, q + 1), t.vertices.push(l), u.vertices.push(l), u.append(v, r, x + 1));
                        else {
                            if (r > q && (q += this.vertices.length), p = Number.MAX_VALUE, q < r) return a;
                            for (var y = r; y <= q; ++y) g.leftOn(v.at(x - 1), v.at(x), v.at(y)) && g.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = g.sqdist(v.at(x), v.at(y)), o < p && (p = o, s = y % this.vertices.length));
                            x < s ? (t.append(v, x, s + 1), 0 != s && u.append(v, s, w.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length), t.append(v, 0, s + 1), u.append(v, s, x + 1))
                        }
                        return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, c, f, h, i), u.quickDecomp(a, b, c, f, h, i)) : (u.quickDecomp(a, b, c, f, h, i), t.quickDecomp(a, b, c, f, h, i)), a
                    }
                return a.push(this), a
            }, d.prototype.removeCollinearPoints = function(a) { for (var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c) g.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1), c--, b++); return b }
        }, { "./Line": 1, "./Point": 2, "./Scalar": 4 }],
        4: [function(a, b, c) {
            function d() {} b.exports = d, d.eq = function(a, b, c) { return c = c || 0, Math.abs(a - b) < c }
        }, {}],
        5: [function(a, b, c) { b.exports = { Polygon: a("./Polygon"), Point: a("./Point") } }, { "./Point": 2, "./Polygon": 3 }],
        6: [function(a, b, c) { b.exports = { name: "p2", version: "0.7.0", description: "A JavaScript 2D physics engine.", author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords: ["p2.js", "p2", "physics", "engine", "2d"], main: "./src/p2.js", engines: { node: "*" }, repository: { type: "git", url: "https://github.com/schteppe/p2.js.git" }, bugs: { url: "https://github.com/schteppe/p2.js/issues" }, licenses: [{ type: "MIT" }], devDependencies: { grunt: "^0.4.5", "grunt-contrib-jshint": "^0.11.2", "grunt-contrib-nodeunit": "^0.4.1", "grunt-contrib-uglify": "~0.4.0", "grunt-contrib-watch": "~0.5.0", "grunt-browserify": "~2.0.1", "grunt-contrib-concat": "^0.4.0" }, dependencies: { "poly-decomp": "0.1.0" } } }, {}],
        7: [function(a, b, c) {
            function d(a) { this.lowerBound = e.create(), a && a.lowerBound && e.copy(this.lowerBound, a.lowerBound), this.upperBound = e.create(), a && a.upperBound && e.copy(this.upperBound, a.upperBound) }
            var e = a("../math/vec2");
            a("../utils/Utils");
            b.exports = d;
            var f = e.create();
            d.prototype.setFromPoints = function(a, b, c, d) {
                var g = this.lowerBound,
                    h = this.upperBound;
                "number" != typeof c && (c = 0), 0 !== c ? e.rotate(g, a[0], c) : e.copy(g, a[0]), e.copy(h, g);
                for (var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++) {
                    var l = a[k];
                    if (0 !== c) {
                        var m = l[0],
                            n = l[1];
                        f[0] = i * m - j * n, f[1] = j * m + i * n, l = f
                    }
                    for (var o = 0; o < 2; o++) l[o] > h[o] && (h[o] = l[o]), l[o] < g[o] && (g[o] = l[o])
                }
                b && (e.add(this.lowerBound, this.lowerBound, b), e.add(this.upperBound, this.upperBound, b)), d && (this.lowerBound[0] -= d, this.lowerBound[1] -= d, this.upperBound[0] += d, this.upperBound[1] += d)
            }, d.prototype.copy = function(a) { e.copy(this.lowerBound, a.lowerBound), e.copy(this.upperBound, a.upperBound) }, d.prototype.extend = function(a) {
                for (var b = 2; b--;) {
                    var c = a.lowerBound[b];
                    this.lowerBound[b] > c && (this.lowerBound[b] = c);
                    var d = a.upperBound[b];
                    this.upperBound[b] < d && (this.upperBound[b] = d)
                }
            }, d.prototype.overlaps = function(a) {
                var b = this.lowerBound,
                    c = this.upperBound,
                    d = a.lowerBound,
                    e = a.upperBound;
                return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1])
            }, d.prototype.containsPoint = function(a) {
                var b = this.lowerBound,
                    c = this.upperBound;
                return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1]
            }, d.prototype.overlapsRay = function(a) {
                var b = 1 / a.direction[0],
                    c = 1 / a.direction[1],
                    d = (this.lowerBound[0] - a.from[0]) * b,
                    e = (this.upperBound[0] - a.from[0]) * b,
                    f = (this.lowerBound[1] - a.from[1]) * c,
                    g = (this.upperBound[1] - a.from[1]) * c,
                    h = Math.max(Math.max(Math.min(d, e), Math.min(f, g))),
                    i = Math.min(Math.min(Math.max(d, e), Math.max(f, g)));
                return i < 0 ? -1 : h > i ? -1 : h
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57 }],
        8: [function(a, b, c) {
            function d(a) { this.type = a, this.result = [], this.world = null, this.boundingVolumeType = d.AABB }
            var e = a("../math/vec2"),
                f = a("../objects/Body");
            b.exports = d, d.AABB = 1, d.BOUNDING_CIRCLE = 2, d.prototype.setWorld = function(a) { this.world = a }, d.prototype.getCollisionPairs = function(a) {};
            var g = e.create();
            d.boundingRadiusCheck = function(a, b) {
                e.sub(g, a.position, b.position);
                var c = e.squaredLength(g),
                    d = a.boundingRadius + b.boundingRadius;
                return c <= d * d
            }, d.aabbCheck = function(a, b) { return a.getAABB().overlaps(b.getAABB()) }, d.prototype.boundingVolumeCheck = function(a, b) {
                var c;
                switch (this.boundingVolumeType) {
                    case d.BOUNDING_CIRCLE:
                        c = d.boundingRadiusCheck(a, b);
                        break;
                    case d.AABB:
                        c = d.aabbCheck(a, b);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return c
            }, d.canCollide = function(a, b) {
                var c = f.KINEMATIC,
                    d = f.STATIC;
                return (a.type !== d || b.type !== d) && (!(a.type === c && b.type === d || a.type === d && b.type === c) && ((a.type !== c || b.type !== c) && ((a.sleepState !== f.SLEEPING || b.sleepState !== f.SLEEPING) && !(a.sleepState === f.SLEEPING && b.type === d || b.sleepState === f.SLEEPING && a.type === d))))
            }, d.NAIVE = 1, d.SAP = 2
        }, { "../math/vec2": 30, "../objects/Body": 31 }],
        9: [function(a, b, c) {
            function d() { e.call(this, e.NAIVE) }
            var e = (a("../shapes/Circle"), a("../shapes/Plane"), a("../shapes/Shape"), a("../shapes/Particle"), a("../collision/Broadphase"));
            a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.getCollisionPairs = function(a) {
                var b = a.bodies,
                    c = this.result;
                c.length = 0;
                for (var d = 0, f = b.length; d !== f; d++)
                    for (var g = b[d], h = 0; h < d; h++) {
                        var i = b[h];
                        e.canCollide(g, i) && this.boundingVolumeCheck(g, i) && c.push(g, i)
                    }
                return c
            }, d.prototype.aabbQuery = function(a, b, c) {
                c = c || [];
                for (var d = a.bodies, e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.aabbNeedsUpdate && f.updateAABB(), f.aabb.overlaps(b) && c.push(f)
                }
                return c
            }
        }, { "../collision/Broadphase": 8, "../math/vec2": 30, "../shapes/Circle": 39, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45 }],
        10: [function(a, b, c) {
            function d() { this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new k({ size: 32 }), this.frictionEquationPool = new l({ size: 64 }), this.restitution = 0, this.stiffness = n.DEFAULT_STIFFNESS, this.relaxation = n.DEFAULT_RELAXATION, this.frictionStiffness = n.DEFAULT_STIFFNESS, this.frictionRelaxation = n.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new m, this.contactSkinSize = .01 }

            function e(a, b) { g.set(a.vertices[0], .5 * -b.length, -b.radius), g.set(a.vertices[1], .5 * b.length, -b.radius), g.set(a.vertices[2], .5 * b.length, b.radius), g.set(a.vertices[3], .5 * -b.length, b.radius) }

            function f(a, b, c, d) {
                for (var e = T, f = U, j = V, k = W, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++) {
                    var p = m[o % m.length],
                        q = m[(o + 1) % m.length];
                    g.rotate(e, p, d), g.rotate(f, q, d), i(e, e, c), i(f, f, c), h(j, e, l), h(k, f, l);
                    var r = g.crossLength(j, k);
                    if (null === n && (n = r), r * n <= 0) return !1;
                    n = r
                }
                return !0
            }
            var g = a("../math/vec2"),
                h = g.sub,
                i = g.add,
                j = g.dot,
                k = (a("../utils/Utils"), a("../utils/ContactEquationPool")),
                l = a("../utils/FrictionEquationPool"),
                m = a("../utils/TupleDictionary"),
                n = a("../equations/Equation"),
                o = (a("../equations/ContactEquation"), a("../equations/FrictionEquation"), a("../shapes/Circle")),
                p = a("../shapes/Convex"),
                q = a("../shapes/Shape"),
                r = (a("../objects/Body"), a("../shapes/Box"));
            b.exports = d;
            var s = g.fromValues(0, 1),
                t = g.fromValues(0, 0),
                u = g.fromValues(0, 0),
                v = g.fromValues(0, 0),
                w = g.fromValues(0, 0),
                x = g.fromValues(0, 0),
                y = g.fromValues(0, 0),
                z = g.fromValues(0, 0),
                A = g.fromValues(0, 0),
                B = g.fromValues(0, 0),
                C = g.fromValues(0, 0),
                D = g.fromValues(0, 0),
                E = g.fromValues(0, 0),
                F = g.fromValues(0, 0),
                G = g.fromValues(0, 0),
                H = g.fromValues(0, 0),
                I = g.fromValues(0, 0),
                J = g.fromValues(0, 0),
                K = g.fromValues(0, 0),
                L = [],
                M = g.create(),
                N = g.create();
            d.prototype.bodiesOverlap = function(a, b) {
                for (var c = M, d = N, e = 0, f = a.shapes.length; e !== f; e++) {
                    var g = a.shapes[e];
                    a.toWorldFrame(c, g.position);
                    for (var h = 0, i = b.shapes.length; h !== i; h++) { var j = b.shapes[h]; if (b.toWorldFrame(d, j.position), this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0)) return !0 }
                }
                return !1
            }, d.prototype.collidedLastStep = function(a, b) {
                var c = 0 | a.id,
                    d = 0 | b.id;
                return !!this.collidingBodiesLastStep.get(c, d)
            }, d.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var a = this.contactEquations, b = a.length; b--;) {
                    var c = a[b],
                        d = c.bodyA.id,
                        e = c.bodyB.id;
                    this.collidingBodiesLastStep.set(d, e, !0)
                }
                for (var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++) this.contactEquationPool.release(f[h]);
                for (var h = 0; h < g.length; h++) this.frictionEquationPool.release(g[h]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, d.prototype.createContactEquation = function(a, b, c, d) { var e = this.contactEquationPool.get(); return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.restitution = this.restitution, e.firstImpact = !this.collidedLastStep(a, b), e.stiffness = this.stiffness, e.relaxation = this.relaxation, e.needsUpdate = !0, e.enabled = this.enabledEquations, e.offset = this.contactSkinSize, e }, d.prototype.createFrictionEquation = function(a, b, c, d) { var e = this.frictionEquationPool.get(); return e.bodyA = a, e.bodyB = b, e.shapeA = c, e.shapeB = d, e.setSlipForce(this.slipForce), e.frictionCoefficient = this.frictionCoefficient, e.relativeVelocity = this.surfaceVelocity, e.enabled = this.enabledEquations, e.needsUpdate = !0, e.stiffness = this.frictionStiffness, e.relaxation = this.frictionRelaxation, e.contactEquations.length = 0, e }, d.prototype.createFrictionFromContact = function(a) { var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB); return g.copy(b.contactPointA, a.contactPointA), g.copy(b.contactPointB, a.contactPointB), g.rotate90cw(b.t, a.normalA), b.contactEquations.push(a), b }, d.prototype.createFrictionFromAverage = function(a) {
                var b = this.contactEquations[this.contactEquations.length - 1],
                    c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB),
                    d = b.bodyA;
                b.bodyB;
                g.set(c.contactPointA, 0, 0), g.set(c.contactPointB, 0, 0), g.set(c.t, 0, 0);
                for (var e = 0; e !== a; e++) b = this.contactEquations[this.contactEquations.length - 1 - e], b.bodyA === d ? (g.add(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointA), g.add(c.contactPointB, c.contactPointB, b.contactPointB)) : (g.sub(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointB), g.add(c.contactPointB, c.contactPointB, b.contactPointA)), c.contactEquations.push(b);
                var f = 1 / a;
                return g.scale(c.contactPointA, c.contactPointA, f), g.scale(c.contactPointB, c.contactPointB, f), g.normalize(c.t, c.t), g.rotate90cw(c.t, c.t), c
            }, d.prototype[q.LINE | q.CONVEX] = d.prototype.convexLine = function(a, b, c, d, e, f, g, h, i) { return !i && 0 }, d.prototype[q.LINE | q.BOX] = d.prototype.lineBox = function(a, b, c, d, e, f, g, h, i) { return !i && 0 };
            var O = new r({ width: 1, height: 1 }),
                P = g.create();
            d.prototype[q.CAPSULE | q.CONVEX] = d.prototype[q.CAPSULE | q.BOX] = d.prototype.convexCapsule = function(a, b, c, d, f, h, i, j, k) {
                var l = P;
                g.set(l, h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
                var m = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                g.set(l, -h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
                var n = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
                if (k && (m || n)) return !0;
                var o = O;
                e(o, h);
                var p = this.convexConvex(a, b, c, d, f, o, i, j, k);
                return p + m + n
            }, d.prototype[q.CAPSULE | q.LINE] = d.prototype.lineCapsule = function(a, b, c, d, e, f, g, h, i) { return !i && 0 };
            var Q = g.create(),
                R = g.create(),
                S = new r({ width: 1, height: 1 });
            d.prototype[q.CAPSULE | q.CAPSULE] = d.prototype.capsuleCapsule = function(a, b, c, d, f, h, i, j, k) {
                for (var l, m = Q, n = R, o = 0, p = 0; p < 2; p++) {
                    g.set(m, (0 === p ? -1 : 1) * b.length / 2, 0), g.rotate(m, m, d), g.add(m, m, c);
                    for (var q = 0; q < 2; q++) {
                        g.set(n, (0 === q ? -1 : 1) * h.length / 2, 0), g.rotate(n, n, j), g.add(n, n, i), this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                        var r = this.circleCircle(a, b, m, d, f, h, n, j, k, b.radius, h.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = l), k && r) return !0;
                        o += r
                    }
                }
                this.enableFrictionReduction && (l = this.enableFriction, this.enableFriction = !1);
                var s = S;
                e(s, b);
                var t = this.convexCapsule(a, s, c, d, f, h, i, j, k);
                if (this.enableFrictionReduction && (this.enableFriction = l), k && t) return !0;
                if (o += t, this.enableFrictionReduction) {
                    var l = this.enableFriction;
                    this.enableFriction = !1
                }
                e(s, h);
                var u = this.convexCapsule(f, s, i, j, a, b, c, d, k);
                return this.enableFrictionReduction && (this.enableFriction = l), !(!k || !u) || (o += u, this.enableFrictionReduction && o && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(o)), o)
            }, d.prototype[q.LINE | q.LINE] = d.prototype.lineLine = function(a, b, c, d, e, f, g, h, i) { return !i && 0 }, d.prototype[q.PLANE | q.LINE] = d.prototype.planeLine = function(a, b, c, d, e, f, k, l, m) {
                var n = t,
                    o = u,
                    p = v,
                    q = w,
                    r = x,
                    C = y,
                    D = z,
                    E = A,
                    F = B,
                    G = L,
                    H = 0;
                g.set(n, -f.length / 2, 0), g.set(o, f.length / 2, 0), g.rotate(p, n, l), g.rotate(q, o, l), i(p, p, k), i(q, q, k), g.copy(n, p), g.copy(o, q), h(r, o, n), g.normalize(C, r), g.rotate90cw(F, C), g.rotate(E, s, d), G[0] = n, G[1] = o;
                for (var I = 0; I < G.length; I++) {
                    var J = G[I];
                    h(D, J, c);
                    var K = j(D, E);
                    if (K < 0) {
                        if (m) return !0;
                        var M = this.createContactEquation(a, e, b, f);
                        H++, g.copy(M.normalA, E), g.normalize(M.normalA, M.normalA), g.scale(D, E, K), h(M.contactPointA, J, D), h(M.contactPointA, M.contactPointA, a.position), h(M.contactPointB, J, k), i(M.contactPointB, M.contactPointB, k), h(M.contactPointB, M.contactPointB, e.position), this.contactEquations.push(M), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                    }
                }
                return !m && (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)), H)
            }, d.prototype[q.PARTICLE | q.CAPSULE] = d.prototype.particleCapsule = function(a, b, c, d, e, f, g, h, i) { return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0) }, d.prototype[q.CIRCLE | q.LINE] = d.prototype.circleLine = function(a, b, c, d, e, f, k, l, m, n, o) {
                var n = n || 0,
                    o = "undefined" != typeof o ? o : b.radius,
                    p = t,
                    q = u,
                    r = v,
                    s = w,
                    H = x,
                    I = y,
                    J = z,
                    K = A,
                    M = B,
                    N = C,
                    O = D,
                    P = E,
                    Q = F,
                    R = G,
                    S = L;
                g.set(K, -f.length / 2, 0), g.set(M, f.length / 2, 0), g.rotate(N, K, l), g.rotate(O, M, l), i(N, N, k), i(O, O, k), g.copy(K, N), g.copy(M, O), h(I, M, K), g.normalize(J, I), g.rotate90cw(H, J), h(P, c, K);
                var T = j(P, H);
                h(s, K, k), h(Q, c, k);
                var U = o + n;
                if (Math.abs(T) < U) {
                    g.scale(p, H, T), h(r, c, p), g.scale(q, H, j(H, Q)), g.normalize(q, q), g.scale(q, q, n), i(r, r, q);
                    var V = j(J, r),
                        W = j(J, K),
                        X = j(J, M);
                    if (V > W && V < X) { if (m) return !0; var Y = this.createContactEquation(a, e, b, f); return g.scale(Y.normalA, p, -1), g.normalize(Y.normalA, Y.normalA), g.scale(Y.contactPointA, Y.normalA, o), i(Y.contactPointA, Y.contactPointA, c), h(Y.contactPointA, Y.contactPointA, a.position), h(Y.contactPointB, r, k), i(Y.contactPointB, Y.contactPointB, k), h(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1 }
                }
                S[0] = K, S[1] = M;
                for (var Z = 0; Z < S.length; Z++) { var $ = S[Z]; if (h(P, $, c), g.squaredLength(P) < Math.pow(U, 2)) { if (m) return !0; var Y = this.createContactEquation(a, e, b, f); return g.copy(Y.normalA, P), g.normalize(Y.normalA, Y.normalA), g.scale(Y.contactPointA, Y.normalA, o), i(Y.contactPointA, Y.contactPointA, c), h(Y.contactPointA, Y.contactPointA, a.position), h(Y.contactPointB, $, k), g.scale(R, Y.normalA, -n), i(Y.contactPointB, Y.contactPointB, R), i(Y.contactPointB, Y.contactPointB, k), h(Y.contactPointB, Y.contactPointB, e.position), this.contactEquations.push(Y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)), 1 } }
                return 0
            }, d.prototype[q.CIRCLE | q.CAPSULE] = d.prototype.circleCapsule = function(a, b, c, d, e, f, g, h, i) { return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius) }, d.prototype[q.CIRCLE | q.CONVEX] = d.prototype[q.CIRCLE | q.BOX] = d.prototype.circleConvex = function(a, b, c, d, e, j, k, l, m, n) {
                for (var n = "number" == typeof n ? n : b.radius, o = t, p = u, q = v, r = w, s = x, y = C, z = D, A = F, B = G, E = H, J = I, K = !1, L = Number.MAX_VALUE, M = j.vertices, N = 0; N !== M.length + 1; N++) {
                    var O = M[N % M.length],
                        P = M[(N + 1) % M.length];
                    if (g.rotate(o, O, l), g.rotate(p, P, l), i(o, o, k), i(p, p, k), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), g.scale(B, s, -b.radius), i(B, B, c), f(B, j, k, l)) {
                        g.sub(E, o, B);
                        var Q = Math.abs(g.dot(E, s));
                        Q < L && (g.copy(J, B), L = Q, g.scale(A, s, Q), g.add(A, A, B), K = !0)
                    }
                }
                if (K) { if (m) return !0; var R = this.createContactEquation(a, e, b, j); return g.sub(R.normalA, J, c), g.normalize(R.normalA, R.normalA), g.scale(R.contactPointA, R.normalA, n), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, A, k), i(R.contactPointB, R.contactPointB, k), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1 }
                if (n > 0)
                    for (var N = 0; N < M.length; N++) { var S = M[N]; if (g.rotate(z, S, l), i(z, z, k), h(y, z, c), g.squaredLength(y) < Math.pow(n, 2)) { if (m) return !0; var R = this.createContactEquation(a, e, b, j); return g.copy(R.normalA, y), g.normalize(R.normalA, R.normalA), g.scale(R.contactPointA, R.normalA, n), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, z, k), i(R.contactPointB, R.contactPointB, k), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1 } }
                return 0
            };
            var T = g.create(),
                U = g.create(),
                V = g.create(),
                W = g.create();
            d.prototype[q.PARTICLE | q.CONVEX] = d.prototype[q.PARTICLE | q.BOX] = d.prototype.particleConvex = function(a, b, c, d, e, k, l, m, n) {
                var o = t,
                    p = u,
                    q = v,
                    r = w,
                    s = x,
                    A = y,
                    B = z,
                    D = C,
                    E = F,
                    G = J,
                    H = K,
                    I = Number.MAX_VALUE,
                    L = !1,
                    M = k.vertices;
                if (!f(c, k, l, m)) return 0;
                if (n) return !0;
                for (var N = 0; N !== M.length + 1; N++) {
                    var O = M[N % M.length],
                        P = M[(N + 1) % M.length];
                    g.rotate(o, O, m), g.rotate(p, P, m), i(o, o, l), i(p, p, l), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), h(D, c, o);
                    j(D, s);
                    h(A, o, l), h(B, c, l), g.sub(G, o, c);
                    var Q = Math.abs(g.dot(G, s));
                    Q < I && (I = Q, g.scale(E, s, Q), g.add(E, E, c), g.copy(H, s), L = !0)
                }
                if (L) { var R = this.createContactEquation(a, e, b, k); return g.scale(R.normalA, H, -1), g.normalize(R.normalA, R.normalA), g.set(R.contactPointA, 0, 0), i(R.contactPointA, R.contactPointA, c), h(R.contactPointA, R.contactPointA, a.position), h(R.contactPointB, E, l), i(R.contactPointB, R.contactPointB, l), h(R.contactPointB, R.contactPointB, e.position), this.contactEquations.push(R), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)), 1 }
                return 0
            }, d.prototype[q.CIRCLE] = d.prototype.circleCircle = function(a, b, c, d, e, f, j, k, l, m, n) {
                var o = t,
                    m = m || b.radius,
                    n = n || f.radius;
                h(o, c, j);
                var p = m + n;
                if (g.squaredLength(o) > Math.pow(p, 2)) return 0;
                if (l) return !0;
                var q = this.createContactEquation(a, e, b, f);
                return h(q.normalA, j, c), g.normalize(q.normalA, q.normalA),
                    g.scale(q.contactPointA, q.normalA, m), g.scale(q.contactPointB, q.normalA, -n), i(q.contactPointA, q.contactPointA, c), h(q.contactPointA, q.contactPointA, a.position), i(q.contactPointB, q.contactPointB, j), h(q.contactPointB, q.contactPointB, e.position), this.contactEquations.push(q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)), 1
            }, d.prototype[q.PLANE | q.CONVEX] = d.prototype[q.PLANE | q.BOX] = d.prototype.planeConvex = function(a, b, c, d, e, f, k, l, m) {
                var n = t,
                    o = u,
                    p = v,
                    q = 0;
                g.rotate(o, s, d);
                for (var r = 0; r !== f.vertices.length; r++) {
                    var w = f.vertices[r];
                    if (g.rotate(n, w, l), i(n, n, k), h(p, n, c), j(p, o) <= 0) {
                        if (m) return !0;
                        q++;
                        var x = this.createContactEquation(a, e, b, f);
                        h(p, n, c), g.copy(x.normalA, o);
                        var y = j(p, x.normalA);
                        g.scale(p, x.normalA, y), h(x.contactPointB, n, e.position), h(x.contactPointA, n, p), h(x.contactPointA, x.contactPointA, a.position), this.contactEquations.push(x), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)), q
            }, d.prototype[q.PARTICLE | q.PLANE] = d.prototype.particlePlane = function(a, b, c, d, e, f, i, k, l) {
                var m = t,
                    n = u;
                k = k || 0, h(m, c, i), g.rotate(n, s, k);
                var o = j(m, n);
                if (o > 0) return 0;
                if (l) return !0;
                var p = this.createContactEquation(e, a, f, b);
                return g.copy(p.normalA, n), g.scale(m, p.normalA, o), h(p.contactPointA, c, m), h(p.contactPointA, p.contactPointA, e.position), h(p.contactPointB, c, a.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
            }, d.prototype[q.CIRCLE | q.PARTICLE] = d.prototype.circleParticle = function(a, b, c, d, e, f, j, k, l) { var m = t; if (h(m, j, c), g.squaredLength(m) > Math.pow(b.radius, 2)) return 0; if (l) return !0; var n = this.createContactEquation(a, e, b, f); return g.copy(n.normalA, m), g.normalize(n.normalA, n.normalA), g.scale(n.contactPointA, n.normalA, b.radius), i(n.contactPointA, n.contactPointA, c), h(n.contactPointA, n.contactPointA, a.position), h(n.contactPointB, j, e.position), this.contactEquations.push(n), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)), 1 };
            var X = new o({ radius: 1 }),
                Y = g.create(),
                Z = g.create();
            g.create();
            d.prototype[q.PLANE | q.CAPSULE] = d.prototype.planeCapsule = function(a, b, c, d, e, f, h, j, k) {
                var l = Y,
                    m = Z,
                    n = X;
                g.set(l, -f.length / 2, 0), g.rotate(l, l, j), i(l, l, h), g.set(m, f.length / 2, 0), g.rotate(m, m, j), i(m, m, h), n.radius = f.radius;
                var o;
                this.enableFrictionReduction && (o = this.enableFriction, this.enableFriction = !1);
                var p = this.circlePlane(e, n, l, 0, a, b, c, d, k),
                    q = this.circlePlane(e, n, m, 0, a, b, c, d, k);
                if (this.enableFrictionReduction && (this.enableFriction = o), k) return p || q;
                var r = p + q;
                return this.enableFrictionReduction && r && this.frictionEquations.push(this.createFrictionFromAverage(r)), r
            }, d.prototype[q.CIRCLE | q.PLANE] = d.prototype.circlePlane = function(a, b, c, d, e, f, k, l, m) {
                var n = a,
                    o = b,
                    p = c,
                    q = e,
                    r = k,
                    w = l;
                w = w || 0;
                var x = t,
                    y = u,
                    z = v;
                h(x, p, r), g.rotate(y, s, w);
                var A = j(y, x);
                if (A > o.radius) return 0;
                if (m) return !0;
                var B = this.createContactEquation(q, n, f, b);
                return g.copy(B.normalA, y), g.scale(B.contactPointB, B.normalA, -o.radius), i(B.contactPointB, B.contactPointB, p), h(B.contactPointB, B.contactPointB, n.position), g.scale(z, B.normalA, A), h(B.contactPointA, x, z), i(B.contactPointA, B.contactPointA, r), h(B.contactPointA, B.contactPointA, q.position), this.contactEquations.push(B), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)), 1
            }, d.prototype[q.CONVEX] = d.prototype[q.CONVEX | q.BOX] = d.prototype[q.BOX] = d.prototype.convexConvex = function(a, b, c, e, f, k, l, m, n, o) {
                var p = t,
                    q = u,
                    r = v,
                    s = w,
                    y = x,
                    C = z,
                    D = A,
                    E = B,
                    F = 0,
                    o = "number" == typeof o ? o : 0,
                    G = d.findSeparatingAxis(b, c, e, k, l, m, p);
                if (!G) return 0;
                h(D, l, c), j(p, D) > 0 && g.scale(p, p, -1);
                var H = d.getClosestEdge(b, e, p, !0),
                    I = d.getClosestEdge(k, m, p);
                if (H === -1 || I === -1) return 0;
                for (var J = 0; J < 2; J++) {
                    var K = H,
                        L = I,
                        M = b,
                        N = k,
                        O = c,
                        P = l,
                        Q = e,
                        R = m,
                        S = a,
                        T = f;
                    if (0 === J) {
                        var U;
                        U = K, K = L, L = U, U = M, M = N, N = U, U = O, O = P, P = U, U = Q, Q = R, R = U, U = S, S = T, T = U
                    }
                    for (var V = L; V < L + 2; V++) {
                        var W = N.vertices[(V + N.vertices.length) % N.vertices.length];
                        g.rotate(q, W, R), i(q, q, P);
                        for (var X = 0, Y = K - 1; Y < K + 2; Y++) {
                            var Z = M.vertices[(Y + M.vertices.length) % M.vertices.length],
                                $ = M.vertices[(Y + 1 + M.vertices.length) % M.vertices.length];
                            g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(E, y), g.normalize(E, E), h(D, q, r);
                            var _ = j(E, D);
                            (Y === K && _ <= o || Y !== K && _ <= 0) && X++
                        }
                        if (X >= 3) {
                            if (n) return !0;
                            var aa = this.createContactEquation(S, T, M, N);
                            F++;
                            var Z = M.vertices[K % M.vertices.length],
                                $ = M.vertices[(K + 1) % M.vertices.length];
                            g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(aa.normalA, y), g.normalize(aa.normalA, aa.normalA), h(D, q, r);
                            var _ = j(aa.normalA, D);
                            g.scale(C, aa.normalA, _), h(aa.contactPointA, q, O), h(aa.contactPointA, aa.contactPointA, C), i(aa.contactPointA, aa.contactPointA, O), h(aa.contactPointA, aa.contactPointA, S.position), h(aa.contactPointB, q, P), i(aa.contactPointB, aa.contactPointB, P), h(aa.contactPointB, aa.contactPointB, T.position), this.contactEquations.push(aa), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(aa))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && F && this.frictionEquations.push(this.createFrictionFromAverage(F)), F
            };
            var $ = g.fromValues(0, 0);
            d.projectConvexOntoAxis = function(a, b, c, d, e) {
                var f, h, i = null,
                    k = null,
                    l = $;
                g.rotate(l, d, -c);
                for (var m = 0; m < a.vertices.length; m++) f = a.vertices[m], h = j(f, l), (null === i || h > i) && (i = h), (null === k || h < k) && (k = h);
                if (k > i) {
                    var n = k;
                    k = i, i = n
                }
                var o = j(b, d);
                g.set(e, k + o, i + o)
            };
            var _ = g.fromValues(0, 0),
                aa = g.fromValues(0, 0),
                ba = g.fromValues(0, 0),
                ca = g.fromValues(0, 0),
                da = g.fromValues(0, 0),
                ea = g.fromValues(0, 0);
            d.findSeparatingAxis = function(a, b, c, e, f, i, j) {
                var k = null,
                    l = !1,
                    m = !1,
                    n = _,
                    o = aa,
                    p = ba,
                    q = ca,
                    s = da,
                    t = ea;
                if (a instanceof r && e instanceof r)
                    for (var u = 0; 2 !== u; u++) {
                        var v = a,
                            w = c;
                        1 === u && (v = e, w = i);
                        for (var x = 0; 2 !== x; x++) {
                            0 === x ? g.set(q, 0, 1) : 1 === x && g.set(q, 1, 0), 0 !== w && g.rotate(q, q, w), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                            var y = s,
                                z = t,
                                A = !1;
                            s[0] > t[0] && (z = s, y = t, A = !0);
                            var B = z[0] - y[1];
                            l = B <= 0, (null === k || B > k) && (g.copy(j, q), k = B, m = l)
                        }
                    }
                else
                    for (var u = 0; 2 !== u; u++) {
                        var v = a,
                            w = c;
                        1 === u && (v = e, w = i);
                        for (var x = 0; x !== v.vertices.length; x++) {
                            g.rotate(o, v.vertices[x], w), g.rotate(p, v.vertices[(x + 1) % v.vertices.length], w), h(n, p, o), g.rotate90cw(q, n), g.normalize(q, q), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                            var y = s,
                                z = t,
                                A = !1;
                            s[0] > t[0] && (z = s, y = t, A = !0);
                            var B = z[0] - y[1];
                            l = B <= 0, (null === k || B > k) && (g.copy(j, q), k = B, m = l)
                        }
                    }
                return m
            };
            var fa = g.fromValues(0, 0),
                ga = g.fromValues(0, 0),
                ha = g.fromValues(0, 0);
            d.getClosestEdge = function(a, b, c, d) {
                var e = fa,
                    f = ga,
                    i = ha;
                g.rotate(e, c, -b), d && g.scale(e, e, -1);
                for (var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++) {
                    h(f, a.vertices[(n + 1) % l], a.vertices[n % l]), g.rotate90cw(i, f), g.normalize(i, i);
                    var o = j(i, e);
                    (k === -1 || o > m) && (k = n % l, m = o)
                }
                return k
            };
            var ia = g.create(),
                ja = g.create(),
                ka = g.create(),
                la = g.create(),
                ma = g.create(),
                na = g.create(),
                oa = g.create();
            d.prototype[q.CIRCLE | q.HEIGHTFIELD] = d.prototype.circleHeightfield = function(a, b, c, d, e, f, j, k, l, m) {
                var n = f.heights,
                    m = m || b.radius,
                    o = f.elementWidth,
                    p = ja,
                    q = ia,
                    r = ma,
                    s = oa,
                    t = na,
                    u = ka,
                    v = la,
                    w = Math.floor((c[0] - m - j[0]) / o),
                    x = Math.ceil((c[0] + m - j[0]) / o);
                w < 0 && (w = 0), x >= n.length && (x = n.length - 1);
                for (var y = n[w], z = n[x], A = w; A < x; A++) n[A] < z && (z = n[A]), n[A] > y && (y = n[A]);
                if (c[1] - m > y) return !l && 0;
                for (var B = !1, A = w; A < x; A++) {
                    g.set(u, A * o, n[A]), g.set(v, (A + 1) * o, n[A + 1]), g.add(u, u, j), g.add(v, v, j), g.sub(t, v, u), g.rotate(t, t, Math.PI / 2), g.normalize(t, t), g.scale(q, t, -m), g.add(q, q, c), g.sub(p, q, u);
                    var C = g.dot(p, t);
                    if (q[0] >= u[0] && q[0] < v[0] && C <= 0) {
                        if (l) return !0;
                        B = !0, g.scale(p, t, -C), g.add(r, q, p), g.copy(s, t);
                        var D = this.createContactEquation(e, a, f, b);
                        g.copy(D.normalA, s), g.scale(D.contactPointB, D.normalA, -m), i(D.contactPointB, D.contactPointB, c), h(D.contactPointB, D.contactPointB, a.position), g.copy(D.contactPointA, r), g.sub(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                    }
                }
                if (B = !1, m > 0)
                    for (var A = w; A <= x; A++)
                        if (g.set(u, A * o, n[A]), g.add(u, u, j), g.sub(p, c, u), g.squaredLength(p) < Math.pow(m, 2)) {
                            if (l) return !0;
                            B = !0;
                            var D = this.createContactEquation(e, a, f, b);
                            g.copy(D.normalA, p), g.normalize(D.normalA, D.normalA), g.scale(D.contactPointB, D.normalA, -m), i(D.contactPointB, D.contactPointB, c), h(D.contactPointB, D.contactPointB, a.position), h(D.contactPointA, u, j), i(D.contactPointA, D.contactPointA, j), h(D.contactPointA, D.contactPointA, e.position), this.contactEquations.push(D), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                        }
                return B ? 1 : 0
            };
            var pa = g.create(),
                qa = g.create(),
                ra = g.create(),
                sa = new p({ vertices: [g.create(), g.create(), g.create(), g.create()] });
            d.prototype[q.BOX | q.HEIGHTFIELD] = d.prototype[q.CONVEX | q.HEIGHTFIELD] = d.prototype.convexHeightfield = function(a, b, c, d, e, f, h, i, j) {
                var k = f.heights,
                    l = f.elementWidth,
                    m = pa,
                    n = qa,
                    o = ra,
                    p = sa,
                    q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l),
                    r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
                q < 0 && (q = 0), r >= k.length && (r = k.length - 1);
                for (var s = k[q], t = k[r], u = q; u < r; u++) k[u] < t && (t = k[u]), k[u] > s && (s = k[u]);
                if (a.aabb.lowerBound[1] > s) return !j && 0;
                for (var v = 0, u = q; u < r; u++) {
                    g.set(m, u * l, k[u]), g.set(n, (u + 1) * l, k[u + 1]), g.add(m, m, h), g.add(n, n, h);
                    var w = 100;
                    g.set(o, .5 * (n[0] + m[0]), .5 * (n[1] + m[1] - w)), g.sub(p.vertices[0], n, o), g.sub(p.vertices[1], m, o), g.copy(p.vertices[2], p.vertices[1]), g.copy(p.vertices[3], p.vertices[0]), p.vertices[2][1] -= w, p.vertices[3][1] -= w, v += this.convexConvex(a, b, c, d, e, p, o, 0, j)
                }
                return v
            }
        }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../shapes/Box": 37, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Shape": 45, "../utils/ContactEquationPool": 48, "../utils/FrictionEquationPool": 49, "../utils/TupleDictionary": 56, "../utils/Utils": 57 }],
        11: [function(a, b, c) {
            function d(a) { a = a || {}, this.from = a.from ? f.fromValues(a.from[0], a.from[1]) : f.create(), this.to = a.to ? f.fromValues(a.to[0], a.to[1]) : f.create(), this.checkCollisionResponse = void 0 === a.checkCollisionResponse || a.checkCollisionResponse, this.skipBackfaces = !!a.skipBackfaces, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1, this.mode = void 0 !== a.mode ? a.mode : d.ANY, this.callback = a.callback || function(a) {}, this.direction = f.create(), this.length = 1, this.update() }

            function e(a, b, c) { f.sub(h, c, a); var d = f.dot(h, b); return f.scale(i, b, d), f.add(i, i, a), f.squaredDistance(c, i) } b.exports = d;
            var f = a("../math/vec2");
            a("../collision/RaycastResult"), a("../shapes/Shape"), a("../collision/AABB");
            d.prototype.constructor = d, d.CLOSEST = 1, d.ANY = 2, d.ALL = 4, d.prototype.update = function() {
                var a = this.direction;
                f.sub(a, this.to, this.from), this.length = f.length(a), f.normalize(a, a)
            }, d.prototype.intersectBodies = function(a, b) {
                for (var c = 0, d = b.length; !a.shouldStop(this) && c < d; c++) {
                    var e = b[c],
                        f = e.getAABB();
                    (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e)
                }
            };
            var g = f.create();
            d.prototype.intersectBody = function(a, b) {
                var c = this.checkCollisionResponse;
                if (!c || b.collisionResponse)
                    for (var d = g, e = 0, h = b.shapes.length; e < h; e++) { var i = b.shapes[e]; if ((!c || i.collisionResponse) && 0 !== (this.collisionGroup & i.collisionMask) && 0 !== (i.collisionGroup & this.collisionMask)) { f.rotate(d, i.position, b.angle), f.add(d, d, b.position); var j = i.angle + b.angle; if (this.intersectShape(a, i, j, d, b), a.shouldStop(this)) break } }
            }, d.prototype.intersectShape = function(a, b, c, d, f) {
                var g = this.from,
                    h = e(g, this.direction, d);
                h > b.boundingRadius * b.boundingRadius || (this._currentBody = f, this._currentShape = b, b.raycast(a, this, d, c), this._currentBody = this._currentShape = null)
            }, d.prototype.getAABB = function(a) {
                var b = this.to,
                    c = this.from;
                f.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])), f.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]))
            };
            f.create();
            d.prototype.reportIntersection = function(a, b, c, e) {
                var g = (this.from, this.to, this._currentShape),
                    h = this._currentBody;
                if (!(this.skipBackfaces && f.dot(c, this.direction) > 0)) switch (this.mode) {
                    case d.ALL:
                        a.set(c, g, h, b, e), this.callback(a);
                        break;
                    case d.CLOSEST:
                        (b < a.fraction || !a.hasHit()) && a.set(c, g, h, b, e);
                        break;
                    case d.ANY:
                        a.set(c, g, h, b, e)
                }
            };
            var h = f.create(),
                i = f.create()
        }, { "../collision/AABB": 7, "../collision/RaycastResult": 12, "../math/vec2": 30, "../shapes/Shape": 45 }],
        12: [function(a, b, c) {
            function d() { this.normal = e.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 }
            var e = a("../math/vec2"),
                f = a("../collision/Ray");
            b.exports = d, d.prototype.reset = function() { e.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 }, d.prototype.getHitDistance = function(a) { return e.distance(a.from, a.to) * this.fraction }, d.prototype.hasHit = function() { return this.fraction !== -1 }, d.prototype.getHitPoint = function(a, b) { e.lerp(a, b.from, b.to, this.fraction) }, d.prototype.stop = function() { this.isStopped = !0 }, d.prototype.shouldStop = function(a) { return this.isStopped || this.fraction !== -1 && a.mode === f.ANY }, d.prototype.set = function(a, b, c, d, f) { e.copy(this.normal, a), this.shape = b, this.body = c, this.fraction = d, this.faceIndex = f }
        }, { "../collision/Ray": 11, "../math/vec2": 30 }],
        13: [function(a, b, c) {
            function d() {
                f.call(this, f.SAP), this.axisList = [], this.axisIndex = 0;
                var a = this;
                this._addBodyHandler = function(b) { a.axisList.push(b.body) }, this._removeBodyHandler = function(b) {
                    var c = a.axisList.indexOf(b.body);
                    c !== -1 && a.axisList.splice(c, 1)
                }
            }
            var e = a("../utils/Utils"),
                f = a("../collision/Broadphase");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.setWorld = function(a) { this.axisList.length = 0, e.appendArray(this.axisList, a.bodies), a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = a }, d.sortAxisList = function(a, b) {
                b = 0 | b;
                for (var c = 1, d = a.length; c < d; c++) {
                    for (var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--) a[f + 1] = a[f];
                    a[f + 1] = e
                }
                return a
            }, d.prototype.sortList = function() {
                var a = this.axisList,
                    b = this.axisIndex;
                d.sortAxisList(a, b)
            }, d.prototype.getCollisionPairs = function(a) {
                var b = this.axisList,
                    c = this.result,
                    d = this.axisIndex;
                c.length = 0;
                for (var e = b.length; e--;) {
                    var g = b[e];
                    g.aabbNeedsUpdate && g.updateAABB()
                }
                this.sortList();
                for (var h = 0, i = 0 | b.length; h !== i; h++)
                    for (var j = b[h], k = h + 1; k < i; k++) {
                        var l = b[k],
                            m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
                        if (!m) break;
                        f.canCollide(j, l) && this.boundingVolumeCheck(j, l) && c.push(j, l)
                    }
                return c
            }, d.prototype.aabbQuery = function(a, b, c) {
                c = c || [], this.sortList();
                var d = this.axisIndex,
                    e = "x";
                1 === d && (e = "y"), 2 === d && (e = "z");
                for (var f = this.axisList, g = (b.lowerBound[e], b.upperBound[e], 0); g < f.length; g++) {
                    var h = f[g];
                    h.aabbNeedsUpdate && h.updateAABB(), h.aabb.overlaps(b) && c.push(h)
                }
                return c
            }
        }, { "../collision/Broadphase": 8, "../utils/Utils": 57 }],
        14: [function(a, b, c) {
            function d(a, b, c, d) { this.type = c, d = e.defaults(d, { collideConnected: !0, wakeUpBodies: !0 }), this.equations = [], this.bodyA = a, this.bodyB = b, this.collideConnected = d.collideConnected, d.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp()) } b.exports = d;
            var e = a("../utils/Utils");
            d.prototype.update = function() { throw new Error("method update() not implmemented in this Constraint subclass!") }, d.DISTANCE = 1, d.GEAR = 2, d.LOCK = 3, d.PRISMATIC = 4, d.REVOLUTE = 5, d.prototype.setStiffness = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.stiffness = a, d.needsUpdate = !0
                }
            }, d.prototype.setRelaxation = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.relaxation = a, d.needsUpdate = !0
                }
            }
        }, { "../utils/Utils": 57 }],
        15: [function(a, b, c) {
            function d(a, b, c) {
                c = h.defaults(c, { localAnchorA: [0, 0], localAnchorB: [0, 0] }), e.call(this, a, b, e.DISTANCE, c), this.localAnchorA = g.fromValues(c.localAnchorA[0], c.localAnchorA[1]), this.localAnchorB = g.fromValues(c.localAnchorB[0], c.localAnchorB[1]);
                var d = this.localAnchorA,
                    i = this.localAnchorB;
                if (this.distance = 0, "number" == typeof c.distance) this.distance = c.distance;
                else {
                    var j = g.create(),
                        k = g.create(),
                        l = g.create();
                    g.rotate(j, d, a.angle), g.rotate(k, i, b.angle), g.add(l, b.position, k), g.sub(l, l, j), g.sub(l, l, a.position), this.distance = g.length(l)
                }
                var m;
                m = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce;
                var n = new f(a, b, (-m), m);
                this.equations = [n], this.maxForce = m;
                var l = g.create(),
                    o = g.create(),
                    p = g.create(),
                    q = this;
                n.computeGq = function() {
                    var a = this.bodyA,
                        b = this.bodyB,
                        c = a.position,
                        e = b.position;
                    return g.rotate(o, d, a.angle), g.rotate(p, i, b.angle), g.add(l, e, p), g.sub(l, l, o), g.sub(l, l, c), g.length(l) - q.distance
                }, this.setMaxForce(m), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }
            var e = a("./Constraint"),
                f = a("../equations/Equation"),
                g = a("../math/vec2"),
                h = a("../utils/Utils");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d;
            var i = g.create(),
                j = g.create(),
                k = g.create();
            d.prototype.update = function() {
                var a = this.equations[0],
                    b = this.bodyA,
                    c = this.bodyB,
                    d = (this.distance, b.position),
                    e = c.position,
                    f = this.equations[0],
                    h = a.G;
                g.rotate(j, this.localAnchorA, b.angle), g.rotate(k, this.localAnchorB, c.angle), g.add(i, e, k), g.sub(i, i, j), g.sub(i, i, d), this.position = g.length(i);
                var l = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (f.maxForce = 0, f.minForce = -this.maxForce, this.distance = this.upperLimit, l = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (f.maxForce = this.maxForce, f.minForce = 0, this.distance = this.lowerLimit, l = !0), (this.lowerLimitEnabled || this.upperLimitEnabled) && !l) return void(f.enabled = !1);
                f.enabled = !0, g.normalize(i, i);
                var m = g.crossLength(j, i),
                    n = g.crossLength(k, i);
                h[0] = -i[0], h[1] = -i[1], h[2] = -m, h[3] = i[0], h[4] = i[1], h[5] = n
            }, d.prototype.setMaxForce = function(a) {
                var b = this.equations[0];
                b.minForce = -a, b.maxForce = a
            }, d.prototype.getMaxForce = function() { var a = this.equations[0]; return a.maxForce }
        }, { "../equations/Equation": 22, "../math/vec2": 30, "../utils/Utils": 57, "./Constraint": 14 }],
        16: [function(a, b, c) {
            function d(a, b, c) { c = c || {}, e.call(this, a, b, e.GEAR, c), this.ratio = void 0 !== c.ratio ? c.ratio : 1, this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle, c.angle = this.angle, c.ratio = this.ratio, this.equations = [new f(a, b, c)], void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque) }
            var e = a("./Constraint"),
                f = (a("../equations/Equation"), a("../equations/AngleLockEquation"));
            a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.update = function() {
                var a = this.equations[0];
                a.ratio !== this.ratio && a.setRatio(this.ratio), a.angle = this.angle
            }, d.prototype.setMaxTorque = function(a) { this.equations[0].setMaxTorque(a) }, d.prototype.getMaxTorque = function(a) { return this.equations[0].maxForce }
        }, { "../equations/AngleLockEquation": 20, "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }],
        17: [function(a, b, c) {
            function d(a, b, c) {
                c = c || {}, e.call(this, a, b, e.LOCK, c);
                var d = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce,
                    h = (c.localAngleB || 0, new g(a, b, (-d), d)),
                    i = new g(a, b, (-d), d),
                    j = new g(a, b, (-d), d),
                    k = f.create(),
                    l = f.create(),
                    m = this;
                h.computeGq = function() { return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[0] }, i.computeGq = function() { return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[1] };
                var n = f.create(),
                    o = f.create();
                j.computeGq = function() { return f.rotate(n, m.localOffsetB, b.angle - m.localAngleB), f.scale(n, n, -1), f.sub(l, a.position, b.position), f.add(l, l, n), f.rotate(o, n, -Math.PI / 2), f.normalize(o, o), f.dot(l, o) }, this.localOffsetB = f.create(), c.localOffsetB ? f.copy(this.localOffsetB, c.localOffsetB) : (f.sub(this.localOffsetB, b.position, a.position), f.rotate(this.localOffsetB, this.localOffsetB, -a.angle)), this.localAngleB = 0, "number" == typeof c.localAngleB ? this.localAngleB = c.localAngleB : this.localAngleB = b.angle - a.angle, this.equations.push(h, i, j), this.setMaxForce(d)
            }
            var e = a("./Constraint"),
                f = a("../math/vec2"),
                g = a("../equations/Equation");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.setMaxForce = function(a) { for (var b = this.equations, c = 0; c < this.equations.length; c++) b[c].maxForce = a, b[c].minForce = -a }, d.prototype.getMaxForce = function() { return this.equations[0].maxForce };
            var h = f.create(),
                i = f.create(),
                j = f.create(),
                k = f.fromValues(1, 0),
                l = f.fromValues(0, 1);
            d.prototype.update = function() {
                var a = this.equations[0],
                    b = this.equations[1],
                    c = this.equations[2],
                    d = this.bodyA,
                    e = this.bodyB;
                f.rotate(h, this.localOffsetB, d.angle), f.rotate(i, this.localOffsetB, e.angle - this.localAngleB), f.scale(i, i, -1), f.rotate(j, i, Math.PI / 2), f.normalize(j, j), a.G[0] = -1, a.G[1] = 0, a.G[2] = -f.crossLength(h, k), a.G[3] = 1, b.G[0] = 0, b.G[1] = -1, b.G[2] = -f.crossLength(h, l), b.G[4] = 1, c.G[0] = -j[0], c.G[1] = -j[1], c.G[3] = j[0], c.G[4] = j[1], c.G[5] = f.crossLength(i, j)
            }
        }, { "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }],
        18: [function(a, b, c) {
            function d(a, b, c) {
                c = c || {}, e.call(this, a, b, e.PRISMATIC, c);
                var d = h.fromValues(0, 0),
                    j = h.fromValues(1, 0),
                    k = h.fromValues(0, 0);
                c.localAnchorA && h.copy(d, c.localAnchorA), c.localAxisA && h.copy(j, c.localAxisA), c.localAnchorB && h.copy(k, c.localAnchorB), this.localAnchorA = d, this.localAnchorB = k, this.localAxisA = j;
                var l = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE,
                    m = new g(a, b, (-l), l),
                    n = new h.create,
                    o = new h.create,
                    p = new h.create,
                    q = new h.create;
                if (m.computeGq = function() { return h.dot(p, q) }, m.updateJacobian = function() {
                        var c = this.G,
                            e = a.position,
                            f = b.position;
                        h.rotate(n, d, a.angle), h.rotate(o, k, b.angle), h.add(p, f, o), h.sub(p, p, e), h.sub(p, p, n), h.rotate(q, j, a.angle + Math.PI / 2), c[0] = -q[0], c[1] = -q[1], c[2] = -h.crossLength(n, q) + h.crossLength(q, p), c[3] = q[0], c[4] = q[1], c[5] = h.crossLength(o, q)
                    }, this.equations.push(m), !c.disableRotationalLock) {
                    var r = new i(a, b, (-l), l);
                    this.equations.push(r)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = "undefined" != typeof c.lowerLimit, this.upperLimitEnabled = "undefined" != typeof c.upperLimit, this.lowerLimit = "undefined" != typeof c.lowerLimit ? c.lowerLimit : 0, this.upperLimit = "undefined" != typeof c.upperLimit ? c.upperLimit : 1, this.upperLimitEquation = new f(a, b), this.lowerLimitEquation = new f(a, b), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l, this.motorEquation = new g(a, b), this.motorEnabled = !1, this.motorSpeed = 0;
                var s = this,
                    t = this.motorEquation;
                t.computeGW;
                t.computeGq = function() { return 0 }, t.computeGW = function() {
                    var a = this.G,
                        b = this.bodyA,
                        c = this.bodyB,
                        d = b.velocity,
                        e = c.velocity,
                        f = b.angularVelocity,
                        g = c.angularVelocity;
                    return this.gmult(a, d, f, e, g) + s.motorSpeed
                }
            }
            var e = a("./Constraint"),
                f = a("../equations/ContactEquation"),
                g = a("../equations/Equation"),
                h = a("../math/vec2"),
                i = a("../equations/RotationalLockEquation");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d;
            var j = h.create(),
                k = h.create(),
                l = h.create(),
                m = h.create(),
                n = h.create(),
                o = h.create();
            d.prototype.update = function() {
                var a = this.equations,
                    b = a[0],
                    c = this.upperLimit,
                    d = this.lowerLimit,
                    e = this.upperLimitEquation,
                    f = this.lowerLimitEquation,
                    g = this.bodyA,
                    i = this.bodyB,
                    p = this.localAxisA,
                    q = this.localAnchorA,
                    r = this.localAnchorB;
                b.updateJacobian(), h.rotate(j, p, g.angle), h.rotate(m, q, g.angle), h.add(k, m, g.position), h.rotate(n, r, i.angle), h.add(l, n, i.position);
                var s = this.position = h.dot(l, j) - h.dot(k, j);
                if (this.motorEnabled) {
                    var t = this.motorEquation.G;
                    t[0] = j[0], t[1] = j[1], t[2] = h.crossLength(j, n), t[3] = -j[0], t[4] = -j[1], t[5] = -h.crossLength(j, m)
                }
                if (this.upperLimitEnabled && s > c) h.scale(e.normalA, j, -1), h.sub(e.contactPointA, k, g.position), h.sub(e.contactPointB, l, i.position), h.scale(o, j, c), h.add(e.contactPointA, e.contactPointA, o), a.indexOf(e) === -1 && a.push(e);
                else {
                    var u = a.indexOf(e);
                    u !== -1 && a.splice(u, 1)
                }
                if (this.lowerLimitEnabled && s < d) h.scale(f.normalA, j, 1), h.sub(f.contactPointA, k, g.position), h.sub(f.contactPointB, l, i.position), h.scale(o, j, d), h.sub(f.contactPointB, f.contactPointB, o), a.indexOf(f) === -1 && a.push(f);
                else {
                    var u = a.indexOf(f);
                    u !== -1 && a.splice(u, 1)
                }
            }, d.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, d.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1), this.motorEnabled = !1
                }
            }, d.prototype.setLimits = function(a, b) { "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1) }
        }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../math/vec2": 30, "./Constraint": 14 }],
        19: [function(a, b, c) {
            function d(a, b, c) {
                c = c || {}, e.call(this, a, b, e.REVOLUTE, c);
                var d = this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE;
                this.pivotA = i.create(), this.pivotB = i.create(), c.worldPivot ? (i.sub(this.pivotA, c.worldPivot, a.position), i.sub(this.pivotB, c.worldPivot, b.position), i.rotate(this.pivotA, this.pivotA, -a.angle), i.rotate(this.pivotB, this.pivotB, -b.angle)) : (i.copy(this.pivotA, c.localPivotA), i.copy(this.pivotB, c.localPivotB));
                var o = this.equations = [new f(a, b, (-d), d), new f(a, b, (-d), d)],
                    p = o[0],
                    q = o[1],
                    r = this;
                p.computeGq = function() { return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, l) }, q.computeGq = function() { return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, m) }, q.minForce = p.minForce = -d, q.maxForce = p.maxForce = d, this.motorEquation = new g(a, b), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new h(a, b), this.lowerLimitEquation = new h(a, b), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }
            var e = a("./Constraint"),
                f = a("../equations/Equation"),
                g = a("../equations/RotationalVelocityEquation"),
                h = a("../equations/RotationalLockEquation"),
                i = a("../math/vec2");
            b.exports = d;
            var j = i.create(),
                k = i.create(),
                l = i.fromValues(1, 0),
                m = i.fromValues(0, 1),
                n = i.create();
            d.prototype = new e, d.prototype.constructor = d, d.prototype.setLimits = function(a, b) { "number" == typeof a ? (this.lowerLimit = a, this.lowerLimitEnabled = !0) : (this.lowerLimit = a, this.lowerLimitEnabled = !1), "number" == typeof b ? (this.upperLimit = b, this.upperLimitEnabled = !0) : (this.upperLimit = b, this.upperLimitEnabled = !1) }, d.prototype.update = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    c = this.pivotA,
                    d = this.pivotB,
                    e = this.equations,
                    f = (e[0], e[1], e[0]),
                    g = e[1],
                    h = this.upperLimit,
                    n = this.lowerLimit,
                    o = this.upperLimitEquation,
                    p = this.lowerLimitEquation,
                    q = this.angle = b.angle - a.angle;
                if (this.upperLimitEnabled && q > h) o.angle = h, e.indexOf(o) === -1 && e.push(o);
                else {
                    var r = e.indexOf(o);
                    r !== -1 && e.splice(r, 1)
                }
                if (this.lowerLimitEnabled && q < n) p.angle = n, e.indexOf(p) === -1 && e.push(p);
                else {
                    var r = e.indexOf(p);
                    r !== -1 && e.splice(r, 1)
                }
                i.rotate(j, c, a.angle), i.rotate(k, d, b.angle), f.G[0] = -1, f.G[1] = 0, f.G[2] = -i.crossLength(j, l), f.G[3] = 1, f.G[4] = 0, f.G[5] = i.crossLength(k, l), g.G[0] = 0, g.G[1] = -1, g.G[2] = -i.crossLength(j, m), g.G[3] = 0, g.G[4] = 1, g.G[5] = i.crossLength(k, m)
            }, d.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, d.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1), this.motorEnabled = !1
                }
            }, d.prototype.motorIsEnabled = function() { return !!this.motorEnabled }, d.prototype.setMotorSpeed = function(a) {
                if (this.motorEnabled) {
                    var b = this.equations.indexOf(this.motorEquation);
                    this.equations[b].relativeVelocity = a
                }
            }, d.prototype.getMotorSpeed = function() { return !!this.motorEnabled && this.motorEquation.relativeVelocity }
        }, { "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../equations/RotationalVelocityEquation": 25, "../math/vec2": 30, "./Constraint": 14 }],
        20: [function(a, b, c) {
            function d(a, b, c) { c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0, this.ratio = "number" == typeof c.ratio ? c.ratio : 1, this.setRatio(this.ratio) }
            var e = a("./Equation");
            a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeGq = function() { return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle }, d.prototype.setRatio = function(a) {
                var b = this.G;
                b[2] = a, b[5] = -1, this.ratio = a
            }, d.prototype.setMaxTorque = function(a) { this.maxForce = a, this.minForce = -a }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        21: [function(a, b, c) {
            function d(a, b) { e.call(this, a, b, 0, Number.MAX_VALUE), this.contactPointA = f.create(), this.penetrationVec = f.create(), this.contactPointB = f.create(), this.normalA = f.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null }
            var e = a("./Equation"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeB = function(a, b, c) {
                var d = this.bodyA,
                    e = this.bodyB,
                    g = this.contactPointA,
                    h = this.contactPointB,
                    i = d.position,
                    j = e.position,
                    k = this.penetrationVec,
                    l = this.normalA,
                    m = this.G,
                    n = f.crossLength(g, l),
                    o = f.crossLength(h, l);
                m[0] = -l[0], m[1] = -l[1], m[2] = -n, m[3] = l[0], m[4] = l[1], m[5] = o, f.add(k, j, h), f.sub(k, k, i), f.sub(k, k, g);
                var p, q;
                this.firstImpact && 0 !== this.restitution ? (q = 0, p = 1 / b * (1 + this.restitution) * this.computeGW()) : (q = f.dot(l, k) + this.offset, p = this.computeGW());
                var r = this.computeGiMf(),
                    s = -q * a - p * b - c * r;
                return s
            }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        22: [function(a, b, c) {
            function d(a, b, c, e) {
                this.minForce = "undefined" == typeof c ? -Number.MAX_VALUE : c, this.maxForce = "undefined" == typeof e ? Number.MAX_VALUE : e, this.bodyA = a, this.bodyB = b, this.stiffness = d.DEFAULT_STIFFNESS, this.relaxation = d.DEFAULT_RELAXATION, this.G = new f.ARRAY_TYPE(6);
                for (var g = 0; g < 6; g++) this.G[g] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }
            b.exports = d;
            var e = a("../math/vec2"),
                f = a("../utils/Utils");
            a("../objects/Body");
            d.prototype.constructor = d, d.DEFAULT_STIFFNESS = 1e6, d.DEFAULT_RELAXATION = 4, d.prototype.update = function() {
                var a = this.stiffness,
                    b = this.relaxation,
                    c = this.timeStep;
                this.a = 4 / (c * (1 + 4 * b)), this.b = 4 * b / (1 + 4 * b), this.epsilon = 4 / (c * c * a * (1 + 4 * b)), this.needsUpdate = !1
            }, d.prototype.gmult = function(a, b, c, d, e) { return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e }, d.prototype.computeB = function(a, b, c) {
                var d = this.computeGW(),
                    e = this.computeGq(),
                    f = this.computeGiMf();
                return -e * a - d * b - f * c
            };
            var g = e.create(),
                h = e.create();
            d.prototype.computeGq = function() {
                var a = this.G,
                    b = this.bodyA,
                    c = this.bodyB,
                    d = (b.position, c.position, b.angle),
                    e = c.angle;
                return this.gmult(a, g, d, h, e) + this.offset
            }, d.prototype.computeGW = function() {
                var a = this.G,
                    b = this.bodyA,
                    c = this.bodyB,
                    d = b.velocity,
                    e = c.velocity,
                    f = b.angularVelocity,
                    g = c.angularVelocity;
                return this.gmult(a, d, f, e, g) + this.relativeVelocity
            }, d.prototype.computeGWlambda = function() {
                var a = this.G,
                    b = this.bodyA,
                    c = this.bodyB,
                    d = b.vlambda,
                    e = c.vlambda,
                    f = b.wlambda,
                    g = c.wlambda;
                return this.gmult(a, d, f, e, g)
            };
            var i = e.create(),
                j = e.create();
            d.prototype.computeGiMf = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    c = a.force,
                    d = a.angularForce,
                    f = b.force,
                    g = b.angularForce,
                    h = a.invMassSolve,
                    k = b.invMassSolve,
                    l = a.invInertiaSolve,
                    m = b.invInertiaSolve,
                    n = this.G;
                return e.scale(i, c, h), e.multiply(i, a.massMultiplier, i), e.scale(j, f, k), e.multiply(j, b.massMultiplier, j), this.gmult(n, i, d * l, j, g * m)
            }, d.prototype.computeGiMGt = function() {
                var a = this.bodyA,
                    b = this.bodyB,
                    c = a.invMassSolve,
                    d = b.invMassSolve,
                    e = a.invInertiaSolve,
                    f = b.invInertiaSolve,
                    g = this.G;
                return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f
            };
            var k = e.create(),
                l = e.create(),
                m = e.create();
            e.create(), e.create(), e.create();
            d.prototype.addToWlambda = function(a) {
                var b = this.bodyA,
                    c = this.bodyB,
                    d = k,
                    f = l,
                    g = m,
                    h = b.invMassSolve,
                    i = c.invMassSolve,
                    j = b.invInertiaSolve,
                    n = c.invInertiaSolve,
                    o = this.G;
                f[0] = o[0], f[1] = o[1], g[0] = o[3], g[1] = o[4], e.scale(d, f, h * a), e.multiply(d, d, b.massMultiplier), e.add(b.vlambda, b.vlambda, d), b.wlambda += j * o[2] * a, e.scale(d, g, i * a), e.multiply(d, d, c.massMultiplier), e.add(c.vlambda, c.vlambda, d), c.wlambda += n * o[5] * a
            }, d.prototype.computeInvC = function(a) { return 1 / (this.computeGiMGt() + a) }
        }, { "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }],
        23: [function(a, b, c) {
            function d(a, b, c) { f.call(this, a, b, -c, c), this.contactPointA = e.create(), this.contactPointB = e.create(), this.t = e.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3 }
            var e = a("../math/vec2"),
                f = a("./Equation");
            a("../utils/Utils");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d,
                d.prototype.setSlipForce = function(a) { this.maxForce = a, this.minForce = -a }, d.prototype.getSlipForce = function() { return this.maxForce }, d.prototype.computeB = function(a, b, c) {
                    var d = (this.bodyA, this.bodyB, this.contactPointA),
                        f = this.contactPointB,
                        g = this.t,
                        h = this.G;
                    h[0] = -g[0], h[1] = -g[1], h[2] = -e.crossLength(d, g), h[3] = g[0], h[4] = g[1], h[5] = e.crossLength(f, g);
                    var i = this.computeGW(),
                        j = this.computeGiMf(),
                        k = -i * b - c * j;
                    return k
                }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Equation": 22 }],
        24: [function(a, b, c) {
            function d(a, b, c) {
                c = c || {}, e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = c.angle || 0;
                var d = this.G;
                d[2] = 1, d[5] = -1
            }
            var e = a("./Equation"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d;
            var g = f.create(),
                h = f.create(),
                i = f.fromValues(1, 0),
                j = f.fromValues(0, 1);
            d.prototype.computeGq = function() { return f.rotate(g, i, this.bodyA.angle + this.angle), f.rotate(h, j, this.bodyB.angle), f.dot(g, h) }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        25: [function(a, b, c) {
            function d(a, b) { e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1 }
            var e = a("./Equation");
            a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeB = function(a, b, c) {
                var d = this.G;
                d[2] = -1, d[5] = this.ratio;
                var e = this.computeGiMf(),
                    f = this.computeGW(),
                    g = -f * b - c * e;
                return g
            }
        }, { "../math/vec2": 30, "./Equation": 22 }],
        26: [function(a, b, c) {
            var d = function() {};
            b.exports = d, d.prototype = {
                constructor: d,
                on: function(a, b, c) { b.context = c || this, void 0 === this._listeners && (this._listeners = {}); var d = this._listeners; return void 0 === d[a] && (d[a] = []), d[a].indexOf(b) === -1 && d[a].push(b), this },
                has: function(a, b) { if (void 0 === this._listeners) return !1; var c = this._listeners; if (b) { if (void 0 !== c[a] && c[a].indexOf(b) !== -1) return !0 } else if (void 0 !== c[a]) return !0; return !1 },
                off: function(a, b) {
                    if (void 0 === this._listeners) return this;
                    var c = this._listeners,
                        d = c[a].indexOf(b);
                    return d !== -1 && c[a].splice(d, 1), this
                },
                emit: function(a) {
                    if (void 0 === this._listeners) return this;
                    var b = this._listeners,
                        c = b[a.type];
                    if (void 0 !== c) {
                        a.target = this;
                        for (var d = 0, e = c.length; d < e; d++) {
                            var f = c[d];
                            f.call(f.context, a)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(a, b, c) {
            function d(a, b, c) {
                if (c = c || {}, !(a instanceof e && b instanceof e)) throw new Error("First two arguments must be Material instances.");
                this.id = d.idCounter++, this.materialA = a, this.materialB = b, this.friction = "undefined" != typeof c.friction ? Number(c.friction) : .3, this.restitution = "undefined" != typeof c.restitution ? Number(c.restitution) : 0, this.stiffness = "undefined" != typeof c.stiffness ? Number(c.stiffness) : f.DEFAULT_STIFFNESS, this.relaxation = "undefined" != typeof c.relaxation ? Number(c.relaxation) : f.DEFAULT_RELAXATION, this.frictionStiffness = "undefined" != typeof c.frictionStiffness ? Number(c.frictionStiffness) : f.DEFAULT_STIFFNESS, this.frictionRelaxation = "undefined" != typeof c.frictionRelaxation ? Number(c.frictionRelaxation) : f.DEFAULT_RELAXATION, this.surfaceVelocity = "undefined" != typeof c.surfaceVelocity ? Number(c.surfaceVelocity) : 0, this.contactSkinSize = .005
            }
            var e = a("./Material"),
                f = a("../equations/Equation");
            b.exports = d, d.idCounter = 0
        }, { "../equations/Equation": 22, "./Material": 28 }],
        28: [function(a, b, c) {
            function d(a) { this.id = a || d.idCounter++ } b.exports = d, d.idCounter = 0
        }, {}],
        29: [function(a, b, c) {
            var d = {};
            d.GetArea = function(a) { if (a.length < 6) return 0; for (var b = a.length - 2, c = 0, d = 0; d < b; d += 2) c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]); return c += (a[0] - a[b]) * (a[b + 1] + a[1]), .5 * -c }, d.Triangulate = function(a) {
                var b = a.length >> 1;
                if (b < 3) return [];
                for (var c = [], e = [], f = 0; f < b; f++) e.push(f);
                for (var f = 0, g = b; g > 3;) {
                    var h = e[(f + 0) % g],
                        i = e[(f + 1) % g],
                        j = e[(f + 2) % g],
                        k = a[2 * h],
                        l = a[2 * h + 1],
                        m = a[2 * i],
                        n = a[2 * i + 1],
                        o = a[2 * j],
                        p = a[2 * j + 1],
                        q = !1;
                    if (d._convex(k, l, m, n, o, p)) { q = !0; for (var r = 0; r < g; r++) { var s = e[r]; if (s != h && s != i && s != j && d._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) { q = !1; break } } }
                    if (q) c.push(h, i, j), e.splice((f + 1) % g, 1), g--, f = 0;
                    else if (f++ > 3 * g) break
                }
                return c.push(e[0], e[1], e[2]), c
            }, d._PointInTriangle = function(a, b, c, d, e, f, g, h) {
                var i = g - c,
                    j = h - d,
                    k = e - c,
                    l = f - d,
                    m = a - c,
                    n = b - d,
                    o = i * i + j * j,
                    p = i * k + j * l,
                    q = i * m + j * n,
                    r = k * k + l * l,
                    s = k * m + l * n,
                    t = 1 / (o * r - p * p),
                    u = (r * q - p * s) * t,
                    v = (o * s - p * q) * t;
                return u >= 0 && v >= 0 && u + v < 1
            }, d._convex = function(a, b, c, d, e, f) { return (b - d) * (e - c) + (c - a) * (f - d) >= 0 }, b.exports = d
        }, {}],
        30: [function(a, b, c) {
            var d = b.exports = {},
                e = a("../utils/Utils");
            d.crossLength = function(a, b) { return a[0] * b[1] - a[1] * b[0] }, d.crossVZ = function(a, b, c) { return d.rotate(a, b, -Math.PI / 2), d.scale(a, a, c), a }, d.crossZV = function(a, b, c) { return d.rotate(a, c, Math.PI / 2), d.scale(a, a, b), a }, d.rotate = function(a, b, c) {
                if (0 !== c) {
                    var d = Math.cos(c),
                        e = Math.sin(c),
                        f = b[0],
                        g = b[1];
                    a[0] = d * f - e * g, a[1] = e * f + d * g
                }
                else a[0] = b[0], a[1] = b[1]
            }, d.rotate90cw = function(a, b) {
                var c = b[0],
                    d = b[1];
                a[0] = d, a[1] = -c
            }, d.toLocalFrame = function(a, b, c, e) { d.copy(a, b), d.sub(a, a, c), d.rotate(a, a, -e) }, d.toGlobalFrame = function(a, b, c, e) { d.copy(a, b), d.rotate(a, a, e), d.add(a, a, c) }, d.vectorToLocalFrame = function(a, b, c) { d.rotate(a, b, -c) }, d.vectorToGlobalFrame = function(a, b, c) { d.rotate(a, b, c) }, d.centroid = function(a, b, c, e) { return d.add(a, b, c), d.add(a, a, e), d.scale(a, a, 1 / 3), a }, d.create = function() { var a = new e.ARRAY_TYPE(2); return a[0] = 0, a[1] = 0, a }, d.clone = function(a) { var b = new e.ARRAY_TYPE(2); return b[0] = a[0], b[1] = a[1], b }, d.fromValues = function(a, b) { var c = new e.ARRAY_TYPE(2); return c[0] = a, c[1] = b, c }, d.copy = function(a, b) { return a[0] = b[0], a[1] = b[1], a }, d.set = function(a, b, c) { return a[0] = b, a[1] = c, a }, d.add = function(a, b, c) { return a[0] = b[0] + c[0], a[1] = b[1] + c[1], a }, d.subtract = function(a, b, c) { return a[0] = b[0] - c[0], a[1] = b[1] - c[1], a }, d.sub = d.subtract, d.multiply = function(a, b, c) { return a[0] = b[0] * c[0], a[1] = b[1] * c[1], a }, d.mul = d.multiply, d.divide = function(a, b, c) { return a[0] = b[0] / c[0], a[1] = b[1] / c[1], a }, d.div = d.divide, d.scale = function(a, b, c) { return a[0] = b[0] * c, a[1] = b[1] * c, a }, d.distance = function(a, b) {
                var c = b[0] - a[0],
                    d = b[1] - a[1];
                return Math.sqrt(c * c + d * d)
            }, d.dist = d.distance, d.squaredDistance = function(a, b) {
                var c = b[0] - a[0],
                    d = b[1] - a[1];
                return c * c + d * d
            }, d.sqrDist = d.squaredDistance, d.length = function(a) {
                var b = a[0],
                    c = a[1];
                return Math.sqrt(b * b + c * c)
            }, d.len = d.length, d.squaredLength = function(a) {
                var b = a[0],
                    c = a[1];
                return b * b + c * c
            }, d.sqrLen = d.squaredLength, d.negate = function(a, b) { return a[0] = -b[0], a[1] = -b[1], a }, d.normalize = function(a, b) {
                var c = b[0],
                    d = b[1],
                    e = c * c + d * d;
                return e > 0 && (e = 1 / Math.sqrt(e), a[0] = b[0] * e, a[1] = b[1] * e), a
            }, d.dot = function(a, b) { return a[0] * b[0] + a[1] * b[1] }, d.str = function(a) { return "vec2(" + a[0] + ", " + a[1] + ")" }, d.lerp = function(a, b, c, d) {
                var e = b[0],
                    f = b[1];
                return a[0] = e + d * (c[0] - e), a[1] = f + d * (c[1] - f), a
            }, d.reflect = function(a, b, c) {
                var d = b[0] * c[0] + b[1] * c[1];
                a[0] = b[0] - 2 * c[0] * d, a[1] = b[1] - 2 * c[1] * d
            }, d.getLineSegmentsIntersection = function(a, b, c, e, f) { var g = d.getLineSegmentsIntersectionFraction(b, c, e, f); return !(g < 0) && (a[0] = b[0] + g * (c[0] - b[0]), a[1] = b[1] + g * (c[1] - b[1]), !0) }, d.getLineSegmentsIntersectionFraction = function(a, b, c, d) {
                var e, f, g = b[0] - a[0],
                    h = b[1] - a[1],
                    i = d[0] - c[0],
                    j = d[1] - c[1];
                return e = (-h * (a[0] - c[0]) + g * (a[1] - c[1])) / (-i * h + g * j), f = (i * (a[1] - c[1]) - j * (a[0] - c[0])) / (-i * h + g * j), e >= 0 && e <= 1 && f >= 0 && f <= 1 ? f : -1
            }
        }, { "../utils/Utils": 57 }],
        31: [function(a, b, c) {
            function d(a) { a = a || {}, k.call(this), this.id = a.id || ++d._idCounter, this.world = null, this.shapes = [], this.mass = a.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!a.fixedRotation, this.fixedX = !!a.fixedX, this.fixedY = !!a.fixedY, this.massMultiplier = e.create(), this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.interpolatedPosition = e.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = e.fromValues(0, 0), this.previousAngle = 0, this.velocity = e.fromValues(0, 0), a.velocity && e.copy(this.velocity, a.velocity), this.vlambda = e.fromValues(0, 0), this.wlambda = 0, this.angle = a.angle || 0, this.angularVelocity = a.angularVelocity || 0, this.force = e.create(), a.force && e.copy(this.force, a.force), this.angularForce = a.angularForce || 0, this.damping = "number" == typeof a.damping ? a.damping : .1, this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : .1, this.type = d.STATIC, "undefined" != typeof a.type ? this.type = a.type : a.mass ? this.type = d.DYNAMIC : this.type = d.STATIC, this.boundingRadius = 0, this.aabb = new j, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === a.allowSleep || a.allowSleep, this.wantsToSleep = !1, this.sleepState = d.AWAKE, this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1, this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties() }
            var e = a("../math/vec2"),
                f = a("poly-decomp"),
                g = a("../shapes/Convex"),
                h = a("../collision/RaycastResult"),
                i = a("../collision/Ray"),
                j = a("../collision/AABB"),
                k = a("../events/EventEmitter");
            b.exports = d, d.prototype = new k, d.prototype.constructor = d, d._idCounter = 0, d.prototype.updateSolveMassProperties = function() { this.sleepState === d.SLEEPING || this.type === d.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia) }, d.prototype.setDensity = function(a) {
                var b = this.getArea();
                this.mass = b * a, this.updateMassProperties()
            }, d.prototype.getArea = function() { for (var a = 0, b = 0; b < this.shapes.length; b++) a += this.shapes[b].area; return a }, d.prototype.getAABB = function() { return this.aabbNeedsUpdate && this.updateAABB(), this.aabb };
            var l = new j,
                m = e.create();
            d.prototype.updateAABB = function() {
                for (var a = this.shapes, b = a.length, c = m, d = this.angle, f = 0; f !== b; f++) {
                    var g = a[f],
                        h = g.angle + d;
                    e.rotate(c, g.position, d), e.add(c, c, this.position), g.computeAABB(l, c, h), 0 === f ? this.aabb.copy(l) : this.aabb.extend(l)
                }
                this.aabbNeedsUpdate = !1
            }, d.prototype.updateBoundingRadius = function() {
                for (var a = this.shapes, b = a.length, c = 0, d = 0; d !== b; d++) {
                    var f = a[d],
                        g = e.length(f.position),
                        h = f.boundingRadius;
                    g + h > c && (c = g + h)
                }
                this.boundingRadius = c
            }, d.prototype.addShape = function(a, b, c) {
                if (a.body) throw new Error("A shape can only be added to one body.");
                a.body = this, b ? e.copy(a.position, b) : e.set(a.position, 0, 0), a.angle = c || 0, this.shapes.push(a), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, d.prototype.removeShape = function(a) { var b = this.shapes.indexOf(a); return b !== -1 && (this.shapes.splice(b, 1), this.aabbNeedsUpdate = !0, a.body = null, !0) }, d.prototype.updateMassProperties = function() {
                if (this.type === d.STATIC || this.type === d.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var a = this.shapes,
                        b = a.length,
                        c = this.mass / b,
                        f = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var g = 0; g < b; g++) {
                            var h = a[g],
                                i = e.squaredLength(h.position),
                                j = h.computeMomentOfInertia(c);
                            f += j + c * i
                        }
                        this.inertia = f, this.invInertia = f > 0 ? 1 / f : 0
                    }
                    this.invMass = 1 / this.mass, e.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            };
            e.create();
            d.prototype.applyForce = function(a, b) {
                if (e.add(this.force, this.force, a), b) {
                    var c = e.crossLength(b, a);
                    this.angularForce += c
                }
            };
            var n = e.create(),
                o = e.create(),
                p = e.create();
            d.prototype.applyForceLocal = function(a, b) {
                b = b || p;
                var c = n,
                    d = o;
                this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyForce(c, d)
            };
            var q = e.create();
            d.prototype.applyImpulse = function(a, b) {
                if (this.type === d.DYNAMIC) {
                    var c = q;
                    if (e.scale(c, a, this.invMass), e.multiply(c, this.massMultiplier, c), e.add(this.velocity, c, this.velocity), b) {
                        var f = e.crossLength(b, a);
                        f *= this.invInertia, this.angularVelocity += f
                    }
                }
            };
            var r = e.create(),
                s = e.create(),
                t = e.create();
            d.prototype.applyImpulseLocal = function(a, b) {
                b = b || t;
                var c = r,
                    d = s;
                this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyImpulse(c, d)
            }, d.prototype.toLocalFrame = function(a, b) { e.toLocalFrame(a, b, this.position, this.angle) }, d.prototype.toWorldFrame = function(a, b) { e.toGlobalFrame(a, b, this.position, this.angle) }, d.prototype.vectorToLocalFrame = function(a, b) { e.vectorToLocalFrame(a, b, this.angle) }, d.prototype.vectorToWorldFrame = function(a, b) { e.vectorToGlobalFrame(a, b, this.angle) }, d.prototype.fromPolygon = function(a, b) {
                b = b || {};
                for (var c = this.shapes.length; c >= 0; --c) this.removeShape(this.shapes[c]);
                var d = new f.Polygon;
                if (d.vertices = a, d.makeCCW(), "number" == typeof b.removeCollinearPoints && d.removeCollinearPoints(b.removeCollinearPoints), "undefined" == typeof b.skipSimpleCheck && !d.isSimple()) return !1;
                this.concavePath = d.vertices.slice(0);
                for (var c = 0; c < this.concavePath.length; c++) {
                    var h = [0, 0];
                    e.copy(h, this.concavePath[c]), this.concavePath[c] = h
                }
                var i;
                i = b.optimalDecomp ? d.decomp() : d.quickDecomp();
                for (var j = e.create(), c = 0; c !== i.length; c++) {
                    for (var k = new g({ vertices: i[c].vertices }), l = 0; l !== k.vertices.length; l++) {
                        var h = k.vertices[l];
                        e.sub(h, h, k.centerOfMass)
                    }
                    e.scale(j, k.centerOfMass, 1), k.updateTriangles(), k.updateCenterOfMass(), k.updateBoundingRadius(), this.addShape(k, j)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
            };
            var u = (e.fromValues(0, 0), e.fromValues(0, 0)),
                v = e.fromValues(0, 0),
                w = e.fromValues(0, 0);
            d.prototype.adjustCenterOfMass = function() {
                var a = u,
                    b = v,
                    c = w,
                    d = 0;
                e.set(b, 0, 0);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    e.scale(a, g.position, g.area), e.add(b, b, a), d += g.area
                }
                e.scale(c, b, 1 / d);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    e.sub(g.position, g.position, c)
                }
                e.add(this.position, this.position, c);
                for (var f = 0; this.concavePath && f < this.concavePath.length; f++) e.sub(this.concavePath[f], this.concavePath[f], c);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, d.prototype.setZeroForce = function() { e.set(this.force, 0, 0), this.angularForce = 0 }, d.prototype.resetConstraintVelocity = function() {
                var a = this,
                    b = a.vlambda;
                e.set(b, 0, 0), a.wlambda = 0
            }, d.prototype.addConstraintVelocity = function() {
                var a = this,
                    b = a.velocity;
                e.add(b, b, a.vlambda), a.angularVelocity += a.wlambda
            }, d.prototype.applyDamping = function(a) {
                if (this.type === d.DYNAMIC) {
                    var b = this.velocity;
                    e.scale(b, b, Math.pow(1 - this.damping, a)), this.angularVelocity *= Math.pow(1 - this.angularDamping, a)
                }
            }, d.prototype.wakeUp = function() {
                var a = this.sleepState;
                this.sleepState = d.AWAKE, this.idleTime = 0, a !== d.AWAKE && this.emit(d.wakeUpEvent)
            }, d.prototype.sleep = function() { this.sleepState = d.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, e.set(this.velocity, 0, 0), e.set(this.force, 0, 0), this.emit(d.sleepEvent) }, d.prototype.sleepTick = function(a, b, c) {
                if (this.allowSleep && this.type !== d.SLEEPING) {
                    this.wantsToSleep = !1;
                    var f = (this.sleepState, e.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)),
                        g = Math.pow(this.sleepSpeedLimit, 2);
                    f >= g ? (this.idleTime = 0, this.sleepState = d.AWAKE) : (this.idleTime += c, this.sleepState = d.SLEEPY), this.idleTime > this.sleepTimeLimit && (b ? this.wantsToSleep = !0 : this.sleep())
                }
            }, d.prototype.overlaps = function(a) { return this.world.overlapKeeper.bodiesAreOverlapping(this, a) };
            var x = e.create(),
                y = e.create();
            d.prototype.integrate = function(a) {
                var b = this.invMass,
                    c = this.force,
                    d = this.position,
                    f = this.velocity;
                e.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a), e.scale(x, c, a * b), e.multiply(x, this.massMultiplier, x), e.add(f, x, f), this.integrateToTimeOfImpact(a) || (e.scale(y, f, a), e.add(d, d, y), this.fixedRotation || (this.angle += this.angularVelocity * a)), this.aabbNeedsUpdate = !0
            };
            var z = new h,
                A = new i({ mode: i.ALL }),
                B = e.create(),
                C = e.create(),
                D = e.create(),
                E = e.create();
            d.prototype.integrateToTimeOfImpact = function(a) {
                if (this.ccdSpeedThreshold < 0 || e.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                e.normalize(B, this.velocity), e.scale(C, this.velocity, a), e.add(C, C, this.position), e.sub(D, C, this.position);
                var b, c = this.angularVelocity * a,
                    d = e.length(D),
                    f = 1,
                    g = this;
                if (z.reset(), A.callback = function(a) { a.body !== g && (b = a.body, a.getHitPoint(C, A), e.sub(D, C, g.position), f = e.length(D) / d, a.stop()) }, e.copy(A.from, this.position), e.copy(A.to, C), A.update(), this.world.raycast(z, A), !b) return !1;
                var h = this.angle;
                e.copy(E, this.position);
                for (var i = 0, j = 0, k = 0, l = f; l >= j && i < this.ccdIterations;) {
                    i++, k = (l - j) / 2, e.scale(y, D, f), e.add(this.position, E, y), this.angle = h + c * f, this.updateAABB();
                    var m = this.aabb.overlaps(b.aabb) && this.world.narrowphase.bodiesOverlap(this, b);
                    m ? j = k : l = k
                }
                return f = k, e.copy(this.position, E), this.angle = h, e.scale(y, D, f), e.add(this.position, this.position, y), this.fixedRotation || (this.angle += c * f), !0
            }, d.prototype.getVelocityAtPoint = function(a, b) { return e.crossVZ(a, b, this.angularVelocity), e.subtract(a, this.velocity, a), a }, d.sleepyEvent = { type: "sleepy" }, d.sleepEvent = { type: "sleep" }, d.wakeUpEvent = { type: "wakeup" }, d.DYNAMIC = 1, d.STATIC = 2, d.KINEMATIC = 4, d.AWAKE = 0, d.SLEEPY = 1, d.SLEEPING = 2
        }, { "../collision/AABB": 7, "../collision/Ray": 11, "../collision/RaycastResult": 12, "../events/EventEmitter": 26, "../math/vec2": 30, "../shapes/Convex": 40, "poly-decomp": 5 }],
        32: [function(a, b, c) {
            function d(a, b, c) {
                c = c || {}, f.call(this, a, b, c), this.localAnchorA = e.fromValues(0, 0), this.localAnchorB = e.fromValues(0, 0), c.localAnchorA && e.copy(this.localAnchorA, c.localAnchorA), c.localAnchorB && e.copy(this.localAnchorB, c.localAnchorB), c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA), c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
                var d = e.create(),
                    g = e.create();
                this.getWorldAnchorA(d), this.getWorldAnchorB(g);
                var h = e.distance(d, g);
                this.restLength = "number" == typeof c.restLength ? c.restLength : h
            }
            var e = a("../math/vec2"),
                f = a("./Spring");
            a("../utils/Utils");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.setWorldAnchorA = function(a) { this.bodyA.toLocalFrame(this.localAnchorA, a) }, d.prototype.setWorldAnchorB = function(a) { this.bodyB.toLocalFrame(this.localAnchorB, a) }, d.prototype.getWorldAnchorA = function(a) { this.bodyA.toWorldFrame(a, this.localAnchorA) }, d.prototype.getWorldAnchorB = function(a) { this.bodyB.toWorldFrame(a, this.localAnchorB) };
            var g = e.create(),
                h = e.create(),
                i = e.create(),
                j = e.create(),
                k = e.create(),
                l = e.create(),
                m = e.create(),
                n = e.create(),
                o = e.create();
            d.prototype.applyForce = function() {
                var a = this.stiffness,
                    b = this.damping,
                    c = this.restLength,
                    d = this.bodyA,
                    f = this.bodyB,
                    p = g,
                    q = h,
                    r = i,
                    s = j,
                    t = o,
                    u = k,
                    v = l,
                    w = m,
                    x = n;
                this.getWorldAnchorA(u), this.getWorldAnchorB(v), e.sub(w, u, d.position), e.sub(x, v, f.position), e.sub(p, v, u);
                var y = e.len(p);
                e.normalize(q, p), e.sub(r, f.velocity, d.velocity), e.crossZV(t, f.angularVelocity, x), e.add(r, r, t), e.crossZV(t, d.angularVelocity, w), e.sub(r, r, t), e.scale(s, q, -a * (y - c) - b * e.dot(r, q)), e.sub(d.force, d.force, s), e.add(f.force, f.force, s);
                var z = e.crossLength(w, s),
                    A = e.crossLength(x, s);
                d.angularForce -= z, f.angularForce += A
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Spring": 34 }],
        33: [function(a, b, c) {
            function d(a, b, c) { c = c || {}, e.call(this, a, b, c), this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle }
            var e = (a("../math/vec2"), a("./Spring"));
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.applyForce = function() {
                var a = this.stiffness,
                    b = this.damping,
                    c = this.restAngle,
                    d = this.bodyA,
                    e = this.bodyB,
                    f = e.angle - d.angle,
                    g = e.angularVelocity - d.angularVelocity,
                    h = -a * (f - c) - b * g * 0;
                d.angularForce -= h, e.angularForce += h
            }
        }, { "../math/vec2": 30, "./Spring": 34 }],
        34: [function(a, b, c) {
            function d(a, b, c) { c = e.defaults(c, { stiffness: 100, damping: 1 }), this.stiffness = c.stiffness, this.damping = c.damping, this.bodyA = a, this.bodyB = b }
            var e = (a("../math/vec2"), a("../utils/Utils"));
            b.exports = d, d.prototype.applyForce = function() {}
        }, { "../math/vec2": 30, "../utils/Utils": 57 }],
        35: [function(a, b, c) {
            function d(a, b) {
                b = b || {}, this.chassisBody = a, this.wheels = [], this.groundBody = new i({ mass: 0 }), this.world = null;
                var c = this;
                this.preStepCallback = function() { c.update() }
            }

            function e(a, b) { b = b || {}, this.vehicle = a, this.forwardEquation = new h(a.chassisBody, a.groundBody), this.sideEquation = new h(a.chassisBody, a.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5), this.localForwardVector = f.fromValues(0, 1), b.localForwardVector && f.copy(this.localForwardVector, b.localForwardVector), this.localPosition = f.fromValues(0, 0), b.localPosition && f.copy(this.localPosition, b.localPosition), g.apply(this, a.chassisBody, a.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0) }
            var f = a("../math/vec2"),
                g = (a("../utils/Utils"), a("../constraints/Constraint")),
                h = a("../equations/FrictionEquation"),
                i = a("../objects/Body");
            b.exports = d, d.prototype.addToWorld = function(a) {
                this.world = a, a.addBody(this.groundBody), a.on("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.addConstraint(c)
                }
            }, d.prototype.removeFromWorld = function() {
                var a = this.world;
                a.removeBody(this.groundBody), a.off("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.removeConstraint(c)
                }
                this.world = null
            }, d.prototype.addWheel = function(a) { var b = new e(this, a); return this.wheels.push(b), b }, d.prototype.update = function() { for (var a = 0; a < this.wheels.length; a++) this.wheels[a].update() }, e.prototype = new g, e.prototype.setBrakeForce = function(a) { this.forwardEquation.setSlipForce(a) }, e.prototype.setSideFriction = function(a) { this.sideEquation.setSlipForce(a) };
            var j = f.create(),
                k = f.create();
            e.prototype.getSpeed = function() { return this.vehicle.chassisBody.vectorToWorldFrame(k, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(j, k), f.dot(j, k) };
            var l = f.create();
            e.prototype.update = function() { this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), f.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), f.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), f.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), f.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), f.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), f.normalize(l, this.forwardEquation.t), f.scale(l, l, this.engineForce), this.vehicle.chassisBody.applyForce(l, this.forwardEquation.contactPointA) }
        }, { "../constraints/Constraint": 14, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }],
        36: [function(a, b, c) {
            var d = b.exports = { AABB: a("./collision/AABB"), AngleLockEquation: a("./equations/AngleLockEquation"), Body: a("./objects/Body"), Broadphase: a("./collision/Broadphase"), Capsule: a("./shapes/Capsule"), Circle: a("./shapes/Circle"), Constraint: a("./constraints/Constraint"), ContactEquation: a("./equations/ContactEquation"), ContactEquationPool: a("./utils/ContactEquationPool"), ContactMaterial: a("./material/ContactMaterial"), Convex: a("./shapes/Convex"), DistanceConstraint: a("./constraints/DistanceConstraint"), Equation: a("./equations/Equation"), EventEmitter: a("./events/EventEmitter"), FrictionEquation: a("./equations/FrictionEquation"), FrictionEquationPool: a("./utils/FrictionEquationPool"), GearConstraint: a("./constraints/GearConstraint"), GSSolver: a("./solver/GSSolver"), Heightfield: a("./shapes/Heightfield"), Line: a("./shapes/Line"), LockConstraint: a("./constraints/LockConstraint"), Material: a("./material/Material"), Narrowphase: a("./collision/Narrowphase"), NaiveBroadphase: a("./collision/NaiveBroadphase"), Particle: a("./shapes/Particle"), Plane: a("./shapes/Plane"), Pool: a("./utils/Pool"), RevoluteConstraint: a("./constraints/RevoluteConstraint"), PrismaticConstraint: a("./constraints/PrismaticConstraint"), Ray: a("./collision/Ray"), RaycastResult: a("./collision/RaycastResult"), Box: a("./shapes/Box"), RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"), SAPBroadphase: a("./collision/SAPBroadphase"), Shape: a("./shapes/Shape"), Solver: a("./solver/Solver"), Spring: a("./objects/Spring"), TopDownVehicle: a("./objects/TopDownVehicle"), LinearSpring: a("./objects/LinearSpring"), RotationalSpring: a("./objects/RotationalSpring"), Utils: a("./utils/Utils"), World: a("./world/World"), vec2: a("./math/vec2"), version: a("../package.json").version };
            Object.defineProperty(d, "Rectangle", { get: function() { return this.Box } })
        }, { "../package.json": 6, "./collision/AABB": 7, "./collision/Broadphase": 8, "./collision/NaiveBroadphase": 9, "./collision/Narrowphase": 10, "./collision/Ray": 11, "./collision/RaycastResult": 12, "./collision/SAPBroadphase": 13, "./constraints/Constraint": 14, "./constraints/DistanceConstraint": 15, "./constraints/GearConstraint": 16, "./constraints/LockConstraint": 17, "./constraints/PrismaticConstraint": 18, "./constraints/RevoluteConstraint": 19, "./equations/AngleLockEquation": 20, "./equations/ContactEquation": 21, "./equations/Equation": 22, "./equations/FrictionEquation": 23, "./equations/RotationalVelocityEquation": 25, "./events/EventEmitter": 26, "./material/ContactMaterial": 27, "./material/Material": 28, "./math/vec2": 30, "./objects/Body": 31, "./objects/LinearSpring": 32, "./objects/RotationalSpring": 33, "./objects/Spring": 34, "./objects/TopDownVehicle": 35, "./shapes/Box": 37, "./shapes/Capsule": 38, "./shapes/Circle": 39, "./shapes/Convex": 40, "./shapes/Heightfield": 41, "./shapes/Line": 42, "./shapes/Particle": 43, "./shapes/Plane": 44, "./shapes/Shape": 45, "./solver/GSSolver": 46, "./solver/Solver": 47, "./utils/ContactEquationPool": 48, "./utils/FrictionEquationPool": 49, "./utils/Pool": 55, "./utils/Utils": 57, "./world/World": 61 }],
        37: [function(a, b, c) {
            function d(a) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = { width: arguments[0], height: arguments[1] }), a = a || {};
                var b = this.width = a.width || 1,
                    c = this.height = a.height || 1,
                    d = [e.fromValues(-b / 2, -c / 2), e.fromValues(b / 2, -c / 2), e.fromValues(b / 2, c / 2), e.fromValues(-b / 2, c / 2)],
                    h = [e.fromValues(1, 0), e.fromValues(0, 1)];
                a.vertices = d, a.axes = h, a.type = f.BOX, g.call(this, a)
            }
            var e = a("../math/vec2"),
                f = a("./Shape"),
                g = a("./Convex");
            b.exports = d, d.prototype = new g, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                var b = this.width,
                    c = this.height;
                return a * (c * c + b * b) / 12
            }, d.prototype.updateBoundingRadius = function() {
                var a = this.width,
                    b = this.height;
                this.boundingRadius = Math.sqrt(a * a + b * b) / 2
            };
            e.create(), e.create(), e.create(), e.create();
            d.prototype.computeAABB = function(a, b, c) { a.setFromPoints(this.vertices, b, c, 0) }, d.prototype.updateArea = function() { this.area = this.width * this.height }
        }, { "../math/vec2": 30, "./Convex": 40, "./Shape": 45 }],
        38: [function(a, b, c) {
            function d(a) { "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = { length: arguments[0], radius: arguments[1] }), a = a || {}, this.length = a.length || 1, this.radius = a.radius || 1, a.type = e.CAPSULE, e.call(this, a) }
            var e = a("./Shape"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius,
                    c = this.length + b,
                    d = 2 * b;
                return a * (d * d + c * c) / 12
            }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius + this.length / 2 }, d.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length };
            var g = f.create();
            d.prototype.computeAABB = function(a, b, c) {
                var d = this.radius;
                f.set(g, this.length / 2, 0), 0 !== c && f.rotate(g, g, c), f.set(a.upperBound, Math.max(g[0] + d, -g[0] + d), Math.max(g[1] + d, -g[1] + d)), f.set(a.lowerBound, Math.min(g[0] - d, -g[0] - d), Math.min(g[1] - d, -g[1] - d)), f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b)
            };
            var h = f.create(),
                i = f.create(),
                j = f.create(),
                k = f.create(),
                l = f.fromValues(0, 1);
            d.prototype.raycast = function(a, b, c, d) {
                for (var e = b.from, g = b.to, m = (b.direction, h), n = i, o = j, p = k, q = this.length / 2, r = 0; r < 2; r++) {
                    var s = this.radius * (2 * r - 1);
                    f.set(o, -q, s), f.set(p, q, s), f.toGlobalFrame(o, o, c, d), f.toGlobalFrame(p, p, c, d);
                    var t = f.getLineSegmentsIntersectionFraction(e, g, o, p);
                    if (t >= 0 && (f.rotate(n, l, d), f.scale(n, n, 2 * r - 1), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return
                }
                for (var u = Math.pow(this.radius, 2) + Math.pow(q, 2), r = 0; r < 2; r++) {
                    f.set(o, q * (2 * r - 1), 0), f.toGlobalFrame(o, o, c, d);
                    var v = Math.pow(g[0] - e[0], 2) + Math.pow(g[1] - e[1], 2),
                        w = 2 * ((g[0] - e[0]) * (e[0] - o[0]) + (g[1] - e[1]) * (e[1] - o[1])),
                        x = Math.pow(e[0] - o[0], 2) + Math.pow(e[1] - o[1], 2) - Math.pow(this.radius, 2),
                        t = Math.pow(w, 2) - 4 * v * x;
                    if (!(t < 0))
                        if (0 === t) { if (f.lerp(m, e, g, t), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return }
                    else {
                        var y = Math.sqrt(t),
                            z = 1 / (2 * v),
                            A = (-w - y) * z,
                            B = (-w + y) * z;
                        if (A >= 0 && A <= 1 && (f.lerp(m, e, g, A), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, A, n, -1), a.shouldStop(b)))) return;
                        if (B >= 0 && B <= 1 && (f.lerp(m, e, g, B), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, B, n, -1), a.shouldStop(b)))) return
                    }
                }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        39: [function(a, b, c) {
            function d(a) { "number" == typeof arguments[0] && (a = { radius: arguments[0] }), a = a || {}, this.radius = a.radius || 1, a.type = e.CIRCLE, e.call(this, a) }
            var e = a("./Shape"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) { var b = this.radius; return a * b * b / 2 }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius }, d.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius }, d.prototype.computeAABB = function(a, b, c) {
                var d = this.radius;
                f.set(a.upperBound, d, d), f.set(a.lowerBound, -d, -d), b && (f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b))
            };
            var g = f.create(),
                h = f.create();
            d.prototype.raycast = function(a, b, c, d) {
                var e = b.from,
                    i = b.to,
                    j = this.radius,
                    k = Math.pow(i[0] - e[0], 2) + Math.pow(i[1] - e[1], 2),
                    l = 2 * ((i[0] - e[0]) * (e[0] - c[0]) + (i[1] - e[1]) * (e[1] - c[1])),
                    m = Math.pow(e[0] - c[0], 2) + Math.pow(e[1] - c[1], 2) - Math.pow(j, 2),
                    n = Math.pow(l, 2) - 4 * k * m,
                    o = g,
                    p = h;
                if (!(n < 0))
                    if (0 === n) f.lerp(o, e, i, n), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, n, p, -1);
                    else {
                        var q = Math.sqrt(n),
                            r = 1 / (2 * k),
                            s = (-l - q) * r,
                            t = (-l + q) * r;
                        if (s >= 0 && s <= 1 && (f.lerp(o, e, i, s), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, s, p, -1), a.shouldStop(b))) return;
                        t >= 0 && t <= 1 && (f.lerp(o, e, i, t), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, t, p, -1))
                    }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        40: [function(a, b, c) {
            function d(a) {
                Array.isArray(arguments[0]) && (a = { vertices: arguments[0], axes: arguments[1] }), a = a || {}, this.vertices = [];
                for (var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++) {
                    var d = f.create();
                    f.copy(d, b[c]), this.vertices.push(d)
                }
                if (this.axes = [], a.axes)
                    for (var c = 0; c < a.axes.length; c++) {
                        var g = f.create();
                        f.copy(g, a.axes[c]), this.axes.push(g)
                    }
                else
                    for (var c = 0; c < this.vertices.length; c++) {
                        var h = this.vertices[c],
                            i = this.vertices[(c + 1) % this.vertices.length],
                            j = f.create();
                        f.sub(j, i, h), f.rotate90cw(j, j), f.normalize(j, j), this.axes.push(j)
                    }
                if (this.centerOfMass = f.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, a.type = e.CONVEX, e.call(this, a), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var e = a("./Shape"),
                f = a("../math/vec2"),
                g = a("../math/polyk");
            a("poly-decomp");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d;
            var h = f.create(),
                i = f.create();
            d.prototype.projectOntoLocalAxis = function(a, b) {
                for (var c, d, e = null, g = null, a = h, i = 0; i < this.vertices.length; i++) c = this.vertices[i], d = f.dot(c, a), (null === e || d > e) && (e = d), (null === g || d < g) && (g = d);
                if (g > e) {
                    var j = g;
                    g = e, e = j
                }
                f.set(b, g, e)
            }, d.prototype.projectOntoWorldAxis = function(a, b, c, d) {
                var e = i;
                this.projectOntoLocalAxis(a, d), 0 !== c ? f.rotate(e, a, c) : e = a;
                var g = f.dot(b, e);
                f.set(d, d[0] + g, d[1] + g)
            }, d.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var a = [], b = 0; b < this.vertices.length; b++) {
                    var c = this.vertices[b];
                    a.push(c[0], c[1])
                }
                for (var d = g.Triangulate(a), b = 0; b < d.length; b += 3) {
                    var e = d[b],
                        f = d[b + 1],
                        h = d[b + 2];
                    this.triangles.push([e, f, h])
                }
            };
            var j = f.create(),
                k = f.create(),
                l = f.create(),
                m = f.create(),
                n = f.create();
            f.create(), f.create(), f.create(), f.create();
            d.prototype.updateCenterOfMass = function() {
                var a = this.triangles,
                    b = this.vertices,
                    c = this.centerOfMass,
                    e = j,
                    g = l,
                    h = m,
                    i = n,
                    o = k;
                f.set(c, 0, 0);
                for (var p = 0, q = 0; q !== a.length; q++) {
                    var r = a[q],
                        g = b[r[0]],
                        h = b[r[1]],
                        i = b[r[2]];
                    f.centroid(e, g, h, i);
                    var s = d.triangleArea(g, h, i);
                    p += s, f.scale(o, e, s), f.add(c, c, o)
                }
                f.scale(c, c, 1 / p)
            }, d.prototype.computeMomentOfInertia = function(a) {
                for (var b = 0, c = 0, d = this.vertices.length, e = d - 1, g = 0; g < d; e = g, g++) {
                    var h = this.vertices[e],
                        i = this.vertices[g],
                        j = Math.abs(f.crossLength(h, i)),
                        k = f.dot(i, i) + f.dot(i, h) + f.dot(h, h);
                    b += j * k, c += j
                }
                return a / 6 * (b / c)
            }, d.prototype.updateBoundingRadius = function() {
                for (var a = this.vertices, b = 0, c = 0; c !== a.length; c++) {
                    var d = f.squaredLength(a[c]);
                    d > b && (b = d)
                }
                this.boundingRadius = Math.sqrt(b)
            }, d.triangleArea = function(a, b, c) { return .5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])) }, d.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var a = this.triangles, b = this.vertices, c = 0; c !== a.length; c++) {
                    var e = a[c],
                        f = b[e[0]],
                        g = b[e[1]],
                        h = b[e[2]],
                        i = d.triangleArea(f, g, h);
                    this.area += i
                }
            }, d.prototype.computeAABB = function(a, b, c) { a.setFromPoints(this.vertices, b, c, 0) };
            var o = f.create(),
                p = f.create(),
                q = f.create();
            d.prototype.raycast = function(a, b, c, d) {
                var e = o,
                    g = p,
                    h = q,
                    i = this.vertices;
                f.toLocalFrame(e, b.from, c, d), f.toLocalFrame(g, b.to, c, d);
                for (var j = i.length, k = 0; k < j && !a.shouldStop(b); k++) {
                    var l = i[k],
                        m = i[(k + 1) % j],
                        n = f.getLineSegmentsIntersectionFraction(e, g, l, m);
                    n >= 0 && (f.sub(h, m, l), f.rotate(h, h, -Math.PI / 2 + d), f.normalize(h, h), b.reportIntersection(a, n, h, k))
                }
            }
        }, { "../math/polyk": 29, "../math/vec2": 30, "./Shape": 45, "poly-decomp": 5 }],
        41: [function(a, b, c) {
            function d(a) {
                if (Array.isArray(arguments[0]) && (a = { heights: arguments[0] }, "object" == typeof arguments[1]))
                    for (var b in arguments[1]) a[b] = arguments[1][b];
                a = a || {}, this.heights = a.heights ? a.heights.slice(0) : [], this.maxValue = a.maxValue || null, this.minValue = a.minValue || null, this.elementWidth = a.elementWidth || .1, void 0 !== a.maxValue && void 0 !== a.minValue || this.updateMaxMinValues(), a.type = e.HEIGHTFIELD, e.call(this, a)
            }
            var e = a("./Shape"),
                f = a("../math/vec2");
            a("../utils/Utils");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.updateMaxMinValues = function() {
                for (var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++) {
                    var e = a[d];
                    e > b && (b = e), e < c && (c = e)
                }
                this.maxValue = b, this.minValue = c
            }, d.prototype.computeMomentOfInertia = function(a) { return Number.MAX_VALUE }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, d.prototype.updateArea = function() {
                for (var a = this.heights, b = 0, c = 0; c < a.length - 1; c++) b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
                this.area = b
            };
            var g = [f.create(), f.create(), f.create(), f.create()];
            d.prototype.computeAABB = function(a, b, c) { f.set(g[0], 0, this.maxValue), f.set(g[1], this.elementWidth * this.heights.length, this.maxValue), f.set(g[2], this.elementWidth * this.heights.length, this.minValue), f.set(g[3], 0, this.minValue), a.setFromPoints(g, b, c) }, d.prototype.getLineSegment = function(a, b, c) {
                var d = this.heights,
                    e = this.elementWidth;
                f.set(a, c * e, d[c]), f.set(b, (c + 1) * e, d[c + 1])
            }, d.prototype.getSegmentIndex = function(a) { return Math.floor(a[0] / this.elementWidth) }, d.prototype.getClampedSegmentIndex = function(a) { var b = this.getSegmentIndex(a); return b = Math.min(this.heights.length, Math.max(b, 0)) };
            var h = (f.create(), f.create()),
                i = f.create(),
                j = f.create(),
                k = f.create(),
                l = f.create();
            f.fromValues(0, 1);
            d.prototype.raycast = function(a, b, c, d) {
                var e = b.from,
                    g = b.to,
                    m = (b.direction, h),
                    n = i,
                    o = j,
                    p = k,
                    q = l;
                f.toLocalFrame(p, e, c, d), f.toLocalFrame(q, g, c, d);
                var r = this.getClampedSegmentIndex(p),
                    s = this.getClampedSegmentIndex(q);
                if (r > s) {
                    var t = r;
                    r = s, s = t
                }
                for (var u = 0; u < this.heights.length - 1; u++) { this.getLineSegment(n, o, u); var v = f.getLineSegmentsIntersectionFraction(p, q, n, o); if (v >= 0 && (f.sub(m, o, n), f.rotate(m, m, d + Math.PI / 2), f.normalize(m, m), b.reportIntersection(a, v, m, -1), a.shouldStop(b))) return }
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }],
        42: [function(a, b, c) {
            function d(a) { "number" == typeof arguments[0] && (a = { length: arguments[0] }), a = a || {}, this.length = a.length || 1, a.type = e.LINE, e.call(this, a) }
            var e = a("./Shape"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) { return a * Math.pow(this.length, 2) / 12 }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = this.length / 2 };
            var g = [f.create(), f.create()];
            d.prototype.computeAABB = function(a, b, c) {
                var d = this.length / 2;
                f.set(g[0], -d, 0), f.set(g[1], d, 0), a.setFromPoints(g, b, c, 0)
            };
            var h = (f.create(), f.create()),
                i = f.create(),
                j = f.create(),
                k = f.fromValues(0, 1);
            d.prototype.raycast = function(a, b, c, d) {
                var e = b.from,
                    g = b.to,
                    l = i,
                    m = j,
                    n = this.length / 2;
                f.set(l, -n, 0), f.set(m, n, 0), f.toGlobalFrame(l, l, c, d), f.toGlobalFrame(m, m, c, d);
                var o = f.getLineSegmentsIntersectionFraction(l, m, e, g);
                if (o >= 0) {
                    var p = h;
                    f.rotate(p, k, d), b.reportIntersection(a, o, p, -1)
                }
            }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        43: [function(a, b, c) {
            function d(a) { a = a || {}, a.type = e.PARTICLE, e.call(this, a) }
            var e = a("./Shape"),
                f = a("../math/vec2");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) { return 0 }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = 0 }, d.prototype.computeAABB = function(a, b, c) { f.copy(a.lowerBound, b), f.copy(a.upperBound, b) }
        }, { "../math/vec2": 30, "./Shape": 45 }],
        44: [function(a, b, c) {
            function d(a) { a = a || {}, a.type = e.PLANE, e.call(this, a) }
            var e = a("./Shape"),
                f = a("../math/vec2");
            a("../utils/Utils");
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.computeMomentOfInertia = function(a) { return 0 }, d.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, d.prototype.computeAABB = function(a, b, c) {
                var d = c % (2 * Math.PI),
                    e = f.set,
                    g = Number.MAX_VALUE,
                    h = a.lowerBound,
                    i = a.upperBound;
                0 === d ? (e(h, -g, -g), e(i, g, 0)) : d === Math.PI / 2 ? (e(h, 0, -g), e(i, g, g)) : d === Math.PI ? (e(h, -g, 0), e(i, g, g)) : d === 3 * Math.PI / 2 ? (e(h, -g, -g), e(i, 0, g)) : (e(h, -g, -g), e(i, g, g)), f.add(h, h, b), f.add(i, i, b)
            }, d.prototype.updateArea = function() { this.area = Number.MAX_VALUE };
            var g = f.create(),
                h = (f.create(), f.create(), f.create()),
                i = f.create();
            d.prototype.raycast = function(a, b, c, d) {
                var e = b.from,
                    j = b.to,
                    k = b.direction,
                    l = g,
                    m = h,
                    n = i;
                f.set(m, 0, 1), f.rotate(m, m, d), f.sub(n, e, c);
                var o = f.dot(n, m);
                f.sub(n, j, c);
                var p = f.dot(n, m);
                if (!(o * p > 0 || f.squaredDistance(e, j) < o * o)) {
                    var q = f.dot(m, k);
                    f.sub(l, e, c);
                    var r = -f.dot(m, l) / q / b.length;
                    b.reportIntersection(a, r, m, -1)
                }
            }
        }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }],
        45: [function(a, b, c) {
            function d(a) { a = a || {}, this.body = null, this.position = e.fromValues(0, 0), a.position && e.copy(this.position, a.position), this.angle = a.angle || 0, this.type = a.type || 0, this.id = d.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1, this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse, this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1, this.material = a.material || null, this.area = 0, this.sensor = void 0 !== a.sensor && a.sensor, this.type && this.updateBoundingRadius(), this.updateArea() } b.exports = d;
            var e = a("../math/vec2");
            d.idCounter = 0, d.CIRCLE = 1, d.PARTICLE = 2, d.PLANE = 4, d.CONVEX = 8, d.LINE = 16, d.BOX = 32, Object.defineProperty(d, "RECTANGLE", { get: function() { return d.BOX } }), d.CAPSULE = 64, d.HEIGHTFIELD = 128, d.prototype.computeMomentOfInertia = function(a) {}, d.prototype.updateBoundingRadius = function() {}, d.prototype.updateArea = function() {}, d.prototype.computeAABB = function(a, b, c) {}, d.prototype.raycast = function(a, b, c, d) {}
        }, { "../math/vec2": 30 }],
        46: [function(a, b, c) {
            function d(a) { g.call(this, a, g.GS), a = a || {}, this.iterations = a.iterations || 10, this.tolerance = a.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new h.ARRAY_TYPE(this.arrayStep), this.Bs = new h.ARRAY_TYPE(this.arrayStep), this.invCs = new h.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0 }

            function e(a) { for (var b = a.length; b--;) a[b] = 0 }
            var f = a("../math/vec2"),
                g = a("./Solver"),
                h = a("../utils/Utils"),
                i = a("../equations/FrictionEquation");
            b.exports = d, d.prototype = new g, d.prototype.constructor = d, d.prototype.solve = function(a, b) {
                this.sortEquations();
                var c = 0,
                    g = this.iterations,
                    j = this.frictionIterations,
                    k = this.equations,
                    l = k.length,
                    m = Math.pow(this.tolerance * l, 2),
                    n = b.bodies,
                    o = b.bodies.length,
                    p = (f.add, f.set, this.useZeroRHS),
                    q = this.lambda;
                if (this.usedIterations = 0, l)
                    for (var r = 0; r !== o; r++) {
                        var s = n[r];
                        s.updateSolveMassProperties()
                    }
                q.length < l && (q = this.lambda = new h.ARRAY_TYPE(l + this.arrayStep), this.Bs = new h.ARRAY_TYPE(l + this.arrayStep), this.invCs = new h.ARRAY_TYPE(l + this.arrayStep)), e(q);
                for (var t = this.invCs, u = this.Bs, q = this.lambda, r = 0; r !== k.length; r++) {
                    var v = k[r];
                    (v.timeStep !== a || v.needsUpdate) && (v.timeStep = a, v.update()), u[r] = v.computeB(v.a, v.b, a), t[r] = v.computeInvC(v.epsilon)
                }
                var v, w, r, x;
                if (0 !== l) {
                    for (r = 0; r !== o; r++) {
                        var s = n[r];
                        s.resetConstraintVelocity()
                    }
                    if (j) {
                        for (c = 0; c !== j; c++) {
                            for (w = 0, x = 0; x !== l; x++) {
                                v = k[x];
                                var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                                w += Math.abs(y)
                            }
                            if (this.usedIterations++, w * w <= m) break
                        }
                        for (d.updateMultipliers(k, q, 1 / a), x = 0; x !== l; x++) {
                            var z = k[x];
                            if (z instanceof i) {
                                for (var A = 0, B = 0; B !== z.contactEquations.length; B++) A += z.contactEquations[B].multiplier;
                                A *= z.frictionCoefficient / z.contactEquations.length, z.maxForce = A, z.minForce = -A
                            }
                        }
                    }
                    for (c = 0; c !== g; c++) {
                        for (w = 0, x = 0; x !== l; x++) {
                            v = k[x];
                            var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                            w += Math.abs(y)
                        }
                        if (this.usedIterations++, w * w <= m) break
                    }
                    for (r = 0; r !== o; r++) n[r].addConstraintVelocity();
                    d.updateMultipliers(k, q, 1 / a)
                }
            }, d.updateMultipliers = function(a, b, c) { for (var d = a.length; d--;) a[d].multiplier = b[d] * c }, d.iterateEquation = function(a, b, c, d, e, f, g, h, i) {
                var j = d[a],
                    k = e[a],
                    l = f[a],
                    m = b.computeGWlambda(),
                    n = b.maxForce,
                    o = b.minForce;
                g && (j = 0);
                var p = k * (j - m - c * l),
                    q = l + p;
                return q < o * h ? p = o * h - l : q > n * h && (p = n * h - l), f[a] += p, b.addToWlambda(p), p
            }
        }, { "../equations/FrictionEquation": 23, "../math/vec2": 30, "../utils/Utils": 57, "./Solver": 47 }],
        47: [function(a, b, c) {
            function d(a, b) { a = a || {}, e.call(this), this.type = b, this.equations = [], this.equationSortFunction = a.equationSortFunction || !1 }
            var e = (a("../utils/Utils"), a("../events/EventEmitter"));
            b.exports = d, d.prototype = new e, d.prototype.constructor = d, d.prototype.solve = function(a, b) { throw new Error("Solver.solve should be implemented by subclasses!") };
            var f = { bodies: [] };
            d.prototype.solveIsland = function(a, b) { this.removeAllEquations(), b.equations.length && (this.addEquations(b.equations), f.bodies.length = 0, b.getBodies(f.bodies), f.bodies.length && this.solve(a, f)) }, d.prototype.sortEquations = function() { this.equationSortFunction && this.equations.sort(this.equationSortFunction) }, d.prototype.addEquation = function(a) { a.enabled && this.equations.push(a) }, d.prototype.addEquations = function(a) {
                for (var b = 0, c = a.length; b !== c; b++) {
                    var d = a[b];
                    d.enabled && this.equations.push(d)
                }
            }, d.prototype.removeEquation = function(a) {
                var b = this.equations.indexOf(a);
                b !== -1 && this.equations.splice(b, 1)
            }, d.prototype.removeAllEquations = function() { this.equations.length = 0 }, d.GS = 1, d.ISLAND = 2
        }, { "../events/EventEmitter": 26, "../utils/Utils": 57 }],
        48: [function(a, b, c) {
            function d() { f.apply(this, arguments) }
            var e = a("../equations/ContactEquation"),
                f = a("./Pool");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() { return new e }, d.prototype.destroy = function(a) { return a.bodyA = a.bodyB = null, this }
        }, { "../equations/ContactEquation": 21, "./Pool": 55 }],
        49: [function(a, b, c) {
            function d() { f.apply(this, arguments) }
            var e = a("../equations/FrictionEquation"),
                f = a("./Pool");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() { return new e }, d.prototype.destroy = function(a) { return a.bodyA = a.bodyB = null, this }
        }, { "../equations/FrictionEquation": 23, "./Pool": 55 }],
        50: [function(a, b, c) {
            function d() { f.apply(this, arguments) }
            var e = a("../world/IslandNode"),
                f = a("./Pool");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() { return new e }, d.prototype.destroy = function(a) { return a.reset(), this }
        }, { "../world/IslandNode": 60, "./Pool": 55 }],
        51: [function(a, b, c) {
            function d() { f.apply(this, arguments) }
            var e = a("../world/Island"),
                f = a("./Pool");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() { return new e }, d.prototype.destroy = function(a) { return a.reset(), this }
        }, { "../world/Island": 58, "./Pool": 55 }],
        52: [function(a, b, c) {
            function d() { this.overlappingShapesLastState = new e, this.overlappingShapesCurrentState = new e, this.recordPool = new f({ size: 16 }), this.tmpDict = new e, this.tmpArray1 = [] }
            var e = a("./TupleDictionary"),
                f = (a("./OverlapKeeperRecord"), a("./OverlapKeeperRecordPool"));
            a("./Utils");
            b.exports = d, d.prototype.tick = function() {
                for (var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--;) {
                    var d = a.keys[c],
                        e = a.getByKey(d);
                    b.getByKey(d);
                    e && this.recordPool.release(e)
                }
                a.reset(), a.copy(b), b.reset()
            }, d.prototype.setOverlapping = function(a, b, c, d) {
                var e = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
                if (!e.get(b.id, d.id)) {
                    var f = this.recordPool.get();
                    f.set(a, b, c, d), e.set(b.id, d.id, f)
                }
            }, d.prototype.getNewOverlaps = function(a) { return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a) }, d.prototype.getEndOverlaps = function(a) { return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a) }, d.prototype.bodiesAreOverlapping = function(a, b) {
                for (var c = this.overlappingShapesCurrentState, d = c.keys.length; d--;) {
                    var e = c.keys[d],
                        f = c.data[e];
                    if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a) return !0
                }
                return !1
            }, d.prototype.getDiff = function(a, b, c) {
                var c = c || [],
                    d = a,
                    e = b;
                c.length = 0;
                for (var f = e.keys.length; f--;) {
                    var g = e.keys[f],
                        h = e.data[g];
                    if (!h) throw new Error("Key " + g + " had no data!");
                    var i = d.data[g];
                    i || c.push(h)
                }
                return c
            }, d.prototype.isNewOverlap = function(a, b) {
                var c = 0 | a.id,
                    d = 0 | b.id,
                    e = this.overlappingShapesLastState,
                    f = this.overlappingShapesCurrentState;
                return !e.get(c, d) && !!f.get(c, d)
            }, d.prototype.getNewBodyOverlaps = function(a) { this.tmpArray1.length = 0; var b = this.getNewOverlaps(this.tmpArray1); return this.getBodyDiff(b, a) }, d.prototype.getEndBodyOverlaps = function(a) { this.tmpArray1.length = 0; var b = this.getEndOverlaps(this.tmpArray1); return this.getBodyDiff(b, a) }, d.prototype.getBodyDiff = function(a, b) {
                b = b || [];
                for (var c = this.tmpDict, d = a.length; d--;) {
                    var e = a[d];
                    c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e)
                }
                for (d = c.keys.length; d--;) {
                    var e = c.getByKey(c.keys[d]);
                    e && b.push(e.bodyA, e.bodyB)
                }
                return c.reset(), b
            }
        }, { "./OverlapKeeperRecord": 53, "./OverlapKeeperRecordPool": 54, "./TupleDictionary": 56, "./Utils": 57 }],
        53: [function(a, b, c) {
            function d(a, b, c, d) { this.shapeA = b, this.shapeB = d, this.bodyA = a, this.bodyB = c } b.exports = d, d.prototype.set = function(a, b, c, e) { d.call(this, a, b, c, e) }
        }, {}],
        54: [function(a, b, c) {
            function d() { f.apply(this, arguments) }
            var e = a("./OverlapKeeperRecord"),
                f = a("./Pool");
            b.exports = d, d.prototype = new f, d.prototype.constructor = d, d.prototype.create = function() { return new e }, d.prototype.destroy = function(a) { return a.bodyA = a.bodyB = a.shapeA = a.shapeB = null, this }
        }, { "./OverlapKeeperRecord": 53, "./Pool": 55 }],
        55: [function(a, b, c) {
            function d(a) { a = a || {}, this.objects = [], void 0 !== a.size && this.resize(a.size) } b.exports = d, d.prototype.resize = function(a) { for (var b = this.objects; b.length > a;) b.pop(); for (; b.length < a;) b.push(this.create()); return this }, d.prototype.get = function() { var a = this.objects; return a.length ? a.pop() : this.create() }, d.prototype.release = function(a) { return this.destroy(a), this.objects.push(a), this }
        }, {}],
        56: [function(a, b, c) {
            function d() { this.data = {}, this.keys = [] }
            var e = a("./Utils");
            b.exports = d, d.prototype.getKey = function(a, b) { return a = 0 | a, b = 0 | b, (0 | a) === (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a) }, d.prototype.getByKey = function(a) { return a = 0 | a, this.data[a] }, d.prototype.get = function(a, b) { return this.data[this.getKey(a, b)] }, d.prototype.set = function(a, b, c) { if (!c) throw new Error("No data!"); var d = this.getKey(a, b); return this.data[d] || this.keys.push(d), this.data[d] = c, d }, d.prototype.reset = function() {
                for (var a = this.data, b = this.keys, c = b.length; c--;) delete a[b[c]];
                b.length = 0
            }, d.prototype.copy = function(a) {
                this.reset(), e.appendArray(this.keys, a.keys);
                for (var b = a.keys.length; b--;) {
                    var c = a.keys[b];
                    this.data[c] = a.data[c]
                }
            }
        }, { "./Utils": 57 }],
        57: [function(a, b, c) {
            function d() {} b.exports = d, d.appendArray = function(a, b) {
                if (b.length < 15e4) a.push.apply(a, b);
                else
                    for (var c = 0, d = b.length; c !== d; ++c) a.push(b[c])
            }, d.splice = function(a, b, c) {
                c = c || 1;
                for (var d = b, e = a.length - c; d < e; d++) a[d] = a[d + c];
                a.length = e
            }, "undefined" != typeof P2_ARRAY_TYPE ? d.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? d.ARRAY_TYPE = Float32Array : d.ARRAY_TYPE = Array, d.extend = function(a, b) { for (var c in b) a[c] = b[c] }, d.defaults = function(a, b) { a = a || {}; for (var c in b) c in a || (a[c] = b[c]); return a }
        }, {}],
        58: [function(a, b, c) {
            function d() { this.equations = [], this.bodies = [] }
            var e = a("../objects/Body");
            b.exports = d, d.prototype.reset = function() { this.equations.length = this.bodies.length = 0 };
            var f = [];
            d.prototype.getBodies = function(a) {
                var b = a || [],
                    c = this.equations;
                f.length = 0;
                for (var d = 0; d !== c.length; d++) {
                    var e = c[d];
                    f.indexOf(e.bodyA.id) === -1 && (b.push(e.bodyA), f.push(e.bodyA.id)), f.indexOf(e.bodyB.id) === -1 && (b.push(e.bodyB), f.push(e.bodyB.id))
                }
                return b
            }, d.prototype.wantsToSleep = function() { for (var a = 0; a < this.bodies.length; a++) { var b = this.bodies[a]; if (b.type === e.DYNAMIC && !b.wantsToSleep) return !1 } return !0 }, d.prototype.sleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    var b = this.bodies[a];
                    b.sleep()
                }
                return !0
            }
        }, { "../objects/Body": 31 }],
        59: [function(a, b, c) {
            function d(a) { this.nodePool = new e({ size: 16 }), this.islandPool = new f({ size: 8 }), this.equations = [], this.islands = [], this.nodes = [], this.queue = [] }
            var e = (a("../math/vec2"), a("./Island"), a("./IslandNode"), a("./../utils/IslandNodePool")),
                f = a("./../utils/IslandPool"),
                g = a("../objects/Body");
            b.exports = d, d.getUnvisitedNode = function(a) { for (var b = a.length, c = 0; c !== b; c++) { var d = a[c]; if (!d.visited && d.body.type === g.DYNAMIC) return d } return !1 }, d.prototype.visit = function(a, b, c) {
                b.push(a.body);
                for (var d = a.equations.length, e = 0; e !== d; e++) {
                    var f = a.equations[e];
                    c.indexOf(f) === -1 && c.push(f)
                }
            }, d.prototype.bfs = function(a, b, c) {
                var e = this.queue;
                for (e.length = 0, e.push(a), a.visited = !0, this.visit(a, b, c); e.length;)
                    for (var f, h = e.pop(); f = d.getUnvisitedNode(h.neighbors);) f.visited = !0, this.visit(f, b, c), f.body.type === g.DYNAMIC && e.push(f)
            }, d.prototype.split = function(a) {
                for (var b = a.bodies, c = this.nodes, e = this.equations; c.length;) this.nodePool.release(c.pop());
                for (var f = 0; f !== b.length; f++) {
                    var g = this.nodePool.get();
                    g.body = b[f], c.push(g)
                }
                for (var h = 0; h !== e.length; h++) {
                    var i = e[h],
                        f = b.indexOf(i.bodyA),
                        j = b.indexOf(i.bodyB),
                        k = c[f],
                        l = c[j];
                    k.neighbors.push(l), l.neighbors.push(k), k.equations.push(i), l.equations.push(i)
                }
                for (var m = this.islands, f = 0; f < m.length; f++) this.islandPool.release(m[f]);
                m.length = 0;
                for (var n; n = d.getUnvisitedNode(c);) {
                    var o = this.islandPool.get();
                    this.bfs(n, o.bodies, o.equations), m.push(o)
                }
                return m
            }
        }, { "../math/vec2": 30, "../objects/Body": 31, "./../utils/IslandNodePool": 50, "./../utils/IslandPool": 51, "./Island": 58, "./IslandNode": 60 }],
        60: [function(a, b, c) {
            function d(a) { this.body = a, this.neighbors = [], this.equations = [], this.visited = !1 } b.exports = d, d.prototype.reset = function() { this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null }
        }, {}],
        61: [function(a, b, c) {
            function d(a) { l.apply(this), a = a || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = a.solver || new e, this.narrowphase = new r(this), this.islandManager = new u, this.gravity = f.fromValues(0, -9.78), a.gravity && f.copy(this.gravity, a.gravity), this.frictionGravity = f.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = a.broadphase || new q, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new n, this.defaultContactMaterial = new o(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = "undefined" == typeof a.islandSplit || !!a.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = { type: "postStep" }, this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.addSpringEvent = { type: "addSpring", spring: null }, this.impactEvent = { type: "impact", bodyA: null, bodyB: null, shapeA: null, shapeB: null, contactEquation: null }, this.postBroadphaseEvent = { type: "postBroadphase", pairs: null }, this.sleepMode = d.NO_SLEEPING, this.beginContactEvent = { type: "beginContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null, contactEquations: [] }, this.endContactEvent = { type: "endContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null }, this.preSolveEvent = { type: "preSolve", contactEquations: null, frictionEquations: null }, this.overlappingShapesLastState = { keys: [] }, this.overlappingShapesCurrentState = { keys: [] }, this.overlapKeeper = new t }
            var e = a("../solver/GSSolver"),
                f = (a("../solver/Solver"), a("../collision/Ray"), a("../math/vec2")),
                g = a("../shapes/Circle"),
                h = a("../shapes/Convex"),
                i = (a("../shapes/Line"), a("../shapes/Plane")),
                j = a("../shapes/Capsule"),
                k = a("../shapes/Particle"),
                l = a("../events/EventEmitter"),
                m = a("../objects/Body"),
                n = (a("../shapes/Shape"), a("../objects/LinearSpring"), a("../material/Material")),
                o = a("../material/ContactMaterial"),
                p = (a("../constraints/DistanceConstraint"), a("../constraints/Constraint"), a("../constraints/LockConstraint"), a("../constraints/RevoluteConstraint"), a("../constraints/PrismaticConstraint"), a("../constraints/GearConstraint"), a("../../package.json"), a("../collision/Broadphase"), a("../collision/AABB")),
                q = a("../collision/SAPBroadphase"),
                r = a("../collision/Narrowphase"),
                s = a("../utils/Utils"),
                t = a("../utils/OverlapKeeper"),
                u = a("./IslandManager");
            a("../objects/RotationalSpring");
            b.exports = d, d.prototype = new Object(l.prototype), d.prototype.constructor = d, d.NO_SLEEPING = 1, d.BODY_SLEEPING = 2, d.ISLAND_SLEEPING = 4, d.prototype.addConstraint = function(a) { this.constraints.push(a) }, d.prototype.addContactMaterial = function(a) { this.contactMaterials.push(a) }, d.prototype.removeContactMaterial = function(a) {
                var b = this.contactMaterials.indexOf(a);
                b !== -1 && s.splice(this.contactMaterials, b, 1)
            }, d.prototype.getContactMaterial = function(a, b) { for (var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++) { var f = c[d]; if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id) return f } return !1 }, d.prototype.removeConstraint = function(a) {
                var b = this.constraints.indexOf(a);
                b !== -1 && s.splice(this.constraints, b, 1)
            };
            var v = (f.create(), f.create(), f.create(), f.create(), f.create(), f.create(), f.create()),
                w = f.fromValues(0, 0),
                x = f.fromValues(0, 0);
            f.fromValues(0, 0), f.fromValues(0, 0);
            d.prototype.step = function(a, b, c) {
                if (c = c || 10, b = b || 0, 0 === b) this.internalStep(a), this.time += a;
                else {
                    this.accumulator += b;
                    for (var d = 0; this.accumulator >= a && d < c;) this.internalStep(a), this.time += a, this.accumulator -= a, d++;
                    for (var e = this.accumulator % a / a, g = 0; g !== this.bodies.length; g++) {
                        var h = this.bodies[g];
                        f.lerp(h.interpolatedPosition, h.previousPosition, h.position, e), h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle)
                    }
                }
            };
            var y = [];
            d.prototype.internalStep = function(a) {
                this.stepping = !0;
                var b = this.springs.length,
                    c = this.springs,
                    e = this.bodies,
                    g = this.gravity,
                    h = this.solver,
                    i = this.bodies.length,
                    j = this.broadphase,
                    k = this.narrowphase,
                    l = this.constraints,
                    n = v,
                    o = (f.scale, f.add),
                    p = (f.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = a, this.useWorldGravityAsFrictionGravity) {
                    var q = f.length(this.gravity);
                    0 === q && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = q)
                }
                if (this.applyGravity)
                    for (var r = 0; r !== i; r++) {
                        var t = e[r],
                            u = t.force;
                        t.type === m.DYNAMIC && t.sleepState !== m.SLEEPING && (f.scale(n, g, t.mass * t.gravityScale), o(u, u, n))
                    }
                if (this.applySpringForces)
                    for (var r = 0; r !== b; r++) {
                        var w = c[r];
                        w.applyForce()
                    }
                if (this.applyDamping)
                    for (var r = 0; r !== i; r++) {
                        var t = e[r];
                        t.type === m.DYNAMIC && t.applyDamping(a)
                    }
                for (var x = j.getCollisionPairs(this), z = this.disabledBodyCollisionPairs, r = z.length - 2; r >= 0; r -= 2)
                    for (var A = x.length - 2; A >= 0; A -= 2)(z[r] === x[A] && z[r + 1] === x[A + 1] || z[r + 1] === x[A] && z[r] === x[A + 1]) && x.splice(A, 2);
                var B = l.length;
                for (r = 0; r !== B; r++) {
                    var C = l[r];
                    if (!C.collideConnected)
                        for (var A = x.length - 2; A >= 0; A -= 2)(C.bodyA === x[A] && C.bodyB === x[A + 1] || C.bodyB === x[A] && C.bodyA === x[A + 1]) && x.splice(A, 2)
                }
                this.postBroadphaseEvent.pairs = x, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, k.reset(this);
                for (var r = 0, D = x.length; r !== D; r += 2)
                    for (var E = x[r], F = x[r + 1], G = 0, H = E.shapes.length; G !== H; G++)
                        for (var I = E.shapes[G], J = I.position, K = I.angle, L = 0, M = F.shapes.length; L !== M; L++) {
                            var N = F.shapes[L],
                                O = N.position,
                                P = N.angle,
                                Q = this.defaultContactMaterial;
                            if (I.material && N.material) {
                                var R = this.getContactMaterial(I.material, N.material);
                                R && (Q = R)
                            }
                            this.runNarrowphase(k, E, I, J, K, F, N, O, P, Q, this.frictionGravity)
                        }
                for (var r = 0; r !== i; r++) {
                    var S = e[r];
                    S._wakeUpAfterNarrowphase && (S.wakeUp(), S._wakeUpAfterNarrowphase = !1)
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(y);
                    for (var T = this.endContactEvent, L = y.length; L--;) {
                        var U = y[L];
                        T.shapeA = U.shapeA, T.shapeB = U.shapeB, T.bodyA = U.bodyA, T.bodyB = U.bodyB, this.emit(T)
                    }
                    y.length = 0
                }
                var V = this.preSolveEvent;
                V.contactEquations = k.contactEquations, V.frictionEquations = k.frictionEquations, this.emit(V), V.contactEquations = V.frictionEquations = null;
                var B = l.length;
                for (r = 0; r !== B; r++) l[r].update();
                if (k.contactEquations.length || k.frictionEquations.length || B)
                    if (this.islandSplit) {
                        for (p.equations.length = 0, s.appendArray(p.equations, k.contactEquations), s.appendArray(p.equations, k.frictionEquations), r = 0; r !== B; r++) s.appendArray(p.equations, l[r].equations);
                        p.split(this);
                        for (var r = 0; r !== p.islands.length; r++) {
                            var W = p.islands[r];
                            W.equations.length && h.solveIsland(a, W)
                        }
                    }
                else {
                    for (h.addEquations(k.contactEquations), h.addEquations(k.frictionEquations), r = 0; r !== B; r++) h.addEquations(l[r].equations);
                    this.solveConstraints && h.solve(a, this), h.removeAllEquations()
                }
                for (var r = 0; r !== i; r++) {
                    var S = e[r];
                    S.integrate(a)
                }
                for (var r = 0; r !== i; r++) e[r].setZeroForce();
                if (this.emitImpactEvent && this.has("impact"))
                    for (var X = this.impactEvent, r = 0; r !== k.contactEquations.length; r++) {
                        var Y = k.contactEquations[r];
                        Y.firstImpact && (X.bodyA = Y.bodyA, X.bodyB = Y.bodyB, X.shapeA = Y.shapeA, X.shapeB = Y.shapeB, X.contactEquation = Y, this.emit(X))
                    }
                if (this.sleepMode === d.BODY_SLEEPING)
                    for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !1, a);
                else if (this.sleepMode === d.ISLAND_SLEEPING && this.islandSplit) {
                    for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !0, a);
                    for (var r = 0; r < this.islandManager.islands.length; r++) {
                        var W = this.islandManager.islands[r];
                        W.wantsToSleep() && W.sleep()
                    }
                }
                this.stepping = !1;
                for (var Z = this.bodiesToBeRemoved, r = 0; r !== Z.length; r++) this.removeBody(Z[r]);
                Z.length = 0, this.emit(this.postStepEvent)
            }, d.prototype.runNarrowphase = function(a, b, c, d, e, g, h, i, j, k, l) {
                if (0 !== (c.collisionGroup & h.collisionMask) && 0 !== (h.collisionGroup & c.collisionMask)) {
                    f.rotate(w, d, b.angle), f.rotate(x, i, g.angle), f.add(w, w, b.position), f.add(x, x, g.position);
                    var n = e + b.angle,
                        o = j + g.angle;
                    a.enableFriction = k.friction > 0, a.frictionCoefficient = k.friction;
                    var p;
                    p = b.type === m.STATIC || b.type === m.KINEMATIC ? g.mass : g.type === m.STATIC || g.type === m.KINEMATIC ? b.mass : b.mass * g.mass / (b.mass + g.mass), a.slipForce = k.friction * l * p, a.restitution = k.restitution, a.surfaceVelocity = k.surfaceVelocity, a.frictionStiffness = k.frictionStiffness, a.frictionRelaxation = k.frictionRelaxation, a.stiffness = k.stiffness, a.relaxation = k.relaxation, a.contactSkinSize = k.contactSkinSize, a.enabledEquations = b.collisionResponse && g.collisionResponse && c.collisionResponse && h.collisionResponse;
                    var q = a[c.type | h.type],
                        r = 0;
                    if (q) {
                        var s = c.sensor || h.sensor,
                            t = a.frictionEquations.length;
                        r = c.type < h.type ? q.call(a, b, c, w, n, g, h, x, o, s) : q.call(a, g, h, x, o, b, c, w, n, s);
                        var u = a.frictionEquations.length - t;
                        if (r) {
                            if (b.allowSleep && b.type === m.DYNAMIC && b.sleepState === m.SLEEPING && g.sleepState === m.AWAKE && g.type !== m.STATIC) {
                                var v = f.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2),
                                    y = Math.pow(g.sleepSpeedLimit, 2);
                                v >= 2 * y && (b._wakeUpAfterNarrowphase = !0)
                            }
                            if (g.allowSleep && g.type === m.DYNAMIC && g.sleepState === m.SLEEPING && b.sleepState === m.AWAKE && b.type !== m.STATIC) {
                                var z = f.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2),
                                    A = Math.pow(b.sleepSpeedLimit, 2);
                                z >= 2 * A && (g._wakeUpAfterNarrowphase = !0)
                            }
                            if (this.overlapKeeper.setOverlapping(b, c, g, h), this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                                var B = this.beginContactEvent;
                                if (B.shapeA = c, B.shapeB = h, B.bodyA = b, B.bodyB = g, B.contactEquations.length = 0, "number" == typeof r)
                                    for (var C = a.contactEquations.length - r; C < a.contactEquations.length; C++) B.contactEquations.push(a.contactEquations[C]);
                                this.emit(B)
                            }
                            if ("number" == typeof r && u > 1)
                                for (var C = a.frictionEquations.length - u; C < a.frictionEquations.length; C++) {
                                    var D = a.frictionEquations[C];
                                    D.setSlipForce(D.getSlipForce() / u)
                                }
                        }
                    }
                }
            }, d.prototype.addSpring = function(a) {
                this.springs.push(a);
                var b = this.addSpringEvent;
                b.spring = a, this.emit(b), b.spring = null
            }, d.prototype.removeSpring = function(a) {
                var b = this.springs.indexOf(a);
                b !== -1 && s.splice(this.springs, b, 1)
            }, d.prototype.addBody = function(a) {
                if (this.bodies.indexOf(a) === -1) {
                    this.bodies.push(a), a.world = this;
                    var b = this.addBodyEvent;
                    b.body = a, this.emit(b), b.body = null
                }
            }, d.prototype.removeBody = function(a) {
                if (this.stepping) this.bodiesToBeRemoved.push(a);
                else {
                    a.world = null;
                    var b = this.bodies.indexOf(a);
                    b !== -1 && (s.splice(this.bodies, b, 1), this.removeBodyEvent.body = a, a.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            }, d.prototype.getBodyById = function(a) { for (var b = this.bodies, c = 0; c < b.length; c++) { var d = b[c]; if (d.id === a) return d } return !1 }, d.prototype.disableBodyCollision = function(a, b) { this.disabledBodyCollisionPairs.push(a, b) }, d.prototype.enableBodyCollision = function(a, b) {
                for (var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2)
                    if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b) return void c.splice(d, 2)
            }, d.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var a = this.constraints, b = a.length - 1; b >= 0; b--) this.removeConstraint(a[b]);
                for (var c = this.bodies, b = c.length - 1; b >= 0; b--) this.removeBody(c[b]);
                for (var e = this.springs, b = e.length - 1; b >= 0; b--) this.removeSpring(e[b]);
                for (var f = this.contactMaterials, b = f.length - 1; b >= 0; b--) this.removeContactMaterial(f[b]);
                d.apply(this)
            };
            var z = f.create(),
                A = (f.fromValues(0, 0), f.fromValues(0, 0));
            d.prototype.hitTest = function(a, b, c) {
                c = c || 0;
                var d = new m({ position: a }),
                    e = new k,
                    l = a,
                    n = 0,
                    o = z,
                    p = A;
                d.addShape(e);
                for (var q = this.narrowphase, r = [], s = 0, t = b.length; s !== t; s++)
                    for (var u = b[s], v = 0, w = u.shapes.length; v !== w; v++) {
                        var x = u.shapes[v];
                        f.rotate(o, x.position, u.angle), f.add(o, o, u.position);
                        var y = x.angle + u.angle;
                        (x instanceof g && q.circleParticle(u, x, o, y, d, e, l, n, !0) || x instanceof h && q.particleConvex(d, e, l, n, u, x, o, y, !0) || x instanceof i && q.particlePlane(d, e, l, n, u, x, o, y, !0) || x instanceof j && q.particleCapsule(d, e, l, n, u, x, o, y, !0) || x instanceof k && f.squaredLength(f.sub(p, o, a)) < c * c) && r.push(u)
                    }
                return r
            }, d.prototype.setGlobalStiffness = function(a) {
                for (var b = this.constraints, c = 0; c !== b.length; c++)
                    for (var d = b[c], e = 0; e !== d.equations.length; e++) {
                        var f = d.equations[e];
                        f.stiffness = a, f.needsUpdate = !0
                    }
                for (var g = this.contactMaterials, c = 0; c !== g.length; c++) {
                    var d = g[c];
                    d.stiffness = d.frictionStiffness = a
                }
                var d = this.defaultContactMaterial;
                d.stiffness = d.frictionStiffness = a
            }, d.prototype.setGlobalRelaxation = function(a) {
                for (var b = 0; b !== this.constraints.length; b++)
                    for (var c = this.constraints[b], d = 0; d !== c.equations.length; d++) {
                        var e = c.equations[d];
                        e.relaxation = a, e.needsUpdate = !0
                    }
                for (var b = 0; b !== this.contactMaterials.length; b++) {
                    var c = this.contactMaterials[b];
                    c.relaxation = c.frictionRelaxation = a
                }
                var c = this.defaultContactMaterial;
                c.relaxation = c.frictionRelaxation = a
            };
            var B = new p,
                C = [];
            d.prototype.raycast = function(a, b) { return b.getAABB(B), this.broadphase.aabbQuery(this, B, C), b.intersectBodies(a, C), C.length = 0, a.hasHit() }
        }, { "../../package.json": 6, "../collision/AABB": 7, "../collision/Broadphase": 8, "../collision/Narrowphase": 10, "../collision/Ray": 11, "../collision/SAPBroadphase": 13, "../constraints/Constraint": 14, "../constraints/DistanceConstraint": 15, "../constraints/GearConstraint": 16, "../constraints/LockConstraint": 17, "../constraints/PrismaticConstraint": 18, "../constraints/RevoluteConstraint": 19, "../events/EventEmitter": 26, "../material/ContactMaterial": 27, "../material/Material": 28, "../math/vec2": 30, "../objects/Body": 31, "../objects/LinearSpring": 32, "../objects/RotationalSpring": 33, "../shapes/Capsule": 38, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Line": 42, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45, "../solver/GSSolver": 46, "../solver/Solver": 47, "../utils/OverlapKeeper": 52, "../utils/Utils": 57, "./IslandManager": 59 }]
    }, {}, [36])(36)
}),
function() {
    var a = this,
        b = b || {};
    return b.game = null, b.WEBGL_RENDERER = 0, b.CANVAS_RENDERER = 1, b.VERSION = "v2.2.9", b._UID = 0, "undefined" != typeof Float32Array ? (b.Float32Array = Float32Array, b.Uint16Array = Uint16Array, b.Uint32Array = Uint32Array, b.ArrayBuffer = ArrayBuffer) : (b.Float32Array = Array, b.Uint16Array = Array), b.PI_2 = 2 * Math.PI, b.RAD_TO_DEG = 180 / Math.PI, b.DEG_TO_RAD = Math.PI / 180, b.RETINA_PREFIX = "@2x",
        b.DisplayObject = function() { this.position = new b.Point(0, 0), this.scale = new b.Point(1, 1), this.pivot = new b.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new b.Matrix, this.worldPosition = new b.Point(0, 0), this.worldScale = new b.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new b.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1 }, b.DisplayObject.prototype.constructor = b.DisplayObject, b.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var a = this.children.length; a--;) this.children[a].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            },
            updateTransform: function(a) {
                if (!a && !this.parent && !this.game) return this;
                var c = this.parent;
                a ? c = a : this.parent || (c = this.game.world);
                var d, e, f, g, h, i, j = c.worldTransform,
                    k = this.worldTransform;
                return this.rotation % b.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), d = this._cr * this.scale.x, e = this._sr * this.scale.x, f = -this._sr * this.scale.y, g = this._cr * this.scale.y, h = this.position.x, i = this.position.y, (this.pivot.x || this.pivot.y) && (h -= this.pivot.x * d + this.pivot.y * f, i -= this.pivot.x * e + this.pivot.y * g), k.a = d * j.a + e * j.c, k.b = d * j.b + e * j.d, k.c = f * j.a + g * j.c, k.d = f * j.b + g * j.d, k.tx = h * j.a + i * j.c + j.tx, k.ty = h * j.b + i * j.d + j.ty) : (d = this.scale.x, g = this.scale.y, h = this.position.x - this.pivot.x * d, i = this.position.y - this.pivot.y * g, k.a = d * j.a, k.b = d * j.b, k.c = g * j.c, k.d = g * j.d, k.tx = h * j.a + i * j.c + j.tx, k.ty = h * j.b + i * j.d + j.ty), this.worldAlpha = this.alpha * c.worldAlpha, this.worldPosition.set(k.tx, k.ty), this.worldScale.set(this.scale.x * Math.sqrt(k.a * k.a + k.c * k.c), this.scale.y * Math.sqrt(k.b * k.b + k.d * k.d)), this.worldRotation = Math.atan2(-k.c, k.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, k, j), this
            },
            preUpdate: function() {},
            generateTexture: function(a, c, d) {
                var e = this.getLocalBounds(),
                    f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
                return b.DisplayObject._tempMatrix.tx = -e.x, b.DisplayObject._tempMatrix.ty = -e.y, f.render(this, b.DisplayObject._tempMatrix), f
            },
            updateCache: function() { return this._generateCachedSprite(), this },
            toGlobal: function(a) { return this.updateTransform(), this.worldTransform.apply(a) },
            toLocal: function(a, b) { return b && (a = b.toGlobal(a)), this.updateTransform(), this.worldTransform.applyInverse(a) },
            _renderCachedSprite: function(a) { this._cachedSprite.worldAlpha = this.worldAlpha, a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a) },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var a = this.getLocalBounds();
                if (a.width = Math.max(1, Math.ceil(a.width)), a.height = Math.max(1, Math.ceil(a.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(a.width, a.height);
                else {
                    var c = new b.RenderTexture(a.width, a.height);
                    this._cachedSprite = new b.Sprite(c), this._cachedSprite.worldTransform = this.worldTransform
                }
                var d = this._filters;
                this._filters = null, this._cachedSprite.filters = d, b.DisplayObject._tempMatrix.tx = -a.x, b.DisplayObject._tempMatrix.ty = -a.y, this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), this._filters = d, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() { this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null) }
        }, b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform, Object.defineProperties(b.DisplayObject.prototype, {
            x: { get: function() { return this.position.x }, set: function(a) { this.position.x = a } },
            y: { get: function() { return this.position.y }, set: function(a) { this.position.y = a } },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var a = this.parent;
                        if (!a) return this.visible;
                        do {
                            if (!a.visible) return !1;
                            a = a.parent
                        } while (a);
                        return !0
                    }
                    return !1
                }
            },
            mask: { get: function() { return this._mask }, set: function(a) { this._mask && (this._mask.isMask = !1), this._mask = a, a && (this._mask.isMask = !0) } },
            filters: {
                get: function() { return this._filters },
                set: function(a) {
                    if (Array.isArray(a)) {
                        for (var c = [], d = 0; d < a.length; d++)
                            for (var e = a[d].passes, f = 0; f < e.length; f++) c.push(e[f]);
                        this._filterBlock = { target: this, filterPasses: c }
                    }
                    this._filters = a, this.blendMode && this.blendMode === b.blendModes.MULTIPLY && (this.blendMode = b.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: { get: function() { return this._cacheAsBitmap }, set: function(a) { this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = a) } }
        }), b.DisplayObjectContainer = function() { b.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1 }, b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype), b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer, b.DisplayObjectContainer.prototype.addChild = function(a) { return this.addChildAt(a, this.children.length) }, b.DisplayObjectContainer.prototype.addChildAt = function(a, b) { if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), a.parent = this, this.children.splice(b, 0, a), a; throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length) }, b.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
            if (a !== b) {
                var c = this.getChildIndex(a),
                    d = this.getChildIndex(b);
                if (c < 0 || d < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[c] = b, this.children[d] = a
            }
        }, b.DisplayObjectContainer.prototype.getChildIndex = function(a) { var b = this.children.indexOf(a); if (b === -1) throw new Error("The supplied DisplayObject must be a child of the caller"); return b }, b.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
            if (b < 0 || b >= this.children.length) throw new Error("The supplied index is out of bounds");
            var c = this.getChildIndex(a);
            this.children.splice(c, 1), this.children.splice(b, 0, a)
        }, b.DisplayObjectContainer.prototype.getChildAt = function(a) { if (a < 0 || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller"); return this.children[a] }, b.DisplayObjectContainer.prototype.removeChild = function(a) { var b = this.children.indexOf(a); if (b !== -1) return this.removeChildAt(b) }, b.DisplayObjectContainer.prototype.removeChildAt = function(a) { var b = this.getChildAt(a); return b && (b.parent = void 0, this.children.splice(a, 1)), b }, b.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
            void 0 === a && (a = 0), void 0 === b && (b = this.children.length);
            var c = b - a;
            if (c > 0 && c <= b) {
                for (var d = this.children.splice(begin, c), e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.parent = void 0
                }
                return d
            }
            if (0 === c && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, b.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform()
        }, b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform, b.DisplayObjectContainer.prototype.getBounds = function(a) {
            var c = a && a instanceof b.DisplayObject,
                d = !0;
            c ? d = a instanceof b.DisplayObjectContainer && a.contains(this) : a = this;
            var e;
            if (c) { var f = a.worldTransform; for (a.worldTransform = b.identityMatrix, e = 0; e < a.children.length; e++) a.children[e].updateTransform() }
            var g, h, i, j = 1 / 0,
                k = 1 / 0,
                l = -(1 / 0),
                m = -(1 / 0),
                n = !1;
            for (e = 0; e < this.children.length; e++) {
                var o = this.children[e];
                o.visible && (n = !0, g = this.children[e].getBounds(), j = j < g.x ? j : g.x, k = k < g.y ? k : g.y, h = g.width + g.x, i = g.height + g.y, l = l > h ? l : h, m = m > i ? m : i)
            }
            var p = this._bounds;
            if (!n) {
                p = new b.Rectangle;
                var q = p.x,
                    r = p.width + p.x,
                    s = p.y,
                    t = p.height + p.y,
                    u = this.worldTransform,
                    v = u.a,
                    w = u.b,
                    x = u.c,
                    y = u.d,
                    z = u.tx,
                    A = u.ty,
                    B = v * r + x * t + z,
                    C = y * t + w * r + A,
                    D = v * q + x * t + z,
                    E = y * t + w * q + A,
                    F = v * q + x * s + z,
                    G = y * s + w * q + A,
                    H = v * r + x * s + z,
                    I = y * s + w * r + A;
                l = B, m = C, j = B, k = C, j = D < j ? D : j, j = F < j ? F : j, j = H < j ? H : j, k = E < k ? E : k, k = G < k ? G : k, k = I < k ? I : k, l = D > l ? D : l, l = F > l ? F : l, l = H > l ? H : l, m = E > m ? E : m, m = G > m ? G : m, m = I > m ? I : m
            }
            if (p.x = j, p.y = k, p.width = l - j, p.height = m - k, c)
                for (a.worldTransform = f, e = 0; e < a.children.length; e++) a.children[e].updateTransform();
            if (!d) {
                var J = a.getBounds();
                p.x -= J.x, p.y -= J.y
            }
            return p
        }, b.DisplayObjectContainer.prototype.getLocalBounds = function() { return this.getBounds(this) }, b.DisplayObjectContainer.prototype.contains = function(a) { return !!a && (a === this || this.contains(a.parent)) }, b.DisplayObjectContainer.prototype._renderWebGL = function(a) {
            if (this.visible && !(this.alpha <= 0)) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
                var b;
                if (this._mask || this._filters) {
                    for (this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
                    a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), a.spriteBatch.start()
                }
                else
                    for (b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a)
            }
        }, b.DisplayObjectContainer.prototype._renderCanvas = function(a) {
            if (this.visible !== !1 && 0 !== this.alpha) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
                this._mask && a.maskManager.pushMask(this._mask, a);
                for (var b = 0; b < this.children.length; b++) this.children[b]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a)
            }
        }, Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
            get: function() { return this.getLocalBounds().width * this.scale.x },
            set: function(a) {
                var b = this.getLocalBounds().width;
                0 !== b ? this.scale.x = a / b : this.scale.x = 1, this._width = a
            }
        }), Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
            get: function() { return this.getLocalBounds().height * this.scale.y },
            set: function(a) {
                var b = this.getLocalBounds().height;
                0 !== b ? this.scale.y = a / b : this.scale.y = 1, this._height = a
            }
        }), b.Sprite = function(a) { b.DisplayObjectContainer.call(this), this.anchor = new b.Point, this.texture = a || b.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = b.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0 }, b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Sprite.prototype.constructor = b.Sprite, Object.defineProperty(b.Sprite.prototype, "width", { get: function() { return this.scale.x * this.texture.frame.width }, set: function(a) { this.scale.x = a / this.texture.frame.width, this._width = a } }), Object.defineProperty(b.Sprite.prototype, "height", { get: function() { return this.scale.y * this.texture.frame.height }, set: function(a) { this.scale.y = a / this.texture.frame.height, this._height = a } }), b.Sprite.prototype.setTexture = function(a, b) { void 0 !== b && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = a, this.texture.valid = !0, this.cachedTint = -1 }, b.Sprite.prototype.onTextureUpdate = function() { this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height) }, b.Sprite.prototype.getBounds = function(a) {
            var b = this.texture.frame.width,
                c = this.texture.frame.height,
                d = b * (1 - this.anchor.x),
                e = b * -this.anchor.x,
                f = c * (1 - this.anchor.y),
                g = c * -this.anchor.y,
                h = a || this.worldTransform,
                i = h.a,
                j = h.b,
                k = h.c,
                l = h.d,
                m = h.tx,
                n = h.ty,
                o = -(1 / 0),
                p = -(1 / 0),
                q = 1 / 0,
                r = 1 / 0;
            if (0 === j && 0 === k) {
                if (i < 0) {
                    i *= -1;
                    var s = d;
                    d = -e, e = -s
                }
                if (l < 0) {
                    l *= -1;
                    var s = f;
                    f = -g, g = -s
                }
                q = i * e + m, o = i * d + m, r = l * g + n, p = l * f + n
            }
            else {
                var t = i * e + k * g + m,
                    u = l * g + j * e + n,
                    v = i * d + k * g + m,
                    w = l * g + j * d + n,
                    x = i * d + k * f + m,
                    y = l * f + j * d + n,
                    z = i * e + k * f + m,
                    A = l * f + j * e + n;
                q = t < q ? t : q, q = v < q ? v : q, q = x < q ? x : q, q = z < q ? z : q, r = u < r ? u : r, r = w < r ? w : r, r = y < r ? y : r, r = A < r ? A : r, o = t > o ? t : o, o = v > o ? v : o, o = x > o ? x : o, o = z > o ? z : o, p = u > p ? u : p, p = w > p ? w : p, p = y > p ? y : p, p = A > p ? A : p
            }
            var B = this._bounds;
            return B.x = q, B.width = o - q, B.y = r, B.height = p - r, this._currentBounds = B, B
        }, b.Sprite.prototype.getLocalBounds = function() {
            var a = this.worldTransform;
            this.worldTransform = b.identityMatrix;
            for (var c = 0; c < this.children.length; c++) this.children[c].updateTransform();
            var d = this.getBounds();
            for (this.worldTransform = a, c = 0; c < this.children.length; c++) this.children[c].updateTransform();
            return d
        }, b.Sprite.prototype._renderWebGL = function(a, b) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var c = this.worldTransform;
                if (b && (c = b), this._mask || this._filters) {
                    var d = a.spriteBatch;
                    this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (d.stop(), a.maskManager.pushMask(this.mask, a), d.start()), d.render(this);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a);
                    d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), d.start()
                }
                else { a.spriteBatch.render(this); for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a, c) }
            }
        }, b.Sprite.prototype._renderCanvas = function(a, c) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var d = this.worldTransform;
                if (c && (d = c), this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a), this.texture.valid) {
                    var e = this.texture.baseTexture.resolution / a.resolution;
                    a.context.globalAlpha = this.worldAlpha, a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode, a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR);
                    var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        h = d.tx * a.resolution + a.shakeX,
                        i = d.ty * a.resolution + a.shakeY;
                    a.roundPixels ? (a.context.setTransform(d.a, d.b, d.c, d.d, 0 | h, 0 | i), f |= 0, g |= 0) : a.context.setTransform(d.a, d.b, d.c, d.d, h, i);
                    var j = this.texture.crop.width,
                        k = this.texture.crop.height;
                    if (f /= e, g /= e, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), a.context.drawImage(this.tintedTexture, 0, 0, j, k, f, g, j / e, k / e);
                    else {
                        var l = this.texture.crop.x,
                            m = this.texture.crop.y;
                        a.context.drawImage(this.texture.baseTexture.source, l, m, j, k, f, g, j / e, k / e)
                    }
                }
                for (var n = 0; n < this.children.length; n++) this.children[n]._renderCanvas(a);
                this._mask && a.maskManager.popMask(a)
            }
        }, b.SpriteBatch = function(a) { b.DisplayObjectContainer.call(this), this.textureThing = a, this.ready = !1 }, b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype), b.SpriteBatch.prototype.constructor = b.SpriteBatch, b.SpriteBatch.prototype.initWebGL = function(a) { this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a), this.ready = !0 }, b.SpriteBatch.prototype.updateTransform = function() { this.displayObjectUpdateTransform() }, b.SpriteBatch.prototype._renderWebGL = function(a) {!this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(a.gl), this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl), a.spriteBatch.stop(), a.shaderManager.setShader(a.shaderManager.fastShader), this.fastSpriteBatch.begin(this, a), this.fastSpriteBatch.render(this), a.spriteBatch.start()) }, b.SpriteBatch.prototype._renderCanvas = function(a) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var b = a.context;
                b.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
                    var f = this.children[e];
                    if (f.visible) {
                        var g = f.texture,
                            h = g.frame;
                        if (b.globalAlpha = this.worldAlpha * f.alpha, f.rotation % (2 * Math.PI) === 0) d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), d = !1), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * (-h.width * f.scale.x) + f.position.x + .5 + a.shakeX | 0, f.anchor.y * (-h.height * f.scale.y) + f.position.y + .5 + a.shakeY | 0, h.width * f.scale.x, h.height * f.scale.y);
                        else {
                            d || (d = !0), f.displayObjectUpdateTransform();
                            var i = f.worldTransform,
                                j = i.tx * a.resolution + a.shakeX,
                                k = i.ty * a.resolution + a.shakeY;
                            a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k) : b.setTransform(i.a, i.b, i.c, i.d, j, k), b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height)
                        }
                    }
                }
            }
        }, b.hex2rgb = function(a) { return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255] }, b.rgb2hex = function(a) { return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2] }, b.canUseNewCanvasBlendModes = function() {
            if (void 0 === document) return !1;
            var a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                c = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                d = new Image;
            d.src = a + "AP804Oa6" + c;
            var e = new Image;
            e.src = a + "/wCKxvRF" + c;
            var f = b.CanvasPool.create(this, 6, 1),
                g = f.getContext("2d");
            if (g.globalCompositeOperation = "multiply", g.drawImage(d, 0, 0), g.drawImage(e, 2, 0), !g.getImageData(2, 0, 1, 1)) return !1;
            var h = g.getImageData(2, 0, 1, 1).data;
            return b.CanvasPool.remove(this), 255 === h[0] && 0 === h[1] && 0 === h[2]
        }, b.getNextPowerOfTwo = function(a) { if (a > 0 && 0 === (a & a - 1)) return a; for (var b = 1; b < a;) b <<= 1; return b }, b.isPowerOfTwo = function(a, b) { return a > 0 && 0 === (a & a - 1) && b > 0 && 0 === (b & b - 1) }, b.CanvasPool = {
            create: function(a, c, d) {
                var e, f = b.CanvasPool.getFirst();
                if (f === -1) {
                    var g = { parent: a, canvas: document.createElement("canvas") };
                    b.CanvasPool.pool.push(g), e = g.canvas
                }
                else b.CanvasPool.pool[f].parent = a, e = b.CanvasPool.pool[f].canvas;
                return void 0 !== c && (e.width = c, e.height = d), e
            },
            getFirst: function() {
                for (var a = b.CanvasPool.pool, c = 0; c < a.length; c++)
                    if (!a[c].parent) return c;
                return -1
            },
            remove: function(a) { for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].parent === a && (c[d].parent = null, c[d].canvas.width = 1, c[d].canvas.height = 1) },
            removeByCanvas: function(a) { for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].canvas === a && (c[d].parent = null, c[d].canvas.width = 1, c[d].canvas.height = 1) },
            getTotal: function() { for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent && c++; return c },
            getFree: function() { for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent || c++; return c }
        }, b.CanvasPool.pool = [], b.initDefaultShaders = function() {}, b.CompileVertexShader = function(a, c) { return b._CompileShader(a, c, a.VERTEX_SHADER) }, b.CompileFragmentShader = function(a, c) { return b._CompileShader(a, c, a.FRAGMENT_SHADER) }, b._CompileShader = function(a, b, c) {
            var d = b;
            Array.isArray(b) && (d = b.join("\n"));
            var e = a.createShader(c);
            return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), null)
        }, b.compileProgram = function(a, c, d) {
            var e = b.CompileFragmentShader(a, d),
                f = b.CompileVertexShader(a, c),
                g = a.createProgram();
            return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || (window.console.log(a.getProgramInfoLog(g)), window.console.log("Could not initialise shaders")), g
        }, b.PixiShader = function(a) { this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init() }, b.PixiShader.prototype.constructor = b.PixiShader, b.PixiShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.colorAttribute === -1 && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
            for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
            this.initUniforms(), this.program = c
        }, b.PixiShader.prototype.initUniforms = function() { this.textureCount = 1; var a, b = this.gl; for (var c in this.uniforms) { a = this.uniforms[c]; var d = a.type; "sampler2D" === d ? (a._init = !1, null !== a.value && this.initSampler2D(a)) : "mat2" === d || "mat3" === d || "mat4" === d ? (a.glMatrix = !0, a.glValueLength = 1, "mat2" === d ? a.glFunc = b.uniformMatrix2fv : "mat3" === d ? a.glFunc = b.uniformMatrix3fv : "mat4" === d && (a.glFunc = b.uniformMatrix4fv)) : (a.glFunc = b["uniform" + d], "2f" === d || "2i" === d ? a.glValueLength = 2 : "3f" === d || "3i" === d ? a.glValueLength = 3 : "4f" === d || "4i" === d ? a.glValueLength = 4 : a.glValueLength = 1) } }, b.PixiShader.prototype.initSampler2D = function(a) {
            if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
                var b = this.gl;
                if (b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), a.textureData) {
                    var c = a.textureData,
                        d = c.magFilter ? c.magFilter : b.LINEAR,
                        e = c.minFilter ? c.minFilter : b.LINEAR,
                        f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE,
                        g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE,
                        h = c.luminance ? b.LUMINANCE : b.RGBA;
                    if (c.repeat && (f = b.REPEAT, g = b.REPEAT), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), c.width) {
                        var i = c.width ? c.width : 512,
                            j = c.height ? c.height : 2,
                            k = c.border ? c.border : 0;
                        b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null)
                    }
                    else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g)
                }
                b.uniform1i(a.uniformLocation, this.textureCount), a._init = !0, this.textureCount++
            }
        }, b.PixiShader.prototype.syncUniforms = function() { this.textureCount = 1; var a, c = this.gl; for (var d in this.uniforms) a = this.uniforms[d], 1 === a.glValueLength ? a.glMatrix === !0 ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(c, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (c.activeTexture(c["TEXTURE" + this.textureCount]), a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]), c.uniform1i(a.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(a)) }, b.PixiShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, b.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], b.PixiFastShader = function(a) { this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init() }, b.PixiFastShader.prototype.constructor = b.PixiFastShader, b.PixiFastShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.dimensions = a.getUniformLocation(c, "dimensions"), this.uMatrix = a.getUniformLocation(c, "uMatrix"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord"), this.aScale = a.getAttribLocation(c, "aScale"), this.aRotation = a.getAttribLocation(c, "aRotation"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.colorAttribute === -1 && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = c
        }, b.PixiFastShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, b.StripShader = function(a) { this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init() }, b.StripShader.prototype.constructor = b.StripShader, b.StripShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.uSampler = a.getUniformLocation(c, "uSampler"), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.StripShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, b.PrimitiveShader = function(a) { this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init() }, b.PrimitiveShader.prototype.constructor = b.PrimitiveShader, b.PrimitiveShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.colorAttribute = a.getAttribLocation(c, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.PrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, b.ComplexPrimitiveShader = function(a) { this._UID = b._UID++, this.gl = a, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init() }, b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader, b.ComplexPrimitiveShader.prototype.init = function() {
            var a = this.gl,
                c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
            a.useProgram(c), this.projectionVector = a.getUniformLocation(c, "projectionVector"), this.offsetVector = a.getUniformLocation(c, "offsetVector"), this.tintColor = a.getUniformLocation(c, "tint"), this.color = a.getUniformLocation(c, "color"), this.flipY = a.getUniformLocation(c, "flipY"), this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = a.getUniformLocation(c, "translationMatrix"), this.alpha = a.getUniformLocation(c, "alpha"), this.program = c
        }, b.ComplexPrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, b.glContexts = [], b.instances = [], b.WebGLRenderer = function(a) { this.game = a, b.defaultRenderer || (b.defaultRenderer = this), this.type = b.WEBGL_RENDERER, this.resolution = a.resolution, this.transparent = a.transparent, this.autoResize = !1, this.preserveDrawingBuffer = a.preserveDrawingBuffer, this.clearBeforeRender = a.clearBeforeRender, this.width = a.width, this.height = a.height, this.view = a.canvas, this._contextOptions = { alpha: this.transparent, antialias: a.antialias, premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent, stencil: !0, preserveDrawingBuffer: this.preserveDrawingBuffer }, this.projection = new b.Point, this.offset = new b.Point, this.shaderManager = new b.WebGLShaderManager, this.spriteBatch = new b.WebGLSpriteBatch, this.maskManager = new b.WebGLMaskManager, this.filterManager = new b.WebGLFilterManager, this.stencilManager = new b.WebGLStencilManager, this.blendModeManager = new b.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes() }, b.WebGLRenderer.prototype.constructor = b.WebGLRenderer, b.WebGLRenderer.prototype.initContext = function() {
            var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = a, !a) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = a.id = b.WebGLRenderer.glContextId++, b.glContexts[this.glContextId] = a, b.instances[this.glContextId] = this, a.disable(a.DEPTH_TEST), a.disable(a.CULL_FACE), a.enable(a.BLEND), this.shaderManager.setContext(a), this.spriteBatch.setContext(a), this.maskManager.setContext(a), this.filterManager.setContext(a), this.blendModeManager.setContext(a), this.stencilManager.setContext(a), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
        }, b.WebGLRenderer.prototype.render = function(a) {
            if (!this.contextLost) {
                var b = this.gl;
                b.viewport(0, 0, this.width, this.height), b.bindFramebuffer(b.FRAMEBUFFER, null), this.game.clearBeforeRender && (b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a), b.clear(b.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(a, this.projection)
            }
        }, b.WebGLRenderer.prototype.renderDisplayObject = function(a, c, d, e) { this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = d ? -1 : 1, this.renderSession.projection = c, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, d), a._renderWebGL(this.renderSession, e), this.spriteBatch.end() }, b.WebGLRenderer.prototype.resize = function(a, b) { this.width = a * this.resolution, this.height = b * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution }, b.WebGLRenderer.prototype.updateTexture = function(a) { if (!a.hasLoaded) return !1; var c = this.gl; return a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()), c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]), c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), a.mipmap && b.isPowerOfTwo(a.width, a.height) ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST), c.generateMipmap(c.TEXTURE_2D)) : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST), a._powerOf2 ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT)) : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)), a._dirty[c.id] = !1, !0 }, b.WebGLRenderer.prototype.destroy = function() { b.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, b.CanvasPool.remove(this), b.instances[this.glContextId] = null, b.WebGLRenderer.glContextId-- }, b.WebGLRenderer.prototype.mapBlendModes = function() {
            var a = this.gl;
            if (!b.blendModesWebGL) {
                var c = [],
                    d = b.blendModes;
                c[d.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.ADD] = [a.SRC_ALPHA, a.DST_ALPHA], c[d.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA], c[d.SCREEN] = [a.SRC_ALPHA, a.ONE], c[d.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], c[d.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA], b.blendModesWebGL = c
            }
        }, b.WebGLRenderer.glContextId = 0, b.WebGLBlendModeManager = function() { this.currentBlendMode = 99999 }, b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager, b.WebGLBlendModeManager.prototype.setContext = function(a) { this.gl = a }, b.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
            if (this.currentBlendMode === a) return !1;
            this.currentBlendMode = a;
            var c = b.blendModesWebGL[this.currentBlendMode];
            return c && this.gl.blendFunc(c[0], c[1]), !0
        }, b.WebGLBlendModeManager.prototype.destroy = function() { this.gl = null }, b.WebGLMaskManager = function() {}, b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager, b.WebGLMaskManager.prototype.setContext = function(a) { this.gl = a }, b.WebGLMaskManager.prototype.pushMask = function(a, c) {
            var d = c.gl;
            a.dirty && b.WebGLGraphics.updateGraphics(a, d), void 0 !== a._webGL[d.id] && void 0 !== a._webGL[d.id].data && 0 !== a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c)
        }, b.WebGLMaskManager.prototype.popMask = function(a, b) {
            var c = this.gl;
            void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b)
        }, b.WebGLMaskManager.prototype.destroy = function() { this.gl = null }, b.WebGLStencilManager = function() { this.stencilStack = [], this.reverse = !0, this.count = 0 }, b.WebGLStencilManager.prototype.setContext = function(a) { this.gl = a }, b.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
            var d = this.gl;
            this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), d.clear(d.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(b);
            var e = this.count;
            d.colorMask(!1, !1, !1, !1), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), 1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP), this.count++
        }, b.WebGLStencilManager.prototype.bindGraphics = function(a, c, d) {
            this._currentGraphics = a;
            var e, f = this.gl,
                g = d.projection,
                h = d.offset;
            1 === c.mode ? (e = d.shaderManager.complexPrimitiveShader, d.shaderManager.setShader(e), f.uniform1f(e.flipY, d.flipY), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform3fv(e.color, c.color), f.uniform1f(e.alpha, a.worldAlpha * c.alpha), f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 8, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer)) : (e = d.shaderManager.primitiveShader, d.shaderManager.setShader(e), f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)), f.uniform1f(e.flipY, d.flipY), f.uniform2f(e.projectionVector, g.x, -g.y), f.uniform2f(e.offsetVector, -h.x, -h.y), f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)), f.uniform1f(e.alpha, a.worldAlpha), f.bindBuffer(f.ARRAY_BUFFER, c.buffer), f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 24, 0), f.vertexAttribPointer(e.colorAttribute, 4, f.FLOAT, !1, 24, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer))
        }, b.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
            var d = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) d.disable(d.STENCIL_TEST);
            else {
                var e = this.count;
                this.bindGraphics(a, b, c), d.colorMask(!1, !1, !1, !1), 1 === b.mode ? (this.reverse = !this.reverse, this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)), d.stencilFunc(d.ALWAYS, 0, 255), d.stencilOp(d.KEEP, d.KEEP, d.INVERT), d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)), d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0), this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)), d.colorMask(!0, !0, !0, !0), d.stencilOp(d.KEEP, d.KEEP, d.KEEP)
            }
        }, b.WebGLStencilManager.prototype.destroy = function() { this.stencilStack = null, this.gl = null }, b.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var a = 0; a < this.maxAttibs; a++) this.attribState[a] = !1;
            this.stack = []
        }, b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager, b.WebGLShaderManager.prototype.setContext = function(a) { this.gl = a, this.primitiveShader = new b.PrimitiveShader(a), this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a), this.defaultShader = new b.PixiShader(a), this.fastShader = new b.PixiFastShader(a), this.stripShader = new b.StripShader(a), this.setShader(this.defaultShader) }, b.WebGLShaderManager.prototype.setAttribs = function(a) {
            var b;
            for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                this.tempAttribState[c] = !0
            }
            var d = this.gl;
            for (b = 0; b < this.attribState.length; b++) this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b], this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b))
        }, b.WebGLShaderManager.prototype.setShader = function(a) { return this._currentId !== a._UID && (this._currentId = a._UID, this.currentShader = a, this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0) }, b.WebGLShaderManager.prototype.destroy = function() { this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null }, b.WebGLSpriteBatch = function() {
            this.vertSize = 5, this.size = 2e3;
            var a = 4 * this.size * 4 * this.vertSize,
                c = 6 * this.size;
            this.vertices = new b.ArrayBuffer(a), this.positions = new b.Float32Array(this.vertices), this.colors = new b.Uint32Array(this.vertices), this.indices = new b.Uint16Array(c), this.lastIndexCount = 0;
            for (var d = 0, e = 0; d < c; d += 6, e += 4) this.indices[d + 0] = e + 0, this.indices[d + 1] = e + 1, this.indices[d + 2] = e + 2, this.indices[d + 3] = e + 0, this.indices[d + 4] = e + 2, this.indices[d + 5] = e + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new b.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }, b.WebGLSpriteBatch.prototype.setContext = function(a) {
            this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var c = new b.PixiShader(a);
            c.fragmentSrc = this.defaultShader.fragmentSrc, c.uniforms = {}, c.init(), this.defaultShader.shaders[a.id] = c
        }, b.WebGLSpriteBatch.prototype.begin = function(a) { this.renderSession = a, this.shader = this.renderSession.shaderManager.defaultShader, this.start() }, b.WebGLSpriteBatch.prototype.end = function() { this.flush() }, b.WebGLSpriteBatch.prototype.render = function(a, b) {
            var c = a.texture,
                d = a.worldTransform;
            b && (d = b), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture);
            var e = c._uvs;
            if (e) {
                var f, g, h, i, j = a.anchor.x,
                    k = a.anchor.y;
                if (c.trim) {
                    var l = c.trim;
                    g = l.x - j * l.width, f = g + c.crop.width, i = l.y - k * l.height, h = i + c.crop.height
                }
                else f = c.frame.width * (1 - j), g = c.frame.width * -j, h = c.frame.height * (1 - k), i = c.frame.height * -k;
                var m = 4 * this.currentBatchSize * this.vertSize,
                    n = c.baseTexture.resolution,
                    o = d.a / n,
                    p = d.b / n,
                    q = d.c / n,
                    r = d.d / n,
                    s = d.tx,
                    t = d.ty,
                    u = this.colors,
                    v = this.positions;
                this.renderSession.roundPixels ? (v[m] = o * g + q * i + s | 0, v[m + 1] = r * i + p * g + t | 0, v[m + 5] = o * f + q * i + s | 0, v[m + 6] = r * i + p * f + t | 0, v[m + 10] = o * f + q * h + s | 0, v[m + 11] = r * h + p * f + t | 0, v[m + 15] = o * g + q * h + s | 0, v[m + 16] = r * h + p * g + t | 0) : (v[m] = o * g + q * i + s, v[m + 1] = r * i + p * g + t, v[m + 5] = o * f + q * i + s, v[m + 6] = r * i + p * f + t, v[m + 10] = o * f + q * h + s, v[m + 11] = r * h + p * f + t, v[m + 15] = o * g + q * h + s, v[m + 16] = r * h + p * g + t), v[m + 2] = e.x0, v[m + 3] = e.y0, v[m + 7] = e.x1, v[m + 8] = e.y1, v[m + 12] = e.x2, v[m + 13] = e.y2, v[m + 17] = e.x3, v[m + 18] = e.y3;
                var w = a.tint;
                u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * a.worldAlpha << 24), this.sprites[this.currentBatchSize++] = a
            }
        }, b.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
            var c = a.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = c.baseTexture), a._uvs || (a._uvs = new b.TextureUvs);
            var d = a._uvs,
                e = c.baseTexture.width,
                f = c.baseTexture.height;
            a.tilePosition.x %= e * a.tileScaleOffset.x, a.tilePosition.y %= f * a.tileScaleOffset.y;
            var g = a.tilePosition.x / (e * a.tileScaleOffset.x),
                h = a.tilePosition.y / (f * a.tileScaleOffset.y),
                i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x),
                j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
            d.x0 = 0 - g, d.y0 = 0 - h, d.x1 = 1 * i - g, d.y1 = 0 - h, d.x2 = 1 * i - g, d.y2 = 1 * j - h, d.x3 = 0 - g, d.y3 = 1 * j - h;
            var k = a.tint,
                l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * a.worldAlpha << 24),
                m = this.positions,
                n = this.colors,
                o = a.width,
                p = a.height,
                q = a.anchor.x,
                r = a.anchor.y,
                s = o * (1 - q),
                t = o * -q,
                u = p * (1 - r),
                v = p * -r,
                w = 4 * this.currentBatchSize * this.vertSize,
                x = c.baseTexture.resolution,
                y = a.worldTransform,
                z = y.a / x,
                A = y.b / x,
                B = y.c / x,
                C = y.d / x,
                D = y.tx,
                E = y.ty;
            m[w++] = z * t + B * v + D, m[w++] = C * v + A * t + E, m[w++] = d.x0, m[w++] = d.y0, n[w++] = l, m[w++] = z * s + B * v + D, m[w++] = C * v + A * s + E, m[w++] = d.x1, m[w++] = d.y1, n[w++] = l, m[w++] = z * s + B * u + D, m[w++] = C * u + A * s + E, m[w++] = d.x2, m[w++] = d.y2, n[w++] = l, m[w++] = z * t + B * u + D, m[w++] = C * u + A * t + E, m[w++] = d.x3, m[w++] = d.y3, n[w++] = l, this.sprites[this.currentBatchSize++] = a
        }, b.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var a, c = this.gl;
                if (this.dirty) {
                    this.dirty = !1, c.activeTexture(c.TEXTURE0), c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a = this.defaultShader.shaders[c.id];
                    var d = 4 * this.vertSize;
                    c.vertexAttribPointer(a.aVertexPosition, 2, c.FLOAT, !1, d, 0), c.vertexAttribPointer(a.aTextureCoord, 2, c.FLOAT, !1, d, 8), c.vertexAttribPointer(a.colorAttribute, 4, c.UNSIGNED_BYTE, !0, d, 16)
                }
                if (this.currentBatchSize > .5 * this.size) c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    c.bufferSubData(c.ARRAY_BUFFER, 0, e)
                }
                for (var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; q < r; q++) {
                    i = this.sprites[q], f = i.tilingTexture ? i.tilingTexture.baseTexture : i.texture.baseTexture, g = i.blendMode, h = i.shader || this.defaultShader, o = m !== g, p = n !== h;
                    var s = f.skipRender;
                    if (s && i.children.length > 0 && (s = !1), (l !== f && !s || o || p) && (this.renderBatch(l, j, k), k = q, j = 0, l = f, o && (m = g, this.renderSession.blendModeManager.setBlendMode(m)), p)) {
                        n = h, a = n.shaders[c.id], a || (a = new b.PixiShader(c), a.fragmentSrc = n.fragmentSrc, a.uniforms = n.uniforms, a.init(), n.shaders[c.id] = a), this.renderSession.shaderManager.setShader(a), a.dirty && a.syncUniforms();
                        var t = this.renderSession.projection;
                        c.uniform2f(a.projectionVector, t.x, t.y);
                        var u = this.renderSession.offset;
                        c.uniform2f(a.offsetVector, u.x, u.y)
                    }
                    j++
                }
                this.renderBatch(l, j, k), this.currentBatchSize = 0
            }
        }, b.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
            if (0 !== b) {
                var d = this.gl;
                if (a._dirty[d.id]) { if (!this.renderSession.renderer.updateTexture(a)) return }
                else d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
                d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++
            }
        }, b.WebGLSpriteBatch.prototype.stop = function() { this.flush(), this.dirty = !0 }, b.WebGLSpriteBatch.prototype.start = function() { this.dirty = !0 }, b.WebGLSpriteBatch.prototype.destroy = function() { this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null }, b.WebGLFastSpriteBatch = function(a) {
            this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
            var c = 4 * this.size * this.vertSize,
                d = 6 * this.maxSize;
            this.vertices = new b.Float32Array(c), this.indices = new b.Uint16Array(d), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var e = 0, f = 0; e < d; e += 6, f += 4) this.indices[e + 0] = f + 0, this.indices[e + 1] = f + 1, this.indices[e + 2] = f + 2, this.indices[e + 3] = f + 0, this.indices[e + 4] = f + 2, this.indices[e + 5] = f + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(a)
        }, b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch, b.WebGLFastSpriteBatch.prototype.setContext = function(a) { this.gl = a, this.vertexBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW) }, b.WebGLFastSpriteBatch.prototype.begin = function(a, b) { this.renderSession = b, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = a.worldTransform.toArray(!0), this.start() }, b.WebGLFastSpriteBatch.prototype.end = function() { this.flush() }, b.WebGLFastSpriteBatch.prototype.render = function(a) {
            var b = a.children,
                c = b[0];
            if (c.texture._uvs) {
                this.currentBaseTexture = c.texture.baseTexture, c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(c.blendMode));
                for (var d = 0, e = b.length; d < e; d++) this.renderSprite(b[d]);
                this.flush()
            }
        }, b.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
            if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || a.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = a.texture.baseTexture, a.texture._uvs))) {
                var b, c, d, e, f, g, h, i, j = this.vertices;
                if (b = a.texture._uvs, c = a.texture.frame.width, d = a.texture.frame.height, a.texture.trim) {
                    var k = a.texture.trim;
                    f = k.x - a.anchor.x * k.width, e = f + a.texture.crop.width, h = k.y - a.anchor.y * k.height, g = h + a.texture.crop.height
                }
                else e = a.texture.frame.width * (1 - a.anchor.x), f = a.texture.frame.width * -a.anchor.x, g = a.texture.frame.height * (1 - a.anchor.y), h = a.texture.frame.height * -a.anchor.y;
                i = 4 * this.currentBatchSize * this.vertSize, j[i++] = f, j[i++] = h, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x0, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = h, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x1, j[i++] = b.y1, j[i++] = a.alpha, j[i++] = e, j[i++] = g, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x2, j[i++] = b.y2, j[i++] = a.alpha, j[i++] = f, j[i++] = g, j[i++] = a.position.x, j[i++] = a.position.y, j[i++] = a.scale.x, j[i++] = a.scale.y, j[i++] = a.rotation, j[i++] = b.x3, j[i++] = b.y3, j[i++] = a.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
            }
        }, b.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var a = this.gl;
                if (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a), a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]), this.currentBatchSize > .5 * this.size) a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    a.bufferSubData(a.ARRAY_BUFFER, 0, b)
                }
                a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
            }
        }, b.WebGLFastSpriteBatch.prototype.stop = function() { this.flush() }, b.WebGLFastSpriteBatch.prototype.start = function() {
            var a = this.gl;
            a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var b = this.renderSession.projection;
            a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var c = 4 * this.vertSize;
            a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0), a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8), a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16), a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24), a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28), a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36)
        }, b.WebGLFilterManager = function() { this.filterStack = [], this.offsetX = 0, this.offsetY = 0 }, b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager, b.WebGLFilterManager.prototype.setContext = function(a) { this.gl = a, this.texturePool = [], this.initShaderBuffers() }, b.WebGLFilterManager.prototype.begin = function(a, b) {
            this.renderSession = a, this.defaultShader = a.shaderManager.defaultShader;
            var c = this.renderSession.projection;
            this.width = 2 * c.x, this.height = 2 * -c.y, this.buffer = b
        }, b.WebGLFilterManager.prototype.pushFilter = function(a) {
            var c = this.gl,
                d = this.renderSession.projection,
                e = this.renderSession.offset;
            a._filterArea = a.target.filterArea || a.target.getBounds(), a._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new b.WebGLStencilManager, this.renderSession.stencilManager.setContext(c), c.disable(c.STENCIL_TEST), this.filterStack.push(a);
            var f = a.filterPasses[0];
            this.offsetX += a._filterArea.x, this.offsetY += a._filterArea.y;
            var g = this.texturePool.pop();
            g ? g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : g = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), c.bindTexture(c.TEXTURE_2D, g.texture);
            var h = a._filterArea,
                i = f.padding;
            h.x -= i, h.y -= i, h.width += 2 * i, h.height += 2 * i, h.x < 0 && (h.x = 0), h.width > this.width && (h.width = this.width), h.y < 0 && (h.y = 0), h.height > this.height && (h.height = this.height), c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer), c.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution), d.x = h.width / 2, d.y = -h.height / 2, e.x = -h.x, e.y = -h.y, c.colorMask(!0, !0, !0, !0), c.clearColor(0, 0, 0, 0), c.clear(c.COLOR_BUFFER_BIT), a._glFilterTexture = g
        }, b.WebGLFilterManager.prototype.popFilter = function() {
            var a = this.gl,
                c = this.filterStack.pop(),
                d = c._filterArea,
                e = c._glFilterTexture,
                f = this.renderSession.projection,
                g = this.renderSession.offset;
            if (c.filterPasses.length > 1) {
                a.viewport(0, 0, d.width * this.renderSession.resolution, d.height * this.renderSession.resolution), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = d.height, this.vertexArray[2] = d.width, this.vertexArray[3] = d.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = d.width, this.vertexArray[7] = 0, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
                var h = e,
                    i = this.texturePool.pop();
                i || (i = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.clear(a.COLOR_BUFFER_BIT), a.disable(a.BLEND);
                for (var j = 0; j < c.filterPasses.length - 1; j++) {
                    var k = c.filterPasses[j];
                    a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), this.applyFilterPass(k, d, d.width, d.height);
                    var l = h;
                    h = i, i = l
                }
                a.enable(a.BLEND), e = h, this.texturePool.push(i)
            }
            var m = c.filterPasses[c.filterPasses.length - 1];
            this.offsetX -= d.x, this.offsetY -= d.y;
            var n = this.width,
                o = this.height,
                p = 0,
                q = 0,
                r = this.buffer;
            if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0);
            else {
                var s = this.filterStack[this.filterStack.length - 1];
                d = s._filterArea, n = d.width, o = d.height, p = d.x, q = d.y, r = s._glFilterTexture.frameBuffer
            }
            f.x = n / 2, f.y = -o / 2, g.x = p, g.y = q, d = c._filterArea;
            var t = d.x - p,
                u = d.y - q;
            a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = t, this.vertexArray[1] = u + d.height, this.vertexArray[2] = t + d.width, this.vertexArray[3] = u + d.height, this.vertexArray[4] = t, this.vertexArray[5] = u, this.vertexArray[6] = t + d.width, this.vertexArray[7] = u, a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = d.width / this.width, this.uvArray[5] = d.height / this.height, this.uvArray[6] = d.width / this.width, this.uvArray[7] = d.height / this.height, a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray), a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution), a.bindFramebuffer(a.FRAMEBUFFER, r), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, e.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = c._previous_stencil_mgr, c._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.applyFilterPass(m, d, n, o), this.texturePool.push(e), c._glFilterTexture = null
        }, b.WebGLFilterManager.prototype.applyFilterPass = function(a, c, d, e) {
            var f = this.gl,
                g = a.shaders[f.id];
            g || (g = new b.PixiShader(f), g.fragmentSrc = a.fragmentSrc, g.uniforms = a.uniforms, g.init(), a.shaders[f.id] = g), this.renderSession.shaderManager.setShader(g), f.uniform2f(g.projectionVector, d / 2, -e / 2), f.uniform2f(g.offsetVector, 0, 0), a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width, a.uniforms.dimensions.value[1] = this.height, a.uniforms.dimensions.value[2] = this.vertexArray[0], a.uniforms.dimensions.value[3] = this.vertexArray[5]), g.syncUniforms(), f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer), f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer), f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer), f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, b.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var a = this.gl;
            this.vertexBuffer = a.createBuffer(), this.uvBuffer = a.createBuffer(), this.colorBuffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.vertexArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW), this.uvArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW), this.colorArray = new b.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW)
        }, b.WebGLFilterManager.prototype.destroy = function() {
            var a = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var b = 0; b < this.texturePool.length; b++) this.texturePool[b].destroy();
            this.texturePool = null, a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer)
        }, b.FilterTexture = function(a, c, d, e) { this.gl = a, this.frameBuffer = a.createFramebuffer(), this.texture = a.createTexture(), e = e || b.scaleModes.DEFAULT, a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0), this.renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer), this.resize(c, d) }, b.FilterTexture.prototype.constructor = b.FilterTexture, b.FilterTexture.prototype.clear = function() {
            var a = this.gl;
            a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT)
        }, b.FilterTexture.prototype.resize = function(a, b) {
            if (this.width !== a || this.height !== b) {
                this.width = a, this.height = b;
                var c = this.gl;
                c.bindTexture(c.TEXTURE_2D, this.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null), c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b)
            }
        }, b.FilterTexture.prototype.destroy = function() {
            var a = this.gl;
            a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, b.CanvasBuffer = function(a, c) { this.width = a, this.height = c, this.canvas = b.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = a, this.canvas.height = c }, b.CanvasBuffer.prototype.constructor = b.CanvasBuffer, b.CanvasBuffer.prototype.clear = function() { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height) }, b.CanvasBuffer.prototype.resize = function(a, b) { this.width = this.canvas.width = a, this.height = this.canvas.height = b }, b.CanvasBuffer.prototype.destroy = function() { b.CanvasPool.remove(this) }, b.CanvasMaskManager = function() {}, b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager, b.CanvasMaskManager.prototype.pushMask = function(a, c) {
            var d = c.context;
            d.save();
            var e = a.alpha,
                f = a.worldTransform,
                g = c.resolution;
            d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), b.CanvasGraphics.renderGraphicsMask(a, d), d.clip(), a.worldAlpha = e
        }, b.CanvasMaskManager.prototype.popMask = function(a) { a.context.restore() }, b.CanvasTinter = function() {}, b.CanvasTinter.getTintedTexture = function(a, c) { var d = a.tintedTexture || b.CanvasPool.create(this); return b.CanvasTinter.tintMethod(a.texture, c, d), d }, b.CanvasTinter.tintWithMultiply = function(a, b, c) {
            var d = c.getContext("2d"),
                e = a.crop;
            c.width === e.width && c.height === e.height || (c.width = e.width, c.height = e.height), d.clearRect(0, 0, e.width, e.height), d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6), d.fillRect(0, 0, e.width, e.height), d.globalCompositeOperation = "multiply", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height), d.globalCompositeOperation = "destination-atop", d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height)
        }, b.CanvasTinter.tintWithPerPixel = function(a, c, d) {
            var e = d.getContext("2d"),
                f = a.crop;
            d.width = f.width, d.height = f.height, e.globalCompositeOperation = "copy", e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
            for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4)
                if (l[m + 0] *= h, l[m + 1] *= i, l[m + 2] *= j, !b.CanvasTinter.canHandleAlpha) {
                    var n = l[m + 3];
                    l[m + 0] /= 255 / n, l[m + 1] /= 255 / n, l[m + 2] /= 255 / n
                }
            e.putImageData(k, 0, 0)
        }, b.CanvasTinter.checkInverseAlpha = function() {
            var a = new b.CanvasBuffer(2, 1);
            a.context.fillStyle = "rgba(10, 20, 30, 0.5)", a.context.fillRect(0, 0, 1, 1);
            var c = a.context.getImageData(0, 0, 1, 1);
            if (null === c) return !1;
            a.context.putImageData(c, 1, 0);
            var d = a.context.getImageData(1, 0, 1, 1);
            return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3]
        }, b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha(), b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes(), b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel, b.CanvasRenderer = function(a) {
            this.game = a,
                b.defaultRenderer || (b.defaultRenderer = this), this.type = b.CANVAS_RENDERER, this.resolution = a.resolution, this.clearBeforeRender = a.clearBeforeRender, this.transparent = a.transparent, this.autoResize = !1, this.width = a.width * this.resolution, this.height = a.height * this.resolution, this.view = a.canvas, this.context = this.view.getContext("2d", { alpha: this.transparent }), this.refresh = !0, this.count = 0, this.maskManager = new b.CanvasMaskManager, this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context), roundPixels: !1 }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, b.CanvasRenderer.prototype.constructor = b.CanvasRenderer, b.CanvasRenderer.prototype.render = function(a) { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : a._bgColor && (this.context.fillStyle = a._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(a) }, b.CanvasRenderer.prototype.destroy = function(a) { void 0 === a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null }, b.CanvasRenderer.prototype.resize = function(a, c) { this.width = a * this.resolution, this.height = c * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === b.scaleModes.LINEAR) }, b.CanvasRenderer.prototype.renderDisplayObject = function(a, b, c) { this.renderSession.context = b || this.context, this.renderSession.resolution = this.resolution, a._renderCanvas(this.renderSession, c) }, b.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!b.blendModesCanvas) {
                var a = [],
                    c = b.blendModes,
                    d = b.canUseNewCanvasBlendModes();
                a[c.NORMAL] = "source-over", a[c.ADD] = "lighter", a[c.MULTIPLY] = d ? "multiply" : "source-over", a[c.SCREEN] = d ? "screen" : "source-over", a[c.OVERLAY] = d ? "overlay" : "source-over", a[c.DARKEN] = d ? "darken" : "source-over", a[c.LIGHTEN] = d ? "lighten" : "source-over", a[c.COLOR_DODGE] = d ? "color-dodge" : "source-over", a[c.COLOR_BURN] = d ? "color-burn" : "source-over", a[c.HARD_LIGHT] = d ? "hard-light" : "source-over", a[c.SOFT_LIGHT] = d ? "soft-light" : "source-over", a[c.DIFFERENCE] = d ? "difference" : "source-over", a[c.EXCLUSION] = d ? "exclusion" : "source-over", a[c.HUE] = d ? "hue" : "source-over", a[c.SATURATION] = d ? "saturation" : "source-over", a[c.COLOR] = d ? "color" : "source-over", a[c.LUMINOSITY] = d ? "luminosity" : "source-over", b.blendModesCanvas = a
            }
        }, b.BaseTexture = function(a, c) { this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = c || b.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = a, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], a && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1) }, b.BaseTexture.prototype.constructor = b.BaseTexture, b.BaseTexture.prototype.forceLoaded = function(a, b) { this.hasLoaded = !0, this.width = a, this.height = b, this.dirty() }, b.BaseTexture.prototype.destroy = function() { this.source && b.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU() }, b.BaseTexture.prototype.updateSourceImage = function(a) {}, b.BaseTexture.prototype.dirty = function() { for (var a = 0; a < this._glTextures.length; a++) this._dirty[a] = !0 }, b.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var a = this._glTextures.length - 1; a >= 0; a--) {
                var c = this._glTextures[a],
                    d = b.glContexts[a];
                d && c && d.deleteTexture(c)
            }
            this._glTextures.length = 0, this.dirty()
        }, b.BaseTexture.fromCanvas = function(a, c) { return 0 === a.width && (a.width = 1), 0 === a.height && (a.height = 1), new b.BaseTexture(a, c) }, b.TextureSilentFail = !1, b.Texture = function(a, c, d, e) { this.noFrame = !1, c || (this.noFrame = !0, c = new b.Rectangle(0, 0, 1, 1)), a instanceof b.Texture && (a = a.baseTexture), this.baseTexture = a, this.frame = c, this.trim = e, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = d || new b.Rectangle(0, 0, 1, 1), a.hasLoaded && (this.noFrame && (c = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(c)) }, b.Texture.prototype.constructor = b.Texture, b.Texture.prototype.onBaseTextureLoaded = function() {
            var a = this.baseTexture;
            this.noFrame && (this.frame = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(this.frame)
        }, b.Texture.prototype.destroy = function(a) { a && this.baseTexture.destroy(), this.valid = !1 }, b.Texture.prototype.setFrame = function(a) { if (this.noFrame = !1, this.frame = a, this.width = a.width, this.height = a.height, this.crop.x = a.x, this.crop.y = a.y, this.crop.width = a.width, this.crop.height = a.height, !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) { if (!b.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this); return void(this.valid = !1) } this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs() }, b.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new b.TextureUvs);
            var a = this.crop,
                c = this.baseTexture.width,
                d = this.baseTexture.height;
            this._uvs.x0 = a.x / c, this._uvs.y0 = a.y / d, this._uvs.x1 = (a.x + a.width) / c, this._uvs.y1 = a.y / d, this._uvs.x2 = (a.x + a.width) / c, this._uvs.y2 = (a.y + a.height) / d, this._uvs.x3 = a.x / c, this._uvs.y3 = (a.y + a.height) / d
        }, b.Texture.fromCanvas = function(a, c) { var d = b.BaseTexture.fromCanvas(a, c); return new b.Texture(d) }, b.TextureUvs = function() { this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0 }, b.RenderTexture = function(a, c, d, e, f) {
            if (this.width = a || 100, this.height = c || 100, this.resolution = f || 1, this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new b.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = d || b.defaultRenderer, this.renderer.type === b.WEBGL_RENDERER) {
                var g = this.renderer.gl;
                this.baseTexture._dirty[g.id] = !1, this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[g.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new b.Point(.5 * this.width, .5 * -this.height)
            }
            else this.render = this.renderCanvas, this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, b.RenderTexture.prototype = Object.create(b.Texture.prototype), b.RenderTexture.prototype.constructor = b.RenderTexture, b.RenderTexture.prototype.resize = function(a, c, d) { a === this.width && c === this.height || (this.valid = a > 0 && c > 0, this.width = a, this.height = c, this.frame.width = this.crop.width = a * this.resolution, this.frame.height = this.crop.height = c * this.resolution, d && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === b.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height)) }, b.RenderTexture.prototype.clear = function() { this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear()) }, b.RenderTexture.prototype.renderWebGL = function(a, b, c) {
            if (this.valid && 0 !== a.alpha) {
                var d = a.worldTransform;
                d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1);
                for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
                var f = this.renderer.gl;
                f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer), c && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b), this.renderer.spriteBatch.dirty = !0
            }
        }, b.RenderTexture.prototype.renderCanvas = function(a, b, c) {
            if (this.valid && 0 !== a.alpha) {
                var d = a.worldTransform;
                d.identity(), b && d.append(b);
                for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
                c && this.textureBuffer.clear();
                var f = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(a, this.textureBuffer.context, b), this.renderer.resolution = f
            }
        }, b.RenderTexture.prototype.getImage = function() { var a = new Image; return a.src = this.getBase64(), a }, b.RenderTexture.prototype.getBase64 = function() { return this.getCanvas().toDataURL() }, b.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === b.WEBGL_RENDERER) {
                var a = this.renderer.gl,
                    c = this.textureBuffer.width,
                    d = this.textureBuffer.height,
                    e = new Uint8Array(4 * c * d);
                a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e), a.bindFramebuffer(a.FRAMEBUFFER, null);
                var f = new b.CanvasBuffer(c, d),
                    g = f.context.getImageData(0, 0, c, d);
                return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas
            }
            return this.textureBuffer.canvas
        }, b.AbstractFilter = function(a, b) { this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = b || {}, this.fragmentSrc = a || [] }, b.AbstractFilter.prototype.constructor = b.AbstractFilter, b.AbstractFilter.prototype.syncUniforms = function() { for (var a = 0, b = this.shaders.length; a < b; a++) this.shaders[a].dirty = !0 }, b.Strip = function(a) { b.DisplayObjectContainer.call(this), this.texture = a, this.uvs = new b.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new b.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new b.Float32Array([1, 1, 1, 1]), this.indices = new b.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = b.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP }, b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype), b.Strip.prototype.constructor = b.Strip, b.Strip.prototype._renderWebGL = function(a) {!this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start()) }, b.Strip.prototype._initWebGL = function(a) {
            var b = a.gl;
            this._vertexBuffer = b.createBuffer(), this._indexBuffer = b.createBuffer(), this._uvBuffer = b.createBuffer(), this._colorBuffer = b.createBuffer(), b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer), b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer), b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW), b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer), b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW)
        }, b.Strip.prototype._renderStrip = function(a) {
            var c = a.gl,
                d = a.projection,
                e = a.offset,
                f = a.shaderManager.stripShader,
                g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
            a.blendModeManager.setBlendMode(this.blendMode), c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)), c.uniform2f(f.projectionVector, d.x, -d.y), c.uniform2f(f.offsetVector, -e.x, -e.y), c.uniform1f(f.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer), c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW)) : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer), c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices), c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer), c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0), c.activeTexture(c.TEXTURE0), this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0)
        }, b.Strip.prototype._renderCanvas = function(a) {
            var c = a.context,
                d = this.worldTransform,
                e = d.tx * a.resolution + a.shakeX,
                f = d.ty * a.resolution + a.shakeY;
            a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f) : c.setTransform(d.a, d.b, d.c, d.d, e, f), this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c)
        }, b.Strip.prototype._renderCanvasTriangleStrip = function(a) {
            var b = this.vertices,
                c = this.uvs,
                d = b.length / 2;
            this.count++;
            for (var e = 0; e < d - 2; e++) {
                var f = 2 * e;
                this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4)
            }
        }, b.Strip.prototype._renderCanvasTriangles = function(a) {
            var b = this.vertices,
                c = this.uvs,
                d = this.indices,
                e = d.length;
            this.count++;
            for (var f = 0; f < e; f += 3) {
                var g = 2 * d[f],
                    h = 2 * d[f + 1],
                    i = 2 * d[f + 2];
                this._renderCanvasDrawTriangle(a, b, c, g, h, i)
            }
        }, b.Strip.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
            var g = this.texture.baseTexture.source,
                h = this.texture.width,
                i = this.texture.height,
                j = b[d],
                k = b[e],
                l = b[f],
                m = b[d + 1],
                n = b[e + 1],
                o = b[f + 1],
                p = c[d] * h,
                q = c[e] * h,
                r = c[f] * h,
                s = c[d + 1] * i,
                t = c[e + 1] * i,
                u = c[f + 1] * i;
            if (this.canvasPadding > 0) {
                var v = this.canvasPadding / this.worldTransform.a,
                    w = this.canvasPadding / this.worldTransform.d,
                    x = (j + k + l) / 3,
                    y = (m + n + o) / 3,
                    z = j - x,
                    A = m - y,
                    B = Math.sqrt(z * z + A * A);
                j = x + z / B * (B + v), m = y + A / B * (B + w), z = k - x, A = n - y, B = Math.sqrt(z * z + A * A), k = x + z / B * (B + v), n = y + A / B * (B + w), z = l - x, A = o - y, B = Math.sqrt(z * z + A * A), l = x + z / B * (B + v), o = y + A / B * (B + w)
            }
            a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), a.clip();
            var C = p * t + s * r + q * u - t * r - s * q - p * u,
                D = j * t + s * l + k * u - t * l - s * k - j * u,
                E = p * k + j * r + q * l - k * r - j * q - p * l,
                F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u,
                G = m * t + s * o + n * u - t * o - s * n - m * u,
                H = p * n + m * r + q * o - n * r - m * q - p * o,
                I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
            a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore()
        }, b.Strip.prototype.renderStripFlat = function(a) {
            var b = this.context,
                c = a.vertices,
                d = c.length / 2;
            this.count++, b.beginPath();
            for (var e = 1; e < d - 2; e++) {
                var f = 2 * e,
                    g = c[f],
                    h = c[f + 2],
                    i = c[f + 4],
                    j = c[f + 1],
                    k = c[f + 3],
                    l = c[f + 5];
                b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l)
            }
            b.fillStyle = "#FF0000", b.fill(), b.closePath()
        }, b.Strip.prototype.onTextureUpdate = function() { this.updateFrame = !0 }, b.Strip.prototype.getBounds = function(a) {
            for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -(1 / 0), k = -(1 / 0), l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; o < p; o += 2) {
                var q = n[o],
                    r = n[o + 1],
                    s = d * q + f * r + h,
                    t = g * r + e * q + i;
                l = s < l ? s : l, m = t < m ? t : m, j = s > j ? s : j, k = t > k ? t : k
            }
            if (l === -(1 / 0) || k === 1 / 0) return b.EmptyRectangle;
            var u = this._bounds;
            return u.x = l, u.width = j - l, u.y = m, u.height = k - m, this._currentBounds = u, u
        }, b.Strip.DrawModes = { TRIANGLE_STRIP: 0, TRIANGLES: 1 }, b.Rope = function(a, c) { b.Strip.call(this, a), this.points = c, this.vertices = new b.Float32Array(4 * c.length), this.uvs = new b.Float32Array(4 * c.length), this.colors = new b.Float32Array(2 * c.length), this.indices = new b.Uint16Array(2 * c.length), this.refresh() }, b.Rope.prototype = Object.create(b.Strip.prototype), b.Rope.prototype.constructor = b.Rope, b.Rope.prototype.refresh = function() {
            var a = this.points;
            if (!(a.length < 1)) {
                var b = this.uvs,
                    c = a[0],
                    d = this.indices,
                    e = this.colors;
                this.count -= .2, b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1, e[0] = 1, e[1] = 1, d[0] = 0, d[1] = 1;
                for (var f, g, h, i = a.length, j = 1; j < i; j++) f = a[j], g = 4 * j, h = j / (i - 1), j % 2 ? (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1) : (b[g] = h, b[g + 1] = 0, b[g + 2] = h, b[g + 3] = 1), g = 2 * j, e[g] = 1, e[g + 1] = 1, g = 2 * j, d[g] = g, d[g + 1] = g + 1, c = f
            }
        }, b.Rope.prototype.updateTransform = function() {
            var a = this.points;
            if (!(a.length < 1)) {
                var c, d = a[0],
                    e = { x: 0, y: 0 };
                this.count -= .2;
                for (var f, g, h, i, j, k = this.vertices, l = a.length, m = 0; m < l; m++) f = a[m], g = 4 * m, c = m < a.length - 1 ? a[m + 1] : f, e.y = -(c.x - d.x), e.x = c.y - d.y, h = 10 * (1 - m / (l - 1)), h > 1 && (h = 1), i = Math.sqrt(e.x * e.x + e.y * e.y), j = this.texture.height / 2, e.x /= i, e.y /= i, e.x *= j, e.y *= j, k[g] = f.x + e.x, k[g + 1] = f.y + e.y, k[g + 2] = f.x - e.x, k[g + 3] = f.y - e.y, d = f;
                b.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, b.Rope.prototype.setTexture = function(a) { this.texture = a }, b.TilingSprite = function(a, c, d) { b.Sprite.call(this, a), this._width = c || 128, this._height = d || 128, this.tileScale = new b.Point(1, 1), this.tileScaleOffset = new b.Point(1, 1), this.tilePosition = new b.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = b.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0 }, b.TilingSprite.prototype = Object.create(b.Sprite.prototype), b.TilingSprite.prototype.constructor = b.TilingSprite, b.TilingSprite.prototype.setTexture = function(a) { this.texture !== a && (this.texture = a, this.refreshTexture = !0, this.cachedTint = 16777215) }, b.TilingSprite.prototype._renderWebGL = function(a) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, a), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                a.spriteBatch.renderTilingSprite(this);
                for (var b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(), this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this._mask, a), a.spriteBatch.start()
            }
        }, b.TilingSprite.prototype._renderCanvas = function(a) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var c = a.context;
                this._mask && a.maskManager.pushMask(this._mask, a), c.globalAlpha = this.worldAlpha;
                var d = this.worldTransform,
                    e = a.resolution,
                    f = d.tx * e + a.shakeX,
                    g = d.ty * e + a.shakeY;
                if (c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, f, g), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, a), !this.tilingTexture) return;
                    this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var h = a.currentBlendMode;
                this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]);
                var i = this.tilePosition,
                    j = this.tileScale;
                i.x %= this.tilingTexture.baseTexture.width, i.y %= this.tilingTexture.baseTexture.height, c.scale(j.x, j.y), c.translate(i.x + this.anchor.x * -this._width, i.y + this.anchor.y * -this._height), c.fillStyle = this.tilePattern;
                var f = -i.x,
                    g = -i.y,
                    k = this._width / j.x,
                    l = this._height / j.y;
                a.roundPixels && (f |= 0, g |= 0, k |= 0, l |= 0), c.fillRect(f, g, k, l), c.scale(1 / j.x, 1 / j.y), c.translate(-i.x + this.anchor.x * this._width, -i.y + this.anchor.y * this._height), this._mask && a.maskManager.popMask(a);
                for (var m = 0; m < this.children.length; m++) this.children[m]._renderCanvas(a);
                h !== this.blendMode && (a.currentBlendMode = h, c.globalCompositeOperation = b.blendModesCanvas[h])
            }
        }, b.TilingSprite.prototype.onTextureUpdate = function() {}, b.TilingSprite.prototype.generateTilingTexture = function(a, c) {
            if (this.texture.baseTexture.hasLoaded) {
                var d = this.texture,
                    e = d.frame,
                    f = this._frame.sourceSizeW || this._frame.width,
                    g = this._frame.sourceSizeH || this._frame.height,
                    h = 0,
                    i = 0;
                this._frame.trimmed && (h = this._frame.spriteSourceSizeX, i = this._frame.spriteSourceSizeY), a && (f = b.getNextPowerOfTwo(f), g = b.getNextPowerOfTwo(g)), this.canvasBuffer ? (this.canvasBuffer.resize(f, g), this.tilingTexture.baseTexture.width = f, this.tilingTexture.baseTexture.height = g, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new b.CanvasBuffer(f, g), this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, f, g));
                var j = d.crop.width,
                    k = d.crop.height;
                j === f && k === g || (j = f, k = g), this.canvasBuffer.context.drawImage(d.baseTexture.source, d.crop.x, d.crop.y, d.crop.width, d.crop.height, h, i, j, k), this.tileScaleOffset.x = e.width / f, this.tileScaleOffset.y = e.height / g, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, b.TilingSprite.prototype.getBounds = function() {
            var a = this._width,
                b = this._height,
                c = a * (1 - this.anchor.x),
                d = a * -this.anchor.x,
                e = b * (1 - this.anchor.y),
                f = b * -this.anchor.y,
                g = this.worldTransform,
                h = g.a,
                i = g.b,
                j = g.c,
                k = g.d,
                l = g.tx,
                m = g.ty,
                n = h * d + j * f + l,
                o = k * f + i * d + m,
                p = h * c + j * f + l,
                q = k * f + i * c + m,
                r = h * c + j * e + l,
                s = k * e + i * c + m,
                t = h * d + j * e + l,
                u = k * e + i * d + m,
                v = -(1 / 0),
                w = -(1 / 0),
                x = 1 / 0,
                y = 1 / 0;
            x = n < x ? n : x, x = p < x ? p : x, x = r < x ? r : x, x = t < x ? t : x, y = o < y ? o : y, y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, v = n > v ? n : v, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = o > w ? o : w, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w;
            var z = this._bounds;
            return z.x = x, z.width = v - x, z.y = y, z.height = w - y, this._currentBounds = z, z
        }, b.TilingSprite.prototype.destroy = function() { b.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null) }, Object.defineProperty(b.TilingSprite.prototype, "width", { get: function() { return this._width }, set: function(a) { this._width = a } }), Object.defineProperty(b.TilingSprite.prototype, "height", { get: function() { return this._height }, set: function(a) { this._height = a } }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b), exports.PIXI = b) : "undefined" != typeof define && define.amd ? define("PIXI", function() { return a.PIXI = b }()) : a.PIXI = b, b
}.call(this),
    function() {
        function a(a, b) { this._scaleFactor = a, this._deltaMode = b, this.originalEvent = null }
        var b = this,
            c = c || { VERSION: "2.6.11", GAMES: [], AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, NONE: 0, LEFT: 1, RIGHT: 2, UP: 3, DOWN: 4, SPRITE: 0, BUTTON: 1, IMAGE: 2, GRAPHICS: 3, TEXT: 4, TILESPRITE: 5, BITMAPTEXT: 6, GROUP: 7, RENDERTEXTURE: 8, TILEMAP: 9, TILEMAPLAYER: 10, EMITTER: 11, POLYGON: 12, BITMAPDATA: 13, CANVAS_FILTER: 14, WEBGL_FILTER: 15, ELLIPSE: 16, SPRITEBATCH: 17, RETROFONT: 18, POINTER: 19, ROPE: 20, CIRCLE: 21, RECTANGLE: 22, LINE: 23, MATRIX: 24, POINT: 25, ROUNDEDRECTANGLE: 26, CREATURE: 27, VIDEO: 28, PENDING_ATLAS: -1, HORIZONTAL: 0, VERTICAL: 1, LANDSCAPE: 0, PORTRAIT: 1, ANGLE_UP: 270, ANGLE_DOWN: 90, ANGLE_LEFT: 180, ANGLE_RIGHT: 0, ANGLE_NORTH_EAST: 315, ANGLE_NORTH_WEST: 225, ANGLE_SOUTH_EAST: 45, ANGLE_SOUTH_WEST: 135, TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12, blendModes: { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16 }, scaleModes: { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }, PIXI: PIXI || {} };
        if (Math.trunc || (Math.trunc = function(a) { return a < 0 ? Math.ceil(a) : Math.floor(a) }), Function.prototype.bind || (Function.prototype.bind = function() {
                var a = Array.prototype.slice;
                return function(b) {
                    function c() {
                        var f = e.concat(a.call(arguments));
                        d.apply(this instanceof c ? this : b, f)
                    }
                    var d = this,
                        e = a.call(arguments, 1);
                    if ("function" != typeof d) throw new TypeError;
                    return c.prototype = function f(a) { if (a && (f.prototype = a), !(this instanceof f)) return new f }(d.prototype), c
                }
            }()), Array.isArray || (Array.isArray = function(a) { return "[object Array]" === Object.prototype.toString.call(a) }), Array.prototype.forEach || (Array.prototype.forEach = function(a) {
                "use strict";
                if (void 0 === this || null === this) throw new TypeError;
                var b = Object(this),
                    c = b.length >>> 0;
                if ("function" != typeof a) throw new TypeError;
                for (var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; e < c; e++) e in b && a.call(d, b[e], e, b)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var d = function(a) {
                var b = new Array;
                window[a] = function(a) { if ("number" == typeof a) { Array.call(this, a), this.length = a; for (var b = 0; b < this.length; b++) this[b] = 0 } else { Array.call(this, a.length), this.length = a.length; for (var b = 0; b < this.length; b++) this[b] = a[b] } }, window[a].prototype = b, window[a].constructor = window[a]
            };
            d("Uint32Array"), d("Int16Array")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), /firefox/i.test(navigator.userAgent) && (window.oldGetComputedStyle = window.getComputedStyle, window.getComputedStyle = function(a, b) { var c = window.oldGetComputedStyle(a, b); return null === c ? { getPropertyValue: function() {} } : c }), c.Utils = {
            reverseString: function(a) { return a.split("").reverse().join("") },
            getProperty: function(a, b) { for (var c = b.split("."), d = c.pop(), e = c.length, f = 1, g = c[0]; f < e && (a = a[g]);) g = c[f], f++; return a ? a[d] : null },
            setProperty: function(a, b, c) { for (var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; g < f && (a = a[h]);) h = d[g], g++; return a && (a[e] = c), a },
            chanceRoll: function(a) { return void 0 === a && (a = 50), a > 0 && 100 * Math.random() <= a },
            randomChoice: function(a, b) { return Math.random() < .5 ? a : b },
            parseDimension: function(a, b) {
                var c = 0,
                    d = 0;
                return "string" == typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100, d = 0 === b ? window.innerWidth * c : window.innerHeight * c) : d = parseInt(a, 10) : d = a, d
            },
            pad: function(a, b, c, d) {
                if (void 0 === b) var b = 0;
                if (void 0 === c) var c = " ";
                if (void 0 === d) var d = 3;
                a = a.toString();
                var e = 0;
                if (b + 1 >= a.length) switch (d) {
                    case 1:
                        a = new Array(b + 1 - a.length).join(c) + a;
                        break;
                    case 3:
                        var f = Math.ceil((e = b - a.length) / 2),
                            g = e - f;
                        a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                        break;
                    default:
                        a += new Array(b + 1 - a.length).join(c)
                }
                return a
            },
            isPlainObject: function(a) { if ("object" != typeof a || a.nodeType || a === a.window) return !1; try { if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1 } catch (b) { return !1 } return !0 },
            extend: function() {
                var a, b, d, e, f, g, h = arguments[0] || {},
                    i = 1,
                    j = arguments.length,
                    k = !1;
                for ("boolean" == typeof h && (k = h, h = arguments[1] || {}, i = 2), j === i && (h = this, --i); i < j; i++)
                    if (null != (a = arguments[i]))
                        for (b in a) d = h[b], e = a[b], h !== e && (k && e && (c.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, g = d && Array.isArray(d) ? d : []) : g = d && c.Utils.isPlainObject(d) ? d : {}, h[b] = c.Utils.extend(k, g, e)) : void 0 !== e && (h[b] = e));
                return h
            },
            mixinPrototype: function(a, b, c) {
                void 0 === c && (c = !1);
                for (var d = Object.keys(b), e = 0; e < d.length; e++) {
                    var f = d[e],
                        g = b[f];
                    !c && f in a || (!g || "function" != typeof g.get && "function" != typeof g.set ? a[f] = g : "function" == typeof g.clone ? a[f] = g.clone() : Object.defineProperty(a, f, g))
                }
            },
            mixin: function(a, b) {
                if (!a || "object" != typeof a) return b;
                for (var d in a) {
                    var e = a[d];
                    if (!e.childNodes && !e.cloneNode) {
                        var f = typeof a[d];
                        a[d] && "object" === f ? typeof b[d] === f ? b[d] = c.Utils.mixin(a[d], b[d]) : b[d] = c.Utils.mixin(a[d], new e.constructor) : b[d] = a[d]
                    }
                }
                return b
            }
        }, c.Circle = function(a, b, d) { a = a || 0, b = b || 0, d = d || 0, this.x = a, this.y = b, this._diameter = d, this._radius = 0, d > 0 && (this._radius = .5 * d), this.type = c.CIRCLE }, c.Circle.prototype = {
            circumference: function() { return 2 * (Math.PI * this._radius) },
            random: function(a) {
                void 0 === a && (a = new c.Point);
                var b = 2 * Math.PI * Math.random(),
                    d = Math.random() + Math.random(),
                    e = d > 1 ? 2 - d : d,
                    f = e * Math.cos(b),
                    g = e * Math.sin(b);
                return a.x = this.x + f * this.radius, a.y = this.y + g * this.radius, a
            },
            getBounds: function() { return new c.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter) },
            setTo: function(a, b, c) { return this.x = a, this.y = b, this._diameter = c, this._radius = .5 * c, this },
            copyFrom: function(a) { return this.setTo(a.x, a.y, a.diameter) },
            copyTo: function(a) { return a.x = this.x, a.y = this.y, a.diameter = this._diameter, a },
            distance: function(a, b) { var d = c.Math.distance(this.x, this.y, a.x, a.y); return b ? Math.round(d) : d },
            clone: function(a) { return void 0 === a || null === a ? a = new c.Circle(this.x, this.y, this.diameter) : a.setTo(this.x, this.y, this.diameter), a },
            contains: function(a, b) { return c.Circle.contains(this, a, b) },
            circumferencePoint: function(a, b, d) { return c.Circle.circumferencePoint(this, a, b, d) },
            offset: function(a, b) { return this.x += a, this.y += b, this },
            offsetPoint: function(a) { return this.offset(a.x, a.y) },
            toString: function() { return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]" }
        }, c.Circle.prototype.constructor = c.Circle, Object.defineProperty(c.Circle.prototype, "diameter", { get: function() { return this._diameter }, set: function(a) { a > 0 && (this._diameter = a, this._radius = .5 * a) } }), Object.defineProperty(c.Circle.prototype, "radius", { get: function() { return this._radius }, set: function(a) { a > 0 && (this._radius = a, this._diameter = 2 * a) } }), Object.defineProperty(c.Circle.prototype, "left", { get: function() { return this.x - this._radius }, set: function(a) { a > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - a } }), Object.defineProperty(c.Circle.prototype, "right", { get: function() { return this.x + this._radius }, set: function(a) { a < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.x } }), Object.defineProperty(c.Circle.prototype, "top", { get: function() { return this.y - this._radius }, set: function(a) { a > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - a } }), Object.defineProperty(c.Circle.prototype, "bottom", { get: function() { return this.y + this._radius }, set: function(a) { a < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = a - this.y } }), Object.defineProperty(c.Circle.prototype, "area", { get: function() { return this._radius > 0 ? Math.PI * this._radius * this._radius : 0 } }), Object.defineProperty(c.Circle.prototype, "empty", { get: function() { return 0 === this._diameter }, set: function(a) { a === !0 && this.setTo(0, 0, 0) } }), c.Circle.contains = function(a, b, c) {
            if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
                var d = (a.x - b) * (a.x - b),
                    e = (a.y - c) * (a.y - c);
                return d + e <= a.radius * a.radius
            }
            return !1
        }, c.Circle.equals = function(a, b) { return a.x === b.x && a.y === b.y && a.diameter === b.diameter }, c.Circle.intersects = function(a, b) { return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius }, c.Circle.circumferencePoint = function(a, b, d, e) { return void 0 === d && (d = !1), void 0 === e && (e = new c.Point), d === !0 && (b = c.Math.degToRad(b)), e.x = a.x + a.radius * Math.cos(b), e.y = a.y + a.radius * Math.sin(b), e }, c.Circle.intersectsRectangle = function(a, b) {
            var c = Math.abs(a.x - b.x - b.halfWidth),
                d = b.halfWidth + a.radius;
            if (c > d) return !1;
            var e = Math.abs(a.y - b.y - b.halfHeight),
                f = b.halfHeight + a.radius;
            if (e > f) return !1;
            if (c <= b.halfWidth || e <= b.halfHeight) return !0;
            var g = c - b.halfWidth,
                h = e - b.halfHeight,
                i = g * g,
                j = h * h,
                k = a.radius * a.radius;
            return i + j <= k
        }, PIXI.Circle = c.Circle, c.Ellipse = function(a, b, d, e) { a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c.ELLIPSE }, c.Ellipse.prototype = {
            setTo: function(a, b, c, d) { return this.x = a, this.y = b, this.width = c, this.height = d, this },
            getBounds: function() { return new c.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height) },
            copyFrom: function(a) { return this.setTo(a.x, a.y, a.width, a.height) },
            copyTo: function(a) { return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a },
            clone: function(a) { return void 0 === a || null === a ? a = new c.Ellipse(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a },
            contains: function(a, b) { return c.Ellipse.contains(this, a, b) },
            random: function(a) {
                void 0 === a && (a = new c.Point);
                var b = Math.random() * Math.PI * 2,
                    d = Math.random();
                return a.x = Math.sqrt(d) * Math.cos(b), a.y = Math.sqrt(d) * Math.sin(b), a.x = this.x + a.x * this.width / 2, a.y = this.y + a.y * this.height / 2, a
            },
            toString: function() { return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]" }
        }, c.Ellipse.prototype.constructor = c.Ellipse, Object.defineProperty(c.Ellipse.prototype, "left", {
            get: function() {
                return this.x;
            },
            set: function(a) { this.x = a }
        }), Object.defineProperty(c.Ellipse.prototype, "right", { get: function() { return this.x + this.width }, set: function(a) { a < this.x ? this.width = 0 : this.width = a - this.x } }), Object.defineProperty(c.Ellipse.prototype, "top", { get: function() { return this.y }, set: function(a) { this.y = a } }), Object.defineProperty(c.Ellipse.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(a) { a < this.y ? this.height = 0 : this.height = a - this.y } }), Object.defineProperty(c.Ellipse.prototype, "empty", { get: function() { return 0 === this.width || 0 === this.height }, set: function(a) { a === !0 && this.setTo(0, 0, 0, 0) } }), c.Ellipse.contains = function(a, b, c) {
            if (a.width <= 0 || a.height <= 0) return !1;
            var d = (b - a.x) / a.width - .5,
                e = (c - a.y) / a.height - .5;
            return d *= d, e *= e, d + e < .25
        }, PIXI.Ellipse = c.Ellipse, c.Line = function(a, b, d, e) { a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.start = new c.Point(a, b), this.end = new c.Point(d, e), this.type = c.LINE }, c.Line.prototype = {
            setTo: function(a, b, c, d) { return this.start.setTo(a, b), this.end.setTo(c, d), this },
            fromSprite: function(a, b, c) { return void 0 === c && (c = !1), c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y) },
            fromAngle: function(a, b, c, d) { return this.start.setTo(a, b), this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d), this },
            rotate: function(a, b) {
                var c = (this.start.x + this.end.x) / 2,
                    d = (this.start.y + this.end.y) / 2;
                return this.start.rotate(c, d, a, b), this.end.rotate(c, d, a, b), this
            },
            rotateAround: function(a, b, c, d) { return this.start.rotate(a, b, c, d), this.end.rotate(a, b, c, d), this },
            intersects: function(a, b, d) { return c.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d) },
            reflect: function(a) { return c.Line.reflect(this, a) },
            midPoint: function(a) { return void 0 === a && (a = new c.Point), a.x = (this.start.x + this.end.x) / 2, a.y = (this.start.y + this.end.y) / 2, a },
            centerOn: function(a, b) {
                var c = (this.start.x + this.end.x) / 2,
                    d = (this.start.y + this.end.y) / 2,
                    e = a - c,
                    f = b - d;
                this.start.add(e, f), this.end.add(e, f)
            },
            pointOnLine: function(a, b) { return (a - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (b - this.start.y) },
            pointOnSegment: function(a, b) {
                var c = Math.min(this.start.x, this.end.x),
                    d = Math.max(this.start.x, this.end.x),
                    e = Math.min(this.start.y, this.end.y),
                    f = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f
            },
            random: function(a) { void 0 === a && (a = new c.Point); var b = Math.random(); return a.x = this.start.x + b * (this.end.x - this.start.x), a.y = this.start.y + b * (this.end.y - this.start.y), a },
            coordinatesOnLine: function(a, b) {
                void 0 === a && (a = 1), void 0 === b && (b = []);
                var c = Math.round(this.start.x),
                    d = Math.round(this.start.y),
                    e = Math.round(this.end.x),
                    f = Math.round(this.end.y),
                    g = Math.abs(e - c),
                    h = Math.abs(f - d),
                    i = c < e ? 1 : -1,
                    j = d < f ? 1 : -1,
                    k = g - h;
                b.push([c, d]);
                for (var l = 1; c !== e || d !== f;) {
                    var m = k << 1;
                    m > -h && (k -= h, c += i), m < g && (k += g, d += j), l % a === 0 && b.push([c, d]), l++
                }
                return b
            },
            clone: function(a) { return void 0 === a || null === a ? a = new c.Line(this.start.x, this.start.y, this.end.x, this.end.y) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y), a }
        }, Object.defineProperty(c.Line.prototype, "length", { get: function() { return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y)) } }), Object.defineProperty(c.Line.prototype, "angle", { get: function() { return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x) } }), Object.defineProperty(c.Line.prototype, "slope", { get: function() { return (this.end.y - this.start.y) / (this.end.x - this.start.x) } }), Object.defineProperty(c.Line.prototype, "perpSlope", { get: function() { return -((this.end.x - this.start.x) / (this.end.y - this.start.y)) } }), Object.defineProperty(c.Line.prototype, "x", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(c.Line.prototype, "y", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(c.Line.prototype, "left", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(c.Line.prototype, "right", { get: function() { return Math.max(this.start.x, this.end.x) } }), Object.defineProperty(c.Line.prototype, "top", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(c.Line.prototype, "bottom", { get: function() { return Math.max(this.start.y, this.end.y) } }), Object.defineProperty(c.Line.prototype, "width", { get: function() { return Math.abs(this.start.x - this.end.x) } }), Object.defineProperty(c.Line.prototype, "height", { get: function() { return Math.abs(this.start.y - this.end.y) } }), Object.defineProperty(c.Line.prototype, "normalX", { get: function() { return Math.cos(this.angle - 1.5707963267948966) } }), Object.defineProperty(c.Line.prototype, "normalY", { get: function() { return Math.sin(this.angle - 1.5707963267948966) } }), Object.defineProperty(c.Line.prototype, "normalAngle", { get: function() { return c.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI) } }), c.Line.intersectsPoints = function(a, b, d, e, f, g) {
            void 0 === f && (f = !0), void 0 === g && (g = new c.Point);
            var h = b.y - a.y,
                i = e.y - d.y,
                j = a.x - b.x,
                k = d.x - e.x,
                l = b.x * a.y - a.x * b.y,
                m = e.x * d.y - d.x * e.y,
                n = h * k - i * j;
            if (0 === n) return null;
            if (g.x = (j * m - k * l) / n, g.y = (i * l - h * m) / n, f) {
                var o = (e.y - d.y) * (b.x - a.x) - (e.x - d.x) * (b.y - a.y),
                    p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o,
                    q = ((b.x - a.x) * (a.y - d.y) - (b.y - a.y) * (a.x - d.x)) / o;
                return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null
            }
            return g
        }, c.Line.intersects = function(a, b, d, e) { return c.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e) }, c.Line.intersectsRectangle = function(a, b) {
            if (!c.Rectangle.intersects(a, b)) return !1;
            var d = a.start.x,
                e = a.start.y,
                f = a.end.x,
                g = a.end.y,
                h = b.x,
                i = b.y,
                j = b.right,
                k = b.bottom,
                l = 0;
            if (d >= h && d <= j && e >= i && e <= k || f >= h && f <= j && g >= i && g <= k) return !0;
            if (d < h && f >= h) { if (l = e + (g - e) * (h - d) / (f - d), l > i && l <= k) return !0 }
            else if (d > j && f <= j && (l = e + (g - e) * (j - d) / (f - d), l >= i && l <= k)) return !0;
            if (e < i && g >= i) { if (l = d + (f - d) * (i - e) / (g - e), l >= h && l <= j) return !0 }
            else if (e > k && g <= k && (l = d + (f - d) * (k - e) / (g - e), l >= h && l <= j)) return !0;
            return !1
        }, c.Line.reflect = function(a, b) { return 2 * b.normalAngle - 3.141592653589793 - a.angle }, c.Matrix = function(a, b, d, e, f, g) { void 0 !== a && null !== a || (a = 1), void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), void 0 !== e && null !== e || (e = 1), void 0 !== f && null !== f || (f = 0), void 0 !== g && null !== g || (g = 0), this.a = a, this.b = b, this.c = d, this.d = e, this.tx = f, this.ty = g, this.type = c.MATRIX }, c.Matrix.prototype = {
            fromArray: function(a) { return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5]) },
            setTo: function(a, b, c, d, e, f) { return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = e, this.ty = f, this },
            clone: function(a) { return void 0 === a || null === a ? a = new c.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (a.a = this.a, a.b = this.b, a.c = this.c, a.d = this.d, a.tx = this.tx, a.ty = this.ty), a },
            copyTo: function(a) { return a.copyFrom(this), a },
            copyFrom: function(a) { return this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d, this.tx = a.tx, this.ty = a.ty, this },
            toArray: function(a, b) { return void 0 === b && (b = new PIXI.Float32Array(9)), a ? (b[0] = this.a, b[1] = this.b, b[2] = 0, b[3] = this.c, b[4] = this.d, b[5] = 0, b[6] = this.tx, b[7] = this.ty, b[8] = 1) : (b[0] = this.a, b[1] = this.c, b[2] = this.tx, b[3] = this.b, b[4] = this.d, b[5] = this.ty, b[6] = 0, b[7] = 0, b[8] = 1), b },
            apply: function(a, b) { return void 0 === b && (b = new c.Point), b.x = this.a * a.x + this.c * a.y + this.tx, b.y = this.b * a.x + this.d * a.y + this.ty, b },
            applyInverse: function(a, b) {
                void 0 === b && (b = new c.Point);
                var d = 1 / (this.a * this.d + this.c * -this.b),
                    e = a.x,
                    f = a.y;
                return b.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d, b.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d, b
            },
            translate: function(a, b) { return this.tx += a, this.ty += b, this },
            scale: function(a, b) { return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, this },
            rotate: function(a) {
                var b = Math.cos(a),
                    c = Math.sin(a),
                    d = this.a,
                    e = this.c,
                    f = this.tx;
                return this.a = d * b - this.b * c, this.b = d * c + this.b * b, this.c = e * b - this.d * c, this.d = e * c + this.d * b, this.tx = f * b - this.ty * c, this.ty = f * c + this.ty * b, this
            },
            append: function(a) {
                var b = this.a,
                    c = this.b,
                    d = this.c,
                    e = this.d;
                return this.a = a.a * b + a.b * d, this.b = a.a * c + a.b * e, this.c = a.c * b + a.d * d, this.d = a.c * c + a.d * e, this.tx = a.tx * b + a.ty * d + this.tx, this.ty = a.tx * c + a.ty * e + this.ty, this
            },
            identity: function() { return this.setTo(1, 0, 0, 1, 0, 0) }
        }, c.identityMatrix = new c.Matrix, PIXI.Matrix = c.Matrix, PIXI.identityMatrix = c.identityMatrix, c.Point = function(a, b) { a = a || 0, b = b || 0, this.x = a, this.y = b, this.type = c.POINT }, c.Point.prototype = {
            copyFrom: function(a) { return this.setTo(a.x, a.y) },
            invert: function() { return this.setTo(this.y, this.x) },
            setTo: function(a, b) { return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this },
            set: function(a, b) { return this.x = a || 0, this.y = b || (0 !== b ? this.x : 0), this },
            add: function(a, b) { return this.x += a, this.y += b, this },
            subtract: function(a, b) { return this.x -= a, this.y -= b, this },
            multiply: function(a, b) { return this.x *= a, this.y *= b, this },
            divide: function(a, b) { return this.x /= a, this.y /= b, this },
            clampX: function(a, b) { return this.x = c.Math.clamp(this.x, a, b), this },
            clampY: function(a, b) { return this.y = c.Math.clamp(this.y, a, b), this },
            clamp: function(a, b) { return this.x = c.Math.clamp(this.x, a, b), this.y = c.Math.clamp(this.y, a, b), this },
            clone: function(a) { return void 0 === a || null === a ? a = new c.Point(this.x, this.y) : a.setTo(this.x, this.y), a },
            copyTo: function(a) { return a.x = this.x, a.y = this.y, a },
            distance: function(a, b) { return c.Point.distance(this, a, b) },
            equals: function(a) { return a.x === this.x && a.y === this.y },
            angle: function(a, b) { return void 0 === b && (b = !1), b ? c.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x) },
            rotate: function(a, b, d, e, f) { return c.Point.rotate(this, a, b, d, e, f) },
            getMagnitude: function() { return Math.sqrt(this.x * this.x + this.y * this.y) },
            getMagnitudeSq: function() { return this.x * this.x + this.y * this.y },
            setMagnitude: function(a) { return this.normalize().multiply(a, a) },
            normalize: function() {
                if (!this.isZero()) {
                    var a = this.getMagnitude();
                    this.x /= a, this.y /= a
                }
                return this
            },
            isZero: function() { return 0 === this.x && 0 === this.y },
            dot: function(a) { return this.x * a.x + this.y * a.y },
            cross: function(a) { return this.x * a.y - this.y * a.x },
            perp: function() { return this.setTo(-this.y, this.x) },
            rperp: function() { return this.setTo(this.y, -this.x) },
            normalRightHand: function() { return this.setTo(this.y * -1, this.x) },
            floor: function() { return this.setTo(Math.floor(this.x), Math.floor(this.y)) },
            ceil: function() { return this.setTo(Math.ceil(this.x), Math.ceil(this.y)) },
            toString: function() { return "[{Point (x=" + this.x + " y=" + this.y + ")}]" }
        }, c.Point.prototype.constructor = c.Point, c.Point.add = function(a, b, d) { return void 0 === d && (d = new c.Point), d.x = a.x + b.x, d.y = a.y + b.y, d }, c.Point.subtract = function(a, b, d) { return void 0 === d && (d = new c.Point), d.x = a.x - b.x, d.y = a.y - b.y, d }, c.Point.multiply = function(a, b, d) { return void 0 === d && (d = new c.Point), d.x = a.x * b.x, d.y = a.y * b.y, d }, c.Point.divide = function(a, b, d) { return void 0 === d && (d = new c.Point), d.x = a.x / b.x, d.y = a.y / b.y, d }, c.Point.equals = function(a, b) { return a.x === b.x && a.y === b.y }, c.Point.angle = function(a, b) { return Math.atan2(a.y - b.y, a.x - b.x) }, c.Point.negative = function(a, b) { return void 0 === b && (b = new c.Point), b.setTo(-a.x, -a.y) }, c.Point.multiplyAdd = function(a, b, d, e) { return void 0 === e && (e = new c.Point), e.setTo(a.x + b.x * d, a.y + b.y * d) }, c.Point.interpolate = function(a, b, d, e) { return void 0 === e && (e = new c.Point), e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d) }, c.Point.perp = function(a, b) { return void 0 === b && (b = new c.Point), b.setTo(-a.y, a.x) }, c.Point.rperp = function(a, b) { return void 0 === b && (b = new c.Point), b.setTo(a.y, -a.x) }, c.Point.distance = function(a, b, d) { var e = c.Math.distance(a.x, a.y, b.x, b.y); return d ? Math.round(e) : e }, c.Point.project = function(a, b, d) { void 0 === d && (d = new c.Point); var e = a.dot(b) / b.getMagnitudeSq(); return 0 !== e && d.setTo(e * b.x, e * b.y), d }, c.Point.projectUnit = function(a, b, d) { void 0 === d && (d = new c.Point); var e = a.dot(b); return 0 !== e && d.setTo(e * b.x, e * b.y), d }, c.Point.normalRightHand = function(a, b) { return void 0 === b && (b = new c.Point), b.setTo(a.y * -1, a.x) }, c.Point.normalize = function(a, b) { void 0 === b && (b = new c.Point); var d = a.getMagnitude(); return 0 !== d && b.setTo(a.x / d, a.y / d), b }, c.Point.rotate = function(a, b, d, e, f, g) {
            if (f && (e = c.Math.degToRad(e)), void 0 === g) {
                a.subtract(b, d);
                var h = Math.sin(e),
                    i = Math.cos(e),
                    j = i * a.x - h * a.y,
                    k = h * a.x + i * a.y;
                a.x = j + b, a.y = k + d
            }
            else {
                var l = e + Math.atan2(a.y - d, a.x - b);
                a.x = b + g * Math.cos(l), a.y = d + g * Math.sin(l)
            }
            return a
        }, c.Point.centroid = function(a, b) { if (void 0 === b && (b = new c.Point), "[object Array]" !== Object.prototype.toString.call(a)) throw new Error("Phaser.Point. Parameter 'points' must be an array"); var d = a.length; if (d < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty"); if (1 === d) return b.copyFrom(a[0]), b; for (var e = 0; e < d; e++) c.Point.add(b, a[e], b); return b.divide(d, d), b }, c.Point.parse = function(a, b, d) { b = b || "x", d = d || "y"; var e = new c.Point; return a[b] && (e.x = parseInt(a[b], 10)), a[d] && (e.y = parseInt(a[d], 10)), e }, PIXI.Point = c.Point, c.Polygon = function() { this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = c.POLYGON }, c.Polygon.prototype = {
            toNumberArray: function(a) { void 0 === a && (a = []); for (var b = 0; b < this._points.length; b++) "number" == typeof this._points[b] ? (a.push(this._points[b]), a.push(this._points[b + 1]), b++) : (a.push(this._points[b].x), a.push(this._points[b].y)); return a },
            flatten: function() { return this._points = this.toNumberArray(), this.flattened = !0, this },
            clone: function(a) { var b = this._points.slice(); return void 0 === a || null === a ? a = new c.Polygon(b) : a.setTo(b), a },
            contains: function(a, b) {
                var c = !1;
                if (this.flattened)
                    for (var d = -2, e = this._points.length - 2;
                        (d += 2) < this._points.length; e = d) {
                        var f = this._points[d],
                            g = this._points[d + 1],
                            h = this._points[e],
                            i = this._points[e + 1];
                        (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                    }
                else
                    for (var d = -1, e = this._points.length - 1; ++d < this._points.length; e = d) {
                        var f = this._points[d].x,
                            g = this._points[d].y,
                            h = this._points[e].x,
                            i = this._points[e].y;
                        (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                    }
                return c
            },
            setTo: function(a) {
                if (this.area = 0, this._points = [], arguments.length > 0) {
                    Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
                    for (var b = Number.MAX_VALUE, c = 0, d = a.length; c < d; c++) {
                        if ("number" == typeof a[c]) {
                            var e = new PIXI.Point(a[c], a[c + 1]);
                            c++
                        }
                        else if (Array.isArray(a[c])) var e = new PIXI.Point(a[c][0], a[c][1]);
                        else var e = new PIXI.Point(a[c].x, a[c].y);
                        this._points.push(e), e.y < b && (b = e.y)
                    }
                    this.calculateArea(b)
                }
                return this
            },
            calculateArea: function(a) { for (var b, c, d, e, f = 0, g = this._points.length; f < g; f++) b = this._points[f], c = f === g - 1 ? this._points[0] : this._points[f + 1], d = (b.y - a + (c.y - a)) / 2, e = b.x - c.x, this.area += d * e; return this.area }
        }, c.Polygon.prototype.constructor = c.Polygon, Object.defineProperty(c.Polygon.prototype, "points", { get: function() { return this._points }, set: function(a) { null != a ? this.setTo(a) : this.setTo() } }), PIXI.Polygon = c.Polygon, c.Rectangle = function(a, b, d, e) { a = a || 0, b = b || 0, d = d || 0, e = e || 0, this.x = a, this.y = b, this.width = d, this.height = e, this.type = c.RECTANGLE }, c.Rectangle.prototype = {
            offset: function(a, b) { return this.x += a, this.y += b, this },
            offsetPoint: function(a) { return this.offset(a.x, a.y) },
            setTo: function(a, b, c, d) { return this.x = a, this.y = b, this.width = c, this.height = d, this },
            scale: function(a, b) { return void 0 === b && (b = a), this.width *= a, this.height *= b, this },
            centerOn: function(a, b) { return this.centerX = a, this.centerY = b, this },
            floor: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y) },
            floorAll: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height) },
            ceil: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y) },
            ceilAll: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height) },
            copyFrom: function(a) { return this.setTo(a.x, a.y, a.width, a.height) },
            copyTo: function(a) { return a.x = this.x, a.y = this.y, a.width = this.width, a.height = this.height, a },
            inflate: function(a, b) { return c.Rectangle.inflate(this, a, b) },
            size: function(a) { return c.Rectangle.size(this, a) },
            resize: function(a, b) { return this.width = a, this.height = b, this },
            clone: function(a) { return c.Rectangle.clone(this, a) },
            contains: function(a, b) { return c.Rectangle.contains(this, a, b) },
            containsRect: function(a) { return c.Rectangle.containsRect(a, this) },
            equals: function(a) { return c.Rectangle.equals(this, a) },
            intersection: function(a, b) { return c.Rectangle.intersection(this, a, b) },
            intersects: function(a) { return c.Rectangle.intersects(this, a) },
            intersectsRaw: function(a, b, d, e, f) { return c.Rectangle.intersectsRaw(this, a, b, d, e, f) },
            union: function(a, b) { return c.Rectangle.union(this, a, b) },
            random: function(a) { return void 0 === a && (a = new c.Point), a.x = this.randomX, a.y = this.randomY, a },
            getPoint: function(a, b) {
                switch (void 0 === b && (b = new c.Point), a) {
                    default:
                        case c.TOP_LEFT:
                        return b.set(this.x, this.y);
                    case c.TOP_CENTER:
                            return b.set(this.centerX, this.y);
                    case c.TOP_RIGHT:
                            return b.set(this.right, this.y);
                    case c.LEFT_CENTER:
                            return b.set(this.x, this.centerY);
                    case c.CENTER:
                            return b.set(this.centerX, this.centerY);
                    case c.RIGHT_CENTER:
                            return b.set(this.right, this.centerY);
                    case c.BOTTOM_LEFT:
                            return b.set(this.x, this.bottom);
                    case c.BOTTOM_CENTER:
                            return b.set(this.centerX, this.bottom);
                    case c.BOTTOM_RIGHT:
                            return b.set(this.right, this.bottom)
                }
            },
            toString: function() { return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]" }
        }, Object.defineProperty(c.Rectangle.prototype, "halfWidth", { get: function() { return Math.round(this.width / 2) } }), Object.defineProperty(c.Rectangle.prototype, "halfHeight", { get: function() { return Math.round(this.height / 2) } }), Object.defineProperty(c.Rectangle.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(a) { a <= this.y ? this.height = 0 : this.height = a - this.y } }), Object.defineProperty(c.Rectangle.prototype, "bottomLeft", { get: function() { return new c.Point(this.x, this.bottom) }, set: function(a) { this.x = a.x, this.bottom = a.y } }), Object.defineProperty(c.Rectangle.prototype, "bottomRight", { get: function() { return new c.Point(this.right, this.bottom) }, set: function(a) { this.right = a.x, this.bottom = a.y } }), Object.defineProperty(c.Rectangle.prototype, "left", { get: function() { return this.x }, set: function(a) { a >= this.right ? this.width = 0 : this.width = this.right - a, this.x = a } }), Object.defineProperty(c.Rectangle.prototype, "right", { get: function() { return this.x + this.width }, set: function(a) { a <= this.x ? this.width = 0 : this.width = a - this.x } }), Object.defineProperty(c.Rectangle.prototype, "volume", { get: function() { return this.width * this.height } }), Object.defineProperty(c.Rectangle.prototype, "perimeter", { get: function() { return 2 * this.width + 2 * this.height } }), Object.defineProperty(c.Rectangle.prototype, "centerX", { get: function() { return this.x + this.halfWidth }, set: function(a) { this.x = a - this.halfWidth } }), Object.defineProperty(c.Rectangle.prototype, "centerY", { get: function() { return this.y + this.halfHeight }, set: function(a) { this.y = a - this.halfHeight } }), Object.defineProperty(c.Rectangle.prototype, "randomX", { get: function() { return this.x + Math.random() * this.width } }), Object.defineProperty(c.Rectangle.prototype, "randomY", { get: function() { return this.y + Math.random() * this.height } }), Object.defineProperty(c.Rectangle.prototype, "top", { get: function() { return this.y }, set: function(a) { a >= this.bottom ? (this.height = 0, this.y = a) : this.height = this.bottom - a } }), Object.defineProperty(c.Rectangle.prototype, "topLeft", { get: function() { return new c.Point(this.x, this.y) }, set: function(a) { this.x = a.x, this.y = a.y } }), Object.defineProperty(c.Rectangle.prototype, "topRight", { get: function() { return new c.Point(this.x + this.width, this.y) }, set: function(a) { this.right = a.x, this.y = a.y } }), Object.defineProperty(c.Rectangle.prototype, "empty", { get: function() { return !this.width || !this.height }, set: function(a) { a === !0 && this.setTo(0, 0, 0, 0) } }), c.Rectangle.prototype.constructor = c.Rectangle, c.Rectangle.inflate = function(a, b, c) { return a.x -= b, a.width += 2 * b, a.y -= c, a.height += 2 * c, a }, c.Rectangle.inflatePoint = function(a, b) { return c.Rectangle.inflate(a, b.x, b.y) }, c.Rectangle.size = function(a, b) { return void 0 === b || null === b ? b = new c.Point(a.width, a.height) : b.setTo(a.width, a.height), b }, c.Rectangle.clone = function(a, b) { return void 0 === b || null === b ? b = new c.Rectangle(a.x, a.y, a.width, a.height) : b.setTo(a.x, a.y, a.width, a.height), b }, c.Rectangle.contains = function(a, b, c) { return !(a.width <= 0 || a.height <= 0) && (b >= a.x && b < a.right && c >= a.y && c < a.bottom) }, c.Rectangle.containsRaw = function(a, b, c, d, e, f) { return e >= a && e < a + c && f >= b && f < b + d }, c.Rectangle.containsPoint = function(a, b) { return c.Rectangle.contains(a, b.x, b.y) }, c.Rectangle.containsRect = function(a, b) { return !(a.volume > b.volume) && (a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom) }, c.Rectangle.equals = function(a, b) { return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height }, c.Rectangle.sameDimensions = function(a, b) { return a.width === b.width && a.height === b.height }, c.Rectangle.intersection = function(a, b, d) { return void 0 === d && (d = new c.Rectangle), c.Rectangle.intersects(a, b) && (d.x = Math.max(a.x, b.x), d.y = Math.max(a.y, b.y), d.width = Math.min(a.right, b.right) - d.x, d.height = Math.min(a.bottom, b.bottom) - d.y), d }, c.Rectangle.intersects = function(a, b) { return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) && !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom) }, c.Rectangle.intersectsRaw = function(a, b, c, d, e, f) { return void 0 === f && (f = 0), !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f) }, c.Rectangle.union = function(a, b, d) { return void 0 === d && (d = new c.Rectangle), d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top)) }, c.Rectangle.aabb = function(a, b) {
            void 0 === b && (b = new c.Rectangle);
            var d = Number.NEGATIVE_INFINITY,
                e = Number.POSITIVE_INFINITY,
                f = Number.NEGATIVE_INFINITY,
                g = Number.POSITIVE_INFINITY;
            return a.forEach(function(a) { a.x > d && (d = a.x), a.x < e && (e = a.x), a.y > f && (f = a.y), a.y < g && (g = a.y) }), b.setTo(e, g, d - e, f - g), b
        }, PIXI.Rectangle = c.Rectangle, PIXI.EmptyRectangle = new c.Rectangle(0, 0, 0, 0), c.RoundedRectangle = function(a, b, d, e, f) { void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = 20), this.x = a, this.y = b, this.width = d, this.height = e, this.radius = f || 20, this.type = c.ROUNDEDRECTANGLE }, c.RoundedRectangle.prototype = { clone: function() { return new c.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius) }, contains: function(a, b) { if (this.width <= 0 || this.height <= 0) return !1; var c = this.x; if (a >= c && a <= c + this.width) { var d = this.y; if (b >= d && b <= d + this.height) return !0 } return !1 } }, c.RoundedRectangle.prototype.constructor = c.RoundedRectangle, PIXI.RoundedRectangle = c.RoundedRectangle, c.Camera = function(a, b, d, e, f, g) { this.game = a, this.world = a.world, this.id = 0, this.view = new c.Rectangle(d, e, f, g), this.bounds = new c.Rectangle(d, e, f, g), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = { x: !1, y: !1 }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new c.Point(1, 1), this.onShakeComplete = new c.Signal, this.onFlashComplete = new c.Signal, this.onFadeComplete = new c.Signal, this.fx = null, this._targetPosition = new c.Point, this._edge = 0, this._position = new c.Point, this._shake = { intensity: 0, duration: 0, horizontal: !1, vertical: !1, shakeBounds: !0, x: 0, y: 0 }, this._fxDuration = 0, this._fxType = 0 }, c.Camera.FOLLOW_LOCKON = 0, c.Camera.FOLLOW_PLATFORMER = 1, c.Camera.FOLLOW_TOPDOWN = 2, c.Camera.FOLLOW_TOPDOWN_TIGHT = 3, c.Camera.SHAKE_BOTH = 4, c.Camera.SHAKE_HORIZONTAL = 5, c.Camera.SHAKE_VERTICAL = 6, c.Camera.ENABLE_FX = !0, c.Camera.prototype = {
            boot: function() { this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, c.Graphics && c.Camera.ENABLE_FX && (this.fx = new c.Graphics(this.game), this.game.stage.addChild(this.fx)) },
            preUpdate: function() { this.totalInView = 0 },
            follow: function(a, b, d, e) {
                void 0 === b && (b = c.Camera.FOLLOW_LOCKON), void 0 === d && (d = 1), void 0 === e && (e = 1), this.target = a, this.lerp.set(d, e);
                var f;
                switch (b) {
                    case c.Camera.FOLLOW_PLATFORMER:
                        var g = this.width / 8,
                            h = this.height / 3;
                        this.deadzone = new c.Rectangle((this.width - g) / 2, (this.height - h) / 2 - .25 * h, g, h);
                        break;
                    case c.Camera.FOLLOW_TOPDOWN:
                        f = Math.max(this.width, this.height) / 4, this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                        break;
                    case c.Camera.FOLLOW_TOPDOWN_TIGHT:
                        f = Math.max(this.width, this.height) / 8, this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
                        break;
                    case c.Camera.FOLLOW_LOCKON:
                        this.deadzone = null;
                        break;
                    default:
                        this.deadzone = null
                }
            },
            unfollow: function() { this.target = null },
            focusOn: function(a) { this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight)) },
            focusOnXY: function(a, b) { this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight)) },
            shake: function(a, b, d, e, f) { return void 0 === a && (a = .05), void 0 === b && (b = 500), void 0 === d && (d = !0), void 0 === e && (e = c.Camera.SHAKE_BOTH), void 0 === f && (f = !0), !(!d && this._shake.duration > 0) && (this._shake.intensity = a, this._shake.duration = b, this._shake.shakeBounds = f, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_HORIZONTAL, this._shake.vertical = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_VERTICAL, !0) },
            flash: function(a, b, c) { return void 0 === a && (a = 16777215), void 0 === b && (b = 500), void 0 === c && (c = !1), !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = b, this._fxType = 0, !0) },
            fade: function(a, b, c) { return void 0 === a && (a = 0), void 0 === b && (b = 500), void 0 === c && (c = !1), !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = b, this._fxType = 1, !0) },
            update: function() { this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y },
            updateFX: function() { 0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch())) },
            updateShake: function() { this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height)) },
            updateTarget: function() { this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y },
            setBoundsToWorld: function() { this.bounds && this.bounds.copyFrom(this.game.world.bounds) },
            checkBounds: function() {
                this.atLimit.x = !1, this.atLimit.y = !1;
                var a = this.view.x + this._shake.x,
                    b = this.view.right + this._shake.x,
                    c = this.view.y + this._shake.y,
                    d = this.view.bottom + this._shake.y;
                a <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), b >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), c <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), d >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
            },
            setPosition: function(a, b) { this.view.x = a, this.view.y = b, this.bounds && this.checkBounds() },
            setSize: function(a, b) { this.view.width = a, this.view.height = b },
            reset: function() { this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX() },
            resetFX: function() { this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0 }
        }, c.Camera.prototype.constructor = c.Camera, Object.defineProperty(c.Camera.prototype, "x", { get: function() { return this.view.x }, set: function(a) { this.view.x = a, this.bounds && this.checkBounds() } }), Object.defineProperty(c.Camera.prototype, "y", { get: function() { return this.view.y }, set: function(a) { this.view.y = a, this.bounds && this.checkBounds() } }), Object.defineProperty(c.Camera.prototype, "position", { get: function() { return this._position.set(this.view.x, this.view.y), this._position }, set: function(a) { "undefined" != typeof a.x && (this.view.x = a.x), "undefined" != typeof a.y && (this.view.y = a.y), this.bounds && this.checkBounds() } }), Object.defineProperty(c.Camera.prototype, "width", { get: function() { return this.view.width }, set: function(a) { this.view.width = a } }), Object.defineProperty(c.Camera.prototype, "height", { get: function() { return this.view.height }, set: function(a) { this.view.height = a } }), Object.defineProperty(c.Camera.prototype, "shakeIntensity", { get: function() { return this._shake.intensity }, set: function(a) { this._shake.intensity = a } }), c.State = function() { this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null }, c.State.prototype = { init: function() {}, preload: function() {}, loadUpdate: function() {}, loadRender: function() {}, create: function() {}, update: function() {}, preRender: function() {}, render: function() {}, resize: function() {}, paused: function() {}, resumed: function() {}, pauseUpdate: function() {}, shutdown: function() {} }, c.State.prototype.constructor = c.State, c.StateManager = function(a, b) { this.game = a, this.states = {}, this._pendingState = null, "undefined" != typeof b && null !== b && (this._pendingState = b), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new c.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null }, c.StateManager.prototype = {
            boot: function() { this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0) },
            add: function(a, b, d) { void 0 === d && (d = !1); var e; return b instanceof c.State ? e = b : "object" == typeof b ? (e = b, e.game = this.game) : "function" == typeof b && (e = new b(this.game)), this.states[a] = e, d && (this.game.isBooted ? this.start(a) : this._pendingState = a), e },
            remove: function(a) { this.current === a && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[a] },
            start: function(a, b, c) { void 0 === b && (b = !0), void 0 === c && (c = !1), this.checkState(a) && (this._pendingState = a, this._clearWorld = b, this._clearCache = c, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3))) },
            restart: function(a, b) {
                void 0 === a && (a = !0), void 0 === b && (b = !1), this._pendingState = this.current, this._clearWorld = a, this._clearCache = b, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2));
            },
            dummy: function() {},
            preUpdate: function() {
                if (this._pendingState && this.game.isBooted) {
                    var a = this.current;
                    if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, a), this.current !== this._pendingState) return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            },
            clearCurrentState: function() { this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy())) },
            checkState: function(a) { return !!this.states[a] && !!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) },
            link: function(a) { this.states[a].game = this.game, this.states[a].add = this.game.add, this.states[a].make = this.game.make, this.states[a].camera = this.game.camera, this.states[a].cache = this.game.cache, this.states[a].input = this.game.input, this.states[a].load = this.game.load, this.states[a].math = this.game.math, this.states[a].sound = this.game.sound, this.states[a].scale = this.game.scale, this.states[a].state = this, this.states[a].stage = this.game.stage, this.states[a].time = this.game.time, this.states[a].tweens = this.game.tweens, this.states[a].world = this.game.world, this.states[a].particles = this.game.particles, this.states[a].rnd = this.game.rnd, this.states[a].physics = this.game.physics, this.states[a].key = a },
            unlink: function(a) { this.states[a] && (this.states[a].game = null, this.states[a].add = null, this.states[a].make = null, this.states[a].camera = null, this.states[a].cache = null, this.states[a].input = null, this.states[a].load = null, this.states[a].math = null, this.states[a].sound = null, this.states[a].scale = null, this.states[a].state = null, this.states[a].stage = null, this.states[a].time = null, this.states[a].tweens = null, this.states[a].world = null, this.states[a].particles = null, this.states[a].rnd = null, this.states[a].physics = null) },
            setCurrentState: function(a) { this.callbackContext = this.states[a], this.link(a), this.onInitCallback = this.states[a].init || this.dummy, this.onPreloadCallback = this.states[a].preload || null, this.onLoadRenderCallback = this.states[a].loadRender || null, this.onLoadUpdateCallback = this.states[a].loadUpdate || null, this.onCreateCallback = this.states[a].create || null, this.onUpdateCallback = this.states[a].update || null, this.onPreRenderCallback = this.states[a].preRender || null, this.onRenderCallback = this.states[a].render || null, this.onResizeCallback = this.states[a].resize || null, this.onPausedCallback = this.states[a].paused || null, this.onResumedCallback = this.states[a].resumed || null, this.onPauseUpdateCallback = this.states[a].pauseUpdate || null, this.onShutDownCallback = this.states[a].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = a, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), a === this._pendingState && (this._args = []), this.game._kickstart = !0 },
            getCurrentState: function() { return this.states[this.current] },
            loadComplete: function() { this._created === !1 && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0 },
            pause: function() { this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game) },
            resume: function() { this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game) },
            update: function() { this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) },
            pauseUpdate: function() { this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) },
            preRender: function(a) { this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a) },
            resize: function(a, b) { this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b) },
            render: function() { this._created ? this.onRenderCallback && (this.game.renderType === c.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game) },
            destroy: function() { this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = "" }
        }, c.StateManager.prototype.constructor = c.StateManager, Object.defineProperty(c.StateManager.prototype, "created", { get: function() { return this._created } }), c.Signal = function() {}, c.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(a, b) { if ("function" != typeof a) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b)) },
            _registerListener: function(a, b, d, e, f) { var g, h = this._indexOfListener(a, d); if (h !== -1) { if (g = this._bindings[h], g.isOnce() !== b) throw new Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.") } else g = new c.SignalBinding(this, a, b, d, e, f), this._addBinding(g); return this.memorize && this._prevParams && g.execute(this._prevParams), g },
            _addBinding: function(a) {
                this._bindings || (this._bindings = []);
                var b = this._bindings.length;
                do b--; while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
                this._bindings.splice(b + 1, 0, a)
            },
            _indexOfListener: function(a, b) {
                if (!this._bindings) return -1;
                void 0 === b && (b = null);
                for (var c, d = this._bindings.length; d--;)
                    if (c = this._bindings[d], c._listener === a && c.context === b) return d;
                return -1
            },
            has: function(a, b) { return this._indexOfListener(a, b) !== -1 },
            add: function(a, b, c) {
                this.validateListener(a, "add");
                var d = [];
                if (arguments.length > 3)
                    for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
                return this._registerListener(a, !1, b, c, d)
            },
            addOnce: function(a, b, c) {
                this.validateListener(a, "addOnce");
                var d = [];
                if (arguments.length > 3)
                    for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
                return this._registerListener(a, !0, b, c, d)
            },
            remove: function(a, b) { this.validateListener(a, "remove"); var c = this._indexOfListener(a, b); return c !== -1 && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)), a },
            removeAll: function(a) {
                if (void 0 === a && (a = null), this._bindings) {
                    for (var b = this._bindings.length; b--;) a ? this._bindings[b].context === a && (this._bindings[b]._destroy(), this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
                    a || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() { return this._bindings ? this._bindings.length : 0 },
            halt: function() { this._shouldPropagate = !1 },
            dispatch: function() {
                if (this.active && this._bindings) {
                    var a, b = Array.prototype.slice.call(arguments),
                        c = this._bindings.length;
                    if (this.memorize && (this._prevParams = b), c) {
                        a = this._bindings.slice(), this._shouldPropagate = !0;
                        do c--; while (a[c] && this._shouldPropagate && a[c].execute(b) !== !1)
                    }
                }
            },
            forget: function() { this._prevParams && (this._prevParams = null) },
            dispose: function() { this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null) },
            toString: function() { return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]" }
        }, Object.defineProperty(c.Signal.prototype, "boundDispatch", { get: function() { var a = this; return this._boundDispatch || (this._boundDispatch = function() { return a.dispatch.apply(a, arguments) }) } }), c.Signal.prototype.constructor = c.Signal, c.SignalBinding = function(a, b, c, d, e, f) { this._listener = b, c && (this._isOnce = !0), null != d && (this.context = d), this._signal = a, e && (this._priority = e), f && f.length && (this._args = f) }, c.SignalBinding.prototype = { context: null, _isOnce: !1, _priority: 0, _args: null, callCount: 0, active: !0, params: null, execute: function(a) { var b, c; return this.active && this._listener && (c = this.params ? this.params.concat(a) : a, this._args && (c = c.concat(this._args)), b = this._listener.apply(this.context, c), this.callCount++, this._isOnce && this.detach()), b }, detach: function() { return this.isBound() ? this._signal.remove(this._listener, this.context) : null }, isBound: function() { return !!this._signal && !!this._listener }, isOnce: function() { return this._isOnce }, getListener: function() { return this._listener }, getSignal: function() { return this._signal }, _destroy: function() { delete this._signal, delete this._listener, delete this.context }, toString: function() { return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]" } }, c.SignalBinding.prototype.constructor = c.SignalBinding, c.Filter = function(a, b, d) {
            this.game = a, this.type = c.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new c.Point;
            var e = new Date;
            if (this.uniforms = { resolution: { type: "2f", value: { x: 256, y: 256 } }, time: { type: "1f", value: 0 }, mouse: { type: "2f", value: { x: 0, y: 0 } }, date: { type: "4fv", value: [e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()] }, sampleRate: { type: "1f", value: 44100 }, iChannel0: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel1: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel2: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel3: { type: "sampler2D", value: null, textureData: { repeat: !0 } } }, b)
                for (var f in b) this.uniforms[f] = b[f];
            this.fragmentSrc = d || ""
        }, c.Filter.prototype = {
            init: function() {},
            setResolution: function(a, b) { this.uniforms.resolution.value.x = a, this.uniforms.resolution.value.y = b },
            update: function(a) {
                if ("undefined" != typeof a) {
                    var b = a.x / this.game.width,
                        c = 1 - a.y / this.game.height;
                    b === this.prevPoint.x && c === this.prevPoint.y || (this.uniforms.mouse.value.x = b.toFixed(2), this.uniforms.mouse.value.y = c.toFixed(2), this.prevPoint.set(b, c))
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds()
            },
            addToWorld: function(a, b, c, d, e, f) { void 0 === e && (e = 0), void 0 === f && (f = 0), void 0 !== c && null !== c ? this.width = c : c = this.width, void 0 !== d && null !== d ? this.height = d : d = this.height; var g = this.game.add.image(a, b, "__default"); return g.width = c, g.height = d, g.anchor.set(e, f), g.filters = [this], g },
            destroy: function() { this.game = null }
        }, c.Filter.prototype.constructor = c.Filter, Object.defineProperty(c.Filter.prototype, "width", { get: function() { return this.uniforms.resolution.value.x }, set: function(a) { this.uniforms.resolution.value.x = a } }), Object.defineProperty(c.Filter.prototype, "height", { get: function() { return this.uniforms.resolution.value.y }, set: function(a) { this.uniforms.resolution.value.y = a } }), c.Plugin = function(a, b) { void 0 === b && (b = null), this.game = a, this.parent = b, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1 }, c.Plugin.prototype = { preUpdate: function() {}, update: function() {}, render: function() {}, postRender: function() {}, destroy: function() { this.game = null, this.parent = null, this.active = !1, this.visible = !1 } }, c.Plugin.prototype.constructor = c.Plugin, c.PluginManager = function(a) { this.game = a, this.plugins = [], this._len = 0, this._i = 0 }, c.PluginManager.prototype = {
            add: function(a) {
                var b = Array.prototype.slice.call(arguments, 1),
                    c = !1;
                return "function" == typeof a ? a = new a(this.game, this) : (a.game = this.game, a.parent = this), "function" == typeof a.preUpdate && (a.hasPreUpdate = !0, c = !0), "function" == typeof a.update && (a.hasUpdate = !0, c = !0), "function" == typeof a.postUpdate && (a.hasPostUpdate = !0, c = !0), "function" == typeof a.render && (a.hasRender = !0, c = !0), "function" == typeof a.postRender && (a.hasPostRender = !0, c = !0), c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0), (a.hasRender || a.hasPostRender) && (a.visible = !0), this._len = this.plugins.push(a), "function" == typeof a.init && a.init.apply(a, b), a) : null
            },
            remove: function(a, b) {
                for (void 0 === b && (b = !0), this._i = this._len; this._i--;)
                    if (this.plugins[this._i] === a) return b && a.destroy(), this.plugins.splice(this._i, 1), void this._len--
            },
            removeAll: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0
            },
            preUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate() },
            update: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update() },
            postUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate() },
            render: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render() },
            postRender: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender() },
            destroy: function() { this.removeAll(), this.game = null }
        }, c.PluginManager.prototype.constructor = c.PluginManager, c.Stage = function(a) { this.game = a, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: "#000000" }, this.game.transparent || (this._bgColor.a = 1), a.config && this.parseConfig(a.config) }, c.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.Stage.prototype.constructor = c.Stage, c.Stage.prototype.parseConfig = function(a) { a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange), a.backgroundColor && this.setBackgroundColor(a.backgroundColor) }, c.Stage.prototype.boot = function() { c.DOM.getOffset(this.game.canvas, this.offset), c.Canvas.setUserSelect(this.game.canvas, "none"), c.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility() }, c.Stage.prototype.preUpdate = function() { this.currentRenderOrderID = 0; for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate() }, c.Stage.prototype.update = function() { for (var a = this.children.length; a--;) this.children[a].update() }, c.Stage.prototype.postUpdate = function() {
            this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
            for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
            this.updateTransform()
        }, c.Stage.prototype.updateTransform = function() { this.worldAlpha = 1; for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform() }, c.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var a = this;
            this._onChange = function(b) { return a.visibilityChange(b) }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() { c.Stage.prototype.visibilityChange.call(a, { type: "pause" }) }), CocoonJS.App.onActivated.addEventListener(function() { c.Stage.prototype.visibilityChange.call(a, { type: "resume" }) }))
        }, c.Stage.prototype.visibilityChange = function(a) { return "pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type ? void("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : "pageshow" !== a.type && "focus" !== a.type || this.game.focusGain(a)) : void(this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a))) }, c.Stage.prototype.setBackgroundColor = function(a) { this.game.transparent || (c.Color.valueToColor(a, this._bgColor), c.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1) }, c.Stage.prototype.destroy = function() { this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null }, Object.defineProperty(c.Stage.prototype, "backgroundColor", { get: function() { return this._bgColor.color }, set: function(a) { this.setBackgroundColor(a) } }), Object.defineProperty(c.Stage.prototype, "smoothed", { get: function() { return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR }, set: function(a) { a ? PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR : PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST } }), c.Group = function(a, b, d, e, f, g) { void 0 === e && (e = !1), void 0 === f && (f = !1), void 0 === g && (g = c.Physics.ARCADE), this.game = a, void 0 === b && (b = a.world), this.name = d || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), e ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : b && (b.addChild(this), this.z = b.children.length), this.type = c.GROUP, this.physicsType = c.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = c.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new c.Signal, this.onChildInputUp = new c.Signal, this.onChildInputOver = new c.Signal, this.onChildInputOut = new c.Signal, this.enableBody = f, this.enableBodyDebug = !1, this.physicsBodyType = g, this.physicsSortDirection = null, this.onDestroy = new c.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new c.Point, this.hash = [], this._sortProperty = "z" }, c.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.Group.prototype.constructor = c.Group, c.Group.RETURN_NONE = 0, c.Group.RETURN_TOTAL = 1, c.Group.RETURN_CHILD = 2, c.Group.RETURN_ALL = 3, c.Group.SORT_ASCENDING = -1, c.Group.SORT_DESCENDING = 1, c.Group.prototype.add = function(a, b, c) { return void 0 === b && (b = !1), a.parent === this ? a : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a), void 0 === c ? (a.z = this.children.length, this.addChild(a)) : (this.addChildAt(a, c), this.updateZ()), this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), !this.inputEnableChildren || a.input && !a.inputEnabled || (a.inputEnabled = !0), !b && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a), a) }, c.Group.prototype.addAt = function(a, b, c) { this.add(a, c, b) }, c.Group.prototype.addToHash = function(a) { if (a.parent === this) { var b = this.hash.indexOf(a); if (b === -1) return this.hash.push(a), !0 } return !1 }, c.Group.prototype.removeFromHash = function(a) { if (a) { var b = this.hash.indexOf(a); if (b !== -1) return this.hash.splice(b, 1), !0 } return !1 }, c.Group.prototype.addMultiple = function(a, b) {
            if (a instanceof c.Group) a.moveAll(this, b);
            else if (Array.isArray(a))
                for (var d = 0; d < a.length; d++) this.add(a[d], b);
            return a
        }, c.Group.prototype.getAt = function(a) { return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a) }, c.Group.prototype.create = function(a, b, c, d, e, f) { void 0 === e && (e = !0); var g = new this.classType(this.game, a, b, c, d); return g.exists = e, g.visible = e, g.alive = e, this.add(g, !1, f) }, c.Group.prototype.createMultiple = function(a, b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = !1), Array.isArray(b) || (b = [b]), Array.isArray(c) || (c = [c]);
            var e = this,
                f = [];
            return b.forEach(function(b) { c.forEach(function(c) { for (var g = 0; g < a; g++) f.push(e.create(0, 0, b, c, d)) }) }), f
        }, c.Group.prototype.updateZ = function() { for (var a = this.children.length; a--;) this.children[a].z = a }, c.Group.prototype.align = function(a, b, d, e, f, g) {
            if (void 0 === f && (f = c.TOP_LEFT), void 0 === g && (g = 0), 0 === this.children.length || g > this.children.length || a === -1 && b === -1) return !1;
            for (var h = new c.Rectangle(0, 0, d, e), i = a * d, j = b * e, k = g; k < this.children.length; k++) {
                var l = this.children[k];
                if (l.alignIn)
                    if (l.alignIn(h, f), a === -1) h.y += e, h.y === j && (h.x += d, h.y = 0);
                    else if (b === -1) h.x += d, h.x === i && (h.x = 0, h.y += e);
                else if (h.x += d, h.x === i && (h.x = 0, h.y += e, h.y === j)) return !0
            }
            return !0
        }, c.Group.prototype.resetCursor = function(a) { if (void 0 === a && (a = 0), a > this.children.length - 1 && (a = 0), this.cursor) return this.cursorIndex = a, this.cursor = this.children[this.cursorIndex], this.cursor }, c.Group.prototype.next = function() { if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor }, c.Group.prototype.previous = function() { if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor }, c.Group.prototype.swap = function(a, b) { this.swapChildren(a, b), this.updateZ() }, c.Group.prototype.bringToTop = function(a) { return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0), this.add(a, !0)), a }, c.Group.prototype.sendToBack = function(a) { return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0), this.addAt(a, 0, !0)), a }, c.Group.prototype.moveUp = function(a) {
            if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
                var b = this.getIndex(a),
                    c = this.getAt(b + 1);
                c && this.swap(a, c)
            }
            return a
        }, c.Group.prototype.moveDown = function(a) {
            if (a.parent === this && this.getIndex(a) > 0) {
                var b = this.getIndex(a),
                    c = this.getAt(b - 1);
                c && this.swap(a, c)
            }
            return a
        }, c.Group.prototype.xy = function(a, b, c) { return a < 0 || a > this.children.length ? -1 : (this.getChildAt(a).x = b, void(this.getChildAt(a).y = c)) }, c.Group.prototype.reverse = function() { this.children.reverse(), this.updateZ() }, c.Group.prototype.getIndex = function(a) { return this.children.indexOf(a) }, c.Group.prototype.getByName = function(a) {
            for (var b = 0; b < this.children.length; b++)
                if (this.children[b].name === a) return this.children[b];
            return null
        }, c.Group.prototype.replace = function(a, b) { var d = this.getIndex(a); if (d !== -1) return b.parent && (b.parent instanceof c.Group ? b.parent.remove(b) : b.parent.removeChild(b)), this.remove(a), this.addAt(b, d), a }, c.Group.prototype.hasProperty = function(a, b) { var c = b.length; return 1 === c && b[0] in a || (2 === c && b[0] in a && b[1] in a[b[0]] || (3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] || 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]])) }, c.Group.prototype.setProperty = function(a, b, c, d, e) { if (void 0 === e && (e = !1), d = d || 0, !this.hasProperty(a, b) && (!e || d > 0)) return !1; var f = b.length; return 1 === f ? 0 === d ? a[b[0]] = c : 1 === d ? a[b[0]] += c : 2 === d ? a[b[0]] -= c : 3 === d ? a[b[0]] *= c : 4 === d && (a[b[0]] /= c) : 2 === f ? 0 === d ? a[b[0]][b[1]] = c : 1 === d ? a[b[0]][b[1]] += c : 2 === d ? a[b[0]][b[1]] -= c : 3 === d ? a[b[0]][b[1]] *= c : 4 === d && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === d ? a[b[0]][b[1]][b[2]] = c : 1 === d ? a[b[0]][b[1]][b[2]] += c : 2 === d ? a[b[0]][b[1]][b[2]] -= c : 3 === d ? a[b[0]][b[1]][b[2]] *= c : 4 === d && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === d ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 === d ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 === d ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 === d ? a[b[0]][b[1]][b[2]][b[3]] *= c : 4 === d && (a[b[0]][b[1]][b[2]][b[3]] /= c)), !0 }, c.Group.prototype.checkProperty = function(a, b, d, e) { return void 0 === e && (e = !1), !(!c.Utils.getProperty(a, b) && e) && c.Utils.getProperty(a, b) === d }, c.Group.prototype.set = function(a, b, c, d, e, f, g) { if (void 0 === g && (g = !1), b = b.split("."), void 0 === d && (d = !1), void 0 === e && (e = !1), (d === !1 || d && a.alive) && (e === !1 || e && a.visible)) return this.setProperty(a, b, c, f, g) }, c.Group.prototype.setAll = function(a, b, c, d, e, f) { void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === f && (f = !1), a = a.split("."), e = e || 0; for (var g = 0; g < this.children.length; g++)(!c || c && this.children[g].alive) && (!d || d && this.children[g].visible) && this.setProperty(this.children[g], a, b, e, f) }, c.Group.prototype.setAllChildren = function(a, b, d, e, f, g) { void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === g && (g = !1), f = f || 0; for (var h = 0; h < this.children.length; h++)(!d || d && this.children[h].alive) && (!e || e && this.children[h].visible) && (this.children[h] instanceof c.Group ? this.children[h].setAllChildren(a, b, d, e, f, g) : this.setProperty(this.children[h], a.split("."), b, f, g)) }, c.Group.prototype.checkAll = function(a, b, c, d, e) {
            void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === e && (e = !1);
            for (var f = 0; f < this.children.length; f++)
                if ((!c || c && this.children[f].alive) && (!d || d && this.children[f].visible) && !this.checkProperty(this.children[f], a, b, e)) return !1;
            return !0
        }, c.Group.prototype.addAll = function(a, b, c, d) { this.setAll(a, b, c, d, 1) }, c.Group.prototype.subAll = function(a, b, c, d) { this.setAll(a, b, c, d, 2) }, c.Group.prototype.multiplyAll = function(a, b, c, d) { this.setAll(a, b, c, d, 3) }, c.Group.prototype.divideAll = function(a, b, c, d) { this.setAll(a, b, c, d, 4) }, c.Group.prototype.callAllExists = function(a, b) { var c; if (arguments.length > 2) { c = []; for (var d = 2; d < arguments.length; d++) c.push(arguments[d]) } for (var d = 0; d < this.children.length; d++) this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c) }, c.Group.prototype.callbackFromArray = function(a, b, c) { if (1 === c) { if (a[b[0]]) return a[b[0]] } else if (2 === c) { if (a[b[0]][b[1]]) return a[b[0]][b[1]] } else if (3 === c) { if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]] } else if (4 === c) { if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]] } else if (a[b]) return a[b]; return !1 }, c.Group.prototype.callAll = function(a, b) {
            if (void 0 !== a) {
                a = a.split(".");
                var c = a.length;
                if (void 0 === b || null === b || "" === b) b = null;
                else if ("string" == typeof b) { b = b.split("."); var d = b.length }
                var e;
                if (arguments.length > 2) { e = []; for (var f = 2; f < arguments.length; f++) e.push(arguments[f]) }
                for (var g = null, h = null, f = 0; f < this.children.length; f++) g = this.callbackFromArray(this.children[f], a, c), b && g ? (h = this.callbackFromArray(this.children[f], b, d), g && g.apply(h, e)) : g && g.apply(this.children[f], e)
            }
        }, c.Group.prototype.preUpdate = function() { if (this.pendingDestroy) return this.destroy(), !1; if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1; for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate(); return !0 }, c.Group.prototype.update = function() { for (var a = this.children.length; a--;) this.children[a].update() }, c.Group.prototype.postUpdate = function() { this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y); for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate() }, c.Group.prototype.filter = function(a, b) {
            for (var d = -1, e = this.children.length, f = []; ++d < e;) {
                var g = this.children[d];
                (!b || b && g.exists) && a(g, d, this.children) && f.push(g)
            }
            return new c.ArraySet(f)
        }, c.Group.prototype.forEach = function(a, b, c) {
            if (void 0 === c && (c = !1), arguments.length <= 3)
                for (var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && a.call(b, this.children[d]);
            else { for (var e = [null], d = 3; d < arguments.length; d++) e.push(arguments[d]); for (var d = 0; d < this.children.length; d++)(!c || c && this.children[d].exists) && (e[0] = this.children[d], a.apply(b, e)) }
        }, c.Group.prototype.forEachExists = function(a, b) { var d; if (arguments.length > 2) { d = [null]; for (var e = 2; e < arguments.length; e++) d.push(arguments[e]) } this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d) }, c.Group.prototype.forEachAlive = function(a, b) { var d; if (arguments.length > 2) { d = [null]; for (var e = 2; e < arguments.length; e++) d.push(arguments[e]) } this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d) }, c.Group.prototype.forEachDead = function(a, b) { var d; if (arguments.length > 2) { d = [null]; for (var e = 2; e < arguments.length; e++) d.push(arguments[e]) } this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d) }, c.Group.prototype.sort = function(a, b) { this.children.length < 2 || (void 0 === a && (a = "z"), void 0 === b && (b = c.Group.SORT_ASCENDING), this._sortProperty = a, b === c.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ()) }, c.Group.prototype.customSort = function(a, b) { this.children.length < 2 || (this.children.sort(a.bind(b)), this.updateZ()) }, c.Group.prototype.ascendingSortHandler = function(a, b) { return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1 }, c.Group.prototype.descendingSortHandler = function(a, b) { return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0 }, c.Group.prototype.iterate = function(a, b, d, e, f, g) {
            if (0 === this.children.length) { if (d === c.Group.RETURN_TOTAL) return 0; if (d === c.Group.RETURN_ALL) return [] }
            var h = 0;
            if (d === c.Group.RETURN_ALL) var i = [];
            for (var j = 0; j < this.children.length; j++)
                if (this.children[j][a] === b) {
                    if (h++, e && (g ? (g[0] = this.children[j], e.apply(f, g)) : e.call(f, this.children[j])), d === c.Group.RETURN_CHILD) return this.children[j];
                    d === c.Group.RETURN_ALL && i.push(this.children[j])
                }
            return d === c.Group.RETURN_TOTAL ? h : d === c.Group.RETURN_ALL ? i : null
        }, c.Group.prototype.getFirstExists = function(a, b, d, e, f, g) { void 0 === b && (b = !1), "boolean" != typeof a && (a = !0); var h = this.iterate("exists", a, c.Group.RETURN_CHILD); return null === h && b ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g) }, c.Group.prototype.getFirstAlive = function(a, b, d, e, f) { void 0 === a && (a = !1); var g = this.iterate("alive", !0, c.Group.RETURN_CHILD); return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f) }, c.Group.prototype.getFirstDead = function(a, b, d, e, f) { void 0 === a && (a = !1); var g = this.iterate("alive", !1, c.Group.RETURN_CHILD); return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f) }, c.Group.prototype.resetChild = function(a, b, c, d, e) { return null === a ? null : (void 0 === b && (b = null), void 0 === c && (c = null), null !== b && null !== c && a.reset(b, c), void 0 !== d && a.loadTexture(d, e), a) }, c.Group.prototype.getTop = function() { if (this.children.length > 0) return this.children[this.children.length - 1] }, c.Group.prototype.getBottom = function() { if (this.children.length > 0) return this.children[0] }, c.Group.prototype.getClosestTo = function(a, b, d) {
            for (var e = Number.MAX_VALUE, f = 0, g = null, h = 0; h < this.children.length; h++) {
                var i = this.children[h];
                i.exists && (f = Math.abs(c.Point.distance(a, i)), f < e && (!b || b.call(d, i, f)) && (e = f, g = i))
            }
            return g
        }, c.Group.prototype.getFurthestFrom = function(a, b, d) {
            for (var e = 0, f = 0, g = null, h = 0; h < this.children.length; h++) {
                var i = this.children[h];
                i.exists && (f = Math.abs(c.Point.distance(a, i)), f > e && (!b || b.call(d, i, f)) && (e = f, g = i))
            }
            return g
        }, c.Group.prototype.countLiving = function() { return this.iterate("alive", !0, c.Group.RETURN_TOTAL) }, c.Group.prototype.countDead = function() { return this.iterate("alive", !1, c.Group.RETURN_TOTAL) }, c.Group.prototype.getRandom = function(a, b) { return void 0 === a && (a = 0), void 0 === b && (b = this.children.length), 0 === b ? null : c.ArrayUtils.getRandomItem(this.children, a, b) }, c.Group.prototype.getRandomExists = function(a, b) { var c = this.getAll("exists", !0, a, b); return this.game.rnd.pick(c) }, c.Group.prototype.getAll = function(a, b, c, d) {
            void 0 === c && (c = 0), void 0 === d && (d = this.children.length);
            for (var e = [], f = c; f < d; f++) {
                var g = this.children[f];
                a && g[a] === b && e.push(g)
            }
            return e
        }, c.Group.prototype.remove = function(a, b, c) {
            if (void 0 === b && (b = !1), void 0 === c && (c = !1), 0 === this.children.length || this.children.indexOf(a) === -1) return !1;
            c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
            var d = this.removeChild(a);
            return this.removeFromHash(a), this.updateZ(), this.cursor === a && this.next(), b && d && d.destroy(!0), !0
        }, c.Group.prototype.moveAll = function(a, b) {
            if (void 0 === b && (b = !1), this.children.length > 0 && a instanceof c.Group) {
                do a.add(this.children[0], b); while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
            return a
        }, c.Group.prototype.removeAll = function(a, b, c) {
            if (void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === c && (c = !1), 0 !== this.children.length) {
                do {
                    !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var d = this.removeChild(this.children[0]);
                    this.removeFromHash(d), a && d && d.destroy(!0, c)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
        }, c.Group.prototype.removeBetween = function(a, b, c, d) {
            if (void 0 === b && (b = this.children.length - 1), void 0 === c && (c = !1),
                void 0 === d && (d = !1), 0 !== this.children.length) {
                if (a > b || a < 0 || b > this.children.length) return !1;
                for (var e = b; e >= a;) {
                    !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
                    var f = this.removeChild(this.children[e]);
                    this.removeFromHash(f), c && f && f.destroy(!0), this.cursor === this.children[e] && (this.cursor = null), e--
                }
                this.updateZ()
            }
        }, c.Group.prototype.destroy = function(a, b) { null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0), void 0 === b && (b = !1), this.onDestroy.dispatch(this, a, b), this.removeAll(a), this.cursor = null, this.filters = null, this.pendingDestroy = !1, b || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1)) }, Object.defineProperty(c.Group.prototype, "total", { get: function() { return this.iterate("exists", !0, c.Group.RETURN_TOTAL) } }), Object.defineProperty(c.Group.prototype, "length", { get: function() { return this.children.length } }), Object.defineProperty(c.Group.prototype, "angle", { get: function() { return c.Math.radToDeg(this.rotation) }, set: function(a) { this.rotation = c.Math.degToRad(a) } }), Object.defineProperty(c.Group.prototype, "centerX", {
            get: function() { return this.getBounds(this.parent).centerX },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.x - b.x;
                this.x = a + c - b.halfWidth
            }
        }), Object.defineProperty(c.Group.prototype, "centerY", {
            get: function() { return this.getBounds(this.parent).centerY },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.y - b.y;
                this.y = a + c - b.halfHeight
            }
        }), Object.defineProperty(c.Group.prototype, "left", {
            get: function() { return this.getBounds(this.parent).left },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.x - b.x;
                this.x = a + c
            }
        }), Object.defineProperty(c.Group.prototype, "right", {
            get: function() { return this.getBounds(this.parent).right },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.x - b.x;
                this.x = a + c - b.width
            }
        }), Object.defineProperty(c.Group.prototype, "top", {
            get: function() { return this.getBounds(this.parent).top },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.y - b.y;
                this.y = a + c
            }
        }), Object.defineProperty(c.Group.prototype, "bottom", {
            get: function() { return this.getBounds(this.parent).bottom },
            set: function(a) {
                var b = this.getBounds(this.parent),
                    c = this.y - b.y;
                this.y = a + c - b.height
            }
        }), c.World = function(a) { c.Group.call(this, a, null, "__world", !1), this.bounds = new c.Rectangle(0, 0, a.width, a.height), this.camera = null, this._definedSize = !1, this._width = a.width, this._height = a.height, this.game.state.onStateChange.add(this.stateChange, this) }, c.World.prototype = Object.create(c.Group.prototype), c.World.prototype.constructor = c.World, c.World.prototype.boot = function() { this.camera = new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot() }, c.World.prototype.stateChange = function() { this.x = 0, this.y = 0, this.camera.reset() }, c.World.prototype.setBounds = function(a, b, c, d) { this._definedSize = !0, this._width = c, this._height = d, this.bounds.setTo(a, b, c, d), this.x = a, this.y = b, this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)), this.game.physics.setBoundsToWorld() }, c.World.prototype.resize = function(a, b) { this._definedSize && (a < this._width && (a = this._width), b < this._height && (b = this._height)), this.bounds.width = a, this.bounds.height = b, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld() }, c.World.prototype.shutdown = function() { this.destroy(!0, !0) }, c.World.prototype.wrap = function(a, b, c, d, e) { void 0 === b && (b = 0), void 0 === c && (c = !1), void 0 === d && (d = !0), void 0 === e && (e = !0), c ? (a.getBounds(), d && (a.x + a._currentBounds.width < this.bounds.x ? a.x = this.bounds.right : a.x > this.bounds.right && (a.x = this.bounds.left)), e && (a.y + a._currentBounds.height < this.bounds.top ? a.y = this.bounds.bottom : a.y > this.bounds.bottom && (a.y = this.bounds.top))) : (d && a.x + b < this.bounds.x ? a.x = this.bounds.right + b : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b), e && a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b)) }, Object.defineProperty(c.World.prototype, "width", { get: function() { return this.bounds.width }, set: function(a) { a < this.game.width && (a = this.game.width), this.bounds.width = a, this._width = a, this._definedSize = !0 } }), Object.defineProperty(c.World.prototype, "height", { get: function() { return this.bounds.height }, set: function(a) { a < this.game.height && (a = this.game.height), this.bounds.height = a, this._height = a, this._definedSize = !0 } }), Object.defineProperty(c.World.prototype, "centerX", { get: function() { return this.bounds.halfWidth + this.bounds.x } }), Object.defineProperty(c.World.prototype, "centerY", { get: function() { return this.bounds.halfHeight + this.bounds.y } }), Object.defineProperty(c.World.prototype, "randomX", { get: function() { return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width) } }), Object.defineProperty(c.World.prototype, "randomY", { get: function() { return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height) } }), c.Game = function(a, b, d, e, f, g, h, i) { return this.id = c.GAMES.push(this) - 1, this.config = null, this.physicsConfig = i, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = c.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = c.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new c.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = { enableDebug: !0 }, "undefined" != typeof a && (this._width = a), "undefined" != typeof b && (this._height = b), "undefined" != typeof d && (this.renderType = d), "undefined" != typeof e && (this.parent = e), "undefined" != typeof g && (this.transparent = g), "undefined" != typeof h && (this.antialias = h), this.rnd = new c.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new c.StateManager(this, f)), this.device.whenReady(this.boot, this), this }, c.Game.prototype = {
            parseConfig: function(a) {
                this.config = a, void 0 === a.enableDebug && (this.config.enableDebug = !0), a.width && (this._width = a.width), a.height && (this._height = a.height), a.renderer && (this.renderType = a.renderer), a.parent && (this.parent = a.parent), void 0 !== a.transparent && (this.transparent = a.transparent), void 0 !== a.antialias && (this.antialias = a.antialias), a.resolution && (this.resolution = a.resolution), void 0 !== a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer), a.physicsConfig && (this.physicsConfig = a.physicsConfig);
                var b = [(Date.now() * Math.random()).toString()];
                a.seed && (b = a.seed), this.rnd = new c.RandomDataGenerator(b);
                var d = null;
                a.state && (d = a.state), this.state = new c.StateManager(this, d)
            },
            boot: function() { this.isBooted || (this.onPause = new c.Signal, this.onResume = new c.Signal, this.onBlur = new c.Signal, this.onFocus = new c.Signal, this.isBooted = !0, PIXI.game = this, this.math = c.Math, this.scale = new c.ScaleManager(this, this._width, this._height), this.stage = new c.Stage(this), this.setUpRenderer(), this.world = new c.World(this), this.add = new c.GameObjectFactory(this), this.make = new c.GameObjectCreator(this), this.cache = new c.Cache(this), this.load = new c.Loader(this), this.time = new c.Time(this), this.tweens = new c.TweenManager(this), this.input = new c.Input(this), this.sound = new c.SoundManager(this), this.physics = new c.Physics(this, this.physicsConfig), this.particles = new c.Particles(this), this.create = new c.Create(this), this.plugins = new c.PluginManager(this), this.net = new c.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new c.Utils.Debug(this), this.debug.boot()) : this.debug = { preUpdate: function() {}, update: function() {}, reset: function() {} }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new c.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new c.RequestAnimationFrame(this, (!1)), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start()) },
            showDebugHeader: function() {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var a = c.VERSION,
                        b = "Canvas",
                        d = "HTML Audio",
                        e = 1;
                    if (this.renderType === c.WEBGL ? (b = "WebGL", e++) : this.renderType === c.HEADLESS && (b = "Headless"), this.device.webAudio && (d = "WebAudio", e++), this.device.chrome)
                        for (var f = ["%c %c %c @orange-games/phaser v" + a + " | Pixi.js | " + b + " | " + d + "  %c %c %c http://phaser.io %câ¥%câ¥%câ¥", "background: #F47820", "background: #ED873F", "color: #ffffff; background: #DD6612;", "background: #ED873F", "background: #F47820", "background: #ffffff"], g = 0; g < 3; g++) g < e ? f.push("color: #ff2424; background: #fff") : f.push("color: #959595; background: #fff");
                    else window.console
                }
            },
            setUpRenderer: function() {
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = c.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === c.HEADLESS || this.renderType === c.CANVAS || this.renderType === c.AUTO && !this.device.webGL) {
                    if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderType = c.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                }
                else this.renderType = c.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === c.CANVAS), this.renderType !== c.HEADLESS && (this.stage.smoothed = this.antialias, c.Canvas.addToDOM(this.canvas, this.parent, !1), c.Canvas.setTouchAction(this.canvas))
            },
            contextLost: function(a) { a.preventDefault(), this.renderer.contextLost = !0 },
            contextRestored: function() { this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1 },
            update: function(a) {
                if (this.time.update(a), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                else {
                    var b = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
                    var c = 0;
                    for (this.updatesThisFrame = Math.floor(this._deltaTime / b), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b, this.currentUpdateID = c, this.updateLogic(this.time.desiredFpsMult), c++, !this.forceSingleUpdate || 1 !== c);) this.time.refresh();
                    c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0), this._lastCount = c, this.updateRender(this._deltaTime / b)
                }
            },
            updateLogic: function(a) { this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(a), this.plugins.preUpdate(a), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform() },
            updateRender: function(a) { this.lockRender || (this.state.preRender(a), this.renderType !== c.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(a), this.state.render(a)), this.plugins.postRender(a)) },
            enableStep: function() { this.stepping = !0, this.pendingStep = !1, this.stepCount = 0 },
            disableStep: function() { this.stepping = !1, this.pendingStep = !1 },
            step: function() { this.pendingStep = !1, this.stepCount++ },
            destroy: function() { this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), c.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, c.GAMES[this.id] = null },
            gamePaused: function(a) { this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !0)) },
            gameResumed: function(a) { this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !1)) },
            focusLoss: function(a) { this.onBlur.dispatch(a), this.stage.disableVisibilityChange || this.gamePaused(a) },
            focusGain: function(a) { this.onFocus.dispatch(a), this.stage.disableVisibilityChange || this.gameResumed(a) }
        }, c.Game.prototype.constructor = c.Game, Object.defineProperty(c.Game.prototype, "paused", { get: function() { return this._paused }, set: function(a) { a === !0 ? (this._paused === !1 && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1) } }), c.Input = function(a) { this.game = a, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = c.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new c.ArraySet, this._localPoint = new c.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0 }, c.Input.MOUSE_OVERRIDES_TOUCH = 0, c.Input.TOUCH_OVERRIDES_MOUSE = 1, c.Input.MOUSE_TOUCH_COMBINE = 2, c.Input.MAX_POINTERS = 10, c.Input.prototype = {
            boot: function() {
                this.mousePointer = new c.Pointer(this.game, 0, c.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new c.Mouse(this.game), this.touch = new c.Touch(this.game), this.mspointer = new c.MSPointer(this.game), c.Keyboard && (this.keyboard = new c.Keyboard(this.game)), c.Gamepad && (this.gamepad = new c.Gamepad(this.game)), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.scale = new c.Point(1, 1), this.speed = new c.Point, this.position = new c.Point, this._oldPosition = new c.Point, this.circle = new c.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.mspointer ? this.mspointer.start() : this.game.device.touch && this.touch.start(), this.mspointer.active || this.mouse.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                var a = this;
                this._onClickTrampoline = function(b) { a.onClickTrampoline(b) }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            },
            destroy: function() { this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline) },
            setInteractiveCandidateHandler: function(a, b) { this.customCandidateHandler = a, this.customCandidateHandlerContext = b },
            addMoveCallback: function(a, b) { this.moveCallbacks.push({ callback: a, context: b }) },
            deleteMoveCallback: function(a, b) {
                for (var c = this.moveCallbacks.length; c--;)
                    if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) return void this.moveCallbacks.splice(c, 1)
            },
            addPointer: function() {
                if (this.pointers.length >= c.Input.MAX_POINTERS) return null;
                var a = this.pointers.length + 1,
                    b = new c.Pointer(this.game, a, c.PointerMode.TOUCH);
                return this.pointers.push(b), this["pointer" + a] = b, b
            },
            update: function() {
                if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
                this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                for (var a = 0; a < this.pointers.length; a++) this.pointers[a].update();
                this._pollCounter = 0
            },
            reset: function(a) { if (this.game.isBooted && !this.resetLocked) { void 0 === a && (a = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(a), this.gamepad && this.gamepad.reset(); for (var b = 0; b < this.pointers.length; b++) this.pointers[b].reset(); "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), a && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new c.Signal, this.onUp = new c.Signal, this.onTap = new c.Signal, this.onHold = new c.Signal, this.moveCallbacks = []), this._pollCounter = 0 } },
            resetSpeed: function(a, b) { this._oldPosition.setTo(a, b), this.speed.setTo(0, 0) },
            startPointer: function(a) { if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null; if (!this.pointer1.active) return this.pointer1.start(a); if (!this.pointer2.active) return this.pointer2.start(a); for (var b = 2; b < this.pointers.length; b++) { var c = this.pointers[b]; if (!c.active) return c.start(a) } return null },
            updatePointer: function(a) { if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.move(a); if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.move(a); for (var b = 2; b < this.pointers.length; b++) { var c = this.pointers[b]; if (c.active && c.identifier === a.identifier) return c.move(a) } return null },
            stopPointer: function(a) { if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.stop(a); if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.stop(a); for (var b = 2; b < this.pointers.length; b++) { var c = this.pointers[b]; if (c.active && c.identifier === a.identifier) return c.stop(a) } return null },
            countActivePointers: function(a) {
                void 0 === a && (a = this.pointers.length);
                for (var b = a, c = 0; c < this.pointers.length && b > 0; c++) {
                    var d = this.pointers[c];
                    d.active && b--
                }
                return a - b
            },
            getPointer: function(a) { void 0 === a && (a = !1); for (var b = 0; b < this.pointers.length; b++) { var c = this.pointers[b]; if (c.active === a) return c } return null },
            getPointerFromIdentifier: function(a) { for (var b = 0; b < this.pointers.length; b++) { var c = this.pointers[b]; if (c.identifier === a) return c } return null },
            getPointerFromId: function(a) { for (var b = 0; b < this.pointers.length; b++) { var c = this.pointers[b]; if (c.pointerId === a) return c } return null },
            getLocalPosition: function(a, b, d) {
                void 0 === d && (d = new c.Point);
                var e = a.worldTransform,
                    f = 1 / (e.a * e.d + e.c * -e.b);
                return d.setTo(e.d * f * b.x + -e.c * f * b.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * b.y + -e.b * f * b.x + (-e.ty * e.a + e.tx * e.b) * f)
            },
            hitTest: function(a, b, d) {
                if (!a.worldVisible) return !1;
                if (this.getLocalPosition(a, b, this._localPoint), d.copyFrom(this._localPoint), a.hitArea && a.hitArea.contains) return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if (a instanceof c.TileSprite) {
                    var e = a.width,
                        f = a.height,
                        g = -e * a.anchor.x;
                    if (this._localPoint.x >= g && this._localPoint.x < g + e) { var h = -f * a.anchor.y; if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0 }
                }
                else if (a instanceof PIXI.Sprite) {
                    var e = a.texture.frame.width,
                        f = a.texture.frame.height,
                        g = -e * a.anchor.x;
                    if (this._localPoint.x >= g && this._localPoint.x < g + e) { var h = -f * a.anchor.y; if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0 }
                }
                else if (a instanceof c.Graphics)
                    for (var i = 0; i < a.graphicsData.length; i++) { var j = a.graphicsData[i]; if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) return !0 }
                for (var i = 0; i < a.children.length; i++)
                    if (this.hitTest(a.children[i], b, d)) return !0;
                return !1
            },
            onClickTrampoline: function() { this.activePointer.processClickTrampolines() }
        }, c.Input.prototype.constructor = c.Input, Object.defineProperty(c.Input.prototype, "x", { get: function() { return this._x }, set: function(a) { this._x = Math.floor(a) } }), Object.defineProperty(c.Input.prototype, "y", { get: function() { return this._y }, set: function(a) { this._y = Math.floor(a) } }), Object.defineProperty(c.Input.prototype, "pollLocked", { get: function() { return this.pollRate > 0 && this._pollCounter < this.pollRate } }), Object.defineProperty(c.Input.prototype, "totalInactivePointers", { get: function() { return this.pointers.length - this.countActivePointers() } }), Object.defineProperty(c.Input.prototype, "totalActivePointers", { get: function() { return this.countActivePointers() } }), Object.defineProperty(c.Input.prototype, "worldX", { get: function() { return this.game.camera.view.x + this.x } }), Object.defineProperty(c.Input.prototype, "worldY", { get: function() { return this.game.camera.view.y + this.y } }), c.Mouse = function(a) { this.game = a, this.input = a.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new c.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null }, c.Mouse.NO_BUTTON = -1, c.Mouse.LEFT_BUTTON = 0, c.Mouse.MIDDLE_BUTTON = 1, c.Mouse.RIGHT_BUTTON = 2, c.Mouse.BACK_BUTTON = 3, c.Mouse.FORWARD_BUTTON = 4, c.Mouse.WHEEL_UP = 1, c.Mouse.WHEEL_DOWN = -1, c.Mouse.prototype = {
            start: function() {
                if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                    var b = this;
                    this._onMouseDown = function(a) { return b.onMouseDown(a) }, this._onMouseMove = function(a) { return b.onMouseMove(a) }, this._onMouseUp = function(a) { return b.onMouseUp(a) }, this._onMouseUpGlobal = function(a) { return b.onMouseUpGlobal(a) }, this._onMouseOutGlobal = function(a) { return b.onMouseOutGlobal(a) }, this._onMouseOut = function(a) { return b.onMouseOut(a) }, this._onMouseOver = function(a) { return b.onMouseOver(a) }, this._onMouseWheel = function(a) { return b.onMouseWheel(a) };
                    var c = this.game.canvas;
                    c.addEventListener("mousedown", this._onMouseDown, !0), c.addEventListener("mousemove", this._onMouseMove, !0), c.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), c.addEventListener("mouseover", this._onMouseOver, !0), c.addEventListener("mouseout", this._onMouseOut, !0));
                    var d = this.game.device.wheelEvent;
                    d && (c.addEventListener(d, this._onMouseWheel, !0), "mousewheel" === d ? this._wheelEvent = new a((-.025), 1) : "DOMMouseScroll" === d && (this._wheelEvent = new a(1, 1)))
                }
            },
            onMouseDown: function(a) { this.event = a, this.capture && a.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.start(a)) },
            onMouseMove: function(a) { this.event = a, this.capture && a.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.move(a)) },
            onMouseUp: function(a) { this.event = a, this.capture && a.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = 0, this.input.mousePointer.stop(a)) },
            onMouseUpGlobal: function(a) { this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), a.identifier = 0, this.input.mousePointer.stop(a)) },
            onMouseOutGlobal: function(a) { this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(a), this.input.mousePointer.leftButton.stop(a), this.input.mousePointer.rightButton.stop(a)) },
            onMouseOut: function(a) { this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && this.stopOnGameOut && (a.identifier = 0, this.input.mousePointer.stop(a)) },
            onMouseOver: function(a) { this.event = a, this.capture && a.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a) },
            onMouseWheel: function(a) { this._wheelEvent && (a = this._wheelEvent.bindEvent(a)), this.event = a, this.capture && a.preventDefault(), this.wheelDelta = c.Math.clamp(-a.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a) },
            requestPointerLock: function() {
                if (this.game.device.pointerLock) {
                    var a = this.game.canvas;
                    a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock();
                    var b = this;
                    this._pointerLockChange = function(a) { return b.pointerLockChange(a) }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            },
            pointerLockChange: function(a) {
                var b = this.game.canvas;
                document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0, this.pointerLock.dispatch(!0, a)) : (this.locked = !1, this.pointerLock.dispatch(!1, a))
            },
            releasePointerLock: function() { document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0) },
            stop: function() {
                var a = this.game.canvas;
                a.removeEventListener("mousedown", this._onMouseDown, !0), a.removeEventListener("mousemove", this._onMouseMove, !0), a.removeEventListener("mouseup", this._onMouseUp, !0), a.removeEventListener("mouseover", this._onMouseOver, !0), a.removeEventListener("mouseout", this._onMouseOut, !0);
                var b = this.game.device.wheelEvent;
                b && a.removeEventListener(b, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        }, c.Mouse.prototype.constructor = c.Mouse, a.prototype = {}, a.prototype.constructor = a, a.prototype.bindEvent = function(b) {
            if (!a._stubsGenerated && b) {
                var c = function(a) { return function() { var b = this.originalEvent[a]; return "function" != typeof b ? b : b.bind(this.originalEvent) } };
                for (var d in b) d in a.prototype || Object.defineProperty(a.prototype, d, { get: c(d) });
                a._stubsGenerated = !0
            }
            return this.originalEvent = b, this
        }, Object.defineProperties(a.prototype, { type: { value: "wheel" }, deltaMode: { get: function() { return this._deltaMode } }, deltaY: { get: function() { return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0 } }, deltaX: { get: function() { return this._scaleFactor * this.originalEvent.wheelDeltaX || 0 } }, deltaZ: { value: 0 } }), c.MSPointer = function(a) { this.game = a, this.input = a.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null }, c.MSPointer.prototype = {
            start: function() {
                if (null === this._onMSPointerDown) {
                    var a = this;
                    if (this.game.device.mspointer) {
                        this._onMSPointerDown = function(b) { return a.onPointerDown(b) }, this._onMSPointerMove = function(b) { return a.onPointerMove(b) }, this._onMSPointerUp = function(b) { return a.onPointerUp(b) }, this._onMSPointerUpGlobal = function(b) { return a.onPointerUpGlobal(b) }, this._onMSPointerOut = function(b) { return a.onPointerOut(b) }, this._onMSPointerOver = function(b) { return a.onPointerOver(b) };
                        var b = this.game.canvas;
                        b.addEventListener("MSPointerDown", this._onMSPointerDown, !1), b.addEventListener("MSPointerMove", this._onMSPointerMove, !1), b.addEventListener("MSPointerUp", this._onMSPointerUp, !1), b.addEventListener("pointerdown", this._onMSPointerDown, !1), b.addEventListener("pointermove", this._onMSPointerMove, !1), b.addEventListener("pointerup", this._onMSPointerUp, !1), b.style["-ms-content-zooming"] = "none", b.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), b.addEventListener("MSPointerOver", this._onMSPointerOver, !0), b.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), b.addEventListener("pointerover", this._onMSPointerOver, !0), b.addEventListener("pointerout", this._onMSPointerOut, !0))
                    }
                }
            },
            onPointerDown: function(a) { this.event = a, this.capture && a.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a)) },
            onPointerMove: function(a) { this.event = a, this.capture && a.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a)) },
            onPointerUp: function(a) { this.event = a, this.capture && a.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && (a.identifier = a.pointerId, "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a)) },
            onPointerUpGlobal: function(a) {
                if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
                    var b = this.input.getPointerFromIdentifier(a.identifier);
                    b && b.withinGame && this.onPointerUp(a)
                }
                else this.onPointerUp(a)
            },
            onPointerOut: function(a) {
                if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !1;
                else {
                    var b = this.input.getPointerFromIdentifier(a.identifier);
                    b && (b.withinGame = !1)
                }
                this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (a.identifier = 0,
                    b ? b.stop(a) : this.input.mousePointer.stop(a))
            },
            onPointerOver: function(a) {
                if (this.event = a, this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType) this.input.mousePointer.withinGame = !0;
                else {
                    var b = this.input.getPointerFromIdentifier(a.identifier);
                    b && (b.withinGame = !0)
                }
                this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a)
            },
            stop: function() {
                var a = this.game.canvas;
                a.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), a.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), a.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), a.removeEventListener("pointerdown", this._onMSPointerDown, !1), a.removeEventListener("pointermove", this._onMSPointerMove, !1), a.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), a.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), a.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), a.removeEventListener("pointerover", this._onMSPointerOver, !0), a.removeEventListener("pointerout", this._onMSPointerOut, !0)
            }
        }, c.MSPointer.prototype.constructor = c.MSPointer, c.DeviceButton = function(a, b) { this.parent = a, this.game = a.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = b, this.onDown = new c.Signal, this.onUp = new c.Signal, this.onFloat = new c.Signal }, c.DeviceButton.prototype = { start: function(a, b) { this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onDown.dispatch(this, b)) }, stop: function(a, b) { this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = a, this.value = b, a && (this.altKey = a.altKey, this.shiftKey = a.shiftKey, this.ctrlKey = a.ctrlKey), this.onUp.dispatch(this, b)) }, padFloat: function(a) { this.value = a, this.onFloat.dispatch(this, a) }, justPressed: function(a) { return a = a || 250, this.isDown && this.timeDown + a > this.game.time.time }, justReleased: function(a) { return a = a || 250, this.isUp && this.timeUp + a > this.game.time.time }, reset: function() { this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1 }, destroy: function() { this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null } }, c.DeviceButton.prototype.constructor = c.DeviceButton, Object.defineProperty(c.DeviceButton.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), c.Pointer = function(a, b, d) { this.game = a, this.id = b, this.type = c.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = d || c.PointerMode.CURSOR | c.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new c.DeviceButton(this, c.Pointer.LEFT_BUTTON), this.middleButton = new c.DeviceButton(this, c.Pointer.MIDDLE_BUTTON), this.rightButton = new c.DeviceButton(this, c.Pointer.RIGHT_BUTTON), this.backButton = new c.DeviceButton(this, c.Pointer.BACK_BUTTON), this.forwardButton = new c.DeviceButton(this, c.Pointer.FORWARD_BUTTON), this.eraserButton = new c.DeviceButton(this, c.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === b, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new c.Point, this.positionDown = new c.Point, this.positionUp = new c.Point, this.circle = new c.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null }, c.Pointer.NO_BUTTON = 0, c.Pointer.LEFT_BUTTON = 1, c.Pointer.RIGHT_BUTTON = 2, c.Pointer.MIDDLE_BUTTON = 4, c.Pointer.BACK_BUTTON = 8, c.Pointer.FORWARD_BUTTON = 16, c.Pointer.ERASER_BUTTON = 32, c.Pointer.prototype = {
            resetButtons: function() { this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset()) },
            processButtonsDown: function(a, b) { c.Pointer.LEFT_BUTTON & a && this.leftButton.start(b), c.Pointer.RIGHT_BUTTON & a && this.rightButton.start(b), c.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(b), c.Pointer.BACK_BUTTON & a && this.backButton.start(b), c.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(b), c.Pointer.ERASER_BUTTON & a && this.eraserButton.start(b) },
            processButtonsUp: function(a, b) { a === c.Mouse.LEFT_BUTTON && this.leftButton.stop(b), a === c.Mouse.RIGHT_BUTTON && this.rightButton.stop(b), a === c.Mouse.MIDDLE_BUTTON && this.middleButton.stop(b), a === c.Mouse.BACK_BUTTON && this.backButton.stop(b), a === c.Mouse.FORWARD_BUTTON && this.forwardButton.stop(b), 5 === a && this.eraserButton.stop(b) },
            updateButtons: function(a) {
                this.button = a.button;
                var b = "down" === a.type.toLowerCase().substr(-4);
                void 0 !== a.buttons ? b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a) : b ? this.leftButton.start(a) : (this.leftButton.stop(a), this.rightButton.stop(a)), 1 === a.buttons && a.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(a), this.rightButton.start(a)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
            },
            start: function(a) { var b = this.game.input; return a.pointerId && (this.pointerId = a.pointerId), this.identifier = a.identifier, this.target = a.target, this.isMouse ? this.updateButtons(a) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(a, !0), this.positionDown.setTo(this.x, this.y), (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.x = this.x, b.y = this.y, b.position.setTo(this.x, this.y), b.onDown.dispatch(this, a), b.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this },
            update: function() {
                var a = this.game.input;
                this.active && (this.dirty && (a.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), this._holdSent === !1 && this.duration >= a.holdRate && ((a.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || a.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers) && a.onHold.dispatch(this), this._holdSent = !0), a.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + a.recordRate, this._history.push({ x: this.position.x, y: this.position.y }), this._history.length > a.recordLimit && this._history.shift()))
            },
            move: function(a, b) { var d = this.game.input; if (!d.pollLocked) { void 0 === b && (b = !1), void 0 !== a.button && (this.button = a.button), b && this.isMouse && this.updateButtons(a), this.clientX = a.clientX, this.clientY = a.clientY, this.pageX = a.pageX, this.pageY = a.pageY, this.screenX = a.screenX, this.screenY = a.screenY, this.isMouse && d.mouse.locked && !b && (this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0, this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (d.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) && (d.activePointer = this, d.x = this.x, d.y = this.y, d.position.setTo(d.x, d.y), d.circle.x = d.x, d.circle.y = d.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY); for (var e = d.moveCallbacks.length; e--;) d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, b); return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : d.interactiveItems.total > 0 && this.processInteractiveObjects(b), this } },
            processInteractiveObjects: function(a) {
                var b = 0,
                    c = -1,
                    d = null,
                    e = this.game.input.interactiveItems.first;
                for (this.interactiveCandidates = []; e;) e.checked = !1, e.validForInput(c, b, !1) && (e.checked = !0, (a && e.checkPointerDown(this, !0) || !a && e.checkPointerOver(this, !0)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e))), e = this.game.input.interactiveItems.next;
                for (e = this.game.input.interactiveItems.first; e;) !e.checked && e.validForInput(c, b, !0) && (a && e.checkPointerDown(this, !1) || !a && e.checkPointerOver(this, !1)) && (b = e.sprite.renderOrderID, c = e.priorityID, d = e, this.interactiveCandidates.push(e)), e = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d)), this.swapTarget(d, !1), null !== this.targetObject
            },
            swapTarget: function(a, b) { void 0 === b && (b = !1), null === a ? this.targetObject && (this.targetObject._pointerOutHandler(this, b), this.targetObject = null) : null === this.targetObject ? (this.targetObject = a, a._pointerOverHandler(this, b)) : this.targetObject === a ? a.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, b), this.targetObject = a, this.targetObject._pointerOverHandler(this, b)) },
            leave: function(a) { this.withinGame = !1, this.move(a, !1) },
            stop: function(a) { var b = this.game.input; return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time, (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers) && (b.onUp.dispatch(this, a), this.duration >= 0 && this.duration <= b.tapRate && (this.timeUp - this.previousTapTime < b.doubleTapRate ? b.onTap.dispatch(this, !0) : b.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(a) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), this.isMouse === !1 && b.currentPointers--, b.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this) },
            justPressed: function(a) { return a = a || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + a > this.game.time.time },
            justReleased: function(a) { return a = a || this.game.input.justReleasedRate, this.isUp && this.timeUp + a > this.game.time.time },
            addClickTrampoline: function(a, b, c, d) {
                if (this.isDown) {
                    for (var e = this._clickTrampolines = this._clickTrampolines || [], f = 0; f < e.length; f++)
                        if (e[f].name === a) { e.splice(f, 1); break }
                    e.push({ name: a, targetObject: this.targetObject, callback: b, callbackContext: c, callbackArgs: d })
                }
            },
            processClickTrampolines: function() {
                var a = this._clickTrampolines;
                if (a) {
                    for (var b = 0; b < a.length; b++) {
                        var c = a[b];
                        c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs)
                    }
                    this._clickTrampolines = null, this._trampolineTargetObject = null
                }
            },
            reset: function() { this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null },
            resetMovement: function() { this.movementX = 0, this.movementY = 0 }
        }, c.Pointer.prototype.constructor = c.Pointer, Object.defineProperty(c.Pointer.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), Object.defineProperty(c.Pointer.prototype, "worldX", { get: function() { return this.game.world.camera.x + this.x } }), Object.defineProperty(c.Pointer.prototype, "worldY", { get: function() { return this.game.world.camera.y + this.y } }), c.PointerMode = { CURSOR: 1, CONTACT: 2 }, c.Touch = function(a) { this.game = a, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null }, c.Touch.prototype = {
            start: function() {
                if (null === this._onTouchStart) {
                    var a = this;
                    this.game.device.touch && (this._onTouchStart = function(b) { return a.onTouchStart(b) }, this._onTouchMove = function(b) { return a.onTouchMove(b) }, this._onTouchEnd = function(b) { return a.onTouchEnd(b) }, this._onTouchEnter = function(b) { return a.onTouchEnter(b) }, this._onTouchLeave = function(b) { return a.onTouchLeave(b) }, this._onTouchCancel = function(b) { return a.onTouchCancel(b) }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                }
            },
            consumeDocumentTouches: function() { this._documentTouchMove = function(a) { a.preventDefault() }, document.addEventListener("touchmove", this._documentTouchMove, !1) },
            addTouchLockCallback: function(a, b, c) { void 0 === c && (c = !1), this.touchLockCallbacks.push({ callback: a, context: b, onEnd: c }) },
            removeTouchLockCallback: function(a, b) {
                for (var c = this.touchLockCallbacks.length; c--;)
                    if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) return this.touchLockCallbacks.splice(c, 1), !0;
                return !1
            },
            onTouchStart: function(a) { for (var b = this.touchLockCallbacks.length; b--;) { var c = this.touchLockCallbacks[b];!c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1) } if (this.event = a, this.game.input.enabled && this.enabled) { this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault(); for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b]) } },
            onTouchCancel: function(a) { if (this.event = a, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled) { this.preventDefault && a.preventDefault(); for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b]) } },
            onTouchEnter: function(a) { this.event = a, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault() },
            onTouchLeave: function(a) { this.event = a, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault() },
            onTouchMove: function(a) { this.event = a, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault(); for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b]) },
            onTouchEnd: function(a) {
                for (var b = this.touchLockCallbacks.length; b--;) {
                    var c = this.touchLockCallbacks[b];
                    c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1)
                }
                this.event = a, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b])
            },
            stop: function() { this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel)) }
        }, c.Touch.prototype.constructor = c.Touch, c.InputHandler = function(a) { this.sprite = a, this.game = a.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new c.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new c.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new c.Point, this.snapPoint = new c.Point, this._dragPoint = new c.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new c.Point, this._pointerData = [], this._pointerData.push({ id: 0, x: 0, y: 0, camX: 0, camY: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 }) }, c.InputHandler.prototype = {
            start: function(a, b) {
                if (a = a || 0, void 0 === b && (b = !1), this.enabled === !1) {
                    this.game.input.interactiveItems.add(this), this.useHandCursor = b, this.priorityID = a;
                    for (var d = 0; d < 10; d++) this._pointerData[d] = { id: d, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 };
                    this.snapOffset = new c.Point, this.enabled = !0, this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
            },
            addedToGroup: function() { this._dragPhase || this._wasEnabled && !this.enabled && this.start() },
            removedFromGroup: function() { this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1) },
            reset: function() { this.enabled = !1; for (var a = 0; a < 10; a++) this._pointerData[a] = { id: a, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 } },
            stop: function() { this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this)) },
            destroy: function() { this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null) },
            validForInput: function(a, b, c) { return void 0 === c && (c = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!c && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID > b)) },
            isPixelPerfect: function() { return this.pixelPerfectClick || this.pixelPerfectOver },
            pointerX: function(a) { return a = a || 0, this._pointerData[a].x },
            pointerY: function(a) { return a = a || 0, this._pointerData[a].y },
            pointerDown: function(a) { return a = a || 0, this._pointerData[a].isDown },
            pointerUp: function(a) { return a = a || 0, this._pointerData[a].isUp },
            pointerTimeDown: function(a) { return a = a || 0, this._pointerData[a].timeDown },
            pointerTimeUp: function(a) { return a = a || 0, this._pointerData[a].timeUp },
            pointerOver: function(a) {
                if (!this.enabled) return !1;
                if (void 0 === a) {
                    for (var b = 0; b < 10; b++)
                        if (this._pointerData[b].isOver) return !0;
                    return !1
                }
                return this._pointerData[a].isOver
            },
            pointerOut: function(a) {
                if (!this.enabled) return !1;
                if (void 0 !== a) return this._pointerData[a].isOut;
                for (var b = 0; b < 10; b++)
                    if (this._pointerData[b].isOut) return !0
            },
            pointerTimeOver: function(a) { return a = a || 0, this._pointerData[a].timeOver },
            pointerTimeOut: function(a) { return a = a || 0, this._pointerData[a].timeOut },
            pointerDragged: function(a) { return a = a || 0, this._pointerData[a].isDragged },
            checkPointerDown: function(a, b) { return !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) },
            checkPointerOver: function(a, b) { return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1), !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) },
            checkPixel: function(a, b, c) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === a && null === b) {
                        this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
                        var a = this._tempPoint.x,
                            b = this._tempPoint.y
                    }
                    if (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y), a += this.sprite.texture.frame.x, b += this.sprite.texture.frame.y, this.sprite.texture.trim && (a -= this.sprite.texture.trim.x, b -= this.sprite.texture.trim.y, a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom)) return this._dx = a, this._dy = b, !1;
                    this._dx = a, this._dy = b, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
                    var d = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                    if (d.data[3] >= this.pixelPerfectAlpha) return !0
                }
                return !1
            },
            update: function(a) { if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = c.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(a), !0) : this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a, !1) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, !0) : (this._pointerOutHandler(a), !1) : void 0 : (this._pointerOutHandler(a), !1) },
            _pointerOverHandler: function(a, b) {
                if (null !== this.sprite) {
                    var d = this._pointerData[a.id];
                    if (d.isOver === !1 || a.dirty) {
                        var e = d.isOver === !1;
                        d.isOver = !0, d.isOut = !1, d.timeOver = this.game.time.time, d.x = a.x - this.sprite.x, d.y = a.y - this.sprite.y, this.useHandCursor && d.isDragged === !1 && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !b && e && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a), this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, a)
                    }
                }
            },
            _pointerOutHandler: function(a, b) {
                if (null !== this.sprite) {
                    var d = this._pointerData[a.id];
                    d.isOver = !1, d.isOut = !0, d.timeOut = this.game.time.time, this.useHandCursor && d.isDragged === !1 && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !b && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, a))
                }
            },
            _touchedHandler: function(a) {
                if (null !== this.sprite) {
                    var b = this._pointerData[a.id];
                    if (!b.isDown && b.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) return;
                        if (b.isDown = !0, b.isUp = !1, b.timeDown = this.game.time.time, this.downPoint.set(a.x, a.y), a.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a), null === this.sprite)) return;
                        this.draggable && this.isDragged === !1 && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(a) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                    }
                }
            },
            dragTimeElapsed: function(a) { this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(a) },
            _releasedHandler: function(a) {
                if (null !== this.sprite) {
                    var b = this._pointerData[a.id];
                    if (b.isDown && a.isUp) {
                        b.isDown = !1, b.isUp = !0, b.timeUp = this.game.time.time, b.downDuration = b.timeUp - b.timeDown;
                        var d = this.checkPointerOver(a);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === a.id) || this.sprite.events.onInputUp$dispatch(this.sprite, a, d), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d), d && (d = this.checkPointerOver(a))), b.isOver = d, !d && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), a.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a)
                    }
                }
            },
            updateDrag: function(a, b) {
                if (void 0 === b && (b = !1), a.isUp) return this.stopDrag(a), !1;
                var c = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x,
                    d = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
                if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = c), this.allowVerticalDrag && (this.sprite.cameraOffset.y = d), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                else {
                    var e = this.game.camera.x - this._pointerData[a.id].camX,
                        f = this.game.camera.y - this._pointerData[a.id].camY;
                    this.allowHorizontalDrag && (this.sprite.x = c + e), this.allowVerticalDrag && (this.sprite.y = d + f), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                }
                return this.sprite.events.onDragUpdate.dispatch(this.sprite, a, c, d, this.snapPoint, b), !0
            },
            justOver: function(a, b) { return a = a || 0, b = b || 500, this._pointerData[a].isOver && this.overDuration(a) < b },
            justOut: function(a, b) { return a = a || 0, b = b || 500, this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b },
            justPressed: function(a, b) { return a = a || 0, b = b || 500, this._pointerData[a].isDown && this.downDuration(a) < b },
            justReleased: function(a, b) { return a = a || 0, b = b || 500, this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b },
            overDuration: function(a) { return a = a || 0, this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1 },
            downDuration: function(a) { return a = a || 0, this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1 },
            enableDrag: function(a, b, d, e, f, g) { void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === d && (d = !1), void 0 === e && (e = 255), void 0 === f && (f = null), void 0 === g && (g = null), this._dragPoint = new c.Point, this.draggable = !0, this.bringToTop = b, this.dragOffset = new c.Point, this.dragFromCenter = a, this.pixelPerfectClick = d, this.pixelPerfectAlpha = e, f && (this.boundsRect = f), g && (this.boundsSprite = g) },
            disableDrag: function() {
                if (this._pointerData)
                    for (var a = 0; a < 10; a++) this._pointerData[a].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
            },
            startDrag: function(a) {
                var b = this.sprite.x,
                    c = this.sprite.y;
                if (this.isDragged = !0, this._draggedPointerID = a.id, this._pointerData[a.id].camX = this.game.camera.x, this._pointerData[a.id].camY = this.game.camera.y, this._pointerData[a.id].isDragged = !0, this.sprite.fixedToCamera) {
                    if (this.dragFromCenter) {
                        var d = this.sprite.getBounds();
                        this.sprite.cameraOffset.x = this.globalToLocalX(a.x) + (this.sprite.cameraOffset.x - d.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(a.y) + (this.sprite.cameraOffset.y - d.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y)
                }
                else {
                    if (this.dragFromCenter) {
                        var d = this.sprite.getBounds();
                        this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX), this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y))
                }
                this.updateDrag(a, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(b, c), this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c), this._pendingDrag = !1
            },
            globalToLocalX: function(a) { return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.x, a *= this.game.scale.grid.scaleFluidInversed.x), a },
            globalToLocalY: function(a) { return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.y, a *= this.game.scale.grid.scaleFluidInversed.y), a },
            stopDrag: function(a) { this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[a.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, a), this.checkPointerOver(a) === !1 && this._pointerOutHandler(a) },
            setDragLock: function(a, b) { void 0 === a && (a = !0), void 0 === b && (b = !0), this.allowHorizontalDrag = a, this.allowVerticalDrag = b },
            enableSnap: function(a, b, c, d, e, f) { void 0 === c && (c = !0), void 0 === d && (d = !1), void 0 === e && (e = 0), void 0 === f && (f = 0), this.snapX = a, this.snapY = b, this.snapOffsetX = e, this.snapOffsetY = f, this.snapOnDrag = c, this.snapOnRelease = d },
            disableSnap: function() { this.snapOnDrag = !1, this.snapOnRelease = !1 },
            checkBoundsRect: function() { this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY))) },
            checkBoundsSprite: function() {
                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width),
                    this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
            }
        }, c.InputHandler.prototype.constructor = c.InputHandler, c.Gamepad = function(a) { this.game = a, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") !== -1 || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this)] }, c.Gamepad.prototype = {
            addCallbacks: function(a, b) { "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a) },
            start: function() {
                if (!this._active) {
                    this._active = !0;
                    var a = this;
                    this._onGamepadConnected = function(b) { return a.onGamepadConnected(b) }, this._onGamepadDisconnected = function(b) { return a.onGamepadDisconnected(b) }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                }
            },
            onGamepadConnected: function(a) {
                var b = a.gamepad;
                this._rawPads.push(b), this._gamepads[b.index].connect(b)
            },
            onGamepadDisconnected: function(a) {
                var b = a.gamepad;
                for (var c in this._rawPads) this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
                this._gamepads[b.index].disconnect()
            },
            update: function() { this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus() },
            _pollGamepads: function() {
                if (this._active) {
                    if (navigator.getGamepads) var a = navigator.getGamepads();
                    else if (navigator.webkitGetGamepads) var a = navigator.webkitGetGamepads();
                    else if (navigator.webkitGamepads) var a = navigator.webkitGamepads();
                    if (a) {
                        this._rawPads = [];
                        for (var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = !0, this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 !== c); c++);
                        for (var d = 0; d < this._gamepads.length; d++) this._gamepads[d]._rawPad = this._rawPads[d];
                        if (b) {
                            for (var e, f = { rawIndices: {}, padIndices: {} }, g = 0; g < this._gamepads.length; g++)
                                if (e = this._gamepads[g], e.connected)
                                    for (var h = 0; h < this._rawPads.length; h++) this._rawPads[h].index === e.index && (f.rawIndices[e.index] = !0, f.padIndices[g] = !0);
                            for (var i = 0; i < this._gamepads.length; i++)
                                if (e = this._gamepads[i], !f.padIndices[i]) { this._rawPads.length < 1 && e.disconnect(); for (var j = 0; j < this._rawPads.length && !f.padIndices[i]; j++) { var k = this._rawPads[j]; if (k) { if (f.rawIndices[k.index]) { e.disconnect(); continue } e.connect(k), f.rawIndices[k.index] = !0, f.padIndices[i] = !0 } else e.disconnect() } }
                        }
                    }
                }
            },
            setDeadZones: function(a) { for (var b = 0; b < this._gamepads.length; b++) this._gamepads[b].deadZone = a },
            stop: function() { this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected) },
            reset: function() { this.update(); for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].reset() },
            justPressed: function(a, b) {
                for (var c = 0; c < this._gamepads.length; c++)
                    if (this._gamepads[c].justPressed(a, b) === !0) return !0;
                return !1
            },
            justReleased: function(a, b) {
                for (var c = 0; c < this._gamepads.length; c++)
                    if (this._gamepads[c].justReleased(a, b) === !0) return !0;
                return !1
            },
            isDown: function(a) {
                for (var b = 0; b < this._gamepads.length; b++)
                    if (this._gamepads[b].isDown(a) === !0) return !0;
                return !1
            },
            destroy: function() { this.stop(); for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].destroy() }
        }, c.Gamepad.prototype.constructor = c.Gamepad, Object.defineProperty(c.Gamepad.prototype, "active", { get: function() { return this._active } }), Object.defineProperty(c.Gamepad.prototype, "supported", { get: function() { return this._gamepadSupportAvailable } }), Object.defineProperty(c.Gamepad.prototype, "padsConnected", { get: function() { return this._rawPads.length } }), Object.defineProperty(c.Gamepad.prototype, "pad1", { get: function() { return this._gamepads[0] } }), Object.defineProperty(c.Gamepad.prototype, "pad2", { get: function() { return this._gamepads[1] } }), Object.defineProperty(c.Gamepad.prototype, "pad3", { get: function() { return this._gamepads[2] } }), Object.defineProperty(c.Gamepad.prototype, "pad4", { get: function() { return this._gamepads[3] } }), c.Gamepad.BUTTON_0 = 0, c.Gamepad.BUTTON_1 = 1, c.Gamepad.BUTTON_2 = 2, c.Gamepad.BUTTON_3 = 3, c.Gamepad.BUTTON_4 = 4, c.Gamepad.BUTTON_5 = 5, c.Gamepad.BUTTON_6 = 6, c.Gamepad.BUTTON_7 = 7, c.Gamepad.BUTTON_8 = 8, c.Gamepad.BUTTON_9 = 9, c.Gamepad.BUTTON_10 = 10, c.Gamepad.BUTTON_11 = 11, c.Gamepad.BUTTON_12 = 12, c.Gamepad.BUTTON_13 = 13, c.Gamepad.BUTTON_14 = 14, c.Gamepad.BUTTON_15 = 15, c.Gamepad.AXIS_0 = 0, c.Gamepad.AXIS_1 = 1, c.Gamepad.AXIS_2 = 2, c.Gamepad.AXIS_3 = 3, c.Gamepad.AXIS_4 = 4, c.Gamepad.AXIS_5 = 5, c.Gamepad.AXIS_6 = 6, c.Gamepad.AXIS_7 = 7, c.Gamepad.AXIS_8 = 8, c.Gamepad.AXIS_9 = 9, c.Gamepad.XBOX360_A = 0, c.Gamepad.XBOX360_B = 1, c.Gamepad.XBOX360_X = 2, c.Gamepad.XBOX360_Y = 3, c.Gamepad.XBOX360_LEFT_BUMPER = 4, c.Gamepad.XBOX360_RIGHT_BUMPER = 5, c.Gamepad.XBOX360_LEFT_TRIGGER = 6, c.Gamepad.XBOX360_RIGHT_TRIGGER = 7, c.Gamepad.XBOX360_BACK = 8, c.Gamepad.XBOX360_START = 9, c.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, c.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, c.Gamepad.XBOX360_DPAD_LEFT = 14, c.Gamepad.XBOX360_DPAD_RIGHT = 15, c.Gamepad.XBOX360_DPAD_UP = 12, c.Gamepad.XBOX360_DPAD_DOWN = 13, c.Gamepad.XBOX360_STICK_LEFT_X = 0, c.Gamepad.XBOX360_STICK_LEFT_Y = 1, c.Gamepad.XBOX360_STICK_RIGHT_X = 2, c.Gamepad.XBOX360_STICK_RIGHT_Y = 3, c.Gamepad.PS3XC_X = 0, c.Gamepad.PS3XC_CIRCLE = 1, c.Gamepad.PS3XC_SQUARE = 2, c.Gamepad.PS3XC_TRIANGLE = 3, c.Gamepad.PS3XC_L1 = 4, c.Gamepad.PS3XC_R1 = 5, c.Gamepad.PS3XC_L2 = 6, c.Gamepad.PS3XC_R2 = 7, c.Gamepad.PS3XC_SELECT = 8, c.Gamepad.PS3XC_START = 9, c.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, c.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, c.Gamepad.PS3XC_DPAD_UP = 12, c.Gamepad.PS3XC_DPAD_DOWN = 13, c.Gamepad.PS3XC_DPAD_LEFT = 14, c.Gamepad.PS3XC_DPAD_RIGHT = 15, c.Gamepad.PS3XC_STICK_LEFT_X = 0, c.Gamepad.PS3XC_STICK_LEFT_Y = 1, c.Gamepad.PS3XC_STICK_RIGHT_X = 2, c.Gamepad.PS3XC_STICK_RIGHT_Y = 3, c.SinglePad = function(a, b) { this.game = a, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = b, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0 }, c.SinglePad.prototype = {
            addCallbacks: function(a, b) { "undefined" != typeof b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback, this.callbackContext = a) },
            getButton: function(a) { return this._buttons[a] ? this._buttons[a] : null },
            pollStatus: function() {
                if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                    for (var a = 0; a < this._buttonsLen; a++) {
                        var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
                        b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b))
                    }
                    for (var c = 0; c < this._axesLen; c++) {
                        var d = this._rawPad.axes[c];
                        d > 0 && d > this.deadZone || d < 0 && d < -this.deadZone ? this.processAxisChange(c, d) : this.processAxisChange(c, 0)
                    }
                    this._prevTimestamp = this._rawPad.timestamp
                }
            },
            connect: function(a) {
                var b = !this.connected;
                this.connected = !0, this.index = a.index, this._rawPad = a, this._buttons = [], this._buttonsLen = a.buttons.length, this._axes = [], this._axesLen = a.axes.length;
                for (var d = 0; d < this._axesLen; d++) this._axes[d] = a.axes[d];
                for (var e in a.buttons) e = parseInt(e, 10), this._buttons[e] = new c.DeviceButton(this, e);
                b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
            },
            disconnect: function() {
                var a = this.connected,
                    b = this.index;
                this.connected = !1, this.index = null, this._rawPad = void 0;
                for (var c = 0; c < this._buttonsLen; c++) this._buttons[c].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b), a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
            },
            destroy: function() {
                this._rawPad = void 0;
                for (var a = 0; a < this._buttonsLen; a++) this._buttons[a].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
            },
            processAxisChange: function(a, b) { this._axes[a] !== b && (this._axes[a] = b, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b)) },
            processButtonDown: function(a, b) { this._buttons[a] && this._buttons[a].start(null, b), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b) },
            processButtonUp: function(a, b) { this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].stop(null, b) },
            processButtonFloat: function(a, b) { this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b), this._buttons[a] && this._buttons[a].padFloat(b) },
            axis: function(a) { return !!this._axes[a] && this._axes[a] },
            isDown: function(a) { return !!this._buttons[a] && this._buttons[a].isDown },
            isUp: function(a) { return !!this._buttons[a] && this._buttons[a].isUp },
            justReleased: function(a, b) { if (this._buttons[a]) return this._buttons[a].justReleased(b) },
            justPressed: function(a, b) { if (this._buttons[a]) return this._buttons[a].justPressed(b) },
            buttonValue: function(a) { return this._buttons[a] ? this._buttons[a].value : null },
            reset: function() { for (var a = 0; a < this._axes.length; a++) this._axes[a] = 0 }
        }, c.SinglePad.prototype.constructor = c.SinglePad, c.Key = function(a, b) { this.game = a, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = b, this.onDown = new c.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new c.Signal, this._justDown = !1, this._justUp = !1 }, c.Key.prototype = { update: function() { this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) }, processKeyDown: function(a) { this._enabled && (this.event = a, this.isDown || (this.altKey = a.altKey, this.ctrlKey = a.ctrlKey, this.shiftKey = a.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this))) }, processKeyUp: function(a) { this._enabled && (this.event = a, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this))) }, reset: function(a) { void 0 === a && (a = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, a && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null) }, downDuration: function(a) { return void 0 === a && (a = 50), this.isDown && this.duration < a }, upDuration: function(a) { return void 0 === a && (a = 50), !this.isDown && this.game.time.time - this.timeUp < a } }, Object.defineProperty(c.Key.prototype, "justDown", { get: function() { var a = this._justDown; return this._justDown = !1, a } }), Object.defineProperty(c.Key.prototype, "justUp", { get: function() { var a = this._justUp; return this._justUp = !1, a } }), Object.defineProperty(c.Key.prototype, "enabled", { get: function() { return this._enabled }, set: function(a) { a = !!a, a !== this._enabled && (a || this.reset(!1), this._enabled = a) } }), c.Key.prototype.constructor = c.Key, c.Keyboard = function(a) { this.game = a, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0 }, c.Keyboard.prototype = {
            addCallbacks: function(a, b, c, d) { this.callbackContext = a, void 0 !== b && null !== b && (this.onDownCallback = b), void 0 !== c && null !== c && (this.onUpCallback = c), void 0 !== d && null !== d && (this.onPressCallback = d) },
            addKey: function(a) { return this._keys[a] || (this._keys[a] = new c.Key(this.game, a), this.addKeyCapture(a)), this._keys[a] },
            addKeys: function(a) { var b = {}; for (var c in a) b[c] = this.addKey(a[c]); return b },
            removeKey: function(a) { this._keys[a] && (this._keys[a] = null, this.removeKeyCapture(a)) },
            createCursorKeys: function() { return this.addKeys({ up: c.KeyCode.UP, down: c.KeyCode.DOWN, left: c.KeyCode.LEFT, right: c.KeyCode.RIGHT }) },
            start: function() {
                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                    var a = this;
                    this._onKeyDown = function(b) { return a.processKeyDown(b) }, this._onKeyUp = function(b) { return a.processKeyUp(b) }, this._onKeyPress = function(b) { return a.processKeyPress(b) }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                }
            },
            stop: function() { window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null },
            destroy: function() { this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0 },
            addKeyCapture: function(a) {
                if ("object" == typeof a)
                    for (var b in a) this._capture[a[b]] = !0;
                else this._capture[a] = !0
            },
            removeKeyCapture: function(a) { delete this._capture[a] },
            clearCaptures: function() { this._capture = {} },
            update: function() { for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update() },
            processKeyDown: function(a) {
                if (this.event = a, this.game.input.enabled && this.enabled) {
                    var b = a.keyCode;
                    this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyDown(a), this._k = b, this.onDownCallback && this.onDownCallback.call(this.callbackContext, a)
                }
            },
            processKeyPress: function(a) { this.pressEvent = a, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a) },
            processKeyUp: function(a) {
                if (this.event = a, this.game.input.enabled && this.enabled) {
                    var b = a.keyCode;
                    this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyUp(a), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a)
                }
            },
            reset: function(a) { void 0 === a && (a = !0), this.event = null; for (var b = this._keys.length; b--;) this._keys[b] && this._keys[b].reset(a) },
            downDuration: function(a, b) { return this._keys[a] ? this._keys[a].downDuration(b) : null },
            upDuration: function(a, b) { return this._keys[a] ? this._keys[a].upDuration(b) : null },
            isDown: function(a) { return this._keys[a] ? this._keys[a].isDown : null }
        }, Object.defineProperty(c.Keyboard.prototype, "lastChar", { get: function() { return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode) } }), Object.defineProperty(c.Keyboard.prototype, "lastKey", { get: function() { return this._keys[this._k] } }), c.Keyboard.prototype.constructor = c.Keyboard, c.KeyCode = { A: "A".charCodeAt(0), B: "B".charCodeAt(0), C: "C".charCodeAt(0), D: "D".charCodeAt(0), E: "E".charCodeAt(0), F: "F".charCodeAt(0), G: "G".charCodeAt(0), H: "H".charCodeAt(0), I: "I".charCodeAt(0), J: "J".charCodeAt(0), K: "K".charCodeAt(0), L: "L".charCodeAt(0), M: "M".charCodeAt(0), N: "N".charCodeAt(0), O: "O".charCodeAt(0), P: "P".charCodeAt(0), Q: "Q".charCodeAt(0), R: "R".charCodeAt(0), S: "S".charCodeAt(0), T: "T".charCodeAt(0), U: "U".charCodeAt(0), V: "V".charCodeAt(0), W: "W".charCodeAt(0), X: "X".charCodeAt(0), Y: "Y".charCodeAt(0), Z: "Z".charCodeAt(0), ZERO: "0".charCodeAt(0), ONE: "1".charCodeAt(0), TWO: "2".charCodeAt(0), THREE: "3".charCodeAt(0), FOUR: "4".charCodeAt(0), FIVE: "5".charCodeAt(0), SIX: "6".charCodeAt(0), SEVEN: "7".charCodeAt(0), EIGHT: "8".charCodeAt(0), NINE: "9".charCodeAt(0), NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, NUMPAD_MULTIPLY: 106, NUMPAD_ADD: 107, NUMPAD_ENTER: 108, NUMPAD_SUBTRACT: 109, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, F13: 124, F14: 125, F15: 126, COLON: 186, EQUALS: 187, COMMA: 188, UNDERSCORE: 189, PERIOD: 190, QUESTION_MARK: 191, TILDE: 192, OPEN_BRACKET: 219, BACKWARD_SLASH: 220, CLOSED_BRACKET: 221, QUOTES: 222, BACKSPACE: 8, TAB: 9, CLEAR: 12, ENTER: 13, SHIFT: 16, CONTROL: 17, ALT: 18, CAPS_LOCK: 20, ESC: 27, SPACEBAR: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PLUS: 43, MINUS: 44, INSERT: 45, DELETE: 46, HELP: 47, NUM_LOCK: 144 };
        for (var e in c.KeyCode) c.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/) && (c.Keyboard[e] = c.KeyCode[e]);
        c.Component = function() {}, c.Component.Angle = function() {}, c.Component.Angle.prototype = { angle: { get: function() { return c.Math.wrapAngle(c.Math.radToDeg(this.rotation)) }, set: function(a) { this.rotation = c.Math.degToRad(c.Math.wrapAngle(a)) } } }, c.Component.Animation = function() {}, c.Component.Animation.prototype = { play: function(a, b, c, d) { if (this.animations) return this.animations.play(a, b, c, d) } }, c.Component.AutoCull = function() {}, c.Component.AutoCull.prototype = { autoCull: !1, inCamera: { get: function() { return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds) } } }, c.Component.Bounds = function() {}, c.Component.Bounds.prototype = {
            offsetX: { get: function() { return this.anchor.x * this.width } },
            offsetY: { get: function() { return this.anchor.y * this.height } },
            centerX: { get: function() { return this.x - this.offsetX + .5 * this.width }, set: function(a) { this.x = a + this.offsetX - .5 * this.width } },
            centerY: { get: function() { return this.y - this.offsetY + .5 * this.height }, set: function(a) { this.y = a + this.offsetY - .5 * this.height } },
            left: { get: function() { return this.x - this.offsetX }, set: function(a) { this.x = a + this.offsetX } },
            right: { get: function() { return this.x + this.width - this.offsetX }, set: function(a) { this.x = a - this.width + this.offsetX } },
            top: { get: function() { return this.y - this.offsetY }, set: function(a) { this.y = a + this.offsetY } },
            bottom: { get: function() { return this.y + this.height - this.offsetY }, set: function(a) { this.y = a - this.height + this.offsetY } },
            alignIn: function(a, b, d, e) {
                switch (void 0 === d && (d = 0), void 0 === e && (e = 0), b) {
                    default:
                        case c.TOP_LEFT:
                        this.left = a.left - d,
                    this.top = a.top - e;
                    break;
                    case c.TOP_CENTER:
                            this.centerX = a.centerX + d,
                        this.top = a.top - e;
                        break;
                    case c.TOP_RIGHT:
                            this.right = a.right + d,
                        this.top = a.top - e;
                        break;
                    case c.LEFT_CENTER:
                            this.left = a.left - d,
                        this.centerY = a.centerY + e;
                        break;
                    case c.CENTER:
                            this.centerX = a.centerX + d,
                        this.centerY = a.centerY + e;
                        break;
                    case c.RIGHT_CENTER:
                            this.right = a.right + d,
                        this.centerY = a.centerY + e;
                        break;
                    case c.BOTTOM_LEFT:
                            this.left = a.left - d,
                        this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_CENTER:
                            this.centerX = a.centerX + d,
                        this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_RIGHT:
                            this.right = a.right + d,
                        this.bottom = a.bottom + e
                }
                return this
            },
            alignTo: function(a, b, d, e) {
                switch (void 0 === d && (d = 0), void 0 === e && (e = 0), b) {
                    default:
                        case c.TOP_LEFT:
                        this.left = a.left - d,
                    this.bottom = a.top - e;
                    break;
                    case c.TOP_CENTER:
                            this.centerX = a.centerX + d,
                        this.bottom = a.top - e;
                        break;
                    case c.TOP_RIGHT:
                            this.right = a.right + d,
                        this.bottom = a.top - e;
                        break;
                    case c.LEFT_TOP:
                            this.right = a.left - d,
                        this.top = a.top - e;
                        break;
                    case c.LEFT_CENTER:
                            this.right = a.left - d,
                        this.centerY = a.centerY + e;
                        break;
                    case c.LEFT_BOTTOM:
                            this.right = a.left - d,
                        this.bottom = a.bottom + e;
                        break;
                    case c.RIGHT_TOP:
                            this.left = a.right + d,
                        this.top = a.top - e;
                        break;
                    case c.RIGHT_CENTER:
                            this.left = a.right + d,
                        this.centerY = a.centerY + e;
                        break;
                    case c.RIGHT_BOTTOM:
                            this.left = a.right + d,
                        this.bottom = a.bottom + e;
                        break;
                    case c.BOTTOM_LEFT:
                            this.left = a.left - d,
                        this.top = a.bottom + e;
                        break;
                    case c.BOTTOM_CENTER:
                            this.centerX = a.centerX + d,
                        this.top = a.bottom + e;
                        break;
                    case c.BOTTOM_RIGHT:
                            this.right = a.right + d,
                        this.top = a.bottom + e
                }
                return this
            }
        }, c.Group.prototype.alignIn = c.Component.Bounds.prototype.alignIn, c.Group.prototype.alignTo = c.Component.Bounds.prototype.alignTo, c.Component.BringToTop = function() {}, c.Component.BringToTop.prototype.bringToTop = function() { return this.parent && this.parent.bringToTop(this), this }, c.Component.BringToTop.prototype.sendToBack = function() { return this.parent && this.parent.sendToBack(this), this }, c.Component.BringToTop.prototype.moveUp = function() { return this.parent && this.parent.moveUp(this), this }, c.Component.BringToTop.prototype.moveDown = function() { return this.parent && this.parent.moveDown(this), this }, c.Component.Core = function() {}, c.Component.Core.install = function(a) {
            c.Utils.mixinPrototype(this, c.Component.Core.prototype), this.components = {};
            for (var b = 0; b < a.length; b++) {
                var d = a[b],
                    e = !1;
                "Destroy" === d && (e = !0), c.Utils.mixinPrototype(this, c.Component[d].prototype, e), this.components[d] = !0
            }
        }, c.Component.Core.init = function(a, b, d, e, f) { this.game = a, this.key = e, this.data = {}, this.position.set(b, d), this.world = new c.Point(b, d), this.previousPosition = new c.Point(b, d), this.events = new c.Events(this), this._bounds = new c.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new c.AnimationManager(this)), this.components.LoadTexture && null !== e && this.loadTexture(e, f), this.components.FixedToCamera && (this.cameraOffset = new c.Point(b, d)) }, c.Component.Core.preUpdate = function() {
            if (this.pendingDestroy) return void this.destroy();
            if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
            for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
            return !0
        }, c.Component.Core.prototype = { game: null, name: "", data: {}, components: {}, z: 0, events: void 0, animations: void 0, key: "", world: null, debug: !1, previousPosition: null, previousRotation: 0, renderOrderID: 0, fresh: !0, pendingDestroy: !1, _bounds: null, _exists: !0, exists: { get: function() { return this._exists }, set: function(a) { a ? (this._exists = !0, this.body && this.body.type === c.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === c.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1) } }, update: function() {}, postUpdate: function() { this.customRender && this.key.render(), this.components.PhysicsBody && c.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && c.Component.FixedToCamera.postUpdate.call(this); for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate() } }, c.Component.Crop = function() {}, c.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(a, b) { void 0 === b && (b = !1), a ? (b && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : b && null === this.cropRect ? this.cropRect = new c.Rectangle(a.x, a.y, a.width, a.height) : this.cropRect = a, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame()) },
            updateCrop: function() {
                if (this.cropRect) {
                    var a = this.texture.crop.x,
                        b = this.texture.crop.y,
                        d = this.texture.crop.width,
                        e = this.texture.crop.height;
                    this._crop = c.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var f = Math.max(this._frame.x, this._crop.x),
                        g = Math.max(this._frame.y, this._crop.y),
                        h = Math.min(this._frame.right, this._crop.right) - f,
                        i = Math.min(this._frame.bottom, this._crop.bottom) - g;
                    this.texture.crop.x = f, this.texture.crop.y = g, this.texture.crop.width = h, this.texture.crop.height = i, this.texture.frame.width = Math.min(h, this.cropRect.width), this.texture.frame.height = Math.min(i, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || a === f && b === g && d === h && e === i || (this.texture.requiresReTint = !0)
                }
            }
        }, c.Component.Delta = function() {}, c.Component.Delta.prototype = { deltaX: { get: function() { return this.world.x - this.previousPosition.x } }, deltaY: { get: function() { return this.world.y - this.previousPosition.y } }, deltaZ: { get: function() { return this.rotation - this.previousRotation } } }, c.Component.Destroy = function() {}, c.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(a, b) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === a && (a = !0), void 0 === b && (b = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var d = this.children.length;
                    if (a)
                        for (; d--;) this.children[d].destroy(a);
                    else
                        for (; d--;) this.removeChild(this.children[d]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), c.Video && this.key instanceof c.Video && this.key.onChangeSource.remove(this.resizeFrame, this), c.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), b && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        }, c.Events = function(a) { this.parent = a }, c.Events.prototype = { destroy: function() { this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose() }, onAddedToGroup: null, onRemovedFromGroup: null, onRemovedFromWorld: null, onDestroy: null, onKilled: null, onRevived: null, onOutOfBounds: null, onEnterBounds: null, onInputOver: null, onInputOut: null, onInputDown: null, onInputUp: null, onDragStart: null, onDragUpdate: null, onDragStop: null, onAnimationStart: null, onAnimationComplete: null, onAnimationLoop: null }, c.Events.prototype.constructor = c.Events;
        for (var f in c.Events.prototype) c.Events.prototype.hasOwnProperty(f) && 0 === f.indexOf("on") && null === c.Events.prototype[f] && ! function(a, b) {
            "use strict";
            Object.defineProperty(c.Events.prototype, a, { get: function() { return this[b] || (this[b] = new c.Signal) } }), c.Events.prototype[a + "$dispatch"] = function() { return this[b] ? this[b].dispatch.apply(this[b], arguments) : null }
        }(f, "_" + f);
        c.Component.FixedToCamera = function() {}, c.Component.FixedToCamera.postUpdate = function() { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y) }, c.Component.FixedToCamera.prototype = { _fixedToCamera: !1, fixedToCamera: { get: function() { return this._fixedToCamera }, set: function(a) { a ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1 } }, cameraOffset: new c.Point }, c.Component.Health = function() {}, c.Component.Health.prototype = { health: 1, maxHealth: 100, damage: function(a) { return this.alive && (this.health -= a, this.health <= 0 && this.kill()), this }, setHealth: function(a) { return this.health = a, this.health > this.maxHealth && (this.health = this.maxHealth), this }, heal: function(a) { return this.alive && (this.health += a, this.health > this.maxHealth && (this.health = this.maxHealth)), this } }, c.Component.InCamera = function() {}, c.Component.InCamera.prototype = { inCamera: { get: function() { return this.game.world.camera.view.intersects(this._bounds) } } }, c.Component.InputEnabled = function() {}, c.Component.InputEnabled.prototype = { input: null, inputEnabled: { get: function() { return this.input && this.input.enabled }, set: function(a) { a ? null === this.input ? (this.input = new c.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop() } } }, c.Component.InWorld = function() {}, c.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, c.Component.InWorld.prototype = { checkWorldBounds: !1, outOfBoundsKill: !1, outOfCameraBoundsKill: !1, _outOfBoundsFired: !1, inWorld: { get: function() { return this.game.world.bounds.intersects(this.getBounds()) } } }, c.Component.LifeSpan = function() {}, c.Component.LifeSpan.preUpdate = function() { return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1) }, c.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(a) {
                return void 0 === a && (a = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(a), this.events && this.events.onRevived$dispatch(this),
                    this
            },
            kill: function() { return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this }
        }, c.Component.LoadTexture = function() {}, c.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(a, b, d) {
                a === c.PENDING_ATLAS ? (a = b, b = 0) : b = b || 0, (d || void 0 === d) && this.animations && this.animations.stop(), this.key = a, this.customRender = !1;
                var e = this.game.cache,
                    f = !0,
                    g = !this.texture.baseTexture.scaleMode;
                if (c.RenderTexture && a instanceof c.RenderTexture) this.key = a.key, this.setTexture(a);
                else if (c.BitmapData && a instanceof c.BitmapData) this.customRender = !0, this.setTexture(a.texture), f = e.hasFrameData(a.key, c.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(a.key, c.Cache.BITMAPDATA), b) : !this.animations.loadFrameData(a.frameData, 0);
                else if (c.Video && a instanceof c.Video) {
                    this.customRender = !0;
                    var h = a.texture.valid;
                    this.setTexture(a.texture), this.setFrame(a.texture.frame.clone()), a.onChangeSource.add(this.resizeFrame, this), this.texture.valid = h
                }
                else if (c.Tilemap && a instanceof c.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(a.canvas));
                else if (a instanceof PIXI.Texture) this.setTexture(a);
                else {
                    var i = e.getImage(a, !0);
                    this.key = i.key, this.setTexture(new PIXI.Texture(i.base)), "__default" === a ? this.texture.baseTexture.skipRender = !0 : this.texture.baseTexture.skipRender = !1, f = !this.animations.loadFrameData(i.frameData, b)
                }
                f && (this._frame = c.Rectangle.clone(this.texture.frame)), g || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(a) { this._frame = a, this.texture.frame.x = a.x, this.texture.frame.y = a.y, this.texture.frame.width = a.width, this.texture.frame.height = a.height, this.texture.crop.x = a.x, this.texture.crop.y = a.y, this.texture.crop.width = a.width, this.texture.crop.height = a.height, a.trimmed ? (this.texture.trim ? (this.texture.trim.x = a.spriteSourceSizeX, this.texture.trim.y = a.spriteSourceSizeY, this.texture.trim.width = a.sourceSizeW, this.texture.trim.height = a.sourceSizeH) : this.texture.trim = { x: a.spriteSourceSizeX, y: a.spriteSourceSizeY, width: a.sourceSizeW, height: a.sourceSizeH }, this.texture.width = a.sourceSizeW, this.texture.height = a.sourceSizeH, this.texture.frame.width = a.sourceSizeW, this.texture.frame.height = a.sourceSizeH) : !a.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0) },
            resizeFrame: function(a, b, c) { this.texture.frame.resize(b, c), this.texture.setFrame(this.texture.frame) },
            resetFrame: function() { this._frame && this.setFrame(this._frame) },
            frame: { get: function() { return this.animations.frame }, set: function(a) { this.animations.frame = a } },
            frameName: { get: function() { return this.animations.frameName }, set: function(a) { this.animations.frameName = a } }
        }, c.Component.Overlap = function() {}, c.Component.Overlap.prototype = { overlap: function(a) { return c.Rectangle.intersects(this.getBounds(), a.getBounds()) } }, c.Component.PhysicsBody = function() {}, c.Component.PhysicsBody.preUpdate = function() { return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1)) }, c.Component.PhysicsBody.postUpdate = function() { this.exists && this.body && this.body.postUpdate() }, c.Component.PhysicsBody.prototype = { body: null, x: { get: function() { return this.position.x }, set: function(a) { this.position.x = a, this.body && !this.body.dirty && (this.body._reset = !0) } }, y: { get: function() { return this.position.y }, set: function(a) { this.position.y = a, this.body && !this.body.dirty && (this.body._reset = !0) } } }, c.Component.Reset = function() {}, c.Component.Reset.prototype.reset = function(a, b, c) { return void 0 === c && (c = 1), this.world.set(a, b), this.position.set(a, b), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = c), this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1), this }, c.Component.ScaleMinMax = function() {}, c.Component.ScaleMinMax.prototype = { transformCallback: null, transformCallbackContext: this, scaleMin: null, scaleMax: null, checkTransform: function(a) { this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x), a.d < this.scaleMin.y && (a.d = this.scaleMin.y)), this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x), a.d > this.scaleMax.y && (a.d = this.scaleMax.y)) }, setScaleMinMax: function(a, b, d, e) { void 0 === b ? b = d = e = a : void 0 === d && (d = e = b, b = a), null === a ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(a, b) : this.scaleMin = new c.Point(a, b), null === d ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(d, e) : this.scaleMax = new c.Point(d, e), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this) } }, c.Component.Smoothed = function() {}, c.Component.Smoothed.prototype = { smoothed: { get: function() { return !this.texture.baseTexture.scaleMode }, set: function(a) { a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1) } } }, c.GameObjectFactory = function(a) { this.game = a, this.world = this.game.world }, c.GameObjectFactory.prototype = {
            existing: function(a) { return this.world.add(a) },
            weapon: function(a, b, d, e) { var f = this.game.plugins.add(c.Weapon); return f.createBullets(a, b, d, e), f },
            image: function(a, b, d, e, f) { return void 0 === f && (f = this.world), f.add(new c.Image(this.game, a, b, d, e)) },
            sprite: function(a, b, c, d, e) { return void 0 === e && (e = this.world), e.create(a, b, c, d) },
            creature: function(a, b, d, e, f) { void 0 === f && (f = this.world); var g = new c.Creature(this.game, a, b, d, e); return f.add(g), g },
            tween: function(a) { return this.game.tweens.create(a) },
            group: function(a, b, d, e, f) { return new c.Group(this.game, a, b, d, e, f) },
            physicsGroup: function(a, b, d, e) { return new c.Group(this.game, b, d, e, (!0), a) },
            spriteBatch: function(a, b, d) { return void 0 === a && (a = null), void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d) },
            audio: function(a, b, c, d) { return this.game.sound.add(a, b, c, d) },
            sound: function(a, b, c, d) { return this.game.sound.add(a, b, c, d) },
            audioSprite: function(a) { return this.game.sound.addSprite(a) },
            tileSprite: function(a, b, d, e, f, g, h) { return void 0 === h && (h = this.world), h.add(new c.TileSprite(this.game, a, b, d, e, f, g)) },
            rope: function(a, b, d, e, f, g) { return void 0 === g && (g = this.world), g.add(new c.Rope(this.game, a, b, d, e, f)) },
            text: function(a, b, d, e, f) { return void 0 === f && (f = this.world), f.add(new c.Text(this.game, a, b, d, e)) },
            button: function(a, b, d, e, f, g, h, i, j, k) { return void 0 === k && (k = this.world), k.add(new c.Button(this.game, a, b, d, e, f, g, h, i, j)) },
            graphics: function(a, b, d) { return void 0 === d && (d = this.world), d.add(new c.Graphics(this.game, a, b)) },
            emitter: function(a, b, d) { return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game, a, b, d)) },
            retroFont: function(a, b, d, e, f, g, h, i, j) { return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j) },
            bitmapText: function(a, b, d, e, f, g) { return void 0 === g && (g = this.world), g.add(new c.BitmapText(this.game, a, b, d, e, f)) },
            tilemap: function(a, b, d, e, f) { return new c.Tilemap(this.game, a, b, d, e, f) },
            renderTexture: function(a, b, d, e) { void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1); var f = new c.RenderTexture(this.game, a, b, d); return e && this.game.cache.addRenderTexture(d, f), f },
            video: function(a, b) { return new c.Video(this.game, a, b) },
            bitmapData: function(a, b, d, e) { void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid()); var f = new c.BitmapData(this.game, d, a, b); return e && this.game.cache.addBitmapData(d, f), f },
            filter: function(a) {
                var b = Array.prototype.slice.call(arguments, 1),
                    a = new c.Filter[a](this.game);
                return a.init.apply(a, b), a
            },
            plugin: function(a) { return this.game.plugins.add(a) }
        }, c.GameObjectFactory.prototype.constructor = c.GameObjectFactory, c.GameObjectCreator = function(a) { this.game = a, this.world = this.game.world }, c.GameObjectCreator.prototype = {
            image: function(a, b, d, e) { return new c.Image(this.game, a, b, d, e) },
            sprite: function(a, b, d, e) { return new c.Sprite(this.game, a, b, d, e) },
            tween: function(a) { return new c.Tween(a, this.game, this.game.tweens) },
            group: function(a, b, d, e, f) { return new c.Group(this.game, a, b, d, e, f) },
            spriteBatch: function(a, b, d) { return void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d) },
            audio: function(a, b, c, d) { return this.game.sound.add(a, b, c, d) },
            audioSprite: function(a) { return this.game.sound.addSprite(a) },
            sound: function(a, b, c, d) { return this.game.sound.add(a, b, c, d) },
            tileSprite: function(a, b, d, e, f, g) { return new c.TileSprite(this.game, a, b, d, e, f, g) },
            rope: function(a, b, d, e, f) { return new c.Rope(this.game, a, b, d, e, f) },
            text: function(a, b, d, e) { return new c.Text(this.game, a, b, d, e) },
            button: function(a, b, d, e, f, g, h, i, j) { return new c.Button(this.game, a, b, d, e, f, g, h, i, j) },
            graphics: function(a, b) { return new c.Graphics(this.game, a, b) },
            emitter: function(a, b, d) { return new c.Particles.Arcade.Emitter(this.game, a, b, d) },
            retroFont: function(a, b, d, e, f, g, h, i, j) { return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j) },
            bitmapText: function(a, b, d, e, f, g) { return new c.BitmapText(this.game, a, b, d, e, f, g) },
            tilemap: function(a, b, d, e, f) { return new c.Tilemap(this.game, a, b, d, e, f) },
            renderTexture: function(a, b, d, e) { void 0 !== d && "" !== d || (d = this.game.rnd.uuid()), void 0 === e && (e = !1); var f = new c.RenderTexture(this.game, a, b, d); return e && this.game.cache.addRenderTexture(d, f), f },
            bitmapData: function(a, b, d, e) { void 0 === e && (e = !1), void 0 !== d && "" !== d || (d = this.game.rnd.uuid()); var f = new c.BitmapData(this.game, d, a, b); return e && this.game.cache.addBitmapData(d, f), f },
            filter: function(a) {
                var b = Array.prototype.slice.call(arguments, 1),
                    a = new c.Filter[a](this.game);
                return a.init.apply(a, b), a
            }
        }, c.GameObjectCreator.prototype.constructor = c.GameObjectCreator, c.Sprite = function(a, b, d, e, f) { b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.SPRITE, this.physicsType = c.SPRITE, PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f) }, c.Sprite.prototype = Object.create(PIXI.Sprite.prototype), c.Sprite.prototype.constructor = c.Sprite, c.Component.Core.install.call(c.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), c.Sprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Sprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Sprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Sprite.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Sprite.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.Image = function(a, b, d, e, f) { b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.IMAGE, PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f) }, c.Image.prototype = Object.create(PIXI.Sprite.prototype), c.Image.prototype.constructor = c.Image, c.Component.Core.install.call(c.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), c.Image.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Image.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Image.prototype.preUpdate = function() { return !!this.preUpdateInWorld() && this.preUpdateCore() }, c.Button = function(a, b, d, e, f, g, h, i, j, k) { b = b || 0, d = d || 0, e = e || null, f = f || null, g = g || this, c.Image.call(this, a, b, d, e, i), this.type = c.BUTTON, this.physicsType = c.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new c.Signal, this.onInputOut = new c.Signal, this.onInputDown = new c.Signal, this.onInputUp = new c.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = c.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(h, i, j, k), null !== f && this.onInputUp.add(f, g), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this) }, c.Button.prototype = Object.create(c.Image.prototype), c.Button.prototype.constructor = c.Button;
        var g = "Over",
            h = "Out",
            i = "Down",
            j = "Up";
        c.Button.prototype.clearFrames = function() { this.setFrames(null, null, null, null) }, c.Button.prototype.removedFromWorld = function() { this.inputEnabled = !1 }, c.Button.prototype.setStateFrame = function(a, b, c) {
                var d = "_on" + a + "Frame";
                null !== b ? (this[d] = b, c && this.changeStateFrame(a)) : this[d] = null
            }, c.Button.prototype.changeStateFrame = function(a) {
                if (this.freezeFrames) return !1;
                var b = "_on" + a + "Frame",
                    c = this[b];
                return "string" == typeof c ? (this.frameName = c, !0) : "number" == typeof c && (this.frame = c, !0)
            }, c.Button.prototype.setFrames = function(a, b, c, d) { this.setStateFrame(g, a, this.input.pointerOver()), this.setStateFrame(h, b, !this.input.pointerOver()), this.setStateFrame(i, c, this.input.pointerDown()), this.setStateFrame(j, d, this.input.pointerUp()) }, c.Button.prototype.setStateSound = function(a, b, d) {
                var e = "on" + a + "Sound",
                    f = "on" + a + "SoundMarker";
                b instanceof c.Sound || b instanceof c.AudioSprite ? (this[e] = b, this[f] = "string" == typeof d ? d : "") : (this[e] = null, this[f] = "")
            }, c.Button.prototype.playStateSound = function(a) {
                var b = "on" + a + "Sound",
                    c = this[b];
                if (c) {
                    var d = "on" + a + "SoundMarker",
                        e = this[d];
                    return c.play(e), !0
                }
                return !1
            }, c.Button.prototype.setSounds = function(a, b, c, d, e, f, k, l) { this.setStateSound(g, a, b), this.setStateSound(h, e, f), this.setStateSound(i, c, d), this.setStateSound(j, k, l) }, c.Button.prototype.setOverSound = function(a, b) { this.setStateSound(g, a, b) }, c.Button.prototype.setOutSound = function(a, b) { this.setStateSound(h, a, b) }, c.Button.prototype.setDownSound = function(a, b) { this.setStateSound(i, a, b) }, c.Button.prototype.setUpSound = function(a, b) { this.setStateSound(j, a, b) }, c.Button.prototype.onInputOverHandler = function(a, b) { b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode || (this.changeStateFrame(g), this.onOverMouseOnly && !b.isMouse || (this.playStateSound(g), this.onInputOver && this.onInputOver.dispatch(this, b))) }, c.Button.prototype.onInputOutHandler = function(a, b) { this.changeStateFrame(h), this.playStateSound(h), this.onInputOut && this.onInputOut.dispatch(this, b) }, c.Button.prototype.onInputDownHandler = function(a, b) { this.changeStateFrame(i), this.playStateSound(i), this.onInputDown && this.onInputDown.dispatch(this, b) }, c.Button.prototype.onInputUpHandler = function(a, b, c) {
                if (this.playStateSound(j), this.onInputUp && this.onInputUp.dispatch(this, b, c), !this.freezeFrames)
                    if (this.forceOut === !0 || (this.forceOut & b.pointerMode) === b.pointerMode) this.changeStateFrame(h);
                    else {
                        var d = this.changeStateFrame(j);
                        d || (c ? this.changeStateFrame(g) : this.changeStateFrame(h))
                    }
            }, c.SpriteBatch = function(a, b, d, e) { void 0 !== b && null !== b || (b = a.world), PIXI.SpriteBatch.call(this), c.Group.call(this, a, b, d, e), this.type = c.SPRITEBATCH }, c.SpriteBatch.prototype = c.Utils.extend(!0, c.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, c.Group.prototype), c.SpriteBatch.prototype.constructor = c.SpriteBatch, c.BitmapData = function(a, b, d, e, f) { void 0 !== d && 0 !== d || (d = 256), void 0 !== e && 0 !== e || (e = 256), void 0 === f && (f = !1), this.game = a, this.key = b, this.width = d, this.height = e, this.canvas = c.Canvas.create(this, d, e, null, f), this.context = this.canvas.getContext("2d", { alpha: !0 }), this.ctx = this.context, this.smoothProperty = a.renderType === c.CANVAS ? a.renderer.renderSession.smoothProperty : c.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, d, e), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new c.FrameData, this.textureFrame = this.frameData.addFrame(new c.Frame(0, 0, 0, d, e, "bitmapData")), this.texture.frame = this.textureFrame, this.type = c.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new c.Point, this._size = new c.Point, this._scale = new c.Point, this._rotate = 0, this._alpha = { prev: 1, current: 1 }, this._anchor = new c.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new c.Circle, this._swapCanvas = void 0 }, c.BitmapData.prototype = {
                move: function(a, b, c) { return 0 !== a && this.moveH(a, c), 0 !== b && this.moveV(b, c), this },
                moveH: function(a, b) {
                    void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                    var c = this._swapCanvas,
                        d = c.getContext("2d"),
                        e = this.height,
                        f = this.canvas;
                    if (d.clearRect(0, 0, this.width, this.height), a < 0) {
                        a = Math.abs(a);
                        var g = this.width - a;
                        b && d.drawImage(f, 0, 0, a, e, g, 0, a, e), d.drawImage(f, a, 0, g, e, 0, 0, g, e)
                    }
                    else {
                        var g = this.width - a;
                        b && d.drawImage(f, g, 0, a, e, 0, 0, a, e), d.drawImage(f, 0, 0, g, e, a, 0, g, e)
                    }
                    return this.clear(), this.copy(this._swapCanvas)
                },
                moveV: function(a, b) {
                    void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                    var c = this._swapCanvas,
                        d = c.getContext("2d"),
                        e = this.width,
                        f = this.canvas;
                    if (d.clearRect(0, 0, this.width, this.height), a < 0) {
                        a = Math.abs(a);
                        var g = this.height - a;
                        b && d.drawImage(f, 0, 0, e, a, 0, g, e, a), d.drawImage(f, 0, a, e, g, 0, 0, e, g)
                    }
                    else {
                        var g = this.height - a;
                        b && d.drawImage(f, 0, g, e, a, 0, 0, e, a), d.drawImage(f, 0, 0, e, g, 0, a, e, g)
                    }
                    return this.clear(), this.copy(this._swapCanvas)
                },
                add: function(a) {
                    if (Array.isArray(a))
                        for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
                    else a.loadTexture(this);
                    return this
                },
                load: function(a) { if ("string" == typeof a && (a = this.game.cache.getImage(a)), a) return this.resize(a.width, a.height), this.cls(), this.draw(a), this.update(), this },
                clear: function(a, b, c, d) { return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.width), void 0 === d && (d = this.height), this.context.clearRect(a, b, c, d), this.dirty = !0, this },
                fill: function(a, b, c, d) { return void 0 === d && (d = 1), this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this },
                generateTexture: function(a) {
                    var b = new Image;
                    b.src = this.canvas.toDataURL("image/png");
                    var c = this.game.cache.addImage(a, "", b);
                    return new PIXI.Texture(c.base)
                },
                resize: function(a, b) { return a === this.width && b === this.height || (this.width = a, this.height = b, this.canvas.width = a, this.canvas.height = b, void 0 !== this._swapCanvas && (this._swapCanvas.width = a, this._swapCanvas.height = b), this.baseTexture.width = a, this.baseTexture.height = b, this.textureFrame.width = a, this.textureFrame.height = b, this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.update(), this.dirty = !0), this },
                update: function(a, b, c, d) { return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = Math.max(1, this.width)), void 0 === d && (d = Math.max(1, this.height)), this.imageData = this.context.getImageData(a, b, c, d), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this },
                processPixelRGB: function(a, b, d, e, f, g) {
                    void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = this.width), void 0 === g && (g = this.height);
                    for (var h = d + f, i = e + g, j = c.Color.createColor(), k = { r: 0, g: 0, b: 0, a: 0 }, l = !1, m = e; m < i; m++)
                        for (var n = d; n < h; n++) c.Color.unpackPixel(this.getPixel32(n, m), j), k = a.call(b, j, n, m), k !== !1 && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1), l = !0);
                    return l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                },
                processPixel: function(a, b, c, d, e, f) {
                    void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = this.width), void 0 === f && (f = this.height);
                    for (var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; l < h; l++)
                        for (var m = c; m < g; m++) i = this.getPixel32(m, l), j = a.call(b, i, m, l), j !== i && (this.pixels[l * this.width + m] = j, k = !0);
                    return k && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                },
                replaceRGB: function(a, b, d, e, f, g, h, i, j) {
                    var k = 0,
                        l = 0,
                        m = this.width,
                        n = this.height,
                        o = c.Color.packPixel(a, b, d, e);
                    void 0 !== j && j instanceof c.Rectangle && (k = j.x, l = j.y, m = j.width, n = j.height);
                    for (var p = 0; p < n; p++)
                        for (var q = 0; q < m; q++) this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                },
                setHSL: function(a, b, d, e) {
                    var f = a || 0 === a,
                        g = b || 0 === b,
                        h = d || 0 === d;
                    if (f || g || h) {
                        void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                        for (var i = c.Color.createColor(), j = e.y; j < e.bottom; j++)
                            for (var k = e.x; k < e.right; k++) c.Color.unpackPixel(this.getPixel32(k, j), i, !0), f && (i.h = a), g && (i.s = b), h && (i.l = d), c.Color.HSLtoRGB(i.h, i.s, i.l, i), this.setPixel32(k, j, i.r, i.g, i.b, i.a, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    }
                },
                shiftHSL: function(a, b, d, e) {
                    if (void 0 !== a && null !== a || (a = !1), void 0 !== b && null !== b || (b = !1), void 0 !== d && null !== d || (d = !1), a || b || d) {
                        void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
                        for (var f = c.Color.createColor(), g = e.y; g < e.bottom; g++)
                            for (var h = e.x; h < e.right; h++) c.Color.unpackPixel(this.getPixel32(h, g), f, !0), a && (f.h = this.game.math.wrap(f.h + a, 0, 1)), b && (f.s = this.game.math.clamp(f.s + b, 0, 1)), d && (f.l = this.game.math.clamp(f.l + d, 0, 1)), c.Color.HSLtoRGB(f.h, f.s, f.l, f), this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    }
                },
                setPixel32: function(a, b, d, e, f, g, h) { return void 0 === h && (h = !0), a >= 0 && a <= this.width && b >= 0 && b <= this.height && (c.Device.LITTLE_ENDIAN ? this.pixels[b * this.width + a] = g << 24 | f << 16 | e << 8 | d : this.pixels[b * this.width + a] = d << 24 | e << 16 | f << 8 | g, h && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this },
                setPixel: function(a, b, c, d, e, f) { return this.setPixel32(a, b, c, d, e, 255, f) },
                getPixel: function(a, b, d) { d || (d = c.Color.createColor()); var e = ~~(a + b * this.width); return e *= 4, d.r = this.data[e], d.g = this.data[++e], d.b = this.data[++e], d.a = this.data[++e], d },
                getPixel32: function(a, b) { if (a >= 0 && a <= this.width && b >= 0 && b <= this.height) return this.pixels[b * this.width + a] },
                getPixelRGB: function(a, b, d, e, f) { return c.Color.unpackPixel(this.getPixel32(a, b), d, e, f) },
                getPixels: function(a) { return this.context.getImageData(a.x, a.y, a.width, a.height) },
                getFirstPixel: function(a) {
                    void 0 === a && (a = 0);
                    var b = c.Color.createColor(),
                        d = 0,
                        e = 0,
                        f = 1,
                        g = !1;
                    1 === a ? (f = -1, e = this.height) : 3 === a && (f = -1, d = this.width);
                    do c.Color.unpackPixel(this.getPixel32(d, e), b), 0 === a || 1 === a ? (d++, d === this.width && (d = 0, e += f, (e >= this.height || e <= 0) && (g = !0))) : 2 !== a && 3 !== a || (e++, e === this.height && (e = 0, d += f, (d >= this.width || d <= 0) && (g = !0))); while (0 === b.a && !g);
                    return b.x = d, b.y = e, b
                },
                getBounds: function(a) { return void 0 === a && (a = new c.Rectangle), a.x = this.getFirstPixel(2).x, a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y, a.width = this.getFirstPixel(3).x - a.x + 1, a.height = this.getFirstPixel(1).y - a.y + 1, a) },
                addToWorld: function(a, b, c, d, e, f) { e = e || 1, f = f || 1; var g = this.game.add.image(a, b, this); return g.anchor.set(c, d), g.scale.set(e, f), g },
                copy: function(a, b, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
                    if (void 0 !== a && null !== a || (a = this), (a instanceof c.RenderTexture || a instanceof PIXI.RenderTexture) && (a = a.getCanvas()), this._image = a, a instanceof c.Sprite || a instanceof c.Image || a instanceof c.Text || a instanceof PIXI.Sprite) this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), this._scale.set(a.scale.x, a.scale.y), this._anchor.set(a.anchor.x, a.anchor.y), this._rotate = a.rotation, this._alpha.current = a.alpha, a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source, void 0 !== g && null !== g || (g = a.x), void 0 !== h && null !== h || (h = a.y), a.texture.trim && (g += a.texture.trim.x - a.anchor.x * a.texture.trim.width, h += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0));
                    else {
                        if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, a instanceof c.BitmapData) this._image = a.canvas;
                        else if ("string" == typeof a) {
                            if (a = this.game.cache.getImage(a), null === a) return;
                            this._image = a
                        }
                        this._size.set(this._image.width, this._image.height)
                    }
                    if (void 0 !== b && null !== b || (b = 0), void 0 !== d && null !== d || (d = 0), e && (this._size.x = e), f && (this._size.y = f), void 0 !== g && null !== g || (g = b), void 0 !== h && null !== h || (h = d), void 0 !== i && null !== i || (i = this._size.x), void 0 !== j && null !== j || (j = this._size.y), "number" == typeof k && (this._rotate = k), "number" == typeof l && (this._anchor.x = l), "number" == typeof m && (this._anchor.y = m), "number" == typeof n && (this._scale.x = n), "number" == typeof o && (this._scale.y = o), "number" == typeof p && (this._alpha.current = p), void 0 === q && (q = null), void 0 === r && (r = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) { var s = this.context; return this._alpha.prev = s.globalAlpha, s.save(), s.globalAlpha = this._alpha.current, q && (this.op = q), r && (g |= 0, h |= 0), s.translate(g, h), s.scale(this._scale.x, this._scale.y), s.rotate(this._rotate), s.drawImage(this._image, this._pos.x + b, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j), s.restore(), s.globalAlpha = this._alpha.prev, this.dirty = !0, this }
                },
                copyTransform: function(a, b, d) {
                    if (void 0 === b && (b = null), void 0 === d && (d = !1), !a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha) return this;
                    var e = a.worldTransform;
                    if (this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), 0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y) return this;
                    a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source;
                    var f = e.tx,
                        g = e.ty;
                    a.texture.trim && (f += a.texture.trim.x - a.anchor.x * a.texture.trim.width, g += a.texture.trim.y - a.anchor.y * a.texture.trim.height), 16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint, a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)), this._image = a.tintedTexture, this._pos.set(0)), d && (f |= 0, g |= 0);
                    var h = this.context;
                    return this._alpha.prev = h.globalAlpha, h.save(), h.globalAlpha = this._alpha.current, b && (this.op = b), h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, h.setTransform(e.a, e.b, e.c, e.d, f, g), h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y), h.restore(), h.globalAlpha = this._alpha.prev, this.dirty = !0, this
                },
                copyRect: function(a, b, c, d, e, f, g) { return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g) },
                draw: function(a, b, c, d, e, f, g) { return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g) },
                drawGroup: function(a, b, c) { return a.total > 0 && a.forEachExists(this.drawGroupProxy, this, b, c), this },
                drawGroupProxy: function(a, b, d) {
                    if (a.hasOwnProperty("texture") && this.copyTransform(a, b, d), a.type === c.GROUP && a.exists) this.drawGroup(a, b, d);
                    else if (a.hasOwnProperty("children") && a.children.length > 0)
                        for (var e = 0; e < a.children.length; e++) a.children[e].exists && this.copyTransform(a.children[e], b, d)
                },
                drawFull: function(a, b, d) {
                    if (a.worldVisible === !1 || 0 === a.worldAlpha || a.hasOwnProperty("exists") && a.exists === !1) return this;
                    if (a.type !== c.GROUP && a.type !== c.EMITTER && a.type !== c.BITMAPTEXT)
                        if (a.type === c.GRAPHICS) {
                            var e = a.getBounds();
                            this.ctx.save(), this.ctx.translate(e.x, e.y), PIXI.CanvasGraphics.renderGraphics(a, this.ctx), this.ctx.restore()
                        }
                    else this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, b, d);
                    if (a.children)
                        for (var f = 0; f < a.children.length; f++) this.drawFull(a.children[f], b, d);
                    return this
                },
                shadow: function(a, b, c, d) { var e = this.context; return void 0 === a || null === a ? e.shadowColor = "rgba(0,0,0,0)" : (e.shadowColor = a, e.shadowBlur = b || 5, e.shadowOffsetX = c || 10, e.shadowOffsetY = d || 10), this },
                alphaMask: function(a, b, c, d) { return void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(), void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(), this },
                extract: function(a, b, c, d, e, f, g, h, i) { return void 0 === e && (e = 255), void 0 === f && (f = !1), void 0 === g && (g = b), void 0 === h && (h = c), void 0 === i && (i = d), f && a.resize(this.width, this.height), this.processPixelRGB(function(f, j, k) { return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1), !1 }, this), a.context.putImageData(a.imageData, 0, 0), a.dirty = !0, a },
                rect: function(a, b, c, d, e) { return "undefined" != typeof e && (this.context.fillStyle = e), this.context.fillRect(a, b, c, d), this },
                text: function(a, b, c, d, e, f) {
                    void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = "14px Courier"), void 0 === e && (e = "rgb(255,255,255)"), void 0 === f && (f = !0);
                    var g = this.context,
                        h = g.font;
                    return g.font = d, f && (g.fillStyle = "rgb(0,0,0)", g.fillText(a, b + 1, c + 1)), g.fillStyle = e, g.fillText(a, b, c), g.font = h, this
                },
                circle: function(a, b, c, d) { var e = this.context; return void 0 !== d && (e.fillStyle = d), e.beginPath(), e.arc(a, b, c, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), this },
                line: function(a, b, c, d, e, f) { void 0 === e && (e = "#fff"), void 0 === f && (f = 1); var g = this.context; return g.beginPath(), g.moveTo(a, b), g.lineTo(c, d), g.lineWidth = f, g.strokeStyle = e, g.stroke(), g.closePath(), this },
                textureLine: function(a, b, d) { if (void 0 === d && (d = "repeat-x"), "string" != typeof b || (b = this.game.cache.getImage(b))) { var e = a.length; "no-repeat" === d && e > b.width && (e = b.width); var f = this.context; return f.fillStyle = f.createPattern(b, d), this._circle = new c.Circle(a.start.x, a.start.y, b.height), this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos), f.save(), f.translate(this._pos.x, this._pos.y), f.rotate(a.angle), f.fillRect(0, 0, e, b.height), f.restore(), this.dirty = !0, this } },
                render: function() { return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this },
                destroy: function() { this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this) },
                blendReset: function() { return this.op = "source-over", this },
                blendSourceOver: function() { return this.op = "source-over", this },
                blendSourceIn: function() { return this.op = "source-in", this },
                blendSourceOut: function() { return this.op = "source-out", this },
                blendSourceAtop: function() { return this.op = "source-atop", this },
                blendDestinationOver: function() { return this.op = "destination-over", this },
                blendDestinationIn: function() { return this.op = "destination-in", this },
                blendDestinationOut: function() { return this.op = "destination-out", this },
                blendDestinationAtop: function() { return this.op = "destination-atop", this },
                blendXor: function() { return this.op = "xor", this },
                blendAdd: function() { return this.op = "lighter", this },
                blendMultiply: function() { return this.op = "multiply", this },
                blendScreen: function() { return this.op = "screen", this },
                blendOverlay: function() { return this.op = "overlay", this },
                blendDarken: function() { return this.op = "darken", this },
                blendLighten: function() { return this.op = "lighten", this },
                blendColorDodge: function() { return this.op = "color-dodge", this },
                blendColorBurn: function() { return this.op = "color-burn", this },
                blendHardLight: function() { return this.op = "hard-light", this },
                blendSoftLight: function() { return this.op = "soft-light", this },
                blendDifference: function() { return this.op = "difference", this },
                blendExclusion: function() { return this.op = "exclusion", this },
                blendHue: function() { return this.op = "hue", this },
                blendSaturation: function() { return this.op = "saturation", this },
                blendColor: function() { return this.op = "color", this },
                blendLuminosity: function() { return this.op = "luminosity", this }
            }, Object.defineProperty(c.BitmapData.prototype, "smoothed", {
                get: function() { c.Canvas.getSmoothingEnabled(this.context) },
                set: function(a) { c.Canvas.setSmoothingEnabled(this.context, a) }
            }), Object.defineProperty(c.BitmapData.prototype, "op", { get: function() { return this.context.globalCompositeOperation }, set: function(a) { this.context.globalCompositeOperation = a } }), c.BitmapData.getTransform = function(a, b, c, d, e, f) { return "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), "number" != typeof c && (c = 1), "number" != typeof d && (d = 1), "number" != typeof e && (e = 0), "number" != typeof f && (f = 0), { sx: c, sy: d, scaleX: c, scaleY: d, skewX: e, skewY: f, translateX: a, translateY: b, tx: a, ty: b } }, c.BitmapData.prototype.constructor = c.BitmapData, PIXI.Graphics = function() { PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1 }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(a, b, c) { return this.lineWidth = a || 0, this.lineColor = b || 0, this.lineAlpha = void 0 === c ? 1 : c, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this }, PIXI.Graphics.prototype.moveTo = function(a, b) { return this.drawShape(new PIXI.Polygon([a, b])), this }, PIXI.Graphics.prototype.lineTo = function(a, b) { return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(a, b), this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                var e, f, g = 20,
                    h = this.currentPath.shape.points;
                0 === h.length && this.moveTo(0, 0);
                for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; l <= g; ++l) k = l / g, e = i + (a - i) * k, f = j + (b - j) * k, h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) { this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0); for (var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; q <= l; ++q) p = q / l, g = 1 - p, h = g * g, i = h * g, j = p * p, k = j * p, m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f); return this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.arcTo = function(a, b, c, d, e) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
                var f = this.currentPath.shape.points,
                    g = f[f.length - 2],
                    h = f[f.length - 1],
                    i = h - b,
                    j = g - a,
                    k = d - b,
                    l = c - a,
                    m = Math.abs(i * l - j * k);
                if (m < 1e-8 || 0 === e) f[f.length - 2] === a && f[f.length - 1] === b || f.push(a, b);
                else {
                    var n = i * i + j * j,
                        o = k * k + l * l,
                        p = i * k + j * l,
                        q = e * Math.sqrt(n) / m,
                        r = e * Math.sqrt(o) / m,
                        s = q * p / n,
                        t = r * p / o,
                        u = q * l + r * j,
                        v = q * k + r * i,
                        w = j * (r + s),
                        x = i * (r + s),
                        y = l * (q + t),
                        z = k * (q + t),
                        A = Math.atan2(x - v, w - u),
                        B = Math.atan2(z - v, y - u);
                    this.arc(u + a, v + b, e, A, B, j * k > l * i)
                }
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.arc = function(a, b, c, d, e, f, g) {
                if (d === e) return this;
                void 0 === f && (f = !1), void 0 === g && (g = 40), !f && e <= d ? e += 2 * Math.PI : f && d <= e && (d += 2 * Math.PI);
                var h = f ? (d - e) * -1 : e - d,
                    i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
                if (0 === h) return this;
                var j = a + Math.cos(d) * c,
                    k = b + Math.sin(d) * c;
                f && this.filling ? this.moveTo(a, b) : this.moveTo(j, k);
                for (var l = this.currentPath.shape.points, m = h / (2 * i), n = 2 * m, o = Math.cos(m), p = Math.sin(m), q = i - 1, r = q % 1 / q, s = 0; s <= q; s++) {
                    var t = s + r * s,
                        u = m + d + n * t,
                        v = Math.cos(u),
                        w = -Math.sin(u);
                    l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b)
                }
                return this.dirty = !0, this._boundsDirty = !0, this
            }, PIXI.Graphics.prototype.beginFill = function(a, b) { return this.filling = !0, this.fillColor = a || 0, this.fillAlpha = void 0 === b ? 1 : b, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this }, PIXI.Graphics.prototype.endFill = function() { return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this }, PIXI.Graphics.prototype.drawRect = function(a, b, c, d) { return this.drawShape(new PIXI.Rectangle(a, b, c, d)), this }, PIXI.Graphics.prototype.drawRoundedRect = function(a, b, c, d, e) { return this.drawShape(new PIXI.RoundedRectangle(a, b, c, d, e)), this }, PIXI.Graphics.prototype.drawCircle = function(a, b, c) { return this.drawShape(new PIXI.Circle(a, b, c)), this }, PIXI.Graphics.prototype.drawEllipse = function(a, b, c, d) { return this.drawShape(new PIXI.Ellipse(a, b, c, d)), this }, PIXI.Graphics.prototype.drawPolygon = function(a) {
                (a instanceof c.Polygon || a instanceof PIXI.Polygon) && (a = a.points);
                var b = a;
                if (!Array.isArray(b)) { b = new Array(arguments.length); for (var d = 0; d < b.length; ++d) b[d] = arguments[d] }
                return this.drawShape(new c.Polygon(b)), this
            }, PIXI.Graphics.prototype.clear = function() { return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this }, PIXI.Graphics.prototype.generateTexture = function(a, b, c) {
                void 0 === a && (a = 1), void 0 === b && (b = PIXI.scaleModes.DEFAULT), void 0 === c && (c = 0);
                var d = this.getBounds();
                d.width += c, d.height += c;
                var e = new PIXI.CanvasBuffer(d.width * a, d.height * a),
                    f = PIXI.Texture.fromCanvas(e.canvas, b);
                return f.baseTexture.resolution = a, e.context.scale(a, a), e.context.translate(-d.x, -d.y), PIXI.CanvasGraphics.renderGraphics(this, e.context), f
            }, PIXI.Graphics.prototype._renderWebGL = function(a) {
                if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                    if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
                    if (a.spriteBatch.stop(), a.blendModeManager.setBlendMode(this.blendMode), this._mask && a.maskManager.pushMask(this._mask, a), this._filters && a.filterManager.pushFilter(this._filterBlock), this.blendMode !== a.spriteBatch.currentBlendMode) {
                        a.spriteBatch.currentBlendMode = this.blendMode;
                        var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
                        a.spriteBatch.gl.blendFunc(b[0], b[1])
                    }
                    if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, a), this.children.length) {
                        a.spriteBatch.start();
                        for (var c = 0; c < this.children.length; c++) this.children[c]._renderWebGL(a);
                        a.spriteBatch.stop()
                    }
                    this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), a.drawCount++, a.spriteBatch.start()
                }
            }, PIXI.Graphics.prototype._renderCanvas = function(a) {
                if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                    if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
                    var b = a.context,
                        c = this.worldTransform;
                    this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode, b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]), this._mask && a.maskManager.pushMask(this._mask, a);
                    var d = a.resolution,
                        e = c.tx * a.resolution + a.shakeX,
                        f = c.ty * a.resolution + a.shakeY;
                    b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f), PIXI.CanvasGraphics.renderGraphics(this, b);
                    for (var g = 0; g < this.children.length; g++) this.children[g]._renderCanvas(a);
                    this._mask && a.maskManager.popMask(a)
                }
            }, PIXI.Graphics.prototype.getBounds = function(a) {
                if (!this._currentBounds) {
                    if (!this.renderable) return PIXI.EmptyRectangle;
                    this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                    var b = this._localBounds,
                        c = b.x,
                        d = b.width + b.x,
                        e = b.y,
                        f = b.height + b.y,
                        g = a || this.worldTransform,
                        h = g.a,
                        i = g.b,
                        j = g.c,
                        k = g.d,
                        l = g.tx,
                        m = g.ty,
                        n = h * d + j * f + l,
                        o = k * f + i * d + m,
                        p = h * c + j * f + l,
                        q = k * f + i * c + m,
                        r = h * c + j * e + l,
                        s = k * e + i * c + m,
                        t = h * d + j * e + l,
                        u = k * e + i * d + m,
                        v = n,
                        w = o,
                        x = n,
                        y = o;
                    x = p < x ? p : x, x = r < x ? r : x, x = t < x ? t : x, y = q < y ? q : y, y = s < y ? s : y, y = u < y ? u : y, v = p > v ? p : v, v = r > v ? r : v, v = t > v ? t : v, w = q > w ? q : w, w = s > w ? s : w, w = u > w ? u : w, this._bounds.x = x, this._bounds.width = v - x, this._bounds.y = y, this._bounds.height = w - y, this._currentBounds = this._bounds
                }
                return this._currentBounds
            }, PIXI.Graphics.prototype.getLocalBounds = function() {
                var a = this.worldTransform;
                this.worldTransform = PIXI.identityMatrix;
                for (var b = 0; b < this.children.length; b++) this.children[b].updateTransform();
                var c = this.getBounds();
                for (this.worldTransform = a, b = 0; b < this.children.length; b++) this.children[b].updateTransform();
                return c
            }, PIXI.Graphics.prototype.containsPoint = function(a) { this.worldTransform.applyInverse(a, tempPoint); for (var b = this.graphicsData, c = 0; c < b.length; c++) { var d = b[c]; if (d.fill && d.shape && d.shape.contains(tempPoint.x, tempPoint.y)) return !0 } return !1 }, PIXI.Graphics.prototype.updateLocalBounds = function() {
                var a = 1 / 0,
                    b = -(1 / 0),
                    d = 1 / 0,
                    e = -(1 / 0);
                if (this.graphicsData.length)
                    for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
                        var m = this.graphicsData[l],
                            n = m.type,
                            o = m.lineWidth;
                        if (f = m.shape, n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC) h = f.x - o / 2, i = f.y - o / 2, j = f.width + o, k = f.height + o, a = h < a ? h : a, b = h + j > b ? h + j : b, d = i < d ? i : d, e = i + k > e ? i + k : e;
                        else if (n === PIXI.Graphics.CIRC) h = f.x, i = f.y, j = f.radius + o / 2, k = f.radius + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
                        else if (n === PIXI.Graphics.ELIP) h = f.x, i = f.y, j = f.width + o / 2, k = f.height + o / 2, a = h - j < a ? h - j : a, b = h + j > b ? h + j : b, d = i - k < d ? i - k : d, e = i + k > e ? i + k : e;
                        else { g = f.points; for (var p = 0; p < g.length; p++) g[p] instanceof c.Point ? (h = g[p].x, i = g[p].y) : (h = g[p], i = g[p + 1], p < g.length - 1 && p++), a = h - o < a ? h - o : a, b = h + o > b ? h + o : b, d = i - o < d ? i - o : d, e = i + o > e ? i + o : e }
                    }
                else a = 0, b = 0, d = 0, e = 0;
                var q = this.boundsPadding;
                this._localBounds.x = a - q, this._localBounds.width = b - a + 2 * q, this._localBounds.y = d - q, this._localBounds.height = e - d + 2 * q
            }, PIXI.Graphics.prototype._generateCachedSprite = function() {
                var a = this.getLocalBounds();
                if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height);
                else {
                    var b = new PIXI.CanvasBuffer(a.width, a.height),
                        c = PIXI.Texture.fromCanvas(b.canvas);
                    this._cachedSprite = new PIXI.Sprite(c), this._cachedSprite.buffer = b, this._cachedSprite.worldTransform = this.worldTransform
                }
                this._cachedSprite.anchor.x = -(a.x / a.width), this._cachedSprite.anchor.y = -(a.y / a.height), this._cachedSprite.buffer.context.translate(-a.x, -a.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
            }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
                var a = this._cachedSprite,
                    b = a.texture,
                    c = a.buffer.canvas;
                b.baseTexture.width = c.width, b.baseTexture.height = c.height, b.crop.width = b.frame.width = c.width, b.crop.height = b.frame.height = c.height, a._width = c.width, a._height = c.height, b.baseTexture.dirty()
            }, PIXI.Graphics.prototype.destroyCachedSprite = function() { this._cachedSprite.texture.destroy(!0), this._cachedSprite = null }, PIXI.Graphics.prototype.drawShape = function(a) { this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, a instanceof c.Polygon && (a = a.clone(), a.flatten()); var b = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a); return this.graphicsData.push(b), b.type === PIXI.Graphics.POLY && (b.shape.closed = this.filling, this.currentPath = b), this.dirty = !0, this._boundsDirty = !0, b }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", { get: function() { return this._cacheAsBitmap }, set: function(a) { this._cacheAsBitmap = a, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0 } }), PIXI.GraphicsData = function(a, b, c, d, e, f, g) { this.lineWidth = a, this.lineColor = b, this.lineAlpha = c, this._lineTint = b, this.fillColor = d, this.fillAlpha = e, this._fillTint = d, this.fill = f, this.shape = g, this.type = g.type }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() { return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape) }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(a, b, c) {
                c = c || 2;
                var d = b && b.length,
                    e = d ? b[0] * c : a.length,
                    f = PIXI.EarCut.linkedList(a, 0, e, c, !0),
                    g = [];
                if (!f) return g;
                var h, i, j, k, l, m, n;
                if (d && (f = PIXI.EarCut.eliminateHoles(a, b, f, c)), a.length > 80 * c) {
                    h = j = a[0], i = k = a[1];
                    for (var o = c; o < e; o += c) l = a[o], m = a[o + 1], l < h && (h = l), m < i && (i = m), l > j && (j = l), m > k && (k = m);
                    n = Math.max(j - h, k - i)
                }
                return PIXI.EarCut.earcutLinked(f, g, c, h, i, n), g
            }, PIXI.EarCut.linkedList = function(a, b, c, d, e) {
                var f, g, h, i = 0;
                for (f = b, g = c - d; f < c; f += d) i += (a[g] - a[f]) * (a[f + 1] + a[g + 1]), g = f;
                if (e === i > 0)
                    for (f = b; f < c; f += d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
                else
                    for (f = c - d; f >= b; f -= d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
                return h
            }, PIXI.EarCut.filterPoints = function(a, b) {
                if (!a) return a;
                b || (b = a);
                var c, d = a;
                do
                    if (c = !1, d.steiner || !PIXI.EarCut.equals(d, d.next) && 0 !== PIXI.EarCut.area(d.prev, d, d.next)) d = d.next;
                    else {
                        if (PIXI.EarCut.removeNode(d), d = b = d.prev, d === d.next) return null;
                        c = !0
                    }
                while (c || d !== b);
                return b
            }, PIXI.EarCut.earcutLinked = function(a, b, c, d, e, f, g) {
                if (a) {
                    !g && f && PIXI.EarCut.indexCurve(a, d, e, f);
                    for (var h, i, j = a; a.prev !== a.next;)
                        if (h = a.prev, i = a.next, f ? PIXI.EarCut.isEarHashed(a, d, e, f) : PIXI.EarCut.isEar(a)) b.push(h.i / c), b.push(a.i / c), b.push(i.i / c), PIXI.EarCut.removeNode(a), a = i.next, j = i.next;
                        else if (a = i, a === j) { g ? 1 === g ? (a = PIXI.EarCut.cureLocalIntersections(a, b, c), PIXI.EarCut.earcutLinked(a, b, c, d, e, f, 2)) : 2 === g && PIXI.EarCut.splitEarcut(a, b, c, d, e, f) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(a), b, c, d, e, f, 1); break }
                }
            }, PIXI.EarCut.isEar = function(a) {
                var b = a.prev,
                    c = a,
                    d = a.next;
                if (PIXI.EarCut.area(b, c, d) >= 0) return !1;
                for (var e = a.next.next; e !== a.prev;) {
                    if (PIXI.EarCut.pointInTriangle(b.x, b.y, c.x, c.y, d.x, d.y, e.x, e.y) && PIXI.EarCut.area(e.prev, e, e.next) >= 0) return !1;
                    e = e.next
                }
                return !0
            }, PIXI.EarCut.isEarHashed = function(a, b, c, d) {
                var e = a.prev,
                    f = a,
                    g = a.next;
                if (PIXI.EarCut.area(e, f, g) >= 0) return !1;
                for (var h = e.x < f.x ? e.x < g.x ? e.x : g.x : f.x < g.x ? f.x : g.x, i = e.y < f.y ? e.y < g.y ? e.y : g.y : f.y < g.y ? f.y : g.y, j = e.x > f.x ? e.x > g.x ? e.x : g.x : f.x > g.x ? f.x : g.x, k = e.y > f.y ? e.y > g.y ? e.y : g.y : f.y > g.y ? f.y : g.y, l = PIXI.EarCut.zOrder(h, i, b, c, d), m = PIXI.EarCut.zOrder(j, k, b, c, d), n = a.nextZ; n && n.z <= m;) {
                    if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                    n = n.nextZ
                }
                for (n = a.prevZ; n && n.z >= l;) {
                    if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                    n = n.prevZ
                }
                return !0
            }, PIXI.EarCut.cureLocalIntersections = function(a, b, c) {
                var d = a;
                do {
                    var e = d.prev,
                        f = d.next.next;
                    PIXI.EarCut.intersects(e, d, d.next, f) && PIXI.EarCut.locallyInside(e, f) && PIXI.EarCut.locallyInside(f, e) && (b.push(e.i / c), b.push(d.i / c), b.push(f.i / c), PIXI.EarCut.removeNode(d), PIXI.EarCut.removeNode(d.next), d = a = f), d = d.next
                } while (d !== a);
                return d
            }, PIXI.EarCut.splitEarcut = function(a, b, c, d, e, f) {
                var g = a;
                do { for (var h = g.next.next; h !== g.prev;) { if (g.i !== h.i && PIXI.EarCut.isValidDiagonal(g, h)) { var i = PIXI.EarCut.splitPolygon(g, h); return g = PIXI.EarCut.filterPoints(g, g.next), i = PIXI.EarCut.filterPoints(i, i.next), PIXI.EarCut.earcutLinked(g, b, c, d, e, f), void PIXI.EarCut.earcutLinked(i, b, c, d, e, f) } h = h.next } g = g.next } while (g !== a)
            }, PIXI.EarCut.eliminateHoles = function(a, b, c, d) { var e, f, g, h, i, j = []; for (e = 0, f = b.length; e < f; e++) g = b[e] * d, h = e < f - 1 ? b[e + 1] * d : a.length, i = PIXI.EarCut.linkedList(a, g, h, d, !1), i === i.next && (i.steiner = !0), j.push(PIXI.EarCut.getLeftmost(i)); for (j.sort(compareX), e = 0; e < j.length; e++) PIXI.EarCut.eliminateHole(j[e], c), c = PIXI.EarCut.filterPoints(c, c.next); return c }, PIXI.EarCut.compareX = function(a, b) { return a.x - b.x }, PIXI.EarCut.eliminateHole = function(a, b) {
                if (b = PIXI.EarCut.findHoleBridge(a, b)) {
                    var c = PIXI.EarCut.splitPolygon(b, a);
                    PIXI.EarCut.filterPoints(c, c.next)
                }
            }, PIXI.EarCut.findHoleBridge = function(a, b) {
                var c, d = b,
                    e = a.x,
                    f = a.y,
                    g = -(1 / 0);
                do {
                    if (f <= d.y && f >= d.next.y) {
                        var h = d.x + (f - d.y) * (d.next.x - d.x) / (d.next.y - d.y);
                        h <= e && h > g && (g = h, c = d.x < d.next.x ? d : d.next)
                    }
                    d = d.next
                } while (d !== b);
                if (!c) return null;
                if (a.x === c.x) return c.prev;
                var i, j = c,
                    k = 1 / 0;
                for (d = c.next; d !== j;) e >= d.x && d.x >= c.x && PIXI.EarCut.pointInTriangle(f < c.y ? e : g, f, c.x, c.y, f < c.y ? g : e, f, d.x, d.y) && (i = Math.abs(f - d.y) / (e - d.x), (i < k || i === k && d.x > c.x) && PIXI.EarCut.locallyInside(d, a) && (c = d, k = i)), d = d.next;
                return c
            }, PIXI.EarCut.indexCurve = function(a, b, c, d) {
                var e = a;
                do null === e.z && (e.z = PIXI.EarCut.zOrder(e.x, e.y, b, c, d)), e.prevZ = e.prev, e.nextZ = e.next, e = e.next; while (e !== a);
                e.prevZ.nextZ = null, e.prevZ = null, PIXI.EarCut.sortLinked(e)
            }, PIXI.EarCut.sortLinked = function(a) {
                var b, c, d, e, f, g, h, i, j = 1;
                do {
                    for (c = a, a = null, f = null, g = 0; c;) {
                        for (g++, d = c, h = 0, b = 0; b < j && (h++, d = d.nextZ, d); b++);
                        for (i = j; h > 0 || i > 0 && d;) 0 === h ? (e = d, d = d.nextZ, i--) : 0 !== i && d ? c.z <= d.z ? (e = c, c = c.nextZ, h--) : (e = d, d = d.nextZ, i--) : (e = c, c = c.nextZ, h--), f ? f.nextZ = e : a = e, e.prevZ = f, f = e;
                        c = d
                    }
                    f.nextZ = null, j *= 2
                } while (g > 1);
                return a
            }, PIXI.EarCut.zOrder = function(a, b, c, d, e) { return a = 32767 * (a - c) / e, b = 32767 * (b - d) / e, a = 16711935 & (a | a << 8), a = 252645135 & (a | a << 4), a = 858993459 & (a | a << 2), a = 1431655765 & (a | a << 1), b = 16711935 & (b | b << 8), b = 252645135 & (b | b << 4), b = 858993459 & (b | b << 2), b = 1431655765 & (b | b << 1), a | b << 1 }, PIXI.EarCut.getLeftmost = function(a) {
                var b = a,
                    c = a;
                do b.x < c.x && (c = b), b = b.next; while (b !== a);
                return c
            }, PIXI.EarCut.pointInTriangle = function(a, b, c, d, e, f, g, h) { return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0 }, PIXI.EarCut.isValidDiagonal = function(a, b) { return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b) }, PIXI.EarCut.area = function(a, b, c) { return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) }, PIXI.EarCut.equals = function(a, b) { return a.x === b.x && a.y === b.y }, PIXI.EarCut.intersects = function(a, b, c, d) { return PIXI.EarCut.area(a, b, c) > 0 != PIXI.EarCut.area(a, b, d) > 0 && PIXI.EarCut.area(c, d, a) > 0 != PIXI.EarCut.area(c, d, b) > 0 }, PIXI.EarCut.intersectsPolygon = function(a, b) {
                var c = a;
                do {
                    if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && PIXI.EarCut.intersects(c, c.next, a, b)) return !0;
                    c = c.next
                } while (c !== a);
                return !1
            }, PIXI.EarCut.locallyInside = function(a, b) { return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0 }, PIXI.EarCut.middleInside = function(a, b) {
                var c = a,
                    d = !1,
                    e = (a.x + b.x) / 2,
                    f = (a.y + b.y) / 2;
                do c.y > f != c.next.y > f && e < (c.next.x - c.x) * (f - c.y) / (c.next.y - c.y) + c.x && (d = !d), c = c.next; while (c !== a);
                return d
            }, PIXI.EarCut.splitPolygon = function(a, b) {
                var c = new PIXI.EarCut.Node(a.i, a.x, a.y),
                    d = new PIXI.EarCut.Node(b.i, b.x, b.y),
                    e = a.next,
                    f = b.prev;
                return a.next = b, b.prev = a, c.next = e, e.prev = c, d.next = c, c.prev = d, f.next = d, d.prev = f, d
            }, PIXI.EarCut.insertNode = function(a, b, c, d) { var e = new PIXI.EarCut.Node(a, b, c); return d ? (e.next = d.next, e.prev = d, d.next.prev = e, d.next = e) : (e.prev = e, e.next = e), e }, PIXI.EarCut.removeNode = function(a) { a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ) }, PIXI.EarCut.Node = function(a, b, c) { this.i = a, this.x = b, this.y = c, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(a, b) {
                var c, d = b.gl,
                    e = b.projection,
                    f = b.offset,
                    g = b.shaderManager.primitiveShader;
                a.dirty && PIXI.WebGLGraphics.updateGraphics(a, d);
                for (var h = a._webGL[d.id], i = 0; i < h.data.length; i++) 1 === h.data[i].mode ? (c = h.data[i], b.stencilManager.pushStencil(a, c, b), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (c.indices.length - 4)), b.stencilManager.popStencil(a, c, b)) : (c = h.data[i], b.shaderManager.setShader(g), g = b.shaderManager.primitiveShader, d.uniformMatrix3fv(g.translationMatrix, !1, a.worldTransform.toArray(!0)), d.uniform1f(g.flipY, 1), d.uniform2f(g.projectionVector, e.x, -e.y), d.uniform2f(g.offsetVector, -f.x, -f.y), d.uniform3fv(g.tintColor, PIXI.hex2rgb(a.tint)), d.uniform1f(g.alpha, a.worldAlpha), d.bindBuffer(d.ARRAY_BUFFER, c.buffer), d.vertexAttribPointer(g.aVertexPosition, 2, d.FLOAT, !1, 24, 0), d.vertexAttribPointer(g.colorAttribute, 4, d.FLOAT, !1, 24, 8), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c.indexBuffer), d.drawElements(d.TRIANGLE_STRIP, c.indices.length, d.UNSIGNED_SHORT, 0))
            }, PIXI.WebGLGraphics.updateGraphics = function(a, b) {
                var c = a._webGL[b.id];
                c || (c = a._webGL[b.id] = { lastIndex: 0, data: [], gl: b }), a.dirty = !1;
                var d;
                if (a.clearDirty) {
                    for (a.clearDirty = !1, d = 0; d < c.data.length; d++) {
                        var e = c.data[d];
                        e.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(e)
                    }
                    c.data = [], c.lastIndex = 0
                }
                var f;
                for (d = c.lastIndex; d < a.graphicsData.length; d++) {
                    var g = a.graphicsData[d];
                    if (g.type === PIXI.Graphics.POLY) {
                        if (g.points = g.shape.points.slice(), g.shape.closed && (g.points[0] === g.points[g.points.length - 2] && g.points[1] === g.points[g.points.length - 1] || g.points.push(g.points[0], g.points[1])), g.fill && g.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                            if (g.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                                f = PIXI.WebGLGraphics.switchMode(c, 0);
                                var h = PIXI.WebGLGraphics.buildPoly(g, f);
                                h || (f = PIXI.WebGLGraphics.switchMode(c, 1), PIXI.WebGLGraphics.buildComplexPoly(g, f))
                            }
                        else f = PIXI.WebGLGraphics.switchMode(c, 1), PIXI.WebGLGraphics.buildComplexPoly(g, f);
                        g.lineWidth > 0 && (f = PIXI.WebGLGraphics.switchMode(c, 0), PIXI.WebGLGraphics.buildLine(g, f))
                    }
                    else f = PIXI.WebGLGraphics.switchMode(c, 0), g.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(g, f) : g.type === PIXI.Graphics.CIRC || g.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(g, f) : g.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(g, f);
                    c.lastIndex++
                }
                for (d = 0; d < c.data.length; d++) f = c.data[d], f.dirty && f.upload()
            }, PIXI.WebGLGraphics.switchMode = function(a, b) { var c; return a.data.length ? (c = a.data[a.data.length - 1], c.mode === b && 1 !== b || (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c))) : (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl), c.mode = b, a.data.push(c)), c.dirty = !0, c }, PIXI.WebGLGraphics.buildRectangle = function(a, b) {
                var c = a.shape,
                    d = c.x,
                    e = c.y,
                    f = c.width,
                    g = c.height;
                if (a.fill) {
                    var h = PIXI.hex2rgb(a.fillColor),
                        i = a.fillAlpha,
                        j = h[0] * i,
                        k = h[1] * i,
                        l = h[2] * i,
                        m = b.points,
                        n = b.indices,
                        o = m.length / 6;
                    m.push(d, e), m.push(j, k, l, i), m.push(d + f, e), m.push(j, k, l, i), m.push(d, e + g), m.push(j, k, l, i), m.push(d + f, e + g), m.push(j, k, l, i), n.push(o, o, o + 1, o + 2, o + 3, o + 3)
                }
                if (a.lineWidth) {
                    var p = a.points;
                    a.points = [d, e, d + f, e, d + f, e + g, d, e + g, d, e], PIXI.WebGLGraphics.buildLine(a, b), a.points = p
                }
            }, PIXI.WebGLGraphics.buildRoundedRectangle = function(a, b) {
                var c = a.shape,
                    d = c.x,
                    e = c.y,
                    f = c.width,
                    g = c.height,
                    h = c.radius,
                    i = [];
                if (i.push(d, e + h), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d, e + g - h, d, e + g, d + h, e + g)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f - h, e + g, d + f, e + g, d + f, e + g - h)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f, e + h, d + f, e, d + f - h, e)), i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + h, e, d, e, d, e + h)), a.fill) {
                    var j = PIXI.hex2rgb(a.fillColor),
                        k = a.fillAlpha,
                        l = j[0] * k,
                        m = j[1] * k,
                        n = j[2] * k,
                        o = b.points,
                        p = b.indices,
                        q = o.length / 6,
                        r = PIXI.EarCut.Triangulate(i, null, 2),
                        s = 0;
                    for (s = 0; s < r.length; s += 3) p.push(r[s] + q), p.push(r[s] + q), p.push(r[s + 1] + q), p.push(r[s + 2] + q), p.push(r[s + 2] + q);
                    for (s = 0; s < i.length; s++) o.push(i[s], i[++s], l, m, n, k)
                }
                if (a.lineWidth) {
                    var t = a.points;
                    a.points = i, PIXI.WebGLGraphics.buildLine(a, b), a.points = t
                }
            }, PIXI.WebGLGraphics.quadraticBezierCurve = function(a, b, c, d, e, f) {
                function g(a, b, c) { var d = b - a; return a + d * c }
                for (var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; q <= n; q++) p = q / n, h = g(a, c, p), i = g(b, d, p), j = g(c, e, p), k = g(d, f, p), l = g(h, j, p), m = g(i, k, p), o.push(l, m);
                return o
            }, PIXI.WebGLGraphics.buildCircle = function(a, b) {
                var c, d, e = a.shape,
                    f = e.x,
                    g = e.y;
                a.type === PIXI.Graphics.CIRC ? (c = e.radius, d = e.radius) : (c = e.width, d = e.height);
                var h = 40,
                    i = 2 * Math.PI / h,
                    j = 0;
                if (a.fill) {
                    var k = PIXI.hex2rgb(a.fillColor),
                        l = a.fillAlpha,
                        m = k[0] * l,
                        n = k[1] * l,
                        o = k[2] * l,
                        p = b.points,
                        q = b.indices,
                        r = p.length / 6;
                    for (q.push(r), j = 0; j < h + 1; j++) p.push(f, g, m, n, o, l), p.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d, m, n, o, l), q.push(r++, r++);
                    q.push(r - 1)
                }
                if (a.lineWidth) {
                    var s = a.points;
                    for (a.points = [], j = 0; j < h + 1; j++) a.points.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d);
                    PIXI.WebGLGraphics.buildLine(a, b), a.points = s
                }
            }, PIXI.WebGLGraphics.buildLine = function(a, b) {
                var c = 0,
                    d = a.points;
                if (0 !== d.length) {
                    if (a.lineWidth % 2)
                        for (c = 0; c < d.length; c++) d[c] += .5;
                    var e = new PIXI.Point(d[0], d[1]),
                        f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
                    if (e.x === f.x && e.y === f.y) {
                        d = d.slice(), d.pop(), d.pop(), f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
                        var g = f.x + .5 * (e.x - f.x),
                            h = f.y + .5 * (e.y - f.y);
                        d.unshift(g, h), d.push(g, h)
                    }
                    var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F = b.points,
                        G = b.indices,
                        H = d.length / 2,
                        I = d.length,
                        J = F.length / 6,
                        K = a.lineWidth / 2,
                        L = PIXI.hex2rgb(a.lineColor),
                        M = a.lineAlpha,
                        N = L[0] * M,
                        O = L[1] * M,
                        P = L[2] * M;
                    for (k = d[0], l = d[1], m = d[2], n = d[3], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, F.push(k - q, l - r, N, O, P, M), F.push(k + q, l + r, N, O, P, M), c = 1; c < H - 1; c++) k = d[2 * (c - 1)], l = d[2 * (c - 1) + 1], m = d[2 * c], n = d[2 * c + 1], o = d[2 * (c + 1)], p = d[2 * (c + 1) + 1], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, s = -(n - p), t = m - o, E = Math.sqrt(s * s + t * t), s /= E, t /= E, s *= K, t *= K, w = -r + l - (-r + n), x = -q + m - (-q + k), y = (-q + k) * (-r + n) - (-q + m) * (-r + l), z = -t + p - (-t + n), A = -s + m - (-s + o), B = (-s + o) * (-t + n) - (-s + m) * (-t + p), C = w * A - z * x, Math.abs(C) < .1 ? (C += 10.1, F.push(m - q, n - r, N, O, P, M), F.push(m + q, n + r, N, O, P, M)) : (i = (x * B - A * y) / C, j = (z * y - w * B) / C, D = (i - m) * (i - m) + (j - n) + (j - n), D > 19600 ? (u = q - s, v = r - t, E = Math.sqrt(u * u + v * v), u /= E, v /= E, u *= K, v *= K, F.push(m - u, n - v), F.push(N, O, P, M), F.push(m + u, n + v), F.push(N, O, P, M), F.push(m - u, n - v), F.push(N, O, P, M), I++) : (F.push(i, j), F.push(N, O, P, M), F.push(m - (i - m), n - (j - n)), F.push(N, O, P, M)));
                    for (k = d[2 * (H - 2)], l = d[2 * (H - 2) + 1], m = d[2 * (H - 1)], n = d[2 * (H - 1) + 1], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, F.push(m - q, n - r), F.push(N, O, P, M), F.push(m + q, n + r), F.push(N, O, P, M), G.push(J), c = 0; c < I; c++) G.push(J++);
                    G.push(J - 1)
                }
            }, PIXI.WebGLGraphics.buildComplexPoly = function(a, b) {
                var c = a.points.slice();
                if (!(c.length < 6)) {
                    var d = b.indices;
                    b.points = c, b.alpha = a.fillAlpha, b.color = PIXI.hex2rgb(a.fillColor);
                    for (var e, f, g = 1 / 0, h = -(1 / 0), i = 1 / 0, j = -(1 / 0), k = 0; k < c.length; k += 2) e = c[k], f = c[k + 1], g = e < g ? e : g, h = e > h ? e : h, i = f < i ? f : i, j = f > j ? f : j;
                    c.push(g, i, h, i, h, j, g, j);
                    var l = c.length / 2;
                    for (k = 0; k < l; k++) d.push(k)
                }
            }, PIXI.WebGLGraphics.buildPoly = function(a, b) {
                var c = a.points;
                if (!(c.length < 6)) {
                    var d = b.points,
                        e = b.indices,
                        f = c.length / 2,
                        g = PIXI.hex2rgb(a.fillColor),
                        h = a.fillAlpha,
                        i = g[0] * h,
                        j = g[1] * h,
                        k = g[2] * h,
                        l = PIXI.EarCut.Triangulate(c, null, 2);
                    if (!l) return !1;
                    var m = d.length / 6,
                        n = 0;
                    for (n = 0; n < l.length; n += 3) e.push(l[n] + m), e.push(l[n] + m), e.push(l[n + 1] + m), e.push(l[n + 2] + m), e.push(l[n + 2] + m);
                    for (n = 0; n < f; n++) d.push(c[2 * n], c[2 * n + 1], i, j, k, h);
                    return !0
                }
            }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(a) { this.gl = a, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = a.createBuffer(), this.indexBuffer = a.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0 }, PIXI.WebGLGraphicsData.prototype.reset = function() { this.points = [], this.indices = [] }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                var a = this.gl;
                this.glPoints = new PIXI.Float32Array(this.points), a.bindBuffer(a.ARRAY_BUFFER, this.buffer), a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW), this.dirty = !1
            }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(a, b) {
                var c = a.worldAlpha;
                a.dirty && (this.updateGraphicsTint(a), a.dirty = !1);
                for (var d = 0; d < a.graphicsData.length; d++) {
                    var e = a.graphicsData[d],
                        f = e.shape,
                        g = e._fillTint,
                        h = e._lineTint;
                    if (b.lineWidth = e.lineWidth, e.type === PIXI.Graphics.POLY) {
                        b.beginPath();
                        var i = f.points;
                        b.moveTo(i[0], i[1]);
                        for (var j = 1; j < i.length / 2; j++) b.lineTo(i[2 * j], i[2 * j + 1]);
                        f.closed && b.lineTo(i[0], i[1]), i[0] === i[i.length - 2] && i[1] === i[i.length - 1] && b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                    }
                    else if (e.type === PIXI.Graphics.RECT)(e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fillRect(f.x, f.y, f.width, f.height)), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.strokeRect(f.x, f.y, f.width, f.height));
                    else if (e.type === PIXI.Graphics.CIRC) b.beginPath(), b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI), b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke());
                    else if (e.type === PIXI.Graphics.ELIP) {
                        var k = 2 * f.width,
                            l = 2 * f.height,
                            m = f.x - k / 2,
                            n = f.y - l / 2;
                        b.beginPath();
                        var o = .5522848,
                            p = k / 2 * o,
                            q = l / 2 * o,
                            r = m + k,
                            s = n + l,
                            t = m + k / 2,
                            u = n + l / 2;
                        b.moveTo(m, u), b.bezierCurveTo(m, u - q, t - p, n, t, n), b.bezierCurveTo(t + p, n, r, u - q, r, u), b.bezierCurveTo(r, u + q, t + p, s, t, s), b.bezierCurveTo(t - p, s, m, u + q, m, u), b.closePath(), e.fill && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                    }
                    else if (e.type === PIXI.Graphics.RREC) {
                        var v = f.x,
                            w = f.y,
                            x = f.width,
                            y = f.height,
                            z = f.radius,
                            A = Math.min(x, y) / 2 | 0;
                        z = z > A ? A : z, b.beginPath(), b.moveTo(v, w + z), b.lineTo(v, w + y - z), b.quadraticCurveTo(v, w + y, v + z, w + y), b.lineTo(v + x - z, w + y), b.quadraticCurveTo(v + x, w + y, v + x, w + y - z), b.lineTo(v + x, w + z), b.quadraticCurveTo(v + x, w, v + x - z, w), b.lineTo(v + z, w), b.quadraticCurveTo(v, w, v, w + z), b.closePath(), (e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c, b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6), b.fill()), e.lineWidth && (b.globalAlpha = e.lineAlpha * c, b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), b.stroke())
                    }
                }
            }, PIXI.CanvasGraphics.renderGraphicsMask = function(a, b) {
                var c = a.graphicsData.length;
                if (0 !== c) {
                    b.beginPath();
                    for (var d = 0; d < c; d++) {
                        var e = a.graphicsData[d],
                            f = e.shape;
                        if (e.type === PIXI.Graphics.POLY) {
                            var g = f.points;
                            b.moveTo(g[0], g[1]);
                            for (var h = 1; h < g.length / 2; h++) b.lineTo(g[2 * h], g[2 * h + 1]);
                            g[0] === g[g.length - 2] && g[1] === g[g.length - 1] && b.closePath()
                        }
                        else if (e.type === PIXI.Graphics.RECT) b.rect(f.x, f.y, f.width, f.height), b.closePath();
                        else if (e.type === PIXI.Graphics.CIRC) b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI), b.closePath();
                        else if (e.type === PIXI.Graphics.ELIP) {
                            var i = 2 * f.width,
                                j = 2 * f.height,
                                k = f.x - i / 2,
                                l = f.y - j / 2,
                                m = .5522848,
                                n = i / 2 * m,
                                o = j / 2 * m,
                                p = k + i,
                                q = l + j,
                                r = k + i / 2,
                                s = l + j / 2;
                            b.moveTo(k, s), b.bezierCurveTo(k, s - o, r - n, l, r, l), b.bezierCurveTo(r + n, l, p, s - o, p, s), b.bezierCurveTo(p, s + o, r + n, q, r, q), b.bezierCurveTo(r - n, q, k, s + o, k, s), b.closePath()
                        }
                        else if (e.type === PIXI.Graphics.RREC) {
                            var t = f.x,
                                u = f.y,
                                v = f.width,
                                w = f.height,
                                x = f.radius,
                                y = Math.min(v, w) / 2 | 0;
                            x = x > y ? y : x, b.moveTo(t, u + x), b.lineTo(t, u + w - x), b.quadraticCurveTo(t, u + w, t + x, u + w), b.lineTo(t + v - x, u + w), b.quadraticCurveTo(t + v, u + w, t + v, u + w - x), b.lineTo(t + v, u + x), b.quadraticCurveTo(t + v, u, t + v - x, u), b.lineTo(t + x, u), b.quadraticCurveTo(t, u, t, u + x), b.closePath()
                        }
                    }
                }
            }, PIXI.CanvasGraphics.updateGraphicsTint = function(a) {
                if (16777215 !== a.tint)
                    for (var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
                        var f = a.graphicsData[e],
                            g = 0 | f.fillColor,
                            h = 0 | f.lineColor;
                        f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255, f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255
                    }
            }, c.Graphics = function(a, b, d) { void 0 === b && (b = 0), void 0 === d && (d = 0), this.type = c.GRAPHICS, this.physicsType = c.SPRITE, this.anchor = new c.Point, PIXI.Graphics.call(this), c.Component.Core.init.call(this, a, b, d, "", null) }, c.Graphics.prototype = Object.create(PIXI.Graphics.prototype), c.Graphics.prototype.constructor = c.Graphics, c.Component.Core.install.call(c.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), c.Graphics.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Graphics.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Graphics.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Graphics.prototype.preUpdateCore = c.Component.Core.preUpdate,
            c.Graphics.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.Graphics.prototype.postUpdate = function() { c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1); for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate() }, c.Graphics.prototype.destroy = function(a) { this.clear(), c.Component.Destroy.prototype.destroy.call(this, a) }, c.Graphics.prototype.drawTriangle = function(a, b) {
                void 0 === b && (b = !1);
                var d = new c.Polygon(a);
                if (b) {
                    var e = new c.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y),
                        f = new c.Point(a[1].x - a[0].x, a[1].y - a[0].y),
                        g = new c.Point(a[1].x - a[2].x, a[1].y - a[2].y),
                        h = g.cross(f);
                    e.dot(h) > 0 && this.drawPolygon(d)
                }
                else this.drawPolygon(d)
            }, c.Graphics.prototype.drawTriangles = function(a, b, d) {
                void 0 === d && (d = !1);
                var e, f = new c.Point,
                    g = new c.Point,
                    h = new c.Point,
                    i = [];
                if (b)
                    if (a[0] instanceof c.Point)
                        for (e = 0; e < b.length / 3; e++) i.push(a[b[3 * e]]), i.push(a[b[3 * e + 1]]), i.push(a[b[3 * e + 2]]), 3 === i.length && (this.drawTriangle(i, d), i = []);
                    else
                        for (e = 0; e < b.length; e++) f.x = a[2 * b[e]], f.y = a[2 * b[e] + 1], i.push(f.copyTo({})), 3 === i.length && (this.drawTriangle(i, d), i = []);
                else if (a[0] instanceof c.Point)
                    for (e = 0; e < a.length / 3; e++) this.drawTriangle([a[3 * e], a[3 * e + 1], a[3 * e + 2]], d);
                else
                    for (e = 0; e < a.length / 6; e++) f.x = a[6 * e + 0], f.y = a[6 * e + 1], g.x = a[6 * e + 2], g.y = a[6 * e + 3], h.x = a[6 * e + 4], h.y = a[6 * e + 5], this.drawTriangle([f, g, h], d)
            }, c.RenderTexture = function(a, b, d, e, f, g) { void 0 === e && (e = ""), void 0 === f && (f = c.scaleModes.DEFAULT), void 0 === g && (g = 1), this.game = a, this.key = e, this.type = c.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, b, d, this.game.renderer, f, g), this.render = c.RenderTexture.prototype.render }, c.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), c.RenderTexture.prototype.constructor = c.RenderTexture, c.RenderTexture.prototype.renderXY = function(a, b, c, d) { a.updateTransform(), this._tempMatrix.copyFrom(a.worldTransform), this._tempMatrix.tx = b, this._tempMatrix.ty = c, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d) }, c.RenderTexture.prototype.renderRawXY = function(a, b, c, d) { this._tempMatrix.identity().translate(b, c), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d) }, c.RenderTexture.prototype.render = function(a, b, c) { void 0 === b || null === b ? this._tempMatrix.copyFrom(a.worldTransform) : this._tempMatrix.copyFrom(b), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, c) : this.renderCanvas(a, this._tempMatrix, c) }, c.Text = function(a, b, d, e, f) { b = b || 0, d = d || 0, e = void 0 === e || null === e ? "" : e.toString(), f = c.Utils.extend({}, f), this.type = c.TEXT, this.physicsType = c.SPRITE, this.padding = new c.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = a.renderer.resolution, this._text = e, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, c.Sprite.call(this, a, b, d, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(f), "" !== e && this.updateText() }, c.Text.prototype = Object.create(c.Sprite.prototype), c.Text.prototype.constructor = c.Text, c.Text.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.Text.prototype.update = function() {}, c.Text.prototype.destroy = function(a) { this.texture.destroy(!0), c.Component.Destroy.prototype.destroy.call(this, a) }, c.Text.prototype.setShadow = function(a, b, c, d, e, f) { return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = "rgba(0, 0, 0, 1)"), void 0 === d && (d = 0), void 0 === e && (e = !0), void 0 === f && (f = !0), this.style.shadowOffsetX = a, this.style.shadowOffsetY = b, this.style.shadowColor = c, this.style.shadowBlur = d, this.style.shadowStroke = e, this.style.shadowFill = f, this.dirty = !0, this }, c.Text.prototype.setStyle = function(a, b) { void 0 === b && (b = !1), a = a || {}, a.font = a.font || "bold 20pt Arial", a.backgroundColor = a.backgroundColor || null, a.fill = a.fill || "black", a.align = a.align || "left", a.boundsAlignH = a.boundsAlignH || "left", a.boundsAlignV = a.boundsAlignV || "top", a.stroke = a.stroke || "black", a.strokeThickness = a.strokeThickness || 0, a.wordWrap = a.wordWrap || !1, a.wordWrapWidth = a.wordWrapWidth || 100, a.maxLines = a.maxLines || 0, a.shadowOffsetX = a.shadowOffsetX || 0, a.shadowOffsetY = a.shadowOffsetY || 0, a.shadowColor = a.shadowColor || "rgba(0,0,0,0)", a.shadowBlur = a.shadowBlur || 0, a.tabs = a.tabs || 0; var c = this.fontToComponents(a.font); return a.fontStyle && (c.fontStyle = a.fontStyle), a.fontVariant && (c.fontVariant = a.fontVariant), a.fontWeight && (c.fontWeight = a.fontWeight), a.fontSize && ("number" == typeof a.fontSize && (a.fontSize = a.fontSize + "px"), c.fontSize = a.fontSize), this._fontComponents = c, a.font = this.componentsToFont(this._fontComponents), this.style = a, this.dirty = !0, b && this.updateText(), this }, c.Text.prototype.updateText = function() {
                this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
                var a = this.text;
                this.style.wordWrap && (a = this.runWordWrap(this.text));
                var b = a.split(/(?:\r\n|\r|\n)/),
                    c = this.style.tabs,
                    d = [],
                    e = 0,
                    f = this.determineFontProperties(this.style.font),
                    g = b.length;
                this.style.maxLines > 0 && this.style.maxLines < b.length && (g = this.style.maxLines), this._charCount = 0;
                for (var h = 0; h < g; h++) {
                    if (0 === c) {
                        var i = this.style.strokeThickness + this.padding.x;
                        i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(b[h]) : this.context.measureText(b[h]).width, this.style.wordWrap && (i -= this.context.measureText(" ").width)
                    }
                    else {
                        var j = b[h].split(/(?:\t)/),
                            i = this.padding.x + this.style.strokeThickness;
                        if (Array.isArray(c))
                            for (var k = 0, l = 0; l < j.length; l++) {
                                var m = 0;
                                m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width), l > 0 && (k += c[l - 1]), i = k + m
                            }
                        else
                            for (var l = 0; l < j.length; l++) {
                                i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width);
                                var n = this.game.math.snapToCeil(i, c) - i;
                                i += n
                            }
                    }
                    d[h] = Math.ceil(i), e = Math.max(e, d[h])
                }
                this.canvas.width = e * this._res;
                var o = f.fontSize + this.style.strokeThickness + this.padding.y,
                    p = o * g,
                    q = this._lineSpacing;
                q < 0 && Math.abs(q) > o && (q = -o), 0 !== q && (p += q > 0 ? q * b.length : q * (b.length - 1)), this.canvas.height = p * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
                var r, s;
                for (this._charCount = 0, h = 0; h < g; h++) r = this.style.strokeThickness / 2, s = this.style.strokeThickness / 2 + h * o + f.ascent, h > 0 && (s += q * h), "right" === this.style.align ? r += e - d[h] : "center" === this.style.align && (r += (e - d[h]) / 2), this.autoRound && (r = Math.round(r), s = Math.round(s)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(b[h], r, s) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === c ? this.context.strokeText(b[h], r, s) : this.renderTabLine(b[h], r, s, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[h], r, s) : this.renderTabLine(b[h], r, s, !0)));
                this.updateTexture(), this.dirty = !1
            }, c.Text.prototype.renderTabLine = function(a, b, c, d) {
                var e = a.split(/(?:\t)/),
                    f = this.style.tabs,
                    g = 0;
                if (Array.isArray(f))
                    for (var h = 0, i = 0; i < e.length; i++) i > 0 && (h += f[i - 1]), g = b + h, d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c);
                else
                    for (var i = 0; i < e.length; i++) {
                        var j = Math.ceil(this.context.measureText(e[i]).width);
                        g = this.game.math.snapToCeil(b, f), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c), b = g + j
                    }
            }, c.Text.prototype.updateShadow = function(a) { a ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0) }, c.Text.prototype.measureLine = function(a) {
                for (var b = 0, c = 0; c < a.length; c++) {
                    var d = a[c];
                    if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                        var e = this.fontToComponents(this.context.font);
                        this.fontStyles[this._charCount] && (e.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (e.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(e)
                    }
                    this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), b += this.context.measureText(d).width, this._charCount++
                }
                return Math.ceil(b)
            }, c.Text.prototype.updateLine = function(a, b, c) {
                for (var d = 0; d < a.length; d++) {
                    var e = a[d];
                    if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                        var f = this.fontToComponents(this.context.font);
                        this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(f)
                    }
                    this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(e, b, c)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(e, b, c)), b += this.context.measureText(e).width, this._charCount++
                }
            }, c.Text.prototype.clearColors = function() { return this.colors = [], this.strokeColors = [], this.dirty = !0, this }, c.Text.prototype.clearFontValues = function() { return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this }, c.Text.prototype.addColor = function(a, b) { return this.colors[b] = a, this.dirty = !0, this }, c.Text.prototype.addStrokeColor = function(a, b) { return this.strokeColors[b] = a, this.dirty = !0, this }, c.Text.prototype.addFontStyle = function(a, b) { return this.fontStyles[b] = a, this.dirty = !0, this }, c.Text.prototype.addFontWeight = function(a, b) { return this.fontWeights[b] = a, this.dirty = !0, this }, c.Text.prototype.precalculateWordWrap = function(a) { this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font; var b = this.runWordWrap(a); return b.split(/(?:\r\n|\r|\n)/) }, c.Text.prototype.runWordWrap = function(a) { return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a) }, c.Text.prototype.advancedWordWrap = function(a) {
                for (var b = this.context, c = this.style.wordWrapWidth, d = "", e = a.replace(/ +/gi, " ").split(/\r?\n/gi), f = e.length, g = 0; g < f; g++) {
                    var h = e[g],
                        i = "";
                    h = h.replace(/^ *|\s*$/gi, "");
                    var j = b.measureText(h).width;
                    if (j < c) d += h + "\n";
                    else {
                        for (var k = c, l = h.split(" "), m = 0; m < l.length; m++) {
                            var n = l[m],
                                o = n + " ",
                                p = b.measureText(o).width;
                            if (p > k) {
                                if (0 === m) {
                                    for (var q = o; q.length && (q = q.slice(0, -1), p = b.measureText(q).width, !(p <= k)););
                                    if (!q.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                    var r = n.substr(q.length);
                                    l[m] = r, i += q
                                }
                                var s = l[m].length ? m : m + 1,
                                    t = l.slice(s).join(" ").replace(/[ \n]*$/gi, "");
                                e[g + 1] = t + " " + (e[g + 1] || ""), f = e.length;
                                break
                            }
                            i += o, k -= p
                        }
                        d += i.replace(/[ \n]*$/gi, "") + "\n"
                    }
                }
                return d = d.replace(/[\s|\n]*$/gi, "")
            }, c.Text.prototype.basicWordWrap = function(a) {
                for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
                    for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
                        var h = this.context.measureText(f[g]).width,
                            i = h + this.context.measureText(" ").width;
                        i > e ? (g > 0 && (b += "\n"), b += f[g] + " ", e = this.style.wordWrapWidth - h) : (e -= i, b += f[g] + " ")
                    }
                    d < c.length - 1 && (b += "\n")
                }
                return b
            }, c.Text.prototype.updateFont = function(a) {
                var b = this.componentsToFont(a);
                this.style.font !== b && (this.style.font = b, this.dirty = !0, this.parent && this.updateTransform())
            }, c.Text.prototype.fontToComponents = function(a) { var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/); if (b) { var c = b[5].trim(); return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c) || (c = "'" + c + "'"), { font: a, fontStyle: b[1] || "normal", fontVariant: b[2] || "normal", fontWeight: b[3] || "normal", fontSize: b[4] || "medium", fontFamily: c } } return { font: a } }, c.Text.prototype.componentsToFont = function(a) { var b, c = []; return b = a.fontStyle, b && "normal" !== b && c.push(b), b = a.fontVariant, b && "normal" !== b && c.push(b), b = a.fontWeight, b && "normal" !== b && c.push(b), b = a.fontSize, b && "medium" !== b && c.push(b), b = a.fontFamily, b && c.push(b), c.length || c.push(a.font), c.join(" ") }, c.Text.prototype.setText = function(a, b) { return void 0 === b && (b = !1), this.text = a.toString() || "", b ? this.updateText() : this.dirty = !0, this }, c.Text.prototype.parseList = function(a) { if (!Array.isArray(a)) return this; for (var b = "", c = 0; c < a.length; c++) Array.isArray(a[c]) ? (b += a[c].join("\t"), c < a.length - 1 && (b += "\n")) : (b += a[c], c < a.length - 1 && (b += "\t")); return this.text = b, this.dirty = !0, this }, c.Text.prototype.setTextBounds = function(a, b, d, e) { return void 0 === a ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(a, b, d, e) : this.textBounds = new c.Rectangle(a, b, d, e), this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)), this.updateTexture(), this }, c.Text.prototype.updateTexture = function() {
                var a = this.texture.baseTexture,
                    b = this.texture.crop,
                    c = this.texture.frame,
                    d = this.canvas.width,
                    e = this.canvas.height;
                if (a.width = d, a.height = e, b.width = d, b.height = e, c.width = d, c.height = e, this.texture.width = d, this.texture.height = e, this._width = d, this._height = e, this.textBounds) {
                    var f = this.textBounds.x,
                        g = this.textBounds.y;
                    "right" === this.style.boundsAlignH ? f += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? g += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -f, this.pivot.y = -g
                }
                this.renderable = 0 !== d && 0 !== e, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
            }, c.Text.prototype._renderWebGL = function(a) { this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, a) }, c.Text.prototype._renderCanvas = function(a) { this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, a) }, c.Text.prototype.determineFontProperties = function(a) {
                var b = c.Text.fontPropertiesCache[a];
                if (!b) {
                    b = {};
                    var d = c.Text.fontPropertiesCanvas,
                        e = c.Text.fontPropertiesContext;
                    e.font = a;
                    var f = Math.ceil(e.measureText("|MÃq").width),
                        g = Math.ceil(e.measureText("|MÃq").width),
                        h = 2 * g;
                    if (g = 1.4 * g | 0, d.width = f, d.height = h, e.fillStyle = "#f00", e.fillRect(0, 0, f, h), e.font = a, e.textBaseline = "alphabetic", e.fillStyle = "#000", e.fillText("|MÃq", 0, g), !e.getImageData(0, 0, f, h)) return b.ascent = g, b.descent = g + 6, b.fontSize = b.ascent + b.descent, c.Text.fontPropertiesCache[a] = b, b;
                    var i, j, k = e.getImageData(0, 0, f, h).data,
                        l = k.length,
                        m = 4 * f,
                        n = 0,
                        o = !1;
                    for (i = 0; i < g; i++) {
                        for (j = 0; j < m; j += 4)
                            if (255 !== k[n + j]) { o = !0; break }
                        if (o) break;
                        n += m
                    }
                    for (b.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--) {
                        for (j = 0; j < m; j += 4)
                            if (255 !== k[n + j]) { o = !0; break }
                        if (o) break;
                        n -= m
                    }
                    b.descent = i - g, b.descent += 6, b.fontSize = b.ascent + b.descent, c.Text.fontPropertiesCache[a] = b
                }
                return b
            }, c.Text.prototype.getBounds = function(a) { return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, a) }, Object.defineProperty(c.Text.prototype, "text", { get: function() { return this._text }, set: function(a) { a !== this._text && (this._text = a.toString() || "", this.dirty = !0, this.parent && this.updateTransform()) } }), Object.defineProperty(c.Text.prototype, "cssFont", { get: function() { return this.componentsToFont(this._fontComponents) }, set: function(a) { a = a || "bold 20pt Arial", this._fontComponents = this.fontToComponents(a), this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "font", { get: function() { return this._fontComponents.fontFamily }, set: function(a) { a = a || "Arial", a = a.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"), this._fontComponents.fontFamily = a, this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "fontSize", { get: function() { var a = this._fontComponents.fontSize; return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a }, set: function(a) { a = a || "0", "number" == typeof a && (a += "px"), this._fontComponents.fontSize = a, this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "fontWeight", { get: function() { return this._fontComponents.fontWeight || "normal" }, set: function(a) { a = a || "normal", this._fontComponents.fontWeight = a, this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "fontStyle", { get: function() { return this._fontComponents.fontStyle || "normal" }, set: function(a) { a = a || "normal", this._fontComponents.fontStyle = a, this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "fontVariant", { get: function() { return this._fontComponents.fontVariant || "normal" }, set: function(a) { a = a || "normal", this._fontComponents.fontVariant = a, this.updateFont(this._fontComponents) } }), Object.defineProperty(c.Text.prototype, "fill", { get: function() { return this.style.fill }, set: function(a) { a !== this.style.fill && (this.style.fill = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "align", { get: function() { return this.style.align }, set: function(a) { a !== this.style.align && (this.style.align = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "resolution", { get: function() { return this._res }, set: function(a) { a !== this._res && (this._res = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "tabs", { get: function() { return this.style.tabs }, set: function(a) { a !== this.style.tabs && (this.style.tabs = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "boundsAlignH", { get: function() { return this.style.boundsAlignH }, set: function(a) { a !== this.style.boundsAlignH && (this.style.boundsAlignH = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "boundsAlignV", { get: function() { return this.style.boundsAlignV }, set: function(a) { a !== this.style.boundsAlignV && (this.style.boundsAlignV = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "stroke", { get: function() { return this.style.stroke }, set: function(a) { a !== this.style.stroke && (this.style.stroke = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "strokeThickness", { get: function() { return this.style.strokeThickness }, set: function(a) { a !== this.style.strokeThickness && (this.style.strokeThickness = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "wordWrap", { get: function() { return this.style.wordWrap }, set: function(a) { a !== this.style.wordWrap && (this.style.wordWrap = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "wordWrapWidth", { get: function() { return this.style.wordWrapWidth }, set: function(a) { a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "lineSpacing", { get: function() { return this._lineSpacing }, set: function(a) { a !== this._lineSpacing && (this._lineSpacing = parseFloat(a), this.dirty = !0, this.parent && this.updateTransform()) } }), Object.defineProperty(c.Text.prototype, "shadowOffsetX", { get: function() { return this.style.shadowOffsetX }, set: function(a) { a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "shadowOffsetY", { get: function() { return this.style.shadowOffsetY }, set: function(a) { a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "shadowColor", { get: function() { return this.style.shadowColor }, set: function(a) { a !== this.style.shadowColor && (this.style.shadowColor = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "shadowBlur", { get: function() { return this.style.shadowBlur }, set: function(a) { a !== this.style.shadowBlur && (this.style.shadowBlur = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "shadowStroke", { get: function() { return this.style.shadowStroke }, set: function(a) { a !== this.style.shadowStroke && (this.style.shadowStroke = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "shadowFill", { get: function() { return this.style.shadowFill }, set: function(a) { a !== this.style.shadowFill && (this.style.shadowFill = a, this.dirty = !0) } }), Object.defineProperty(c.Text.prototype, "width", { get: function() { return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width }, set: function(a) { this.scale.x = a / this.texture.frame.width, this._width = a } }), Object.defineProperty(c.Text.prototype, "height", { get: function() { return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height }, set: function(a) { this.scale.y = a / this.texture.frame.height, this._height = a } }), c.Text.fontPropertiesCache = {}, c.Text.fontPropertiesCanvas = document.createElement("canvas"), c.Text.fontPropertiesContext = c.Text.fontPropertiesCanvas.getContext("2d"), c.BitmapText = function(a, b, d, e, f, g, h) { b = b || 0, d = d || 0, e = e || "", f = f || "", g = g || 32, h = h || "left", PIXI.DisplayObjectContainer.call(this), this.type = c.BITMAPTEXT, this.physicsType = c.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new c.Point, this._prevAnchor = new c.Point, this._glyphs = [], this._maxWidth = 0, this._text = f.toString() || "", this._data = a.cache.getBitmapFont(e), this._font = e, this._fontSize = g, this._align = h, this._tint = 16777215, this.updateText(), this.dirty = !1, c.Component.Core.init.call(this, a, b, d, "", null) }, c.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), c.BitmapText.prototype.constructor = c.BitmapText, c.Component.Core.install.call(c.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), c.BitmapText.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.BitmapText.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.BitmapText.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.BitmapText.prototype.preUpdateCore = c.Component.Core.preUpdate, c.BitmapText.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.BitmapText.prototype.postUpdate = function() { c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === c.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight)) }, c.BitmapText.prototype.setText = function(a) { this.text = a }, c.BitmapText.prototype.scanLine = function(a, b, c) {
                for (var d = 0, e = 0, f = -1, g = 0, h = null, i = this._maxWidth > 0 ? this._maxWidth : null, j = [], k = 0; k < c.length; k++) {
                    var l = k === c.length - 1;
                    if (/(?:\r\n|\r|\n)/.test(c.charAt(k))) return { width: e, text: c.substr(0, k), end: l, chars: j };
                    var m = c.charCodeAt(k),
                        n = a.chars[m],
                        o = 0;
                    void 0 === n && (m = 32, n = a.chars[m]);
                    var p = h && n.kerning[h] ? n.kerning[h] : 0;
                    if (/(\s)/.test(c.charAt(k)) && (f = k, g = e), o = (p + n.texture.width + n.xOffset) * b, i && e + o >= i && f > -1) return { width: g || e, text: c.substr(0, k - (k - f)), end: l, chars: j };
                    e += (n.xAdvance + p) * b, j.push(d + (n.xOffset + p) * b), d += (n.xAdvance + p) * b, h = m
                }
                return { width: e, text: c, end: l, chars: j }
            }, c.BitmapText.prototype.cleanText = function(a, b) {
                void 0 === b && (b = "");
                var c = this._data.font;
                if (!c) return "";
                for (var d = /\r\n|\n\r|\n|\r/g, e = a.replace(d, "\n").split("\n"), f = 0; f < e.length; f++) {
                    for (var g = "", h = e[f], i = 0; i < h.length; i++) g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
                    e[f] = g
                }
                return e.join("\n")
            }, c.BitmapText.prototype.updateText = function() {
                var a = this._data.font;
                if (a) {
                    var b = this.text,
                        c = this._fontSize / a.size,
                        d = [],
                        e = 0;
                    this.textWidth = 0;
                    do {
                        var f = this.scanLine(a, c, b);
                        f.y = e, d.push(f), f.width > this.textWidth && (this.textWidth = f.width), e += a.lineHeight * c, b = b.substr(f.text.length + 1)
                    } while (f.end === !1);
                    this.textHeight = e;
                    for (var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++) {
                        var f = d[k];
                        "right" === this._align ? h = this.textWidth - f.width : "center" === this._align && (h = (this.textWidth - f.width) / 2);
                        for (var l = 0; l < f.text.length; l++) {
                            var m = f.text.charCodeAt(l),
                                n = a.chars[m];
                            void 0 === n && (m = 32, n = a.chars[m]);
                            var o = this._glyphs[g];
                            o ? o.texture = n.texture : (o = new PIXI.Sprite(n.texture), o.name = f.text[l], this._glyphs.push(o)), o.position.x = f.chars[l] + h - i, o.position.y = f.y + n.yOffset * c - j, o.scale.set(c), o.tint = this.tint, o.texture.requiresReTint = !0, o.parent || this.addChild(o), g++
                        }
                    }
                    for (k = g; k < this._glyphs.length; k++) this.removeChild(this._glyphs[k])
                }
            }, c.BitmapText.prototype.purgeGlyphs = function() { for (var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++) this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]); return this._glyphs = [], this._glyphs = b, this.updateText(), a - b.length }, c.BitmapText.prototype.updateTransform = function() {!this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }, Object.defineProperty(c.BitmapText.prototype, "align", { get: function() { return this._align }, set: function(a) { a === this._align || "left" !== a && "center" !== a && "right" !== a || (this._align = a, this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "tint", { get: function() { return this._tint }, set: function(a) { a !== this._tint && (this._tint = a, this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "font", { get: function() { return this._font }, set: function(a) { a !== this._font && (this._font = a.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "fontSize", { get: function() { return this._fontSize }, set: function(a) { a = parseInt(a, 10), a !== this._fontSize && a > 0 && (this._fontSize = a, this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "text", { get: function() { return this._text }, set: function(a) { a !== this._text && (this._text = a.toString() || "", this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "maxWidth", { get: function() { return this._maxWidth }, set: function(a) { a !== this._maxWidth && (this._maxWidth = a, this.updateText()) } }), Object.defineProperty(c.BitmapText.prototype, "smoothed", { get: function() { return !this._data.base.scaleMode }, set: function(a) { a ? this._data.base.scaleMode = 0 : this._data.base.scaleMode = 1 } }), c.RetroFont = function(a, b, d, e, f, g, h, i, j, k) {
                if (!a.cache.checkImageKey(b)) return !1;
                void 0 !== g && null !== g || (g = a.cache.getImage(b).width / d), this.characterWidth = d, this.characterHeight = e, this.characterSpacingX = h || 0, this.characterSpacingY = i || 0, this.characterPerRow = g, this.offsetX = j || 0, this.offsetY = k || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = a.cache.getImage(b), this._text = "", this.grabData = [], this.frameData = new c.FrameData;
                for (var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++) {
                    var p = this.frameData.addFrame(new c.Frame(o, l, m, this.characterWidth, this.characterHeight));
                    this.grabData[f.charCodeAt(o)] = p.index, n++, n === this.characterPerRow ? (n = 0, l = this.offsetX, m += this.characterHeight + this.characterSpacingY) : l += this.characterWidth + this.characterSpacingX
                }
                a.cache.updateFrameData(b, this.frameData), this.stamp = new c.Image(a, 0, 0, b, 0), c.RenderTexture.call(this, a, 100, 100, "", c.scaleModes.NEAREST), this.type = c.RETROFONT
            }, c.RetroFont.prototype = Object.create(c.RenderTexture.prototype), c.RetroFont.prototype.constructor = c.RetroFont, c.RetroFont.ALIGN_LEFT = "left", c.RetroFont.ALIGN_RIGHT = "right", c.RetroFont.ALIGN_CENTER = "center", c.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", c.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", c.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", c.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", c.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", c.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", c.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", c.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", c.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", c.RetroFont.prototype.setFixedWidth = function(a, b) { void 0 === b && (b = "left"), this.fixedWidth = a, this.align = b }, c.RetroFont.prototype.setText = function(a, b, c, d, e, f) { this.multiLine = b || !1, this.customSpacingX = c || 0, this.customSpacingY = d || 0, this.align = e || "left", f ? this.autoUpperCase = !1 : this.autoUpperCase = !0, a.length > 0 && (this.text = a) }, c.RetroFont.prototype.buildRetroFontText = function() {
                var a = 0,
                    b = 0;
                if (this.clear(), this.multiLine) {
                    var d = this._text.split("\n");
                    this.fixedWidth > 0 ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                    for (var e = 0; e < d.length; e++) a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - d[e].length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(d[e], a, b, this.customSpacingX), b += this.characterHeight + this.customSpacingY
                }
                else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), a = 0, this.align === c.RetroFont.ALIGN_RIGHT ? a = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === c.RetroFont.ALIGN_CENTER && (a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, a += this.customSpacingX / 2), a < 0 && (a = 0), this.pasteLine(this._text, a, 0, this.customSpacingX);
                this.requiresReTint = !0
            }, c.RetroFont.prototype.pasteLine = function(a, b, c, d) {
                for (var e = 0; e < a.length; e++)
                    if (" " === a.charAt(e)) b += this.characterWidth + d;
                    else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)], this.renderXY(this.stamp, b, c, !1), b += this.characterWidth + d, b > this.width)) break
            }, c.RetroFont.prototype.getLongestLine = function() {
                var a = 0;
                if (this._text.length > 0)
                    for (var b = this._text.split("\n"), c = 0; c < b.length; c++) b[c].length > a && (a = b[c].length);
                return a
            }, c.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
                for (var b = "", c = 0; c < this._text.length; c++) {
                    var d = this._text[c],
                        e = d.charCodeAt(0);
                    (this.grabData[e] >= 0 || !a && "\n" === d) && (b = b.concat(d))
                }
                return b
            }, c.RetroFont.prototype.updateOffset = function(a, b) {
                if (this.offsetX !== a || this.offsetY !== b) {
                    for (var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--;) e[f].x += c, e[f].y += d;
                    this.buildRetroFontText()
                }
            }, Object.defineProperty(c.RetroFont.prototype, "text", {
                get: function() { return this._text },
                set: function(a) {
                    var b;
                    b = this.autoUpperCase ? a.toUpperCase() : a, b !== this._text && (this._text = b, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
                }
            }), Object.defineProperty(c.RetroFont.prototype, "smoothed", { get: function() { return this.stamp.smoothed }, set: function(a) { this.stamp.smoothed = a, this.buildRetroFontText() } }), c.Rope = function(a, b, d, e, f, g) {
                this.points = [], this.points = g, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null,
                    b = b || 0, d = d || 0, e = e || null, f = f || null, this.type = c.ROPE, PIXI.Rope.call(this, c.Cache.DEFAULT, this.points), c.Component.Core.init.call(this, a, b, d, e, f)
            }, c.Rope.prototype = Object.create(PIXI.Rope.prototype), c.Rope.prototype.constructor = c.Rope, c.Component.Core.install.call(c.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), c.Rope.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.Rope.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.Rope.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.Rope.prototype.preUpdateCore = c.Component.Core.preUpdate, c.Rope.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.Rope.prototype.update = function() { this._hasUpdateAnimation && this.updateAnimation.call(this) }, c.Rope.prototype.reset = function(a, b) { return c.Component.Reset.prototype.reset.call(this, a, b), this }, Object.defineProperty(c.Rope.prototype, "updateAnimation", { get: function() { return this._updateAnimation }, set: function(a) { a && "function" == typeof a ? (this._hasUpdateAnimation = !0, this._updateAnimation = a) : (this._hasUpdateAnimation = !1, this._updateAnimation = null) } }), Object.defineProperty(c.Rope.prototype, "segments", { get: function() { for (var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++) a = 4 * k, b = this.vertices[a] * this.scale.x, d = this.vertices[a + 1] * this.scale.y, e = this.vertices[a + 4] * this.scale.x, f = this.vertices[a + 3] * this.scale.y, g = c.Math.difference(b, e), h = c.Math.difference(d, f), b += this.world.x, d += this.world.y, i = new c.Rectangle(b, d, g, h), j.push(i); return j } }), c.TileSprite = function(a, b, d, e, f, g, h) {
                b = b || 0, d = d || 0, e = e || 256, f = f || 256, g = g || null, h = h || null, this.type = c.TILESPRITE, this.physicsType = c.SPRITE, this._scroll = new c.Point;
                var i = a.cache.getImage("__default", !0);
                PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f), c.Component.Core.init.call(this, a, b, d, g, h)
            }, c.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), c.TileSprite.prototype.constructor = c.TileSprite, c.Component.Core.install.call(c.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), c.TileSprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate, c.TileSprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate, c.TileSprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate, c.TileSprite.prototype.preUpdateCore = c.Component.Core.preUpdate, c.TileSprite.prototype.preUpdate = function() { return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, c.TileSprite.prototype.autoScroll = function(a, b) { this._scroll.set(a, b) }, c.TileSprite.prototype.stopScroll = function() { this._scroll.set(0, 0) }, c.TileSprite.prototype.destroy = function(a) { c.Component.Destroy.prototype.destroy.call(this, a), PIXI.TilingSprite.prototype.destroy.call(this) }, c.TileSprite.prototype.reset = function(a, b) { return c.Component.Reset.prototype.reset.call(this, a, b), this.tilePosition.x = 0, this.tilePosition.y = 0, this }, c.Device = function() { this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.wechatMinigame = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1 }, c.Device = new c.Device, c.Device.onInitialized = new c.Signal, c.Device.whenReady = function(a, b, c) {
                var d = this._readyCheck;
                if (this.deviceReadyAt || !d) a.call(b, this);
                else if (d._monitor || c) d._queue = d._queue || [], d._queue.push([a, b]);
                else {
                    d._monitor = d.bind(this), d._queue = d._queue || [], d._queue.push([a, b]);
                    var e = "undefined" != typeof window.cordova,
                        f = navigator.isCocoonJS;
                    "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(d._monitor, 0) : e && !f ? document.addEventListener("deviceready", d._monitor, !1) : (document.addEventListener("DOMContentLoaded", d._monitor, !1), window.addEventListener("load", d._monitor, !1))
                }
            }, c.Device._readyCheck = function() {
                var a = this._readyCheck;
                if (document.body) {
                    if (!this.deviceReadyAt) {
                        this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", a._monitor), document.removeEventListener("DOMContentLoaded", a._monitor), window.removeEventListener("load", a._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                        for (var b; b = a._queue.shift();) {
                            var c = b[0],
                                d = b[1];
                            c.call(d, this)
                        }
                        this._readyCheck = null, this._initialize = null, this.onInitialized = null
                    }
                }
                else window.setTimeout(a._monitor, 20)
            }, c.Device._initialize = function() {
                function a() {
                    var a = navigator.userAgent;
                    /Playstation Vita/.test(a) ? l.vita = !0 : /Kindle/.test(a) || /\bKF[A-Z][A-Z]+/.test(a) || /Silk.*Mobile Safari/.test(a) ? l.kindle = !0 : /Android/.test(a) ? l.android = !0 : /CrOS/.test(a) ? l.chromeOS = !0 : /iP[ao]d|iPhone/i.test(a) ? (l.iOS = !0, navigator.appVersion.match(/OS (\d+)/), l.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(a) ? l.linux = !0 : /Mac OS/.test(a) ? l.macOS = !0 : /Windows/.test(a) && (l.windows = !0), (/Windows Phone/i.test(a) || /IEMobile/i.test(a)) && (l.android = !1, l.iOS = !1, l.macOS = !1, l.windows = !0, l.windowsPhone = !0);
                    var b = /Silk/.test(a);
                    (l.windows || l.macOS || l.linux && !b || l.chromeOS) && (l.desktop = !0), (l.windowsPhone || /Windows NT/i.test(a) && /Touch/i.test(a)) && (l.desktop = !1)
                }

                function b() {
                    l.canvas = !!window.CanvasRenderingContext2D || l.cocoonJS;
                    try { l.localStorage = !!localStorage.getItem }
                    catch (a) { l.localStorage = !1 } l.file = !!(window.File && window.FileReader && window.FileList && window.Blob), l.fileSystem = !!window.requestFileSystem;
                    var b = { stencil: !0 };
                    l.webGL = function() { try { var a = document.createElement("canvas"); return a.screencanvas = !1, !!window.WebGLRenderingContext && (a.getContext("webgl", b) || a.getContext("experimental-webgl", b)) } catch (c) { return !1 } }(), l.webGL = !!l.webGL, l.worker = !!window.Worker, l.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, l.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, l.getUserMedia = l.getUserMedia && !!navigator.getUserMedia && !!window.URL, l.firefox && l.firefoxVersion < 21 && (l.getUserMedia = !1), !l.iOS && (l.ie || l.firefox || l.chrome) && (l.canvasBitBltShift = !0), (l.safari || l.mobileSafari) && (l.canvasBitBltShift = !1)
                }

                function c() {
                    ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (l.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (l.mspointer = !0), l.cocoonJS || ("onwheel" in window || l.ie && "WheelEvent" in window ? l.wheelEvent = "wheel" : "onmousewheel" in window ? l.wheelEvent = "mousewheel" : l.firefox && "MouseScrollEvent" in window && (l.wheelEvent = "DOMMouseScroll"))
                }

                function d() {
                    for (var a = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], b = document.createElement("div"), c = 0; c < a.length; c++)
                        if (b[a[c]]) { l.fullscreen = !0, l.requestFullscreen = a[c]; break }
                    var d = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (l.fullscreen)
                        for (var c = 0; c < d.length; c++)
                            if (document[d[c]]) { l.cancelFullscreen = d[c]; break }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (l.fullscreenKeyboard = !0)
                }

                function e() {
                    var a = navigator.userAgent;
                    if (/Arora/.test(a) ? l.arora = !0 : /Edge\/\d+/.test(a) ? l.edge = !0 : /Chrome\/(\d+)/.test(a) && !l.windowsPhone ? (l.chrome = !0, l.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(a) ? l.epiphany = !0 : /Firefox\D+(\d+)/.test(a) ? (l.firefox = !0, l.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(a) && l.iOS ? l.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(a) ? (l.ie = !0, l.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(a) ? l.midori = !0 : /Opera/.test(a) ? l.opera = !0 : /Safari\/(\d+)/.test(a) && !l.windowsPhone ? (l.safari = !0, /Version\/(\d+)\./.test(a) && (l.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && (l.ie = !0, l.trident = !0, l.tridentVersion = parseInt(RegExp.$1, 10), l.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(a) && (l.silk = !0), navigator.standalone && (l.webApp = !0), "undefined" != typeof window.cordova && (l.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (l.node = !0), l.node && "object" == typeof process.versions && (l.nodeWebkit = !!process.versions["node-webkit"], l.electron = !!process.versions.electron), navigator.isCocoonJS && (l.cocoonJS = !0), "undefined" != typeof window.wx && (l.wechatMinigame = !0), l.cocoonJS) try { l.cocoonJSApp = "undefined" != typeof CocoonJS }
                    catch (b) { l.cocoonJSApp = !1 }
                    "undefined" != typeof window.ejecta && (l.ejecta = !0), /Crosswalk/.test(a) && (l.crosswalk = !0)
                }

                function f() {
                    var a = document.createElement("video"),
                        b = !1;
                    try {
                        (b = !!a.canPlayType) && (a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (l.oggVideo = !0), a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.h264Video = !0, l.mp4Video = !0), a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (l.webmVideo = !0), a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (l.vp9Video = !0), a.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.hlsVideo = !0))
                    }
                    catch (c) {}
                }

                function g() {
                    l.audioData = !!window.Audio, l.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                    var a = document.createElement("audio"),
                        b = !1;
                    try {
                        if ((b = !!a.canPlayType) && (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (l.ogg = !0), (a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || a.canPlayType("audio/opus;").replace(/^no$/, "")) && (l.opus = !0), a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (l.mp3 = !0), a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (l.wav = !0), (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) && (l.m4a = !0), a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (l.webm = !0), "" !== a.canPlayType('audio/mp4;codecs="ec-3"')))
                            if (l.edge) l.dolby = !0;
                            else if (l.safari && l.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                            var c = parseInt(RegExp.$1, 10),
                                d = parseInt(RegExp.$2, 10);
                            (10 === c && d >= 11 || c > 10) && (l.dolby = !0)
                        }
                    }
                    catch (e) {}
                }

                function h() {
                    var a = new ArrayBuffer(4),
                        b = new Uint8Array(a),
                        c = new Uint32Array(a);
                    return b[0] = 161, b[1] = 178, b[2] = 195, b[3] = 212, 3569595041 === c[0] || 2712847316 !== c[0] && null
                }

                function i() {
                    if (void 0 === Uint8ClampedArray) return !1;
                    var a = PIXI.CanvasPool.create(this, 1, 1),
                        b = a.getContext("2d");
                    if (!b) return !1;
                    var c = b.createImageData(1, 1);
                    return PIXI.CanvasPool.remove(this), c.data instanceof Uint8ClampedArray
                }

                function j() { l.pixelRatio = window.devicePixelRatio || 1, l.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") !== -1, l.iPhone4 = 2 === l.pixelRatio && l.iPhone, l.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") !== -1, "undefined" != typeof Int8Array ? l.typedArray = !0 : l.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (l.littleEndian = h(), l.LITTLE_ENDIAN = l.littleEndian), l.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== l.littleEndian && i(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (l.vibration = !0) }

                function k() {
                    var a, b = document.createElement("p"),
                        c = { webkitTransform: "-webkit-transform", OTransform: "-o-transform", msTransform: "-ms-transform", MozTransform: "-moz-transform", transform: "transform" };
                    document.body.insertBefore(b, null);
                    for (var d in c) void 0 !== b.style[d] && (b.style[d] = "translate3d(1px,1px,1px)", a = window.getComputedStyle(b).getPropertyValue(c[d]));
                    document.body.removeChild(b), l.css3D = void 0 !== a && a.length > 0 && "none" !== a
                }
                var l = this;
                a(), e(), g(), f(), k(), j(), b(), d(), c()
            }, c.Device.canPlayAudio = function(a) { return !("mp3" !== a || !this.mp3) || (!("ogg" !== a || !this.ogg && !this.opus) || (!("m4a" !== a || !this.m4a) || (!("opus" !== a || !this.opus) || (!("wav" !== a || !this.wav) || (!("webm" !== a || !this.webm) || !("mp4" !== a || !this.dolby)))))) }, c.Device.canPlayVideo = function(a) { return !("webm" !== a || !this.webmVideo && !this.vp9Video) || (!("mp4" !== a || !this.mp4Video && !this.h264Video) || (!("ogg" !== a && "ogv" !== a || !this.oggVideo) || !("mpeg" !== a || !this.hlsVideo))) }, c.Device.isConsoleOpen = function() { return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && console.profiles.length > 0 }, c.Device.isAndroidStockBrowser = function() { var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/); return a && a[1] < 537 }, c.Canvas = { create: function(a, b, c, d, e) { b = b || 256, c = c || 256; var f = e ? document.createElement("canvas") : PIXI.CanvasPool.create(a, b, c); return "string" == typeof d && "" !== d && (f.id = d), f.width = b, f.height = c, f.style.display = "block", f }, setBackgroundColor: function(a, b) { return b = b || "rgb(0,0,0)", a.style.backgroundColor = b, a }, setTouchAction: function(a, b) { return b = b || "none", a.style.msTouchAction = b, a.style["ms-touch-action"] = b, a.style["touch-action"] = b, a }, setUserSelect: function(a, b) { return b = b || "none", a.style["-webkit-touch-callout"] = b, a.style["-webkit-user-select"] = b, a.style["-khtml-user-select"] = b, a.style["-moz-user-select"] = b, a.style["-ms-user-select"] = b, a.style["user-select"] = b, a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", a }, addToDOM: function(a, b, c) { var d; return void 0 === c && (c = !0), b && ("string" == typeof b ? d = document.getElementById(b) : "object" == typeof b && 1 === b.nodeType && (d = b)), d || (d = document.body), c && d.style && (d.style.overflow = "hidden"), d.appendChild(a), a }, removeFromDOM: function(a) { a.parentNode && a.parentNode.removeChild(a) }, setTransform: function(a, b, c, d, e, f, g) { return a.setTransform(d, f, g, e, b, c), a }, setSmoothingEnabled: function(a, b) { var d = c.Canvas.getSmoothingPrefix(a); return d && (a[d] = b), a }, getSmoothingPrefix: function(a) { var b = ["i", "webkitI", "msI", "mozI", "oI"]; for (var c in b) { var d = b[c] + "mageSmoothingEnabled"; if (d in a) return d } return null }, getSmoothingEnabled: function(a) { var b = c.Canvas.getSmoothingPrefix(a); if (b) return a[b] }, setImageRenderingCrisp: function(a) { for (var b = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], c = 0; c < b.length; c++) a.style["image-rendering"] = b[c]; return a.style.msInterpolationMode = "nearest-neighbor", a }, setImageRenderingBicubic: function(a) { return a.style["image-rendering"] = "auto", a.style.msInterpolationMode = "bicubic", a } }, c.RequestAnimationFrame = function(a, b) {
                void 0 === b && (b = !1), this.game = a, this.isRunning = !1, this.forceSetTimeOut = b;
                for (var c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !window.requestAnimationFrame; d++) window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"];
                this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
            }, c.RequestAnimationFrame.prototype = { start: function() { this.isRunning = !0; var a = this;!window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() { return a.updateSetTimeout() }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(b) { return a.updateRAF(b) }, this._timeOutID = window.requestAnimationFrame(this._onLoop)) }, updateRAF: function(a) { this.isRunning && (this.game.update(Math.floor(a)), this._timeOutID = window.requestAnimationFrame(this._onLoop)) }, updateSetTimeout: function() { this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)) }, stop: function() { this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1 }, isSetTimeOut: function() { return this._isSetTimeOut }, isRAF: function() { return this._isSetTimeOut === !1 } }, c.RequestAnimationFrame.prototype.constructor = c.RequestAnimationFrame, c.Math = {
                PI2: 2 * Math.PI,
                between: function(a, b) { return Math.floor(Math.random() * (b - a + 1) + a) },
                fuzzyEqual: function(a, b, c) { return void 0 === c && (c = 1e-4), Math.abs(a - b) < c },
                fuzzyLessThan: function(a, b, c) { return void 0 === c && (c = 1e-4), a < b + c },
                fuzzyGreaterThan: function(a, b, c) { return void 0 === c && (c = 1e-4), a > b - c },
                fuzzyCeil: function(a, b) { return void 0 === b && (b = 1e-4), Math.ceil(a - b) },
                fuzzyFloor: function(a, b) { return void 0 === b && (b = 1e-4), Math.floor(a + b) },
                average: function() { for (var a = 0, b = arguments.length, c = 0; c < b; c++) a += +arguments[c]; return a / b },
                shear: function(a) { return a % 1 },
                snapTo: function(a, b, c) { return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.round(a / b), c + a) },
                snapToFloor: function(a, b, c) { return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.floor(a / b), c + a) },
                snapToCeil: function(a, b, c) { return void 0 === c && (c = 0), 0 === b ? a : (a -= c, a = b * Math.ceil(a / b), c + a) },
                roundTo: function(a, b, c) { void 0 === b && (b = 0), void 0 === c && (c = 10); var d = Math.pow(c, -b); return Math.round(a * d) / d },
                floorTo: function(a, b, c) { void 0 === b && (b = 0), void 0 === c && (c = 10); var d = Math.pow(c, -b); return Math.floor(a * d) / d },
                ceilTo: function(a, b, c) { void 0 === b && (b = 0), void 0 === c && (c = 10); var d = Math.pow(c, -b); return Math.ceil(a * d) / d },
                rotateToAngle: function(a, b, d) { return void 0 === d && (d = .05), a === b ? a : (Math.abs(b - a) <= d || Math.abs(b - a) >= c.Math.PI2 - d ? a = b : (Math.abs(b - a) > Math.PI && (b < a ? b += c.Math.PI2 : b -= c.Math.PI2), b > a ? a += d : b < a && (a -= d)), a) },
                getShortestAngle: function(a, b) { var c = b - a; if (0 === c) return 0; var d = Math.floor((c - -180) / 360); return c - 360 * d },
                angleBetween: function(a, b, c, d) { return Math.atan2(d - b, c - a) },
                angleBetweenY: function(a, b, c, d) { return Math.atan2(c - a, d - b) },
                angleBetweenPoints: function(a, b) { return Math.atan2(b.y - a.y, b.x - a.x) },
                angleBetweenPointsY: function(a, b) { return Math.atan2(b.x - a.x, b.y - a.y) },
                reverseAngle: function(a) { return this.normalizeAngle(a + Math.PI, !0) },
                normalizeAngle: function(a) { return a %= 2 * Math.PI, a >= 0 ? a : a + 2 * Math.PI },
                maxAdd: function(a, b, c) { return Math.min(a + b, c) },
                minSub: function(a, b, c) { return Math.max(a - b, c) },
                wrap: function(a, b, c) { var d = c - b; if (d <= 0) return 0; var e = (a - b) % d; return e < 0 && (e += d), e + b },
                wrapValue: function(a, b, c) { var d; return a = Math.abs(a), b = Math.abs(b), c = Math.abs(c), d = (a + b) % c },
                isOdd: function(a) { return !!(1 & a) },
                isEven: function(a) { return !(1 & a) },
                min: function() {
                    if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
                    else var a = arguments;
                    for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] < a[c] && (c = b);
                    return a[c]
                },
                max: function() {
                    if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
                    else var a = arguments;
                    for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] > a[c] && (c = b);
                    return a[c]
                },
                minProperty: function(a) {
                    if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
                    else var b = arguments.slice(1);
                    for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] < b[d][a] && (d = c);
                    return b[d][a]
                },
                maxProperty: function(a) {
                    if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
                    else var b = arguments.slice(1);
                    for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] > b[d][a] && (d = c);
                    return b[d][a]
                },
                wrapAngle: function(a, b) { return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180) },
                linearInterpolation: function(a, b) {
                    var c = a.length - 1,
                        d = c * b,
                        e = Math.floor(d);
                    return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e)
                },
                bezierInterpolation: function(a, b) { for (var c = 0, d = a.length - 1, e = 0; e <= d; e++) c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e); return c },
                catmullRomInterpolation: function(a, b) {
                    var c = a.length - 1,
                        d = c * b,
                        e = Math.floor(d);
                    return a[0] === a[c] ? (b < 0 && (e = Math.floor(d = c * (1 + b))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : b < 0 ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e)
                },
                linear: function(a, b, c) { return (b - a) * c + a },
                bernstein: function(a, b) { return this.factorial(a) / this.factorial(b) / this.factorial(a - b) },
                factorial: function(a) { if (0 === a) return 1; for (var b = a; --a;) b *= a; return b },
                catmullRom: function(a, b, c, d, e) {
                    var f = .5 * (c - a),
                        g = .5 * (d - b),
                        h = e * e,
                        i = e * h;
                    return (2 * b - 2 * c + f + g) * i + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b
                },
                difference: function(a, b) { return Math.abs(a - b) },
                roundAwayFromZero: function(a) { return a > 0 ? Math.ceil(a) : Math.floor(a) },
                sinCosGenerator: function(a, b, c, d) { void 0 === b && (b = 1), void 0 === c && (c = 1), void 0 === d && (d = 1); for (var e = b, f = c, g = d * Math.PI / a, h = [], i = [], j = 0; j < a; j++) f -= e * g, e += f * g, h[j] = f, i[j] = e; return { sin: i, cos: h, length: a } },
                distance: function(a, b, c, d) {
                    var e = a - c,
                        f = b - d;
                    return Math.sqrt(e * e + f * f)
                },
                distanceSq: function(a, b, c, d) {
                    var e = a - c,
                        f = b - d;
                    return e * e + f * f
                },
                distancePow: function(a, b, c, d, e) { return void 0 === e && (e = 2), Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e)) },
                clamp: function(a, b, c) { return a < b ? b : c < a ? c : a },
                clampBottom: function(a, b) { return a < b ? b : a },
                within: function(a, b, c) { return Math.abs(a - b) <= c },
                mapLinear: function(a, b, c, d, e) { return d + (a - b) * (e - d) / (c - b) },
                smoothstep: function(a, b, c) { return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * (3 - 2 * a) },
                smootherstep: function(a, b, c) { return a = Math.max(0, Math.min(1, (a - b) / (c - b))), a * a * a * (a * (6 * a - 15) + 10) },
                sign: function(a) { return a < 0 ? -1 : a > 0 ? 1 : 0 },
                percent: function(a, b, c) { return void 0 === c && (c = 0), a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b }
            };
        var k = Math.PI / 180,
            l = 180 / Math.PI;
        return c.Math.degToRad = function(a) { return a * k }, c.Math.radToDeg = function(a) { return a * l }, c.RandomDataGenerator = function(a) { void 0 === a && (a = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof a ? this.state(a) : this.sow(a) }, c.RandomDataGenerator.prototype = {
            rnd: function() { var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | a, this.s0 = this.s1, this.s1 = this.s2, this.s2 = a - this.c, this.s2 },
            sow: function(a) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, a)
                    for (var b = 0; b < a.length && null != a[b]; b++) {
                        var c = a[b];
                        this.s0 -= this.hash(c), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(c), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(c), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(a) { var b, c, d; for (d = 4022871197, a = a.toString(), c = 0; c < a.length; c++) d += a.charCodeAt(c), b = .02519603282416938 * d, d = b >>> 0, b -= d, b *= d, d = b >>> 0, b -= d, d += 4294967296 * b; return 2.3283064365386963e-10 * (d >>> 0) },
            integer: function() { return 4294967296 * this.rnd.apply(this) },
            frac: function() { return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0) },
            real: function() { return this.integer() + this.frac() },
            integerInRange: function(a, b) { return Math.floor(this.realInRange(0, b - a + 1) + a) },
            between: function(a, b) { return this.integerInRange(a, b) },
            realInRange: function(a, b) { return this.frac() * (b - a) + a },
            normal: function() { return 1 - 2 * this.frac() },
            uuid: function() {
                var a = "",
                    b = "";
                for (b = a = ""; a++ <<
                    36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-");
                return b
            },
            pick: function(a) { return a[this.integerInRange(0, a.length - 1)] },
            sign: function() { return this.pick([-1, 1]) },
            weightedPick: function(a) { return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + .5)] },
            timestamp: function(a, b) { return this.realInRange(a || 9466848e5, b || 1577862e6) },
            angle: function() { return this.integerInRange(-180, 180) },
            state: function(a) { return "string" == typeof a && a.match(/^!rnd/) && (a = a.split(","), this.c = parseFloat(a[1]), this.s0 = parseFloat(a[2]), this.s1 = parseFloat(a[3]), this.s2 = parseFloat(a[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",") }
        }, c.RandomDataGenerator.prototype.constructor = c.RandomDataGenerator, c.QuadTree = function(a, b, c, d, e, f, g) { this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(a, b, c, d, e, f, g) }, c.QuadTree.prototype = {
            reset: function(a, b, c, d, e, f, g) { this.maxObjects = e || 10, this.maxLevels = f || 4, this.level = g || 0, this.bounds = { x: Math.round(a), y: Math.round(b), width: c, height: d, subWidth: Math.floor(c / 2), subHeight: Math.floor(d / 2), right: Math.round(a) + Math.floor(c / 2), bottom: Math.round(b) + Math.floor(d / 2) }, this.objects.length = 0, this.nodes.length = 0 },
            populate: function(a) { a.forEach(this.populateHandler, this, !0) },
            populateHandler: function(a) { a.body && a.exists && this.insert(a.body) },
            split: function() { this.nodes[0] = new c.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new c.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new c.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new c.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1) },
            insert: function(a) {
                var b, c = 0;
                if (null != this.nodes[0] && (b = this.getIndex(a), b !== -1)) return void this.nodes[b].insert(a);
                if (this.objects.push(a), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                    for (null == this.nodes[0] && this.split(); c < this.objects.length;) b = this.getIndex(this.objects[c]), b !== -1 ? this.nodes[b].insert(this.objects.splice(c, 1)[0]) : c++
            },
            getIndex: function(a) { var b = -1; return a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3)), b },
            retrieve: function(a) {
                if (a instanceof c.Rectangle) var b = this.objects,
                    d = this.getIndex(a);
                else {
                    if (!a.body) return this._empty;
                    var b = this.objects,
                        d = this.getIndex(a.body)
                }
                return this.nodes[0] && (d !== -1 ? b = b.concat(this.nodes[d].retrieve(a)) : (b = b.concat(this.nodes[0].retrieve(a)), b = b.concat(this.nodes[1].retrieve(a)), b = b.concat(this.nodes[2].retrieve(a)), b = b.concat(this.nodes[3].retrieve(a)))), b
            },
            clear: function() {
                this.objects.length = 0;
                for (var a = this.nodes.length; a--;) this.nodes[a].clear(), this.nodes.splice(a, 1);
                this.nodes.length = 0
            }
        }, c.QuadTree.prototype.constructor = c.QuadTree, c.Net = function(a) { this.game = a }, c.Net.prototype = {
            getHostName: function() { return window.location && window.location.hostname ? window.location.hostname : null },
            checkDomainName: function(a) { return window.location.hostname.indexOf(a) !== -1 },
            updateQueryString: function(a, b, c, d) {
                void 0 === c && (c = !1), void 0 !== d && "" !== d || (d = window.location.href);
                var e = "",
                    f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
                if (f.test(d)) e = "undefined" != typeof b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
                else if ("undefined" != typeof b && null !== b) {
                    var g = d.indexOf("?") !== -1 ? "&" : "?",
                        h = d.split("#");
                    d = h[0] + g + a + "=" + b, h[1] && (d += "#" + h[1]), e = d
                }
                else e = d;
                return c ? void(window.location.href = e) : e
            },
            getQueryString: function(a) {
                void 0 === a && (a = "");
                var b = {},
                    c = location.search.substring(1).split("&");
                for (var d in c) {
                    var e = c[d].split("=");
                    if (e.length > 1) {
                        if (a && a === this.decodeURI(e[0])) return this.decodeURI(e[1]);
                        b[this.decodeURI(e[0])] = this.decodeURI(e[1])
                    }
                }
                return b
            },
            decodeURI: function(a) { return decodeURIComponent(a.replace(/\+/g, " ")) }
        }, c.Net.prototype.constructor = c.Net, c.TweenManager = function(a) { this.game = a, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = { Power0: c.Easing.Power0, Power1: c.Easing.Power1, Power2: c.Easing.Power2, Power3: c.Easing.Power3, Power4: c.Easing.Power4, Linear: c.Easing.Linear.None, Quad: c.Easing.Quadratic.Out, Cubic: c.Easing.Cubic.Out, Quart: c.Easing.Quartic.Out, Quint: c.Easing.Quintic.Out, Sine: c.Easing.Sinusoidal.Out, Expo: c.Easing.Exponential.Out, Circ: c.Easing.Circular.Out, Elastic: c.Easing.Elastic.Out, Back: c.Easing.Back.Out, Bounce: c.Easing.Bounce.Out, "Quad.easeIn": c.Easing.Quadratic.In, "Cubic.easeIn": c.Easing.Cubic.In, "Quart.easeIn": c.Easing.Quartic.In, "Quint.easeIn": c.Easing.Quintic.In, "Sine.easeIn": c.Easing.Sinusoidal.In, "Expo.easeIn": c.Easing.Exponential.In, "Circ.easeIn": c.Easing.Circular.In, "Elastic.easeIn": c.Easing.Elastic.In, "Back.easeIn": c.Easing.Back.In, "Bounce.easeIn": c.Easing.Bounce.In, "Quad.easeOut": c.Easing.Quadratic.Out, "Cubic.easeOut": c.Easing.Cubic.Out, "Quart.easeOut": c.Easing.Quartic.Out, "Quint.easeOut": c.Easing.Quintic.Out, "Sine.easeOut": c.Easing.Sinusoidal.Out, "Expo.easeOut": c.Easing.Exponential.Out, "Circ.easeOut": c.Easing.Circular.Out, "Elastic.easeOut": c.Easing.Elastic.Out, "Back.easeOut": c.Easing.Back.Out, "Bounce.easeOut": c.Easing.Bounce.Out, "Quad.easeInOut": c.Easing.Quadratic.InOut, "Cubic.easeInOut": c.Easing.Cubic.InOut, "Quart.easeInOut": c.Easing.Quartic.InOut, "Quint.easeInOut": c.Easing.Quintic.InOut, "Sine.easeInOut": c.Easing.Sinusoidal.InOut, "Expo.easeInOut": c.Easing.Exponential.InOut, "Circ.easeInOut": c.Easing.Circular.InOut, "Elastic.easeInOut": c.Easing.Elastic.InOut, "Back.easeInOut": c.Easing.Back.InOut, "Bounce.easeInOut": c.Easing.Bounce.InOut }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this) }, c.TweenManager.prototype = {
            getAll: function() { return this._tweens },
            removeAll: function() {
                for (var a = 0; a < this._tweens.length; a++) this._tweens[a].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(a, b) {
                void 0 === b && (b = !0);
                var d, e;
                if (Array.isArray(a))
                    for (d = 0, e = a.length; d < e; d++) this.removeFrom(a[d]);
                else if (a.type === c.GROUP && b)
                    for (var d = 0, e = a.children.length; d < e; d++) this.removeFrom(a.children[d]);
                else { for (d = 0, e = this._tweens.length; d < e; d++) a === this._tweens[d].target && this.remove(this._tweens[d]); for (d = 0, e = this._add.length; d < e; d++) a === this._add[d].target && this.remove(this._add[d]) }
            },
            add: function(a) { a._manager = this, this._add.push(a) },
            create: function(a) { return new c.Tween(a, this.game, this) },
            remove: function(a) {
                var b = this._tweens.indexOf(a);
                b !== -1 ? this._tweens[b].pendingDelete = !0 : (b = this._add.indexOf(a), b !== -1 && (this._add[b].pendingDelete = !0))
            },
            update: function() {
                var a = this._add.length,
                    b = this._tweens.length;
                if (0 === b && 0 === a) return !1;
                for (var c = 0; c < b;) this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1), b--);
                return a > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(a) { return this._tweens.some(function(b) { return b.target === a }) },
            _pauseAll: function() { for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._pause() },
            _resumeAll: function() { for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._resume() },
            pauseAll: function() { for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].pause() },
            resumeAll: function() { for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].resume(!0) }
        }, c.TweenManager.prototype.constructor = c.TweenManager, c.Tween = function(a, b, d) { this.game = b, this.target = a, this.manager = d, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new c.Signal, this.onLoop = new c.Signal, this.onRepeat = new c.Signal, this.onChildComplete = new c.Signal, this.onComplete = new c.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = d.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1 }, c.Tween.prototype = {
            to: function(a, b, d, e, f, g, h) {
                return (void 0 === b || b <= 0) && (b = 1e3), void 0 !== d && null !== d || (d = c.Easing.Default),
                    void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? this : (this.timeline.push(new c.TweenData(this).to(a, b, d, f, g, h)), e && this.start(), this)
            },
            from: function(a, b, d, e, f, g, h) { return void 0 === b && (b = 1e3), void 0 !== d && null !== d || (d = c.Easing.Default), void 0 === e && (e = !1), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = !1), "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]), this.isRunning ? this : (this.timeline.push(new c.TweenData(this).from(a, b, d, f, g, h)), e && this.start(), this) },
            start: function(a) {
                if (void 0 === a && (a = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (var b = 0; b < this.timeline.length; b++)
                    for (var c in this.timeline[b].vEnd) this.properties[c] = this.target[c] || 0, Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
                for (var b = 0; b < this.timeline.length; b++) this.timeline[b].loadValues();
                return this.manager.add(this), this.isRunning = !0, (a < 0 || a > this.timeline.length - 1) && (a = 0), this.current = a, this.timeline[this.current].start(), this
            },
            stop: function(a) { return void 0 === a && (a = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, a && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this },
            updateTweenData: function(a, b, c) {
                if (0 === this.timeline.length) return this;
                if (void 0 === c && (c = 0), c === -1)
                    for (var d = 0; d < this.timeline.length; d++) this.timeline[d][a] = b;
                else this.timeline[c][a] = b;
                return this
            },
            delay: function(a, b) { return this.updateTweenData("delay", a, b) },
            repeat: function(a, b, c) { return void 0 === b && (b = 0), this.updateTweenData("repeatCounter", a, c), this.updateTweenData("repeatDelay", b, c) },
            repeatDelay: function(a, b) { return this.updateTweenData("repeatDelay", a, b) },
            yoyo: function(a, b, c) { return void 0 === b && (b = 0), this.updateTweenData("yoyo", a, c), this.updateTweenData("yoyoDelay", b, c) },
            yoyoDelay: function(a, b) { return this.updateTweenData("yoyoDelay", a, b) },
            easing: function(a, b) { return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]), this.updateTweenData("easingFunction", a, b) },
            interpolation: function(a, b, d) { return void 0 === b && (b = c.Math), this.updateTweenData("interpolationFunction", a, d), this.updateTweenData("interpolationContext", b, d) },
            repeatAll: function(a) { return void 0 === a && (a = 0), this.repeatCounter = a, this },
            chain: function() { for (var a = arguments.length; a--;) a > 0 ? arguments[a - 1].chainedTween = arguments[a] : this.chainedTween = arguments[a]; return this },
            loop: function(a) { return void 0 === a && (a = !0), this.repeatCounter = a ? -1 : 0, this },
            onUpdateCallback: function(a, b) { return this._onUpdateCallback = a, this._onUpdateCallbackContext = b, this },
            pause: function() { this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time },
            _pause: function() { this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time) },
            resume: function() { if (this.isPaused) { this.isPaused = !1, this._codePaused = !1; for (var a = 0; a < this.timeline.length; a++) this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime) } },
            _resume: function() { this._codePaused || this.resume() },
            update: function(a) { if (this.pendingDelete || !this.target) return !1; if (this.isPaused) return !0; var b = this.timeline[this.current].update(a); if (b === c.TweenData.PENDING) return !0; if (b === c.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning; if (b === c.TweenData.LOOPED) return this.timeline[this.current].repeatCounter === -1 ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0; if (b === c.TweenData.COMPLETE) { var d = !1; return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, d = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, d = !0)), d ? this.repeatCounter === -1 ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0) } },
            generateData: function(a, b) {
                if (null === this.game || null === this.target) return null;
                void 0 === a && (a = 60), void 0 === b && (b = []);
                for (var c = 0; c < this.timeline.length; c++)
                    for (var d in this.timeline[c].vEnd) this.properties[d] = this.target[d] || 0, Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
                for (var c = 0; c < this.timeline.length; c++) this.timeline[c].loadValues();
                for (var c = 0; c < this.timeline.length; c++) b = b.concat(this.timeline[c].generateData(a));
                return b
            }
        }, Object.defineProperty(c.Tween.prototype, "totalDuration", { get: function() { for (var a = 0, b = 0; b < this.timeline.length; b++) a += this.timeline[b].duration; return a } }), c.Tween.prototype.constructor = c.Tween, c.TweenData = function(a) { this.parent = a, this.game = a.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = c.Easing.Default, this.interpolationFunction = c.Math.linearInterpolation, this.interpolationContext = c.Math, this.isRunning = !1, this.isFrom = !1 }, c.TweenData.PENDING = 0, c.TweenData.RUNNING = 1, c.TweenData.LOOPED = 2, c.TweenData.COMPLETE = 3, c.TweenData.prototype = {
            to: function(a, b, c, d, e, f) { return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !1, this },
            from: function(a, b, c, d, e, f) { return this.vEnd = a, this.duration = b, this.easingFunction = c, this.delay = d, this.repeatTotal = e, this.yoyo = f, this.isFrom = !0, this },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a], this.parent.target[a] = this.vStart[a];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var a in this.parent.properties) {
                    if (this.vStart[a] = this.parent.properties[a], Array.isArray(this.vEnd[a])) {
                        if (0 === this.vEnd[a].length) continue;
                        0 === this.percent && (this.vEnd[a] = [this.vStart[a]].concat(this.vEnd[a]))
                    }
                    "undefined" != typeof this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)), this.parent.properties[a] = this.vEnd[a]) : this.vEnd[a] = this.vStart[a], this.vStartCache[a] = this.vStart[a], this.vEndCache[a] = this.vEnd[a]
                }
                return this
            },
            update: function(a) {
                if (this.isRunning) { if (a < this.startTime) return c.TweenData.RUNNING }
                else {
                    if (!(a >= this.startTime)) return c.TweenData.PENDING;
                    this.isRunning = !0
                }
                var b = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                this.parent.reverse ? (this.dt -= b * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += b * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                for (var d in this.vEnd) {
                    var e = this.vStart[d],
                        f = this.vEnd[d];
                    Array.isArray(f) ? this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value) : this.parent.target[d] = e + (f - e) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : c.TweenData.RUNNING
            },
            generateData: function(a) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var b = [],
                    c = !1,
                    d = 1 / a * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= d, this.dt = Math.max(this.dt, 0)) : (this.dt += d, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var e = {};
                    for (var f in this.vEnd) {
                        var g = this.vStart[f],
                            h = this.vEnd[f];
                        Array.isArray(h) ? e[f] = this.interpolationFunction(h, this.value) : e[f] = g + (h - g) * this.value
                    }
                    b.push(e), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (c = !0)
                } while (!c);
                if (this.yoyo) {
                    var i = b.slice();
                    i.reverse(), b = b.concat(i)
                }
                return b
            },
            repeat: function() {
                if (this.yoyo) { if (this.inReverse && 0 === this.repeatCounter) { for (var a in this.vStartCache) this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a]; return this.inReverse = !1, c.TweenData.COMPLETE } this.inReverse = !this.inReverse }
                else if (0 === this.repeatCounter) return c.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var a in this.vStartCache) this.vStart[a] = this.vEndCache[a], this.vEnd[a] = this.vStartCache[a];
                else {
                    for (var a in this.vStartCache) this.vStart[a] = this.vStartCache[a], this.vEnd[a] = this.vEndCache[a];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, c.TweenData.LOOPED
            }
        }, c.TweenData.prototype.constructor = c.TweenData, c.Easing = {
            Linear: { None: function(a) { return a } },
            Quadratic: { In: function(a) { return a * a }, Out: function(a) { return a * (2 - a) }, InOut: function(a) { return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1) } },
            Cubic: { In: function(a) { return a * a * a }, Out: function(a) { return --a * a * a + 1 }, InOut: function(a) { return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2) } },
            Quartic: { In: function(a) { return a * a * a * a }, Out: function(a) { return 1 - --a * a * a * a }, InOut: function(a) { return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2) } },
            Quintic: { In: function(a) { return a * a * a * a * a }, Out: function(a) { return --a * a * a * a * a + 1 }, InOut: function(a) { return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2) } },
            Sinusoidal: { In: function(a) { return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2) }, Out: function(a) { return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2) }, InOut: function(a) { return 0 === a ? 0 : 1 === a ? 1 : .5 * (1 - Math.cos(Math.PI * a)) } },
            Exponential: { In: function(a) { return 0 === a ? 0 : Math.pow(1024, a - 1) }, Out: function(a) { return 1 === a ? 1 : 1 - Math.pow(2, -10 * a) }, InOut: function(a) { return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2) } },
            Circular: { In: function(a) { return 1 - Math.sqrt(1 - a * a) }, Out: function(a) { return Math.sqrt(1 - --a * a) }, InOut: function(a) { return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1) } },
            Elastic: {
                In: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d)))
                },
                Out: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), c * Math.pow(2, -10 * a) * Math.sin((a - b) * (2 * Math.PI) / d) + 1)
                },
                InOut: function(a) {
                    var b, c = .1,
                        d = .4;
                    return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI), (a *= 2) < 1 ? -.5 * (c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d)) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * .5 + 1)
                }
            },
            Back: { In: function(a) { var b = 1.70158; return a * a * ((b + 1) * a - b) }, Out: function(a) { var b = 1.70158; return --a * a * ((b + 1) * a + b) + 1 }, InOut: function(a) { var b = 2.5949095; return (a *= 2) < 1 ? .5 * (a * a * ((b + 1) * a - b)) : .5 * ((a -= 2) * a * ((b + 1) * a + b) + 2) } },
            Bounce: { In: function(a) { return 1 - c.Easing.Bounce.Out(1 - a) }, Out: function(a) { return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375 }, InOut: function(a) { return a < .5 ? .5 * c.Easing.Bounce.In(2 * a) : .5 * c.Easing.Bounce.Out(2 * a - 1) + .5 } }
        }, c.Easing.Default = c.Easing.Linear.None, c.Easing.Power0 = c.Easing.Linear.None, c.Easing.Power1 = c.Easing.Quadratic.Out, c.Easing.Power2 = c.Easing.Cubic.Out, c.Easing.Power3 = c.Easing.Quartic.Out, c.Easing.Power4 = c.Easing.Quintic.Out, c.Time = function(a) { this.game = a, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new c.Timer(this.game, (!1)), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = [] }, c.Time.prototype = {
            boot: function() { this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time },
            add: function(a) { return this._timers.push(a), a },
            create: function(a) { void 0 === a && (a = !0); var b = new c.Timer(this.game, a); return this._timers.push(b), b },
            removeAll: function() {
                for (var a = 0; a < this._timers.length; a++) this._timers[a].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var a = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - a
            },
            update: function(a) {
                var b = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - b, this.prevTime = this.now, this.now = a, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - a))), this.timeExpected = a + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() { for (var a = 0, b = this._timers.length; a < b;) this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1), b--) },
            updateAdvancedTiming: function() { this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0) },
            gamePaused: function() { this._pauseStarted = Date.now(), this.events.pause(); for (var a = this._timers.length; a--;) this._timers[a]._pause() },
            gameResumed: function() { this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume(); for (var a = this._timers.length; a--;) this._timers[a]._resume() },
            totalElapsedSeconds: function() { return .001 * (this.time - this._started) },
            elapsedSince: function(a) { return this.time - a },
            elapsedSecondsSince: function(a) { return .001 * (this.time - a) },
            reset: function() { this._started = this.time, this.removeAll() }
        }, Object.defineProperty(c.Time.prototype, "desiredFps", { get: function() { return this._desiredFps }, set: function(a) { this._desiredFps = a, this.physicsElapsed = 1 / a, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / a } }), c.Time.prototype.constructor = c.Time, c.Timer = function(a, b) { void 0 === b && (b = !0), this.game = a, this.running = !1, this.autoDestroy = b, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new c.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0 }, c.Timer.MINUTE = 6e4, c.Timer.SECOND = 1e3, c.Timer.HALF = 500, c.Timer.QUARTER = 250, c.Timer.prototype = {
            create: function(a, b, d, e, f, g) {
                a = Math.round(a);
                var h = a;
                h += 0 === this._now ? this.game.time.time : this._now;
                var i = new c.TimerEvent(this, a, h, d, b, e, f, g);
                return this.events.push(i), this.order(), this.expired = !1, i
            },
            add: function(a, b, c) { return this.create(a, !1, 0, b, c, Array.prototype.slice.call(arguments, 3)) },
            repeat: function(a, b, c, d) { return this.create(a, !1, b, c, d, Array.prototype.slice.call(arguments, 4)) },
            loop: function(a, b, c) { return this.create(a, !0, 0, b, c, Array.prototype.slice.call(arguments, 3)) },
            start: function(a) { if (!this.running) { this._started = this.game.time.time + (a || 0), this.running = !0; for (var b = 0; b < this.events.length; b++) this.events[b].tick = this.events[b].delay + this._started } },
            stop: function(a) { this.running = !1, void 0 === a && (a = !0), a && (this.events.length = 0) },
            remove: function(a) {
                for (var b = 0; b < this.events.length; b++)
                    if (this.events[b] === a) return this.events[b].pendingDelete = !0, !0;
                return !1
            },
            order: function() { this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick) },
            sortHandler: function(a, b) { return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0 },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(a) {
                if (this.paused) return !0;
                if (this.elapsed = a - this._now, this._now = a, this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() { this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0)) },
            _pause: function() {!this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0) },
            adjustEvents: function(a) {
                for (var b = 0; b < this.events.length; b++)
                    if (!this.events[b].pendingDelete) {
                        var c = this.events[b].tick - a;
                        c < 0 && (c = 0), this.events[b].tick = this._now + c
                    }
                var d = this.nextTick - a;
                d < 0 ? this.nextTick = this._now : this.nextTick = this._now + d
            },
            resume: function() {
                if (this.paused) {
                    var a = this.game.time.time;
                    this._pauseTotal += a - this._now, this._now = a, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() { this._codePaused || this.resume() },
            removeAll: function() { this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0 },
            destroy: function() { this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0 }
        }, Object.defineProperty(c.Timer.prototype, "next", { get: function() { return this.nextTick } }), Object.defineProperty(c.Timer.prototype, "duration", { get: function() { return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0 } }), Object.defineProperty(c.Timer.prototype, "length", { get: function() { return this.events.length } }), Object.defineProperty(c.Timer.prototype, "ms", { get: function() { return this.running ? this._now - this._started - this._pauseTotal : 0 } }), Object.defineProperty(c.Timer.prototype, "seconds", { get: function() { return this.running ? .001 * this.ms : 0 } }), c.Timer.prototype.constructor = c.Timer, c.TimerEvent = function(a, b, c, d, e, f, g, h) { this.timer = a, this.delay = b, this.tick = c, this.repeatCount = d - 1, this.loop = e, this.callback = f, this.callbackContext = g, this.args = h, this.pendingDelete = !1 }, c.TimerEvent.prototype.constructor = c.TimerEvent, c.AnimationManager = function(a) { this.sprite = a, this.game = a.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = [] }, c.AnimationManager.prototype = {
            loadFrameData: function(a, b) {
                if (void 0 === a) return !1;
                if (this.isLoaded)
                    for (var c in this._anims) this._anims[c].updateFrameData(a);
                return this._frameData = a, void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0
            },
            copyFrameData: function(a, b) {
                if (this._frameData = a.clone(), this.isLoaded)
                    for (var c in this._anims) this._anims[c].updateFrameData(this._frameData);
                return void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b, this.isLoaded = !0, !0
            },
            add: function(a, b, d, e, f) { return b = b || [], d = d || 60, void 0 === e && (e = !1), void 0 === f && (f = !(!b || "number" != typeof b[0])), this._outputFrames = [], this._frameData.getFrameIndexes(b, f, this._outputFrames), this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e), this.currentAnim = this._anims[a], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[a] },
            validateFrames: function(a, b) {
                void 0 === b && (b = !0);
                for (var c = 0; c < a.length; c++)
                    if (b === !0) { if (a[c] > this._frameData.total) return !1 }
                else if (this._frameData.checkFrameName(a[c]) === !1) return !1;
                return !0
            },
            play: function(a, b, c, d) { if (this._anims[a]) return this.currentAnim === this._anims[a] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[a], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(b, c, d)) },
            stop: function(a, b) { void 0 === b && (b = !1), !this.currentAnim || "string" == typeof a && a !== this.currentAnim.name || this.currentAnim.stop(b) },
            update: function() { return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0)) },
            next: function(a) { this.currentAnim && (this.currentAnim.next(a), this.currentFrame = this.currentAnim.currentFrame) },
            previous: function(a) { this.currentAnim && (this.currentAnim.previous(a), this.currentFrame = this.currentAnim.currentFrame) },
            getAnimation: function(a) { return "string" == typeof a && this._anims[a] ? this._anims[a] : null },
            refreshFrame: function() {},
            destroy: function() {
                var a = null;
                for (var a in this._anims) this._anims.hasOwnProperty(a) && this._anims[a].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, c.AnimationManager.prototype.constructor = c.AnimationManager, Object.defineProperty(c.AnimationManager.prototype, "frameData", { get: function() { return this._frameData } }), Object.defineProperty(c.AnimationManager.prototype, "frameTotal", { get: function() { return this._frameData.total } }), Object.defineProperty(c.AnimationManager.prototype, "paused", { get: function() { return this.currentAnim.isPaused }, set: function(a) { this.currentAnim.paused = a } }), Object.defineProperty(c.AnimationManager.prototype, "name", { get: function() { if (this.currentAnim) return this.currentAnim.name } }), Object.defineProperty(c.AnimationManager.prototype, "frame", { get: function() { if (this.currentFrame) return this.currentFrame.index }, set: function(a) { "number" == typeof a && this._frameData && null !== this._frameData.getFrame(a) && (this.currentFrame = this._frameData.getFrame(a), this.currentFrame && this.sprite.setFrame(this.currentFrame)) } }), Object.defineProperty(c.AnimationManager.prototype, "frameName", { get: function() { if (this.currentFrame) return this.currentFrame.name }, set: function(a) { "string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a) && (this.currentFrame = this._frameData.getFrameByName(a), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) } }), c.Animation = function(a, b, d, e, f, g, h) { void 0 === h && (h = !1), this.game = a, this._parent = b, this._frameData = e, this.name = d, this._frames = [], this._frames = this._frames.concat(f), this.delay = 1e3 / g, this.loop = h, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new c.Signal, this.onUpdate = null, this.onComplete = new c.Signal, this.onLoop = new c.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this) }, c.Animation.prototype = {
            play: function(a, b, c) { return "number" == typeof a && (this.delay = 1e3 / a), "boolean" == typeof b && (this.loop = b), "undefined" != typeof c && (this.killOnComplete = c), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this },
            restart: function() { this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this) },
            reverse: function() { return this.reversed = !this.reversed, this },
            reverseOnce: function() { return this.onComplete.addOnce(this.reverse, this), this.reverse() },
            setFrame: function(a, b) {
                var c;
                if (void 0 === b && (b = !1), "string" == typeof a)
                    for (var d = 0; d < this._frames.length; d++) this._frameData.getFrame(this._frames[d]).name === a && (c = d);
                else if ("number" == typeof a)
                    if (b) c = a;
                    else
                        for (var d = 0; d < this._frames.length; d++) this._frames[d] === a && (c = d);
                c && (this._frameIndex = c - 1, this._timeNextFrame = this.game.time.time, this.update())
            },
            stop: function(a, b) { void 0 === a && (a = !1), void 0 === b && (b = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, a && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this)) },
            onPause: function() { this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time) },
            onResume: function() { this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff) },
            update: function() { return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))) },
            updateCurrentFrame: function(a, b) { if (void 0 === b && (b = !1), !this._frameData) return !1; var c = this.currentFrame.index; return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (b || !b && c !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData) },
            next: function(a) {
                void 0 === a && (a = 1);
                var b = this._frameIndex + a;
                b >= this._frames.length && (this.loop ? b %= this._frames.length : b = this._frames.length - 1), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0))
            },
            previous: function(a) {
                void 0 === a && (a = 1);
                var b = this._frameIndex - a;
                b < 0 && (this.loop ? b = this._frames.length + b : b++), b !== this._frameIndex && (this._frameIndex = b, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(a) { this._frameData = a, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null },
            destroy: function() { this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose()) },
            complete: function() { this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill() }
        }, c.Animation.prototype.constructor = c.Animation, Object.defineProperty(c.Animation.prototype, "paused", { get: function() { return this.isPaused }, set: function(a) { this.isPaused = a, a ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay) } }), Object.defineProperty(c.Animation.prototype, "reversed", { get: function() { return this.isReversed }, set: function(a) { this.isReversed = a } }), Object.defineProperty(c.Animation.prototype, "frameTotal", { get: function() { return this._frames.length } }), Object.defineProperty(c.Animation.prototype, "frame", { get: function() { return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex }, set: function(a) { this.currentFrame = this._frameData.getFrame(this._frames[a]), null !== this.currentFrame && (this._frameIndex = a, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame)) } }), Object.defineProperty(c.Animation.prototype, "speed", { get: function() { return 1e3 / this.delay }, set: function(a) { a > 0 && (this.delay = 1e3 / a) } }), Object.defineProperty(c.Animation.prototype, "enableUpdate", { get: function() { return null !== this.onUpdate }, set: function(a) { a && null === this.onUpdate ? this.onUpdate = new c.Signal : a || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null) } }), c.Animation.generateFrameNames = function(a, b, d, e, f) {
            void 0 === e && (e = "");
            var g = [],
                h = "";
            if (b < d)
                for (var i = b; i <= d; i++) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
            else
                for (var i = b; i >= d; i--) h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString(), h = a + h + e, g.push(h);
            return g
        }, c.Frame = function(a, b, d, e, f, g) { this.index = a, this.x = b, this.y = d, this.width = e, this.height = f, this.name = g, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(f / 2), this.distance = c.Math.distance(0, 0, e, f), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = e, this.sourceSizeH = f, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height }, c.Frame.prototype = { resize: function(a, b) { this.width = a, this.height = b, this.centerX = Math.floor(a / 2), this.centerY = Math.floor(b / 2), this.distance = c.Math.distance(0, 0, a, b), this.sourceSizeW = a, this.sourceSizeH = b, this.right = this.x + a, this.bottom = this.y + b }, setTrim: function(a, b, c, d, e, f, g) { this.trimmed = a, a && (this.sourceSizeW = b, this.sourceSizeH = c, this.centerX = Math.floor(b / 2), this.centerY = Math.floor(c / 2), this.spriteSourceSizeX = d, this.spriteSourceSizeY = e, this.spriteSourceSizeW = f, this.spriteSourceSizeH = g) }, clone: function() { var a = new c.Frame(this.index, this.x, this.y, this.width, this.height, this.name); for (var b in this) this.hasOwnProperty(b) && (a[b] = this[b]); return a }, getRect: function(a) { return void 0 === a ? a = new c.Rectangle(this.x, this.y, this.width, this.height) : a.setTo(this.x, this.y, this.width, this.height), a } }, c.Frame.prototype.constructor = c.Frame, c.FrameData = function() { this._frames = [], this._frameNames = [] }, c.FrameData.prototype = {
            addFrame: function(a) { return a.index = this._frames.length, this._frames.push(a), "" !== a.name && (this._frameNames[a.name] = a.index), a },
            getFrame: function(a) { return a >= this._frames.length && (a = 0), this._frames[a] },
            getFrameByName: function(a) {
                return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null
            },
            checkFrameName: function(a) { return null != this._frameNames[a] },
            clone: function() { for (var a = new c.FrameData, b = 0; b < this._frames.length; b++) a._frames.push(this._frames[b].clone()); for (var d in this._frameNames) this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]); return a },
            getFrameRange: function(a, b, c) { void 0 === c && (c = []); for (var d = a; d <= b; d++) c.push(this._frames[d]); return c },
            getFrames: function(a, b, c) {
                if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)
                    for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d]);
                else
                    for (var d = 0; d < a.length; d++) b ? c.push(this.getFrame(a[d])) : c.push(this.getFrameByName(a[d]));
                return c
            },
            getFrameIndexes: function(a, b, c) {
                if (void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)
                    for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d].index);
                else
                    for (var d = 0; d < a.length; d++) b && this._frames[a[d]] ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
                return c
            },
            destroy: function() { this._frames = null, this._frameNames = null }
        }, c.FrameData.prototype.constructor = c.FrameData, Object.defineProperty(c.FrameData.prototype, "total", { get: function() { return this._frames.length } }), c.AnimationParser = {
            spriteSheet: function(a, b, d, e, f, g, h) {
                var i = b;
                if ("string" == typeof b && (i = a.cache.getImage(b)), null === i) return null;
                var j = i.width,
                    k = i.height;
                d <= 0 && (d = Math.floor(-j / Math.min(-1, d))), e <= 0 && (e = Math.floor(-k / Math.min(-1, e)));
                var l = Math.floor((j - g) / (d + h)),
                    m = Math.floor((k - g) / (e + h)),
                    n = l * m;
                if (f !== -1 && (n = f), 0 === j || 0 === k || j < d || k < e || 0 === n) return null;
                for (var o = new c.FrameData, p = g, q = g, r = 0; r < n; r++) o.addFrame(new c.Frame(r, p, q, d, e, "")), p += d + h, p + d > j && (p = g, q += e + h);
                return o
            },
            JSONData: function(a, b) { if (b.frames) { for (var d, e = new c.FrameData, f = b.frames, g = 0; g < f.length; g++) d = e.addFrame(new c.Frame(g, f[g].frame.x, f[g].frame.y, f[g].frame.w, f[g].frame.h, f[g].filename)), f[g].trimmed && d.setTrim(f[g].trimmed, f[g].sourceSize.w, f[g].sourceSize.h, f[g].spriteSourceSize.x, f[g].spriteSourceSize.y, f[g].spriteSourceSize.w, f[g].spriteSourceSize.h); return e } },
            JSONDataPyxel: function(a, b) { var d = ["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"]; if (d.forEach(function(a) {!b[a] }), 1 === b.layers.length) { for (var e, f = new c.FrameData, g = b.tileheight, h = b.tilewidth, i = b.layers[0].tiles, j = 0; j < i.length; j++) e = f.addFrame(new c.Frame(j, i[j].x, i[j].y, h, g, "frame_" + j)), e.setTrim(!1); return f } },
            JSONDataHash: function(a, b) {
                if (b.frames) {
                    var d, e = new c.FrameData,
                        f = b.frames,
                        g = 0;
                    for (var h in f) d = e.addFrame(new c.Frame(g, f[h].frame.x, f[h].frame.y, f[h].frame.w, f[h].frame.h, h)), f[h].trimmed && d.setTrim(f[h].trimmed, f[h].sourceSize.w, f[h].sourceSize.h, f[h].spriteSourceSize.x, f[h].spriteSourceSize.y, f[h].spriteSourceSize.w, f[h].spriteSourceSize.h), g++;
                    return e
                }
            },
            XMLData: function(a, b) { if (b.getElementsByTagName("TextureAtlas")) { for (var d, e, f, g, h, i, j, k, l, m, n, o = new c.FrameData, p = b.getElementsByTagName("SubTexture"), q = 0; q < p.length; q++) f = p[q].attributes, e = f.name.value, g = parseInt(f.x.value, 10), h = parseInt(f.y.value, 10), i = parseInt(f.width.value, 10), j = parseInt(f.height.value, 10), k = null, l = null, f.frameX && (k = Math.abs(parseInt(f.frameX.value, 10)), l = Math.abs(parseInt(f.frameY.value, 10)), m = parseInt(f.frameWidth.value, 10), n = parseInt(f.frameHeight.value, 10)), d = o.addFrame(new c.Frame(q, g, h, i, j, e)), null === k && null === l || d.setTrim(!0, i, j, k, l, m, n); return o } }
        }, c.Cache = function(a) { this.game = a, this.autoResolveURL = !1, this._cache = { canvas: {}, image: {}, texture: {}, sound: {}, video: {}, text: {}, json: {}, xml: {}, physics: {}, tilemap: {}, binary: {}, bitmapData: {}, bitmapFont: {}, shader: {}, renderTexture: {} }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new c.Signal, this._cacheMap = [], this._cacheMap[c.Cache.CANVAS] = this._cache.canvas, this._cacheMap[c.Cache.IMAGE] = this._cache.image, this._cacheMap[c.Cache.TEXTURE] = this._cache.texture, this._cacheMap[c.Cache.SOUND] = this._cache.sound, this._cacheMap[c.Cache.TEXT] = this._cache.text, this._cacheMap[c.Cache.PHYSICS] = this._cache.physics, this._cacheMap[c.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[c.Cache.BINARY] = this._cache.binary, this._cacheMap[c.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[c.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[c.Cache.JSON] = this._cache.json, this._cacheMap[c.Cache.XML] = this._cache.xml, this._cacheMap[c.Cache.VIDEO] = this._cache.video, this._cacheMap[c.Cache.SHADER] = this._cache.shader, this._cacheMap[c.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage() }, c.Cache.CANVAS = 1, c.Cache.IMAGE = 2, c.Cache.TEXTURE = 3, c.Cache.SOUND = 4, c.Cache.TEXT = 5, c.Cache.PHYSICS = 6, c.Cache.TILEMAP = 7, c.Cache.BINARY = 8, c.Cache.BITMAPDATA = 9, c.Cache.BITMAPFONT = 10, c.Cache.JSON = 11, c.Cache.XML = 12, c.Cache.VIDEO = 13, c.Cache.SHADER = 14, c.Cache.RENDER_TEXTURE = 15, c.Cache.DEFAULT = null, c.Cache.MISSING = null, c.Cache.prototype = {
            addCanvas: function(a, b, c) { void 0 === c && (c = b.getContext("2d")), this._cache.canvas[a] = { canvas: b, context: c } },
            addImage: function(a, b, d) { this.checkImageKey(a) && this.removeImage(a); var e = { key: a, url: b, data: d, base: new PIXI.BaseTexture(d), frame: new c.Frame(0, 0, 0, d.width, d.height, a), frameData: new c.FrameData }; return e.frameData.addFrame(new c.Frame(0, 0, 0, d.width, d.height, b)), this._cache.image[a] = e, this._resolveURL(b, e), "__default" === a ? c.Cache.DEFAULT = new PIXI.Texture(e.base) : "__missing" === a && (c.Cache.MISSING = new PIXI.Texture(e.base)), e },
            addDefaultImage: function() {
                var a = new Image;
                a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var b = this.addImage("__default", null, a);
                b.base.skipRender = !0, c.Cache.DEFAULT = new PIXI.Texture(b.base)
            },
            addMissingImage: function() {
                var a = new Image;
                a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var b = this.addImage("__missing", null, a);
                c.Cache.MISSING = new PIXI.Texture(b.base)
            },
            addSound: function(a, b, c, d, e) {
                void 0 === d && (d = !0, e = !1), void 0 === e && (d = !1, e = !0);
                var f = !1;
                e && (f = !0), this._cache.sound[a] = { url: b, data: c, isDecoding: !1, decoded: f, webAudio: d, audioTag: e, locked: this.game.sound.touchLocked }, this._resolveURL(b, this._cache.sound[a])
            },
            addText: function(a, b, c) { this._cache.text[a] = { url: b, data: c }, this._resolveURL(b, this._cache.text[a]) },
            addPhysicsData: function(a, b, c, d) { this._cache.physics[a] = { url: b, data: c, format: d }, this._resolveURL(b, this._cache.physics[a]) },
            addTilemap: function(a, b, c, d) { this._cache.tilemap[a] = { url: b, data: c, format: d }, this._resolveURL(b, this._cache.tilemap[a]) },
            addBinary: function(a, b) { this._cache.binary[a] = b },
            addBitmapData: function(a, b, d) { return b.key = a, void 0 === d && (d = new c.FrameData, d.addFrame(b.textureFrame)), this._cache.bitmapData[a] = { data: b, frameData: d }, b },
            addBitmapFont: function(a, b, d, e, f, g, h) {
                var i = { url: b, data: d, font: null, base: new PIXI.BaseTexture(d) };
                void 0 === g && (g = 0), void 0 === h && (h = 0), "json" === f ? i.font = c.LoaderParser.jsonBitmapFont(e, i.base, g, h) : i.font = c.LoaderParser.xmlBitmapFont(e, i.base, g, h), this._cache.bitmapFont[a] = i, this._resolveURL(b, i)
            },
            addJSON: function(a, b, c) { this._cache.json[a] = { url: b, data: c }, this._resolveURL(b, this._cache.json[a]) },
            addXML: function(a, b, c) { this._cache.xml[a] = { url: b, data: c }, this._resolveURL(b, this._cache.xml[a]) },
            addVideo: function(a, b, c, d) { this._cache.video[a] = { url: b, data: c, isBlob: d, locked: !0 }, this._resolveURL(b, this._cache.video[a]) },
            addShader: function(a, b, c) { this._cache.shader[a] = { url: b, data: c }, this._resolveURL(b, this._cache.shader[a]) },
            addRenderTexture: function(a, b) { this._cache.renderTexture[a] = { texture: b, frame: new c.Frame(0, 0, 0, b.width, b.height, "", "") } },
            addSpriteSheet: function(a, b, d, e, f, g, h, i) {
                void 0 === g && (g = -1), void 0 === h && (h = 0), void 0 === i && (i = 0);
                var j = { key: a, url: b, data: d, frameWidth: e, frameHeight: f, margin: h, spacing: i, base: new PIXI.BaseTexture(d), frameData: c.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i) };
                this._cache.image[a] = j, this._resolveURL(b, j)
            },
            addTextureAtlas: function(a, b, d, e, f) {
                var g = { key: a, url: b, data: d, base: new PIXI.BaseTexture(d) };
                f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? g.frameData = c.AnimationParser.XMLData(this.game, e, a) : f === c.Loader.TEXTURE_ATLAS_JSON_PYXEL ? g.frameData = c.AnimationParser.JSONDataPyxel(this.game, e, a) : Array.isArray(e.frames) ? g.frameData = c.AnimationParser.JSONData(this.game, e, a) : g.frameData = c.AnimationParser.JSONDataHash(this.game, e, a), this._cache.image[a] = g, this._resolveURL(b, g)
            },
            reloadSound: function(a) {
                var b = this,
                    c = this.getSound(a);
                c && (c.data.src = c.url, c.data.addEventListener("canplaythrough", function() { return b.reloadSoundComplete(a) }, !1), c.data.load())
            },
            reloadSoundComplete: function(a) {
                var b = this.getSound(a);
                b && (b.locked = !1, this.onSoundUnlock.dispatch(a))
            },
            updateSound: function(a, b, c) {
                var d = this.getSound(a);
                d && (d[b] = c)
            },
            decodedSound: function(a, b) {
                var c = this.getSound(a);
                c.data = b, c.decoded = !0, c.isDecoding = !1
            },
            isSoundDecoded: function(a) { var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded"); if (b) return b.decoded },
            isSoundReady: function(a) { var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded"); if (b) return b.decoded && !this.game.sound.touchLocked },
            checkKey: function(a, b) { return !!this._cacheMap[a][b] },
            checkURL: function(a) { return !!this._urlMap[this._resolveURL(a)] },
            checkCanvasKey: function(a) { return this.checkKey(c.Cache.CANVAS, a) },
            checkImageKey: function(a) { return this.checkKey(c.Cache.IMAGE, a) },
            checkTextureKey: function(a) { return this.checkKey(c.Cache.TEXTURE, a) },
            checkSoundKey: function(a) { return this.checkKey(c.Cache.SOUND, a) },
            checkTextKey: function(a) { return this.checkKey(c.Cache.TEXT, a) },
            checkPhysicsKey: function(a) { return this.checkKey(c.Cache.PHYSICS, a) },
            checkTilemapKey: function(a) { return this.checkKey(c.Cache.TILEMAP, a) },
            checkBinaryKey: function(a) { return this.checkKey(c.Cache.BINARY, a) },
            checkBitmapDataKey: function(a) { return this.checkKey(c.Cache.BITMAPDATA, a) },
            checkBitmapFontKey: function(a) { return this.checkKey(c.Cache.BITMAPFONT, a) },
            checkJSONKey: function(a) { return this.checkKey(c.Cache.JSON, a) },
            checkXMLKey: function(a) { return this.checkKey(c.Cache.XML, a) },
            checkVideoKey: function(a) { return this.checkKey(c.Cache.VIDEO, a) },
            checkShaderKey: function(a) { return this.checkKey(c.Cache.SHADER, a) },
            checkRenderTextureKey: function(a) { return this.checkKey(c.Cache.RENDER_TEXTURE, a) },
            getItem: function(a, b, c, d) { return this.checkKey(b, a) ? void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : null },
            getCanvas: function(a) { return this.getItem(a, c.Cache.CANVAS, "getCanvas", "canvas") },
            getImage: function(a, b) { void 0 !== a && null !== a || (a = "__default"), void 0 === b && (b = !1); var d = this.getItem(a, c.Cache.IMAGE, "getImage"); return null === d && (d = this.getItem("__missing", c.Cache.IMAGE, "getImage")), b ? d : d.data },
            getTextureFrame: function(a) { return this.getItem(a, c.Cache.TEXTURE, "getTextureFrame", "frame") },
            getSound: function(a) { return this.getItem(a, c.Cache.SOUND, "getSound") },
            getSoundData: function(a) { return this.getItem(a, c.Cache.SOUND, "getSoundData", "data") },
            getText: function(a) { return this.getItem(a, c.Cache.TEXT, "getText", "data") },
            getPhysicsData: function(a, b, d) {
                var e = this.getItem(a, c.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === e || void 0 === b || null === b) return e;
                if (e[b]) {
                    var f = e[b];
                    if (!f || !d) return f;
                    for (var g in f)
                        if (g = f[g], g.fixtureKey === d) return g
                }
                return null
            },
            getTilemapData: function(a) { return this.getItem(a, c.Cache.TILEMAP, "getTilemapData") },
            getBinary: function(a) { return this.getItem(a, c.Cache.BINARY, "getBinary") },
            getBitmapData: function(a) { return this.getItem(a, c.Cache.BITMAPDATA, "getBitmapData", "data") },
            getBitmapFont: function(a) { return this.getItem(a, c.Cache.BITMAPFONT, "getBitmapFont") },
            getJSON: function(a, b) { var d = this.getItem(a, c.Cache.JSON, "getJSON", "data"); return d ? b ? c.Utils.extend(!0, Array.isArray(d) ? [] : {}, d) : d : null },
            getXML: function(a) { return this.getItem(a, c.Cache.XML, "getXML", "data") },
            getVideo: function(a) { return this.getItem(a, c.Cache.VIDEO, "getVideo") },
            getShader: function(a) { return this.getItem(a, c.Cache.SHADER, "getShader", "data") },
            getRenderTexture: function(a) { return this.getItem(a, c.Cache.RENDER_TEXTURE, "getRenderTexture") },
            getBaseTexture: function(a, b) { return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getBaseTexture", "base") },
            getFrame: function(a, b) { return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrame", "frame") },
            getFrameCount: function(a, b) { var c = this.getFrameData(a, b); return c ? c.total : 0 },
            getFrameData: function(a, b) { return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrameData", "frameData") },
            hasFrameData: function(a, b) { return void 0 === b && (b = c.Cache.IMAGE), null !== this.getItem(a, b, "", "frameData") },
            updateFrameData: function(a, b, d) { void 0 === d && (d = c.Cache.IMAGE), this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = b) },
            getFrameByIndex: function(a, b, c) { var d = this.getFrameData(a, c); return d ? d.getFrame(b) : null },
            getFrameByName: function(a, b, c) { var d = this.getFrameData(a, c); return d ? d.getFrameByName(b) : null },
            getURL: function(a) { var a = this._resolveURL(a); return a ? this._urlMap[a] : null },
            getKeys: function(a) {
                void 0 === a && (a = c.Cache.IMAGE);
                var b = [];
                if (this._cacheMap[a])
                    for (var d in this._cacheMap[a]) "__default" !== d && "__missing" !== d && b.push(d);
                return b
            },
            removeCanvas: function(a) { delete this._cache.canvas[a] },
            removeImage: function(a, b) {
                void 0 === b && (b = !0);
                var c = this.getImage(a, !0);
                b && c.base && c.base.destroy(), delete this._cache.image[a]
            },
            removeSound: function(a) { delete this._cache.sound[a] },
            removeText: function(a) { delete this._cache.text[a] },
            removePhysics: function(a) { delete this._cache.physics[a] },
            removeTilemap: function(a) { delete this._cache.tilemap[a] },
            removeBinary: function(a) { delete this._cache.binary[a] },
            removeBitmapData: function(a) { delete this._cache.bitmapData[a] },
            removeBitmapFont: function(a) { delete this._cache.bitmapFont[a] },
            removeJSON: function(a) { delete this._cache.json[a] },
            removeXML: function(a) { delete this._cache.xml[a] },
            removeVideo: function(a) { delete this._cache.video[a] },
            removeShader: function(a) { delete this._cache.shader[a] },
            removeRenderTexture: function(a) { delete this._cache.renderTexture[a] },
            removeSpriteSheet: function(a) { delete this._cache.spriteSheet[a] },
            removeTextureAtlas: function(a) { delete this._cache.atlas[a] },
            clearGLTextures: function() { for (var a in this._cache.image) this._cache.image[a].base._glTextures = [] },
            _resolveURL: function(a, b) { return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", b && (this._urlMap[this._urlTemp] = b), this._urlTemp) : null },
            destroy: function() { for (var a = 0; a < this._cacheMap.length; a++) { var b = this._cacheMap[a]; for (var c in b) "__default" !== c && "__missing" !== c && (b[c].destroy && b[c].destroy(), delete b[c]) } this._urlMap = null, this._urlResolver = null, this._urlTemp = null }
        }, c.Cache.prototype.constructor = c.Cache, c.Loader = function(a) { this.game = a, this.cache = a.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = { requestedWith: !1, json: "application/json", xml: "application/xml" }, this.onLoadStart = new c.Signal, this.onLoadComplete = new c.Signal, this.onPackComplete = new c.Signal, this.onFileStart = new c.Signal, this.onFileComplete = new c.Signal, this.onFileError = new c.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0 }, c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, c.Loader.TEXTURE_ATLAS_JSON_HASH = 1, c.Loader.TEXTURE_ATLAS_XML_STARLING = 2, c.Loader.PHYSICS_LIME_CORONA_JSON = 3, c.Loader.PHYSICS_PHASER_JSON = 4, c.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, c.Loader.prototype = {
            setPreloadSprite: function(a, b) { b = b || 0, this.preloadSprite = { sprite: a, direction: b, width: a.width, height: a.height, rect: null }, 0 === b ? this.preloadSprite.rect = new c.Rectangle(0, 0, 1, a.height) : this.preloadSprite.rect = new c.Rectangle(0, 0, a.width, 1), a.crop(this.preloadSprite.rect), a.visible = !0 },
            resize: function() { this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height) },
            checkKeyExists: function(a, b) { return this.getAssetIndex(a, b) > -1 },
            getAssetIndex: function(a, b) { for (var c = -1, d = 0; d < this._fileList.length; d++) { var e = this._fileList[d]; if (e.type === a && e.key === b && (c = d, !e.loaded && !e.loading)) break } return c },
            getAsset: function(a, b) { var c = this.getAssetIndex(a, b); return c > -1 && { index: c, file: this._fileList[c] } },
            reset: function(a, b) { void 0 === b && (b = !1), this.resetLocked || (a && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, b && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll())) },
            addToFileList: function(a, b, c, d, e, f) {
                if (void 0 === e && (e = !1), void 0 === b || "" === b) return this;
                if (void 0 === c || null === c) {
                    if (!f) return this;
                    c = b + f
                }
                var g = { type: a, key: b, path: this.path, url: c, syncPoint: this._withSyncPointDepth > 0, data: null, loading: !1, loaded: !1, error: !1 };
                if (d)
                    for (var h in d) g[h] = d[h];
                var i = this.getAssetIndex(a, b);
                if (e && i > -1) {
                    var j = this._fileList[i];
                    j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : this._fileList[i] = g
                }
                else i === -1 && (this._fileList.push(g), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(a, b, c, d) { return this.addToFileList(a, b, c, d, !0) },
            pack: function(a, b, c, d) {
                if (void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null), !b && !c) return this;
                var e = { type: "packfile", key: a, url: b, path: this.path, syncPoint: !0, data: null, loading: !1, loaded: !1, error: !1, callbackContext: d };
                c && ("string" == typeof c && (c = JSON.parse(c)), e.data = c || {}, e.loaded = !0);
                for (var f = 0; f < this._fileList.length + 1; f++) { var g = this._fileList[f]; if (!g || !g.loaded && !g.loading && "packfile" !== g.type) { this._fileList.splice(f, 0, e), this._totalPackCount++; break } }
                return this
            },
            image: function(a, b, c) { return this.addToFileList("image", a, b, void 0, c, ".png") },
            images: function(a, b) {
                if (Array.isArray(b))
                    for (var c = 0; c < a.length; c++) this.image(a[c], b[c]);
                else
                    for (var c = 0; c < a.length; c++) this.image(a[c]);
                return this
            },
            text: function(a, b, c) { return this.addToFileList("text", a, b, void 0, c, ".txt") },
            json: function(a, b, c) { return this.addToFileList("json", a, b, void 0, c, ".json") },
            shader: function(a, b, c) { return this.addToFileList("shader", a, b, void 0, c, ".frag") },
            xml: function(a, b, c) { return this.addToFileList("xml", a, b, void 0, c, ".xml") },
            script: function(a, b, c, d) { return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = this), this.addToFileList("script", a, b, { syncPoint: !0, callback: c, callbackContext: d }, !1, ".js") },
            binary: function(a, b, c, d) { return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = c), this.addToFileList("binary", a, b, { callback: c, callbackContext: d }, !1, ".bin") },
            spritesheet: function(a, b, c, d, e, f, g) { return void 0 === e && (e = -1), void 0 === f && (f = 0), void 0 === g && (g = 0), this.addToFileList("spritesheet", a, b, { frameWidth: c, frameHeight: d, frameMax: e, margin: f, spacing: g }, !1, ".png") },
            audio: function(a, b, c) { return this.game.sound.noAudio ? this : (void 0 === c && (c = !0), "string" == typeof b && (b = [b]), this.addToFileList("audio", a, b, { buffer: null, autoDecode: c })) },
            audioSprite: function(a, b, c, d, e) { return this.game.sound.noAudio ? this : (void 0 === c && (c = null), void 0 === d && (d = null), void 0 === e && (e = !0), this.audio(a, b, e), c ? this.json(a + "-audioatlas", c) : d && ("string" == typeof d && (d = JSON.parse(d)), this.cache.addJSON(a + "-audioatlas", "", d)), this) },
            audiosprite: function(a, b, c, d, e) { return this.audioSprite(a, b, c, d, e) },
            video: function(a, b, c, d) { return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === d && (d = !1), "string" == typeof b && (b = [b]), this.addToFileList("video", a, b, { buffer: null, asBlob: d, loadEvent: c }) },
            tilemap: function(a, b, d, e) {
                if (void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Tilemap.CSV), b || d || (b = e === c.Tilemap.CSV ? a + ".csv" : a + ".json"), d) {
                    switch (e) {
                        case c.Tilemap.CSV:
                            break;
                        case c.Tilemap.TILED_JSON:
                            "string" == typeof d && (d = JSON.parse(d))
                    }
                    this.cache.addTilemap(a, null, d, e)
                }
                else this.addToFileList("tilemap", a, b, { format: e });
                return this
            },
            physics: function(a, b, d, e) { return void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Physics.LIME_CORONA_JSON), b || d || (b = a + ".json"), d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, { format: e }), this },
            bitmapFont: function(a, b, c, d, e, f) {
                if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === c && (c = null), void 0 === d && (d = null), null === c && null === d && (c = a + ".xml"), void 0 === e && (e = 0), void 0 === f && (f = 0), c) this.addToFileList("bitmapfont", a, b, { atlasURL: c, xSpacing: e, ySpacing: f });
                else if ("string" == typeof d) {
                    var g, h;
                    try { g = JSON.parse(d) }
                    catch (i) { h = this.parseXml(d) }
                    if (!h && !g) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", a, b, { atlasURL: null, atlasData: g || h, atlasType: g ? "json" : "xml", xSpacing: e, ySpacing: f })
                }
                return this
            },
            atlasJSONArray: function(a, b, d, e) { return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY) },
            atlasJSONHash: function(a, b, d, e) { return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH) },
            atlasXML: function(a, b, d, e) { return void 0 === d && (d = null), void 0 === e && (e = null), d || e || (d = a + ".xml"), this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING) },
            atlas: function(a, b, d, e, f) {
                if (void 0 !== b && null !== b || (b = a + ".png"), void 0 === d && (d = null), void 0 === e && (e = null), void 0 === f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY), d || e || (d = f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"), d) this.addToFileList("textureatlas", a, b, { atlasURL: d, format: f });
                else {
                    switch (f) {
                        case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof e && (e = JSON.parse(e));
                            break;
                        case c.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof e) {
                                var g = this.parseXml(e);
                                if (!g) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                e = g
                            }
                    }
                    this.addToFileList("textureatlas", a, b, { atlasURL: null, atlasData: e, format: f })
                }
                return this
            },
            withSyncPoint: function(a, b) { this._withSyncPointDepth++; try { a.call(b || this, this) } finally { this._withSyncPointDepth-- } return this },
            addSyncPoint: function(a, b) { var c = this.getAsset(a, b); return c && (c.file.syncPoint = !0), this },
            removeFile: function(a, b) {
                var c = this.getAsset(a, b);
                c && (c.loaded || c.loading || this._fileList.splice(c.index, 1))
            },
            removeAll: function() { this._fileList.length = 0, this._flightQueue.length = 0 },
            start: function() { this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue()) },
            processLoadQueue: function() {
                if (!this.isLoading) return void this.finishedLoading(!0);
                for (var a = 0; a < this._flightQueue.length; a++) {
                    var b = this._flightQueue[a];
                    (b.loaded || b.error) && (this._flightQueue.splice(a, 1), a--, b.loading = !1, b.requestUrl = null, b.requestObject = null, b.error && this.onFileError.dispatch(b.key, b), "packfile" !== b.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, b.key, !b.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === b.type && b.error && (this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)))
                }
                for (var d = !1, e = this.enableParallel ? c.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, a = this._processingHead; a < this._fileList.length; a++) { var b = this._fileList[a]; if ("packfile" === b.type && !b.error && b.loaded && a === this._processingHead && (this.processPack(b), this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)), b.loaded || b.error ? a === this._processingHead && (this._processingHead = a + 1) : !b.loading && this._flightQueue.length < e && ("packfile" !== b.type || b.data ? d || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(b), b.loading = !0, this.onFileStart.dispatch(this.progress, b.key, b.url), this.loadFile(b)) : (this._flightQueue.push(b), b.loading = !0, this.loadFile(b))), !b.loaded && b.syncPoint && (d = !0), this._flightQueue.length >= e || d && this._loadedPackCount === this._totalPackCount) break }
                if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                else if (!this._flightQueue.length) {
                    var f = this;
                    setTimeout(function() { f.finishedLoading(!0) }, 2e3)
                }
            },
            finishedLoading: function(a) { this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, a || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset()) },
            asyncComplete: function(a, b) { void 0 === b && (b = ""), a.loaded = !0, a.error = !!b, b && (a.errorMessage = b), this.processLoadQueue() },
            processPack: function(a) {
                var b = a.data[a.key];
                if (b)
                    for (var d = 0; d < b.length; d++) {
                        var e = b[d];
                        switch (e.type) {
                            case "image":
                                this.image(e.key, e.url, e.overwrite);
                                break;
                            case "text":
                                this.text(e.key, e.url, e.overwrite);
                                break;
                            case "json":
                                this.json(e.key, e.url, e.overwrite);
                                break;
                            case "xml":
                                this.xml(e.key, e.url, e.overwrite);
                                break;
                            case "script":
                                this.script(e.key, e.url, e.callback, a.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                                break;
                            case "video":
                                this.video(e.key, e.urls);
                                break;
                            case "audio":
                                this.audio(e.key, e.urls, e.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(e.key, e.url, e.data, c.Tilemap[e.format]);
                                break;
                            case "physics":
                                this.physics(e.key, e.url, e.data, c.Loader[e.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                                break;
                            case "atlas":
                                this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, c.Loader[e.format]);
                                break;
                            case "shader":
                                this.shader(e.key, e.url, e.overwrite)
                        }
                    }
            },
            transformUrl: function(a, b) { return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a) },
            loadFile: function(a) {
                switch (a.type) {
                    case "packfile":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(a);
                        break;
                    case "audio":
                        a.url = this.getAudioURL(a.url), a.url ? this.game.sound.usingWebAudio ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(a) : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        a.url = this.getVideoURL(a.url), a.url ? a.asBlob ? this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete) : this.loadVideoTag(a) : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        a.format === c.Tilemap.TILED_JSON ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete) : a.format === c.Tilemap.CSV ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete) : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(a) {
                var b = this;
                a.data = new Image, a.data.name = a.key, this.crossOrigin && (a.data.crossOrigin = this.crossOrigin), a.data.onload = function() { a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileComplete(a)) }, a.data.onerror = function() { a.data.onload && (a.data.onload = null, a.data.onerror = null, b.fileError(a)) }, a.data.src = this.transformUrl(a.url, a), a.data.complete && a.data.width && a.data.height && (a.data.onload = null, a.data.onerror = null, this.fileComplete(a))
            },
            loadVideoTag: function(a) {
                var b = this;
                a.data = document.createElement("video"), a.data.name = a.key, a.data.controls = !1, a.data.autoplay = !1;
                var d = function() { a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !0, c.GAMES[b.game.id].load.fileComplete(a) };
                a.data.onerror = function() { a.data.removeEventListener(a.loadEvent, d, !1), a.data.onerror = null, a.data.canplay = !1, b.fileError(a) }, a.data.addEventListener(a.loadEvent, d, !1), a.data.src = this.transformUrl(a.url, a), a.data.load()
            },
            loadAudioTag: function(a) {
                var b = this;
                if (this.game.sound.touchLocked) a.data = new Audio, a.data.name = a.key, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), this.fileComplete(a);
                else {
                    a.data = new Audio, a.data.name = a.key;
                    var c = function() { a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileComplete(a) };
                    a.data.onerror = function() { a.data.removeEventListener("canplaythrough", c, !1), a.data.onerror = null, b.fileError(a) }, a.data.preload = "auto", a.data.src = this.transformUrl(a.url, a), a.data.addEventListener("canplaythrough", c, !1), a.data.load()
                }
            },
            xhrLoad: function(a, b, c, d, e) {
                if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(a, b, c, d, e);
                var f = new XMLHttpRequest;
                f.open("GET", b, !0), f.responseType = c, this.headers.requestedWith !== !1 && f.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[a.type] && f.setRequestHeader("Accept", this.headers[a.type]), e = e || this.fileError;
                var g = this;
                f.onload = function() { try { return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f) } catch (b) { g.hasLoaded ? window.console : g.asyncComplete(a, b.message || "Exception") } }, f.onerror = function() { try { return e.call(g, a, f) } catch (b) { g.hasLoaded ? window.console : g.asyncComplete(a, b.message || "Exception") } }, a.requestObject = f, a.requestUrl = b, f.send()
            },
            xhrLoadWithXDR: function(a, b, c, d, e) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0);
                var f = new window.XDomainRequest;
                f.open("GET", b, !0), f.responseType = c, f.timeout = 3e3, e = e || this.fileError;
                var g = this;
                f.onerror = function() { try { return e.call(g, a, f) } catch (b) { g.asyncComplete(a, b.message || "Exception") } }, f.ontimeout = function() { try { return e.call(g, a, f) } catch (b) { g.asyncComplete(a, b.message || "Exception") } }, f.onprogress = function() {}, f.onload = function() { try { return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f) } catch (b) { g.asyncComplete(a, b.message || "Exception") } }, a.requestObject = f, a.requestUrl = b, setTimeout(function() { f.send() }, 0)
            },
            getVideoURL: function(a) {
                for (var b = 0; b < a.length; b++) {
                    var c, d = a[b];
                    if (d.uri) { if (c = d.type, d = d.uri, this.game.device.canPlayVideo(c)) return d }
                    else {
                        if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                        d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                        var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                        if (c = e.toLowerCase(), this.game.device.canPlayVideo(c)) return a[b]
                    }
                }
                return null
            },
            getAudioURL: function(a) {
                if (this.game.sound.noAudio) return null;
                for (var b = 0; b < a.length; b++) {
                    var c, d = a[b];
                    if (d.uri) { if (c = d.type, d = d.uri, this.game.device.canPlayAudio(c)) return d }
                    else {
                        if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
                        d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
                        var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
                        if (c = e.toLowerCase(), this.game.device.canPlayAudio(c)) return a[b]
                    }
                }
                return null
            },
            fileError: function(a, b, c) {
                var d = a.requestUrl || this.transformUrl(a.url, a),
                    e = "error loading asset from URL " + d;
                !c && b && (c = b.status), c && (e = e + " (" + c + ")"), this.asyncComplete(a, e)
            },
            fileComplete: function(a, b) {
                var d = !0;
                switch (a.type) {
                    case "packfile":
                        var e = JSON.parse(b.responseText);
                        a.data = e || {};
                        break;
                    case "image":
                        this.cache.addImage(a.key, a.url, a.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
                        break;
                    case "textureatlas":
                        if (null == a.atlasURL) this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
                        else if (d = !1,
                            a.format === c.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format === c.Loader.TEXTURE_ATLAS_JSON_HASH || a.format === c.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
                        else {
                            if (a.format !== c.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                            this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        a.atlasURL ? (d = !1, this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function(a, b) { var c; try { c = JSON.parse(b.responseText) } catch (d) {} c ? (a.atlasType = "json", this.jsonLoadComplete(a, b)) : (a.atlasType = "xml", this.xmlLoadComplete(a, b)) })) : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
                        break;
                    case "video":
                        if (a.asBlob) try { a.data = b.response }
                        catch (f) { throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key) } this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (a.data = b.response, this.cache.addSound(a.key, a.url, a.data, !0, !1), a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
                        break;
                    case "text":
                        a.data = b.responseText, this.cache.addText(a.key, a.url, a.data);
                        break;
                    case "shader":
                        a.data = b.responseText, this.cache.addShader(a.key, a.url, a.data);
                        break;
                    case "physics":
                        var e = JSON.parse(b.responseText);
                        this.cache.addPhysicsData(a.key, a.url, e, a.format);
                        break;
                    case "script":
                        a.data = document.createElement("script"), a.data.language = "javascript", a.data.type = "text/javascript", a.data.defer = !1, a.data.text = b.responseText, document.head.appendChild(a.data), a.callback && (a.data = a.callback.call(a.callbackContext, a.key, b.responseText));
                        break;
                    case "binary":
                        a.callback ? a.data = a.callback.call(a.callbackContext, a.key, b.response) : a.data = b.response, this.cache.addBinary(a.key, a.data)
                }
                d && this.asyncComplete(a)
            },
            jsonLoadComplete: function(a, b) { var c = JSON.parse(b.responseText); "tilemap" === a.type ? this.cache.addTilemap(a.key, a.url, c, a.format) : "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing) : "json" === a.type ? this.cache.addJSON(a.key, a.url, c) : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format), this.asyncComplete(a) },
            csvLoadComplete: function(a, b) {
                var c = b.responseText;
                this.cache.addTilemap(a.key, a.url, c, a.format), this.asyncComplete(a)
            },
            xmlLoadComplete: function(a, b) {
                var c = b.responseText,
                    d = this.parseXml(c);
                if (!d) { b.responseType || b.contentType; return void this.asyncComplete(a, "invalid XML") }
                "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing) : "textureatlas" === a.type ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format) : "xml" === a.type && this.cache.addXML(a.key, a.url, d), this.asyncComplete(a)
            },
            parseXml: function(a) {
                var b;
                try {
                    if (window.DOMParser) {
                        var c = new DOMParser;
                        b = c.parseFromString(a, "text/xml")
                    }
                    else b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a)
                }
                catch (d) { b = null }
                return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null
            },
            updateProgress: function() { this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null) },
            totalLoadedFiles: function() { return this._loadedFileCount },
            totalQueuedFiles: function() { return this._totalFileCount - this._loadedFileCount },
            totalLoadedPacks: function() { return this._totalPackCount },
            totalQueuedPacks: function() { return this._totalPackCount - this._loadedPackCount }
        }, Object.defineProperty(c.Loader.prototype, "progressFloat", { get: function() { var a = this._loadedFileCount / this._totalFileCount * 100; return c.Math.clamp(a || 0, 0, 100) } }), Object.defineProperty(c.Loader.prototype, "progress", { get: function() { return Math.round(this.progressFloat) } }), c.Loader.prototype.constructor = c.Loader, c.LoaderParser = {
            bitmapFont: function(a, b, c, d) { return this.xmlBitmapFont(a, b, c, d) },
            xmlBitmapFont: function(a, b, c, d) {
                var e = {},
                    f = a.getElementsByTagName("info")[0],
                    g = a.getElementsByTagName("common")[0];
                e.font = f.getAttribute("face"), e.size = parseInt(f.getAttribute("size"), 10), e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d, e.chars = {};
                for (var h = a.getElementsByTagName("char"), i = 0; i < h.length; i++) {
                    var j = parseInt(h[i].getAttribute("id"), 10);
                    e.chars[j] = { x: parseInt(h[i].getAttribute("x"), 10), y: parseInt(h[i].getAttribute("y"), 10), width: parseInt(h[i].getAttribute("width"), 10), height: parseInt(h[i].getAttribute("height"), 10), xOffset: parseInt(h[i].getAttribute("xoffset"), 10), yOffset: parseInt(h[i].getAttribute("yoffset"), 10), xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c, kerning: {} }
                }
                var k = a.getElementsByTagName("kerning");
                for (i = 0; i < k.length; i++) {
                    var l = parseInt(k[i].getAttribute("first"), 10),
                        m = parseInt(k[i].getAttribute("second"), 10),
                        n = parseInt(k[i].getAttribute("amount"), 10);
                    e.chars[m].kerning[l] = n
                }
                return this.finalizeBitmapFont(b, e)
            },
            jsonBitmapFont: function(a, b, c, d) {
                var e = { font: a.font.info._face, size: parseInt(a.font.info._size, 10), lineHeight: parseInt(a.font.common._lineHeight, 10) + d, chars: {} };
                return a.font.chars["char"].forEach(function(a) {
                    var b = parseInt(a._id, 10);
                    e.chars[b] = { x: parseInt(a._x, 10), y: parseInt(a._y, 10), width: parseInt(a._width, 10), height: parseInt(a._height, 10), xOffset: parseInt(a._xoffset, 10), yOffset: parseInt(a._yoffset, 10), xAdvance: parseInt(a._xadvance, 10) + c, kerning: {} }
                }), a.font.kernings && a.font.kernings.kerning && a.font.kernings.kerning.forEach(function(a) { e.chars[a._second].kerning[a._first] = parseInt(a._amount, 10) }), this.finalizeBitmapFont(b, e)
            },
            finalizeBitmapFont: function(a, b) {
                return Object.keys(b.chars).forEach(function(d) {
                    var e = b.chars[d];
                    e.texture = new PIXI.Texture(a, new c.Rectangle(e.x, e.y, e.width, e.height))
                }), b
            }
        }, c.AudioSprite = function(a, b) {
            this.game = a, this.key = b, this.config = this.game.cache.getJSON(b + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
            for (var c in this.config.spritemap) {
                var d = this.config.spritemap[c],
                    e = this.game.add.sound(this.key);
                e.addMarker(c, d.start, d.end - d.start, null, d.loop), this.sounds[c] = e
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, c.AudioSprite.prototype = {
            play: function(a, b) { return void 0 === b && (b = 1), this.sounds[a].play(a, null, b) },
            stop: function(a) {
                if (a) this.sounds[a].stop();
                else
                    for (var b in this.sounds) this.sounds[b].stop()
            },
            get: function(a) { return this.sounds[a] }
        }, c.AudioSprite.prototype.constructor = c.AudioSprite, c.Sound = function(a, b, d, e, f) { void 0 === d && (d = 1), void 0 === e && (e = !1), void 0 === f && (f = a.sound.connectToMaster), this.game = a, this.name = b, this.key = b, this.loop = e, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = d * this.game.sound.volume, f && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(b) && this.game.cache.isSoundReady(b) ? (this._sound = this.game.cache.getSoundData(b), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new c.Signal, this.onPlay = new c.Signal, this.onPause = new c.Signal, this.onResume = new c.Signal, this.onLoop = new c.Signal, this.onStop = new c.Signal, this.onMute = new c.Signal, this.onMarkerComplete = new c.Signal, this.onFadeComplete = new c.Signal, this._volume = d, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1 }, c.Sound.prototype = {
            soundHasUnlocked: function(a) { a === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration) },
            addMarker: function(a, b, c, d, e) { void 0 !== c && null !== c || (c = 1), void 0 !== d && null !== d || (d = 1), void 0 === e && (e = !1), this.markers[a] = { name: a, start: b, stop: b + c, volume: d, duration: c, durationMS: 1e3 * c, loop: e } },
            removeMarker: function(a) { delete this.markers[a] },
            onEndedHandler: function() { this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop() },
            update: function() { return this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), void(this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop())))) : void this.destroy() },
            loopFull: function(a) { return this.play(null, 0, a, !0) },
            play: function(a, b, c, d, e) {
                if (void 0 !== a && a !== !1 && null !== a || (a = ""), void 0 === e && (e = !0), this.isPlaying && !this.allowMultiple && !e && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try { this._sound.stop(0) }
                        catch (f) {} this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    }
                    else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                var g = Object.keys(this.markers);
                if ("" === a && 1 === g.length && (a = g[0]), "" === a && g.length > 0) return this;
                if ("" !== a) {
                    if (!this.markers[a]) return this;
                    this.currentMarker = a, this.position = this.markers[a].start, this.volume = this.markers[a].volume, this.loop = this.markers[a].loop, this.duration = this.markers[a].duration, this.durationMS = this.markers[a].durationMS, "undefined" != typeof c && (this.volume = c), "undefined" != typeof d && (this.loop = d), this._tempMarker = a, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                }
                else b = b || 0, void 0 === c && (c = this._volume), void 0 === d && (d = this.loop), this.position = Math.max(0, b), this.volume = c, this.loop = d, this.duration = 0, this.durationMS = 0, this._tempMarker = a, this._tempPosition = b, this._tempVolume = c, this._tempLoop = d;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === a && (this._sound.loop = !0), this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.wechatMinigame || this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this.loop && (this._sound.loop = !0), !this.loop && "" === a && this.game.device.wechatMinigame && this._sound.addEventListener("ended", this.onEndedHandler.bind(this)), this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
            },
            restart: function(a, b, c, d) { a = a || "", b = b || 0, c = c || 1, void 0 === d && (d = !1), this.play(a, b, c, d, !0) },
            pause: function() { this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop()) },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var a = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var b = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a) : this._sound.start(0, a, b)
                    }
                    else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try { this._sound.stop(0) }
                        catch (a) {} this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    }
                else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) { var b = this.currentMarker; "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, b) }
            },
            fadeIn: function(a, b, c) { void 0 === b && (b = !1), void 0 === c && (c = this.currentMarker), this.paused || (this.play(c, 0, 0, b), this.fadeTo(a, 1)) },
            fadeOut: function(a) { this.fadeTo(a, 0) },
            fadeTo: function(a, b) { this.isPlaying && !this.paused && b !== this.volume && (void 0 === a && (a = 1e3), void 0 !== b && (this.fadeTween = this.game.add.tween(this).to({ volume: b }, a, c.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this))) },
            fadeComplete: function() { this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop() },
            updateGlobalVolume: function(a) { this.usingAudioTag && this._sound && (this._sound.volume = a * this._volume) },
            destroy: function(a) { void 0 === a && (a = !0), this.stop(), a ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()) }
        }, c.Sound.prototype.constructor = c.Sound, Object.defineProperty(c.Sound.prototype, "isDecoding", { get: function() { return this.game.cache.getSound(this.key).isDecoding } }), Object.defineProperty(c.Sound.prototype, "isDecoded", { get: function() { return this.game.cache.isSoundDecoded(this.key) } }), Object.defineProperty(c.Sound.prototype, "mute", { get: function() { return this._muted || this.game.sound.mute }, set: function(a) { a = a || !1, a !== this._muted && (a ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this)) } }), Object.defineProperty(c.Sound.prototype, "volume", { get: function() { return this._volume }, set: function(a) { return this.game.device.firefox && this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)), this._muted ? void(this._muteVolume = a) : (this._tempVolume = a, this._volume = a, void(this.usingWebAudio ? this.gainNode.gain.value = a : this.usingAudioTag && this._sound && (this._sound.volume = a))) } }), c.SoundManager = function(a) { this.game = a, this.onSoundDecode = new c.Signal, this.onVolumeChange = new c.Signal, this.onMute = new c.Signal, this.onUnMute = new c.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new c.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null }, c.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), window.PhaserGlobal) { if (window.PhaserGlobal.disableAudio === !0) return this.noAudio = !0, void(this.touchLocked = !1); if (window.PhaserGlobal.disableWebAudio === !0) return this.usingAudioTag = !0, void(this.touchLocked = !1) }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try { this.context = new window.AudioContext }
                catch (a) { this.context = null, this.usingWebAudio = !1, this.touchLocked = !1 }
                else if (window.webkitAudioContext) try { this.context = new window.webkitAudioContext }
                catch (a) { this.context = null, this.usingWebAudio = !1, this.touchLocked = !1 }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                }
                else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || !this.game.device.cocoonJS && (this.game.device.chrome || this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() { this.noAudio || window.PhaserGlobal && window.PhaserGlobal.disableAudio === !0 || (this.game.device.iOSVersion > 8 || this.game.device.chromeVersion >= 55 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0) },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var a = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = a, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), "suspended" === this._unlockSource.context.state && this._unlockSource.context.resume()
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume()
            },
            decode: function(a, b) { b = b || null; var c = this.game.cache.getSoundData(a); if (c && this.game.cache.isSoundDecoded(a) === !1) { this.game.cache.updateSound(a, "isDecoding", !0); var d = this; try { this.context.decodeAudioData(c, function(c) { c && (d.game.cache.decodedSound(a, c), d.onSoundDecode.dispatch(a, b)) }) } catch (e) {} } },
            setDecodedCallback: function(a, b, d) {
                "string" == typeof a && (a = [a]), this._watchList.reset();
                for (var e = 0; e < a.length; e++) a[e] instanceof c.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
                0 === this._watchList.total ? (this._watching = !1, b.call(d)) : (this._watching = !0, this._watchCallback = b, this._watchContext = d)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update();
                    if (this._watching) {
                        for (var b = this._watchList.first; b;) this.game.cache.isSoundDecoded(b) && this._watchList.remove(b), b = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(a, b, d, e) { void 0 === b && (b = 1), void 0 === d && (d = !1), void 0 === e && (e = this.connectToMaster); var f = new c.Sound(this.game, a, b, d, e); return this._sounds.push(f), f },
            addSprite: function(a) { var b = new c.AudioSprite(this.game, a); return b },
            remove: function(a) {
                for (var b = this._sounds.length; b--;)
                    if (this._sounds[b] === a) return this._sounds[b].destroy(!1), this._sounds.splice(b, 1), !0;
                return !1
            },
            removeByKey: function(a) { for (var b = this._sounds.length, c = 0; b--;) this._sounds[b].key === a && (this._sounds[b].destroy(!1), this._sounds.splice(b, 1), c++); return c },
            play: function(a, b, c) { if (!this.noAudio) { var d = this.add(a, b, c); return d.play(), d } },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        }, c.SoundManager.prototype.constructor = c.SoundManager, Object.defineProperty(c.SoundManager.prototype, "mute", {
            get: function() { return this._muted },
            set: function(a) {
                if (a = a || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                }
                else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(c.SoundManager.prototype, "volume", {
            get: function() { return this._volume },
            set: function(a) {
                if (a < 0 ? a = 0 : a > 1 && (a = 1), this._volume !== a) {
                    if (this._volume = a, this.usingWebAudio) this.masterGain.gain.value = a;
                    else
                        for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && this._sounds[b].updateGlobalVolume(a);
                    this.onVolumeChange.dispatch(a)
                }
            }
        }), c.ScaleManager = function(a, b, d) { this.game = a, this.dom = c.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new c.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new c.Signal, this.enterIncorrectOrientation = new c.Signal, this.leaveIncorrectOrientation = new c.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new c.Signal, this.onFullScreenChange = new c.Signal, this.onFullScreenError = new c.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new c.Point(1, 1), this.scaleFactorInversed = new c.Point(1, 1), this.margin = { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0 }, this.bounds = new c.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = { right: "layout", bottom: "" }, this.compatibility = { supportsFullScreen: !1, orientationFallback: null, noMargins: !1, scrollTo: null, forceMinimumDocumentHeight: !1, canExpandParent: !0, clickTrampoline: "" }, this._scaleMode = c.ScaleManager.NO_SCALE, this._fullScreenScaleMode = c.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new c.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new c.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new c.Rectangle, this._userScaleFactor = new c.Point(1, 1), this._userScaleTrim = new c.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new c.Rectangle, this._tempBounds = new c.Rectangle, this._lastReportedCanvasSize = new c.Rectangle, this._lastReportedGameSize = new c.Rectangle, this._booted = !1, a.config && this.parseConfig(a.config), this.setupScale(b, d) }, c.ScaleManager.EXACT_FIT = 0, c.ScaleManager.NO_SCALE = 1, c.ScaleManager.SHOW_ALL = 2, c.ScaleManager.RESIZE = 3, c.ScaleManager.USER_SCALE = 4, c.ScaleManager.prototype = {
            boot: function() {
                var a = this.compatibility;
                a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? a.scrollTo = new c.Point(0, 1) : a.scrollTo = new c.Point(0, 0)), this.game.device.desktop ? (a.orientationFallback = "screen", a.clickTrampoline = "when-not-mouse") : (a.orientationFallback = "", a.clickTrampoline = "");
                var b = this;
                this._orientationChange = function(a) { return b.orientationChange(a) }, this._windowResize = function(a) { return b.windowResize(a) }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(a) { return b.fullScreenChange(a) }, this._fullScreenError = function(a) { return b.fullScreenError(a) }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), c.FlexGrid && (this.grid = new c.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(a) { void 0 !== a.scaleMode && (this._booted ? this.scaleMode = a.scaleMode : this._pendingScaleMode = a.scaleMode), void 0 !== a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode), a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget) },
            setupScale: function(a, b) {
                var d, e = new c.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? d = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)), d ? (this.parentNode = d, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), e.width = this._parentBounds.width, e.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, e.width = this.dom.visualBounds.width, e.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var f = 0,
                    g = 0;
                "number" == typeof a ? f = a : (this.parentScaleFactor.x = parseInt(a, 10) / 100, f = e.width * this.parentScaleFactor.x), "number" == typeof b ? g = b : (this.parentScaleFactor.y = parseInt(b, 10) / 100, g = e.height * this.parentScaleFactor.y), f = Math.floor(f), g = Math.floor(g), this._gameSize.setTo(0, 0, f, g), this.updateDimensions(f, g, !1)
            },
            _gameResumed: function() { this.queueUpdate(!0) },
            setGameSize: function(a, b) { this._gameSize.setTo(0, 0, a, b), this.currentScaleMode !== c.ScaleManager.RESIZE && this.updateDimensions(a, b, !0), this.queueUpdate(!0) },
            setUserScale: function(a, b, c, d) { this._userScaleFactor.setTo(a, b), this._userScaleTrim.setTo(0 | c, 0 | d), this.queueUpdate(!0) },
            setResizeCallback: function(a, b) { this.onResize = a, this.onResizeContext = b },
            signalSizeChange: function() {
                if (!c.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !c.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var a = this.width,
                        b = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, a, b), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(a, b), this.onSizeChange.dispatch(this, a, b), this.currentScaleMode === c.ScaleManager.RESIZE && (this.game.state.resize(a, b), this.game.load.resize(a, b))
                }
            },
            setMinMax: function(a, b, c, d) { this.minWidth = a, this.minHeight = b, "undefined" != typeof c && (this.maxWidth = c), "undefined" != typeof d && (this.maxHeight = d) },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var a = this._updateThrottle;
                    this._updateThrottleReset = a >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var b = this._parentBounds.width,
                        d = this._parentBounds.height,
                        e = this.getParentBounds(this._parentBounds),
                        f = e.width !== b || e.height !== d,
                        g = this.updateOrientationState();
                    (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e), this.updateLayout(), this.signalSizeChange());
                    var h = 2 * this._updateThrottle;
                    this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)), this._updateThrottle = c.Math.clamp(h, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() { this.preUpdate(), this._updateThrottle = this.trackParentInterval },
            updateDimensions: function(a, b, c) { this.width = a * this.parentScaleFactor.x, this.height = b * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), c && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height)) },
            updateScalingAndBounds: function() { this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y) },
            forceOrientation: function(a, b) { void 0 === b && (b = !1), this.forceLandscape = a, this.forcePortrait = b, this.queueUpdate(!0) },
            classifyOrientation: function(a) { return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null },
            updateOrientationState: function() {
                var a = this.screenOrientation,
                    b = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var c = a !== this.screenOrientation,
                    d = b !== this.incorrectOrientation;
                return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (c || d) && this.onOrientationChange.dispatch(this, a, b), c || d
            },
            orientationChange: function(a) { this.event = a, this.queueUpdate(!0) },
            windowResize: function(a) {
                this.event = a, this.queueUpdate(!0);
            },
            scrollTop: function() {
                var a = this.compatibility.scrollTo;
                a && window.scrollTo(a.x, a.y)
            },
            refresh: function() { this.scrollTop(), this.queueUpdate(!0) },
            updateLayout: function() {
                var a = this.currentScaleMode;
                if (a === c.ScaleManager.RESIZE) return void this.reflowGame();
                if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : a === c.ScaleManager.EXACT_FIT ? this.setExactFit() : a === c.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : a === c.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : a === c.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (a === c.ScaleManager.SHOW_ALL || a === c.ScaleManager.USER_SCALE)) {
                    var b = this.getParentBounds(this._tempBounds);
                    this.width = Math.min(this.width, b.width), this.height = Math.min(this.height, b.height)
                }
                this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
            },
            getParentBounds: function(a) {
                var b = a || new c.Rectangle,
                    d = this.boundingParent,
                    e = this.dom.visualBounds,
                    f = this.dom.layoutBounds;
                if (d) {
                    var g = d.getBoundingClientRect(),
                        h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
                    b.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
                    var i = this.windowConstraints;
                    if (i.right) {
                        var j = "layout" === i.right ? f : e;
                        b.right = Math.min(b.right, j.width)
                    }
                    if (i.bottom) {
                        var j = "layout" === i.bottom ? f : e;
                        b.bottom = Math.min(b.bottom, j.height)
                    }
                }
                else b.setTo(0, 0, e.width, e.height);
                return b.setTo(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)), b
            },
            alignCanvas: function(a, b) {
                var c = this.getParentBounds(this._tempBounds),
                    d = this.game.canvas,
                    e = this.margin;
                if (a) {
                    e.left = e.right = 0;
                    var f = d.getBoundingClientRect();
                    if (this.width < c.width && !this.incorrectOrientation) {
                        var g = f.left - c.x,
                            h = c.width / 2 - this.width / 2;
                        h = Math.max(h, 0);
                        var i = h - g;
                        e.left = Math.round(i)
                    }
                    d.style.marginLeft = e.left + "px", 0 !== e.left && (e.right = -(c.width - f.width - e.left), d.style.marginRight = e.right + "px")
                }
                if (b) {
                    e.top = e.bottom = 0;
                    var f = d.getBoundingClientRect();
                    if (this.height < c.height && !this.incorrectOrientation) {
                        var g = f.top - c.y,
                            h = c.height / 2 - this.height / 2;
                        h = Math.max(h, 0);
                        var i = h - g;
                        e.top = Math.round(i)
                    }
                    d.style.marginTop = e.top + "px", 0 !== e.top && (e.bottom = -(c.height - f.height - e.top), d.style.marginBottom = e.bottom + "px")
                }
                e.x = e.left, e.y = e.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var a = this.getParentBounds(this._tempBounds);
                this.updateDimensions(a.width, a.height, !0)
            },
            reflowCanvas: function() { this.incorrectOrientation || (this.width = c.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = c.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds() },
            resetCanvas: function(a, b) {
                void 0 === a && (a = this.width + "px"), void 0 === b && (b = this.height + "px");
                var c = this.game.canvas;
                this.compatibility.noMargins || (c.style.marginLeft = "", c.style.marginTop = "", c.style.marginRight = "", c.style.marginBottom = ""), c.style.width = a, c.style.height = b
            },
            queueUpdate: function(a) { a && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset },
            reset: function(a) { a && this.grid && this.grid.reset() },
            setMaximum: function() { this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height },
            setShowAll: function(a) {
                var b, c = this.getParentBounds(this._tempBounds),
                    d = c.width,
                    e = c.height;
                b = a ? Math.max(e / this.game.height, d / this.game.width) : Math.min(e / this.game.height, d / this.game.width), this.width = Math.round(this.game.width * b), this.height = Math.round(this.game.height * b)
            },
            setExactFit: function() {
                var a = this.getParentBounds(this._tempBounds);
                this.width = a.width, this.height = a.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() { var a = document.createElement("div"); return a.style.margin = "0", a.style.padding = "0", a.style.background = "#000", a },
            startFullScreen: function(a, b) {
                if (this.isFullScreen) return !1;
                if (!this.compatibility.supportsFullScreen) { var d = this; return void setTimeout(function() { d.fullScreenError() }, 10) }
                if ("when-not-mouse" === this.compatibility.clickTrampoline) { var e = this.game.input; if (e.activePointer && e.activePointer !== e.mousePointer && (b || b !== !1)) return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [a, !1]) } void 0 !== a && this.game.renderType === c.CANVAS && (this.game.stage.smoothed = a);
                var f = this.fullScreenTarget;
                f || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), f = this._createdFullScreenTarget);
                var g = { targetElement: f };
                if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, g), this._createdFullScreenTarget) {
                    var h = this.game.canvas,
                        i = h.parentNode;
                    i.insertBefore(f, h), f.appendChild(h)
                }
                return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](), !0
            },
            stopFullScreen: function() { return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0) },
            cleanupCreatedTarget: function() {
                var a = this._createdFullScreenTarget;
                if (a && a.parentNode) {
                    var b = a.parentNode;
                    b.insertBefore(this.game.canvas, a), b.removeChild(a)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(a) {
                var b = !!this._createdFullScreenTarget,
                    d = this._createdFullScreenTarget || this.fullScreenTarget;
                a ? (b || this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT) && d !== this.game.canvas && (this._fullScreenRestore = { targetWidth: d.style.width, targetHeight: d.style.height }, d.style.width = "100%", d.style.height = "100%") : (this._fullScreenRestore && (d.style.width = this._fullScreenRestore.targetWidth, d.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(a) { this.event = a, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height) },
            fullScreenError: function(a) { this.event = a, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this) },
            scaleSprite: function(a, b, c, d) {
                if (void 0 === b && (b = this.width), void 0 === c && (c = this.height), void 0 === d && (d = !1), !a || !a.scale) return a;
                if (a.scale.x = 1, a.scale.y = 1, a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0) return a;
                var e = b,
                    f = a.height * b / a.width,
                    g = a.width * c / a.height,
                    h = c,
                    i = g > b;
                return i = i ? d : !d, i ? (a.width = Math.floor(e), a.height = Math.floor(f)) : (a.width = Math.floor(g), a.height = Math.floor(h)), a
            },
            destroy: function() { this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1)) }
        }, c.ScaleManager.prototype.constructor = c.ScaleManager, Object.defineProperty(c.ScaleManager.prototype, "boundingParent", { get: function() { if (this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget) return null; var a = this.game.canvas && this.game.canvas.parentNode; return a || null } }), Object.defineProperty(c.ScaleManager.prototype, "scaleMode", { get: function() { return this._scaleMode }, set: function(a) { return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = a), this._scaleMode } }), Object.defineProperty(c.ScaleManager.prototype, "fullScreenScaleMode", { get: function() { return this._fullScreenScaleMode }, set: function(a) { return a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = a, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = a), this._fullScreenScaleMode } }), Object.defineProperty(c.ScaleManager.prototype, "currentScaleMode", { get: function() { return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode } }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignHorizontally", { get: function() { return this._pageAlignHorizontally }, set: function(a) { a !== this._pageAlignHorizontally && (this._pageAlignHorizontally = a, this.queueUpdate(!0)) } }), Object.defineProperty(c.ScaleManager.prototype, "pageAlignVertically", { get: function() { return this._pageAlignVertically }, set: function(a) { a !== this._pageAlignVertically && (this._pageAlignVertically = a, this.queueUpdate(!0)) } }), Object.defineProperty(c.ScaleManager.prototype, "isFullScreen", { get: function() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) } }), Object.defineProperty(c.ScaleManager.prototype, "isPortrait", { get: function() { return "portrait" === this.classifyOrientation(this.screenOrientation) } }), Object.defineProperty(c.ScaleManager.prototype, "isLandscape", { get: function() { return "landscape" === this.classifyOrientation(this.screenOrientation) } }), Object.defineProperty(c.ScaleManager.prototype, "isGamePortrait", { get: function() { return this.height > this.width } }), Object.defineProperty(c.ScaleManager.prototype, "isGameLandscape", { get: function() { return this.width > this.height } }), c.Utils.Debug = function(a) { this.game = a, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1 }, c.Utils.Debug.prototype = {
            boot: function() { this.game.renderType === c.CANVAS ? this.context = this.game.context : (this.bmd = new c.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, (!0)), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")) },
            resize: function(a, b, c) { this.bmd.resize(b, c), this.canvas.width = b, this.canvas.height = c },
            preUpdate: function() { this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1) },
            reset: function() { this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear() },
            start: function(a, b, c, d) { "number" != typeof a && (a = 0), "number" != typeof b && (b = 0), c = c || "rgb(255,255,255)", void 0 === d && (d = 0), this.currentX = a, this.currentY = b, this.currentColor = c, this.columnWidth = d, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = c, this.context.fillStyle = c, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha },
            stop: function() { this.context.restore() },
            line: function() {
                for (var a = this.currentX, b = 0; b < arguments.length; b++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[b], a + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[b], a, this.currentY), a += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(a, b, c, d) { this.start(b, c, d), this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback), this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding), this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying), this.line("Time: " + a.currentTime), this.line("Volume: " + a.volume + " Muted: " + a.mute), this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag), "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"), this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop), this.line("Position: " + a.position)), this.stop() },
            cameraInfo: function(a, b, c, d) { this.start(b, c, d), this.line("Camera (" + a.width + " x " + a.height + ")"), this.line("X: " + a.x + " Y: " + a.y), a.bounds && this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height), this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height), this.line("Total in view: " + a.totalInView), this.stop() },
            timer: function(a, b, c, d) { this.start(b, c, d), this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"), this.line("Next Tick: " + a.next + " Duration: " + a.duration), this.line("Paused: " + a.paused + " Length: " + a.length), this.stop() },
            pointer: function(a, b, c, d, e) { null != a && (void 0 === b && (b = !1), c = c || "rgba(0,255,0,0.5)", d = d || "rgba(255,0,0,0.5)", b === !0 && a.isUp === !0 || (this.start(a.x, a.y - 100, e), this.context.beginPath(), this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI), a.active ? this.context.fillStyle = c : this.context.fillStyle = d, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(a.positionDown.x, a.positionDown.y), this.context.lineTo(a.position.x, a.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + a.id + " Active: " + a.active), this.line("World X: " + a.worldX + " World Y: " + a.worldY), this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame), this.line("Duration: " + a.duration + " ms"), this.line("is Down: " + a.isDown + " is Up: " + a.isUp), this.stop())) },
            spriteInputInfo: function(a, b, c, d) { this.start(b, c, d), this.line("Sprite Input: (" + a.width + " x " + a.height + ")"), this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)), this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)), this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)), this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()), this.stop() },
            key: function(a, b, c, d) { this.start(b, c, d, 150), this.line("Key:", a.keyCode, "isDown:", a.isDown), this.line("justDown:", a.justDown, "justUp:", a.justUp), this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)), this.stop() },
            inputInfo: function(a, b, c) { this.start(a, b, c), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop() },
            spriteBounds: function(a, b, c) {
                var d = a.getBounds();
                d.x += this.game.camera.x, d.y += this.game.camera.y, this.rectangle(d, b, c)
            },
            ropeSegments: function(a, b, c) {
                var d = a.segments,
                    e = this;
                d.forEach(function(a) { e.rectangle(a, b, c) }, this)
            },
            spriteInfo: function(a, b, c, d) { this.start(b, c, d), this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y), this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)), this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)), this.line("visible: " + a.visible + " in camera: " + a.inCamera), this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)), this.stop() },
            spriteCoords: function(a, b, c, d) { this.start(b, c, d, 100), a.name && this.line(a.name), this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)), this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)), this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)), this.stop() },
            lineInfo: function(a, b, c, d) { this.start(b, c, d, 80), this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)), this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)), this.line("length:", a.length.toFixed(2), "angle:", a.angle), this.stop() },
            pixel: function(a, b, c, d) { d = d || 2, this.start(), this.context.fillStyle = c, this.context.fillRect(a, b, d, d), this.stop() },
            geom: function(a, b, d, e) { void 0 === d && (d = !0), void 0 === e && (e = 0), b = b || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = b, this.context.strokeStyle = b, a instanceof c.Rectangle || 1 === e ? d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : a instanceof c.Circle || 2 === e ? (this.context.beginPath(), this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), this.context.closePath(), d ? this.context.fill() : this.context.stroke()) : a instanceof c.Point || 3 === e ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4) : (a instanceof c.Line || 4 === e) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(a.start.x + .5 - this.game.camera.x, a.start.y + .5 - this.game.camera.y), this.context.lineTo(a.end.x + .5 - this.game.camera.x, a.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop() },
            rectangle: function(a, b, c) { void 0 === c && (c = !0), b = b || "rgba(0, 255, 0, 0.4)", this.start(), c ? (this.context.fillStyle = b, this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.strokeStyle = b, this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)), this.stop() },
            text: function(a, b, c, d, e) { d = d || "rgb(255,255,255)", e = e || "16px Courier", this.start(), this.context.font = e, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(a, b + 1, c + 1)), this.context.fillStyle = d, this.context.fillText(a, b, c), this.stop() },
            quadTree: function(a, b) {
                b = b || "rgba(255,0,0,0.3)", this.start();
                var c = a.bounds;
                if (0 === a.nodes.length) { this.context.strokeStyle = b, this.context.strokeRect(c.x, c.y, c.width, c.height), this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)"; for (var d = 0; d < a.objects.length; d++) this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height) }
                else
                    for (var d = 0; d < a.nodes.length; d++) this.quadTree(a.nodes[d]);
                this.stop()
            },
            body: function(a, b, d) { a.body && (this.start(), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.NINJA ? c.Physics.Ninja.Body.render(this.context, a.body, b, d) : a.body.type === c.Physics.BOX2D && c.Physics.Box2D.renderBody(this.context, a.body, b), this.stop()) },
            bodyInfo: function(a, b, d, e) { a.body && (this.start(b, d, e, 210), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === c.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body), this.stop()) },
            box2dWorld: function() { this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop() },
            box2dBody: function(a, b) { this.start(), c.Physics.Box2D.renderBody(this.context, a, b), this.stop() },
            displayList: function(a) {
                if (void 0 === a && (a = this.game.world), a.hasOwnProperty("renderOrderID"), a.children && a.children.length > 0)
                    for (var b = 0; b < a.children.length; b++) this.game.debug.displayList(a.children[b])
            },
            destroy: function() { PIXI.CanvasPool.remove(this) }
        }, c.Utils.Debug.prototype.constructor = c.Utils.Debug, c.DOM = {
            getOffset: function(a, b) {
                b = b || new c.Point;
                var d = a.getBoundingClientRect(),
                    e = c.DOM.scrollY,
                    f = c.DOM.scrollX,
                    g = document.documentElement.clientTop,
                    h = document.documentElement.clientLeft;
                return b.x = d.left + f - h, b.y = d.top + e - g, b
            },
            getBounds: function(a, b) { return void 0 === b && (b = 0), a = a && !a.nodeType ? a[0] : a, !(!a || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b) },
            calibrate: function(a, b) { b = +b || 0; var c = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 }; return c.width = (c.right = a.right + b) - (c.left = a.left - b), c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b), c },
            getAspectRatio: function(a) {
                a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
                var b = a.width,
                    c = a.height;
                return "function" == typeof b && (b = b.call(a)), "function" == typeof c && (c = c.call(a)), b / c
            },
            inLayoutViewport: function(a, b) { var c = this.getBounds(a, b); return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height },
            getScreenOrientation: function(a) {
                var b = window.screen,
                    c = b.orientation || b.mozOrientation || b.msOrientation;
                if (c && "string" == typeof c.type) return c.type;
                if ("string" == typeof c) return c;
                var d = "portrait-primary",
                    e = "landscape-primary";
                if ("screen" === a) return b.height > b.width ? d : e;
                if ("viewport" === a) return this.visualBounds.height > this.visualBounds.width ? d : e;
                if ("window.orientation" === a && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? d : e;
                if (window.matchMedia) { if (window.matchMedia("(orientation: portrait)").matches) return d; if (window.matchMedia("(orientation: landscape)").matches) return e }
                return this.visualBounds.height > this.visualBounds.width ? d : e
            },
            visualBounds: new c.Rectangle,
            layoutBounds: new c.Rectangle,
            documentBounds: new c.Rectangle
        }, c.Device.whenReady(function(a) {
            var b = window && "pageXOffset" in window ? function() { return window.pageXOffset } : function() { return document.documentElement.scrollLeft },
                d = window && "pageYOffset" in window ? function() { return window.pageYOffset } : function() { return document.documentElement.scrollTop };
            Object.defineProperty(c.DOM, "scrollX", { get: b }), Object.defineProperty(c.DOM, "scrollY", { get: d }), Object.defineProperty(c.DOM.visualBounds, "x", { get: b }), Object.defineProperty(c.DOM.visualBounds, "y", { get: d }), Object.defineProperty(c.DOM.layoutBounds, "x", { value: 0 }), Object.defineProperty(c.DOM.layoutBounds, "y", { value: 0 });
            var e = a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
            if (e) {
                var f = function() { return Math.max(window.innerWidth, document.documentElement.clientWidth) },
                    g = function() { return Math.max(window.innerHeight, document.documentElement.clientHeight) };
                Object.defineProperty(c.DOM.visualBounds, "width", { get: f }), Object.defineProperty(c.DOM.visualBounds, "height", { get: g }), Object.defineProperty(c.DOM.layoutBounds, "width", { get: f }), Object.defineProperty(c.DOM.layoutBounds, "height", { get: g })
            }
            else Object.defineProperty(c.DOM.visualBounds, "width", { get: function() { return window.innerWidth } }), Object.defineProperty(c.DOM.visualBounds, "height", { get: function() { return window.innerHeight } }), Object.defineProperty(c.DOM.layoutBounds, "width", {
                get: function() {
                    var a = document.documentElement.clientWidth,
                        b = window.innerWidth;
                    return a < b ? b : a
                }
            }), Object.defineProperty(c.DOM.layoutBounds, "height", {
                get: function() {
                    var a = document.documentElement.clientHeight,
                        b = window.innerHeight;
                    return a < b ? b : a
                }
            });
            Object.defineProperty(c.DOM.documentBounds, "x", { value: 0 }), Object.defineProperty(c.DOM.documentBounds, "y", { value: 0 }), Object.defineProperty(c.DOM.documentBounds, "width", { get: function() { var a = document.documentElement; return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth) } }), Object.defineProperty(c.DOM.documentBounds, "height", { get: function() { var a = document.documentElement; return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight) } })
        }, null, !0), c.ArraySet = function(a) { this.position = 0, this.list = a || [] }, c.ArraySet.prototype = {
            add: function(a) { return this.exists(a) || this.list.push(a), a },
            getIndex: function(a) { return this.list.indexOf(a) },
            getByKey: function(a, b) {
                for (var c = this.list.length; c--;)
                    if (this.list[c][a] === b) return this.list[c];
                return null
            },
            exists: function(a) { return this.list.indexOf(a) > -1 },
            reset: function() { this.list.length = 0 },
            remove: function(a) { var b = this.list.indexOf(a); if (b > -1) return this.list.splice(b, 1), a },
            setAll: function(a, b) { for (var c = this.list.length; c--;) this.list[c] && (this.list[c][a] = b) },
            callAll: function(a) { for (var b = Array.prototype.slice.call(arguments, 1), c = this.list.length; c--;) this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b) },
            removeAll: function(a) {
                void 0 === a && (a = !1);
                for (var b = this.list.length; b--;)
                    if (this.list[b]) {
                        var c = this.remove(this.list[b]);
                        a && c.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(c.ArraySet.prototype, "total", { get: function() { return this.list.length } }), Object.defineProperty(c.ArraySet.prototype, "first", { get: function() { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }), Object.defineProperty(c.ArraySet.prototype, "next", { get: function() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }), c.ArraySet.prototype.constructor = c.ArraySet, c.ArrayUtils = {
            getRandomItem: function(a, b, c) {
                if (null === a) return null;
                void 0 === b && (b = 0), void 0 === c && (c = a.length);
                var d = b + Math.floor(Math.random() * c);
                return void 0 === a[d] ? null : a[d]
            },
            removeRandomItem: function(a, b, c) {
                if (null == a) return null;
                void 0 === b && (b = 0), void 0 === c && (c = a.length);
                var d = b + Math.floor(Math.random() * c);
                if (d < a.length) { var e = a.splice(d, 1); return void 0 === e[0] ? null : e[0] }
                return null
            },
            shuffle: function(a) {
                for (var b = a.length - 1; b > 0; b--) {
                    var c = Math.floor(Math.random() * (b + 1)),
                        d = a[b];
                    a[b] = a[c], a[c] = d
                }
                return a
            },
            transposeMatrix: function(a) { for (var b = a.length, c = a[0].length, d = new Array(c), e = 0; e < c; e++) { d[e] = new Array(b); for (var f = b - 1; f > -1; f--) d[e][f] = a[f][e] } return d },
            rotateMatrix: function(a, b) {
                if ("string" != typeof b && (b = (b % 360 + 360) % 360), 90 === b || b === -270 || "rotateLeft" === b) a = c.ArrayUtils.transposeMatrix(a), a = a.reverse();
                else if (b === -90 || 270 === b || "rotateRight" === b) a = a.reverse(), a = c.ArrayUtils.transposeMatrix(a);
                else if (180 === Math.abs(b) || "rotate180" === b) {
                    for (var d = 0; d < a.length; d++) a[d].reverse();
                    a = a.reverse()
                }
                return a
            },
            findClosest: function(a, b) {
                if (!b.length) return NaN;
                if (1 === b.length || a < b[0]) return b[0];
                for (var c = 1; b[c] < a;) c++;
                var d = b[c - 1],
                    e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
                return e - a <= a - d ? e : d
            },
            rotateRight: function(a) { var b = a.pop(); return a.unshift(b), b },
            rotateLeft: function(a) { var b = a.shift(); return a.push(b), b },
            rotate: function(a) { var b = a.shift(); return a.push(b), b },
            numberArray: function(a, b) { for (var c = [], d = a; d <= b; d++) c.push(d); return c },
            numberArrayStep: function(a, b, d) { void 0 !== a && null !== a || (a = 0), void 0 !== b && null !== b || (b = a, a = 0), void 0 === d && (d = 1); for (var e = [], f = Math.max(c.Math.roundAwayFromZero((b - a) / (d || 1)), 0), g = 0; g < f; g++) e.push(a), a += d; return e }
        }, c.LinkedList = function() { this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0 }, c.LinkedList.prototype = {
            add: function(a) { return 0 === this.total && null === this.first && null === this.last ? (this.first = a, this.last = a, this.next = a, a.prev = this, this.total++, a) : (this.last.next = a, a.prev = this.last, this.last = a, this.total++, a) },
            reset: function() { this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0 },
            remove: function(a) { return 1 === this.total ? (this.reset(), void(a.next = a.prev = null)) : (a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev), a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), a.next = a.prev = null, null === this.first && (this.last = null), void this.total--) },
            callAll: function(a) {
                if (this.first && this.last) {
                    var b = this.first;
                    do b && b[a] && b[a].call(b), b = b.next; while (b !== this.last.next)
                }
            }
        }, c.LinkedList.prototype.constructor = c.LinkedList, c.Create = function(a) { this.game = a, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{ 0: "#000", 1: "#9D9D9D", 2: "#FFF", 3: "#BE2633", 4: "#E06F8B", 5: "#493C2B", 6: "#A46422", 7: "#EB8931", 8: "#F7E26B", 9: "#2F484E", A: "#44891A", B: "#A3CE27", C: "#1B2632", D: "#005784", E: "#31A2F2", F: "#B2DCEF" }, { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#f5f4eb" }, { 0: "#000", 1: "#2234d1", 2: "#0c7e45", 3: "#44aacc", 4: "#8a3622", 5: "#5c2e78", 6: "#aa5c3d", 7: "#b5b5b5", 8: "#5e606e", 9: "#4c81fb", A: "#6cd947", B: "#7be2f9", C: "#eb8a60", D: "#e23d69", E: "#ffd93f", F: "#fff" }, { 0: "#000", 1: "#fff", 2: "#8b4131", 3: "#7bbdc5", 4: "#8b41ac", 5: "#6aac41", 6: "#3931a4", 7: "#d5de73", 8: "#945a20", 9: "#5a4100", A: "#bd736a", B: "#525252", C: "#838383", D: "#acee8b", E: "#7b73de", F: "#acacac" }, { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#fff" }] }, c.Create.PALETTE_ARNE = 0, c.Create.PALETTE_JMP = 1, c.Create.PALETTE_CGA = 2, c.Create.PALETTE_C64 = 3, c.Create.PALETTE_JAPANESE_MACHINE = 4, c.Create.prototype = {
            texture: function(a, b, c, d, e) {
                void 0 === c && (c = 8), void 0 === d && (d = c), void 0 === e && (e = 0);
                var f = b[0].length * c,
                    g = b.length * d;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(f, g), this.bmd.clear();
                for (var h = 0; h < b.length; h++)
                    for (var i = b[h], j = 0; j < i.length; j++) { var k = i[j]; "." !== k && " " !== k && (this.ctx.fillStyle = this.palettes[e][k], this.ctx.fillRect(j * c, h * d, c, d)) }
                return this.bmd.generateTexture(a)
            },
            grid: function(a, b, c, d, e, f) { null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(b, c), this.ctx.fillStyle = f; for (var g = 0; g < c; g += e) this.ctx.fillRect(0, g, b, 1); for (var h = 0; h < b; h += d) this.ctx.fillRect(h, 0, 1, c); return this.bmd.generateTexture(a) }
        }, c.Create.prototype.constructor = c.Create, c.FlexGrid = function(a, b, d) { this.game = a.game, this.manager = a, this.width = b, this.height = d, this.boundsCustom = new c.Rectangle(0, 0, b, d), this.boundsFluid = new c.Rectangle(0, 0, b, d), this.boundsFull = new c.Rectangle(0, 0, b, d), this.boundsNone = new c.Rectangle(0, 0, b, d), this.positionCustom = new c.Point(0, 0), this.positionFluid = new c.Point(0, 0), this.positionFull = new c.Point(0, 0), this.positionNone = new c.Point(0, 0), this.scaleCustom = new c.Point(1, 1), this.scaleFluid = new c.Point(1, 1), this.scaleFluidInversed = new c.Point(1, 1), this.scaleFull = new c.Point(1, 1), this.scaleNone = new c.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = b / d, this.ratioV = d / b, this.multiplier = 0, this.layers = [] }, c.FlexGrid.prototype = {
            setSize: function(a, b) { this.width = a, this.height = b, this.ratioH = a / b, this.ratioV = b / a, this.scaleNone = new c.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh() },
            createCustomLayer: function(a, b, d, e) { void 0 === e && (e = !0), this.customWidth = a, this.customHeight = b, this.boundsCustom.width = a, this.boundsCustom.height = b; var f = new c.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom); return e && this.game.world.add(f), this.layers.push(f), "undefined" != typeof d && null !== typeof d && f.addMultiple(d), f },
            createFluidLayer: function(a, b) { void 0 === b && (b = !0); var d = new c.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid); return b && this.game.world.add(d), this.layers.push(d), "undefined" != typeof a && null !== typeof a && d.addMultiple(a), d },
            createFullLayer: function(a) { var b = new c.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid); return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b },
            createFixedLayer: function(a) { var b = new c.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone); return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b },
            reset: function() { for (var a = this.layers.length; a--;) this.layers[a].persist || (this.layers[a].position = null, this.layers[a].scale = null, this.layers.slice(a, 1)) },
            onResize: function(a, b) { this.ratioH = a / b, this.ratioV = b / a, this.refresh(a, b) },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier),
                    this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(a) { this.manager.scaleSprite(a), a.x = this.manager.bounds.centerX, a.y = this.manager.bounds.centerY },
            debug: function() { this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1) }
        }, c.FlexGrid.prototype.constructor = c.FlexGrid, c.FlexLayer = function(a, b, d, e) { c.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1), this.manager = a.manager, this.grid = a, this.persist = !1, this.position = b, this.bounds = d, this.scale = e, this.topLeft = d.topLeft, this.topMiddle = new c.Point(d.halfWidth, 0), this.topRight = d.topRight, this.bottomLeft = d.bottomLeft, this.bottomMiddle = new c.Point(d.halfWidth, d.bottom), this.bottomRight = d.bottomRight }, c.FlexLayer.prototype = Object.create(c.Group.prototype), c.FlexLayer.prototype.constructor = c.FlexLayer, c.FlexLayer.prototype.resize = function() {}, c.FlexLayer.prototype.debug = function() { this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9") }, c.Color = {
            packPixel: function(a, b, d, e) { return c.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | b << 8 | a) >>> 0 : (a << 24 | b << 16 | d << 8 | e) >>> 0 },
            unpackPixel: function(a, b, d, e) { return void 0 !== b && null !== b || (b = c.Color.createColor()), void 0 !== d && null !== d || (d = !1), void 0 !== e && null !== e || (e = !1), c.Device.LITTLE_ENDIAN ? (b.a = (4278190080 & a) >>> 24, b.b = (16711680 & a) >>> 16, b.g = (65280 & a) >>> 8, b.r = 255 & a) : (b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a), b.color = a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")", d && c.Color.RGBtoHSL(b.r, b.g, b.b, b), e && c.Color.RGBtoHSV(b.r, b.g, b.b, b), b },
            fromRGBA: function(a, b) { return b || (b = c.Color.createColor()), b.r = (4278190080 & a) >>> 24, b.g = (16711680 & a) >>> 16, b.b = (65280 & a) >>> 8, b.a = 255 & a, b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")", b },
            toRGBA: function(a, b, c, d) { return a << 24 | b << 16 | c << 8 | d },
            toABGR: function(a, b, c, d) { return (d << 24 | c << 16 | b << 8 | a) >>> 0 },
            RGBtoHSL: function(a, b, d, e) {
                e || (e = c.Color.createColor(a, b, d, 1)), a /= 255, b /= 255, d /= 255;
                var f = Math.min(a, b, d),
                    g = Math.max(a, b, d);
                if (e.h = 0, e.s = 0, e.l = (g + f) / 2, g !== f) {
                    var h = g - f;
                    e.s = e.l > .5 ? h / (2 - g - f) : h / (g + f), g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6
                }
                return e
            },
            HSLtoRGB: function(a, b, d, e) {
                if (e ? (e.r = d, e.g = d, e.b = d) : e = c.Color.createColor(d, d, d), 0 !== b) {
                    var f = d < .5 ? d * (1 + b) : d + b - d * b,
                        g = 2 * d - f;
                    e.r = c.Color.hueToColor(g, f, a + 1 / 3), e.g = c.Color.hueToColor(g, f, a), e.b = c.Color.hueToColor(g, f, a - 1 / 3)
                }
                return e.r = Math.floor(255 * e.r | 0), e.g = Math.floor(255 * e.g | 0), e.b = Math.floor(255 * e.b | 0), c.Color.updateColor(e), e
            },
            RGBtoHSV: function(a, b, d, e) {
                e || (e = c.Color.createColor(a, b, d, 255)), a /= 255, b /= 255, d /= 255;
                var f = Math.min(a, b, d),
                    g = Math.max(a, b, d),
                    h = g - f;
                return e.h = 0, e.s = 0 === g ? 0 : h / g, e.v = g, g !== f && (g === a ? e.h = (b - d) / h + (b < d ? 6 : 0) : g === b ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - b) / h + 4), e.h /= 6), e
            },
            HSVtoRGB: function(a, b, d, e) {
                void 0 === e && (e = c.Color.createColor(0, 0, 0, 1, a, b, 0, d));
                var f, g, h, i = Math.floor(6 * a),
                    j = 6 * a - i,
                    k = d * (1 - b),
                    l = d * (1 - j * b),
                    m = d * (1 - (1 - j) * b);
                switch (i % 6) {
                    case 0:
                        f = d, g = m, h = k;
                        break;
                    case 1:
                        f = l, g = d, h = k;
                        break;
                    case 2:
                        f = k, g = d, h = m;
                        break;
                    case 3:
                        f = k, g = l, h = d;
                        break;
                    case 4:
                        f = m, g = k, h = d;
                        break;
                    case 5:
                        f = d, g = k, h = l
                }
                return e.r = Math.floor(255 * f), e.g = Math.floor(255 * g), e.b = Math.floor(255 * h), c.Color.updateColor(e), e
            },
            hueToColor: function(a, b, c) { return c < 0 && (c += 1), c > 1 && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : c < .5 ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a },
            createColor: function(a, b, d, e, f, g, h, i) { var j = { r: a || 0, g: b || 0, b: d || 0, a: e || 1, h: f || 0, s: g || 0, l: h || 0, v: i || 0, color: 0, color32: 0, rgba: "" }; return c.Color.updateColor(j) },
            updateColor: function(a) { return a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")", a.color = c.Color.getColor(a.r, a.g, a.b), a.color32 = c.Color.getColor32(255 * a.a, a.r, a.g, a.b), a },
            getColor32: function(a, b, c, d) { return a << 24 | b << 16 | c << 8 | d },
            getColor: function(a, b, c) { return a << 16 | b << 8 | c },
            RGBtoString: function(a, b, d, e, f) { return void 0 === e && (e = 255), void 0 === f && (f = "#"), "#" === f ? "#" + ((1 << 24) + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c.Color.componentToHex(e) + c.Color.componentToHex(a) + c.Color.componentToHex(b) + c.Color.componentToHex(d) },
            hexToRGB: function(a) { var b = c.Color.hexToColor(a); if (b) return c.Color.getColor32(b.a, b.r, b.g, b.b) },
            hexToColor: function(a, b) {
                a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) { return b + b + c + c + d + d });
                var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
                if (d) {
                    var e = parseInt(d[1], 16),
                        f = parseInt(d[2], 16),
                        g = parseInt(d[3], 16);
                    b ? (b.r = e, b.g = f, b.b = g) : b = c.Color.createColor(e, f, g)
                }
                return b
            },
            webToColor: function(a, b) { b || (b = c.Color.createColor()); var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a); return d && (b.r = parseInt(d[1], 10), b.g = parseInt(d[2], 10), b.b = parseInt(d[3], 10), b.a = void 0 !== d[4] ? parseFloat(d[4]) : 1, c.Color.updateColor(b)), b },
            valueToColor: function(a, b) { if (b || (b = c.Color.createColor()), "string" == typeof a) return 0 === a.indexOf("rgb") ? c.Color.webToColor(a, b) : (b.a = 1, c.Color.hexToColor(a, b)); if ("number" == typeof a) { var d = c.Color.getRGB(a); return b.r = d.r, b.g = d.g, b.b = d.b, b.a = d.a / 255, b } return b },
            componentToHex: function(a) { var b = a.toString(16); return 1 === b.length ? "0" + b : b },
            HSVColorWheel: function(a, b) { void 0 === a && (a = 1), void 0 === b && (b = 1); for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSVtoRGB(e / 359, a, b)); return d },
            HSLColorWheel: function(a, b) { void 0 === a && (a = .5), void 0 === b && (b = .5); for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSLtoRGB(e / 359, a, b)); return d },
            interpolateColor: function(a, b, d, e, f) {
                void 0 === f && (f = 255);
                var g = c.Color.getRGB(a),
                    h = c.Color.getRGB(b),
                    i = (h.red - g.red) * e / d + g.red,
                    j = (h.green - g.green) * e / d + g.green,
                    k = (h.blue - g.blue) * e / d + g.blue;
                return c.Color.getColor32(f, i, j, k)
            },
            interpolateColorWithRGB: function(a, b, d, e, f, g) {
                var h = c.Color.getRGB(a),
                    i = (b - h.red) * g / f + h.red,
                    j = (d - h.green) * g / f + h.green,
                    k = (e - h.blue) * g / f + h.blue;
                return c.Color.getColor(i, j, k)
            },
            interpolateRGB: function(a, b, d, e, f, g, h, i) {
                var j = (e - a) * i / h + a,
                    k = (f - b) * i / h + b,
                    l = (g - d) * i / h + d;
                return c.Color.getColor(j, k, l)
            },
            getRandomColor: function(a, b, d) {
                if (void 0 === a && (a = 0), void 0 === b && (b = 255), void 0 === d && (d = 255), b > 255 || a > b) return c.Color.getColor(255, 255, 255);
                var e = a + Math.round(Math.random() * (b - a)),
                    f = a + Math.round(Math.random() * (b - a)),
                    g = a + Math.round(Math.random() * (b - a));
                return c.Color.getColor32(d, e, f, g)
            },
            getRGB: function(a) { return a > 16777215 ? { alpha: a >>> 24, red: a >> 16 & 255, green: a >> 8 & 255, blue: 255 & a, a: a >>> 24, r: a >> 16 & 255, g: a >> 8 & 255, b: 255 & a } : { alpha: 255, red: a >> 16 & 255, green: a >> 8 & 255, blue: 255 & a, a: 255, r: a >> 16 & 255, g: a >> 8 & 255, b: 255 & a } },
            getWebRGB: function(a) { if ("object" == typeof a) return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")"; var b = c.Color.getRGB(a); return "rgba(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + "," + (b.a / 255).toString() + ")" },
            getAlpha: function(a) { return a >>> 24 },
            getAlphaFloat: function(a) { return (a >>> 24) / 255 },
            getRed: function(a) { return a >> 16 & 255 },
            getGreen: function(a) { return a >> 8 & 255 },
            getBlue: function(a) { return 255 & a },
            blendNormal: function(a) { return a },
            blendLighten: function(a, b) { return b > a ? b : a },
            blendDarken: function(a, b) { return b > a ? a : b },
            blendMultiply: function(a, b) { return a * b / 255 },
            blendAverage: function(a, b) { return (a + b) / 2 },
            blendAdd: function(a, b) { return Math.min(255, a + b) },
            blendSubtract: function(a, b) { return Math.max(0, a + b - 255) },
            blendDifference: function(a, b) { return Math.abs(a - b) },
            blendNegation: function(a, b) { return 255 - Math.abs(255 - a - b) },
            blendScreen: function(a, b) { return 255 - ((255 - a) * (255 - b) >> 8) },
            blendExclusion: function(a, b) { return a + b - 2 * a * b / 255 },
            blendOverlay: function(a, b) { return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255 },
            blendSoftLight: function(a, b) { return b < 128 ? 2 * ((a >> 1) + 64) * (b / 255) : 255 - 2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255 },
            blendHardLight: function(a, b) { return c.Color.blendOverlay(b, a) },
            blendColorDodge: function(a, b) { return 255 === b ? b : Math.min(255, (a << 8) / (255 - b)) },
            blendColorBurn: function(a, b) { return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b) },
            blendLinearDodge: function(a, b) { return c.Color.blendAdd(a, b) },
            blendLinearBurn: function(a, b) { return c.Color.blendSubtract(a, b) },
            blendLinearLight: function(a, b) { return b < 128 ? c.Color.blendLinearBurn(a, 2 * b) : c.Color.blendLinearDodge(a, 2 * (b - 128)) },
            blendVividLight: function(a, b) { return b < 128 ? c.Color.blendColorBurn(a, 2 * b) : c.Color.blendColorDodge(a, 2 * (b - 128)) },
            blendPinLight: function(a, b) { return b < 128 ? c.Color.blendDarken(a, 2 * b) : c.Color.blendLighten(a, 2 * (b - 128)) },
            blendHardMix: function(a, b) { return c.Color.blendVividLight(a, b) < 128 ? 0 : 255 },
            blendReflect: function(a, b) { return 255 === b ? b : Math.min(255, a * a / (255 - b)) },
            blendGlow: function(a, b) { return c.Color.blendReflect(b, a) },
            blendPhoenix: function(a, b) { return Math.min(a, b) - Math.max(a, b) + 255 }
        }, c.Physics = function(a, b) { b = b || {}, this.game = a, this.config = b, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig() }, c.Physics.ARCADE = 0, c.Physics.P2JS = 1, c.Physics.NINJA = 2, c.Physics.BOX2D = 3, c.Physics.CHIPMUNK = 4, c.Physics.MATTERJS = 5, c.Physics.prototype = { parseConfig: function() { this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !c.Physics.hasOwnProperty("Arcade") || (this.arcade = new c.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && c.Physics.hasOwnProperty("Ninja") && (this.ninja = new c.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && this.config.p2 === !0 && c.Physics.hasOwnProperty("P2") && (this.p2 = new c.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && this.config.box2d === !0 && c.Physics.hasOwnProperty("BOX2D") && (this.box2d = new c.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && this.config.matter === !0 && c.Physics.hasOwnProperty("Matter") && (this.matter = new c.Physics.Matter(this.game, this.config)) }, startSystem: function(a) { a === c.Physics.ARCADE ? this.arcade = new c.Physics.Arcade(this.game) : a === c.Physics.P2JS ? null === this.p2 ? this.p2 = new c.Physics.P2(this.game, this.config) : this.p2.reset() : a === c.Physics.NINJA ? this.ninja = new c.Physics.Ninja(this.game) : a === c.Physics.BOX2D ? null === this.box2d ? this.box2d = new c.Physics.Box2D(this.game, this.config) : this.box2d.reset() : a === c.Physics.MATTERJS && (null === this.matter ? this.matter = new c.Physics.Matter(this.game, this.config) : this.matter.reset()) }, enable: function(a, b, d) { void 0 === b && (b = c.Physics.ARCADE), void 0 === d && (d = !1), b === c.Physics.ARCADE ? this.arcade.enable(a) : b === c.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : b === c.Physics.NINJA && this.ninja ? this.ninja.enableAABB(a) : b === c.Physics.BOX2D && this.box2d ? this.box2d.enable(a) : b === c.Physics.MATTERJS && this.matter && this.matter.enable(a) }, preUpdate: function() { this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate() }, update: function() { this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update() }, setBoundsToWorld: function() { this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld() }, clear: function() { this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear() }, reset: function() { this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset() }, destroy: function() { this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null } }, c.Physics.prototype.constructor = c.Physics, c.Physics.Arcade = function(a) { this.game = a, this.gravity = new c.Point, this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height), this.checkCollision = { up: !0, down: !0, left: !0, right: !0 }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = c.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new c.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld() }, c.Physics.Arcade.prototype.constructor = c.Physics.Arcade, c.Physics.Arcade.SORT_NONE = 0, c.Physics.Arcade.LEFT_RIGHT = 1, c.Physics.Arcade.RIGHT_LEFT = 2, c.Physics.Arcade.TOP_BOTTOM = 3, c.Physics.Arcade.BOTTOM_TOP = 4, c.Physics.Arcade.prototype = {
            setBounds: function(a, b, c, d) { this.bounds.setTo(a, b, c, d) },
            setBoundsToWorld: function() { this.bounds.copyFrom(this.game.world.bounds) },
            enable: function(a, b) {
                void 0 === b && (b = !0);
                var d = 1;
                if (Array.isArray(a))
                    for (d = a.length; d--;) a[d] instanceof c.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), b && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0));
                else a instanceof c.Group ? this.enable(a.children, b) : (this.enableBody(a), b && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0))
            },
            enableBody: function(a) { a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.Arcade.Body(a), a.parent && a.parent instanceof c.Group && a.parent.addToHash(a)) },
            updateMotion: function(a) {
                var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
                a.angularVelocity += b, a.rotation += a.angularVelocity * this.game.time.physicsElapsed, a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x), a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y)
            },
            computeVelocity: function(a, b, c, d, e, f) { return void 0 === f && (f = 1e4), 1 === a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed), d ? c += d * this.game.time.physicsElapsed : e && (e *= this.game.time.physicsElapsed, c - e > 0 ? c -= e : c + e < 0 ? c += e : c = 0), c > f ? c = f : c < -f && (c = -f), c },
            overlap: function(a, b, c, d, e) {
                if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !0);
                else if (Array.isArray(a) && !Array.isArray(b))
                    for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !0);
                else if (Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < a.length; f++)
                        for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !0);
                else this.collideHandler(a, b, c, d, e, !0);
                return this._total > 0
            },
            collide: function(a, b, c, d, e) {
                if (c = c || null, d = d || null, e = e || c, this._total = 0, !Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !1);
                else if (Array.isArray(a) && !Array.isArray(b))
                    for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !1);
                else if (Array.isArray(a) && Array.isArray(b))
                    for (var f = 0; f < a.length; f++)
                        for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !1);
                else this.collideHandler(a, b, c, d, e, !1);
                return this._total > 0
            },
            sortLeftRight: function(a, b) { return a.body && b.body ? a.body.x - b.body.x : 0 },
            sortRightLeft: function(a, b) { return a.body && b.body ? b.body.x - a.body.x : 0 },
            sortTopBottom: function(a, b) { return a.body && b.body ? a.body.y - b.body.y : 0 },
            sortBottomTop: function(a, b) { return a.body && b.body ? b.body.y - a.body.y : 0 },
            sort: function(a, b) { null !== a.physicsSortDirection ? b = a.physicsSortDirection : void 0 === b && (b = this.sortDirection), b === c.Physics.Arcade.LEFT_RIGHT ? a.hash.sort(this.sortLeftRight) : b === c.Physics.Arcade.RIGHT_LEFT ? a.hash.sort(this.sortRightLeft) : b === c.Physics.Arcade.TOP_BOTTOM ? a.hash.sort(this.sortTopBottom) : b === c.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop) },
            collideHandler: function(a, b, d, e, f, g) { return void 0 === b && a.physicsType === c.GROUP ? (this.sort(a), void this.collideGroupVsSelf(a, d, e, f, g)) : void(a && b && a.exists && b.exists && (this.sortDirection !== c.Physics.Arcade.SORT_NONE && (a.physicsType === c.GROUP && this.sort(a), b.physicsType === c.GROUP && this.sort(b)), a.physicsType === c.SPRITE ? b.physicsType === c.SPRITE ? this.collideSpriteVsSprite(a, b, d, e, f, g) : b.physicsType === c.GROUP ? this.collideSpriteVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.GROUP ? b.physicsType === c.SPRITE ? this.collideSpriteVsGroup(b, a, d, e, f, g) : b.physicsType === c.GROUP ? this.collideGroupVsGroup(a, b, d, e, f, g) : b.physicsType === c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f, g) : a.physicsType === c.TILEMAPLAYER && (b.physicsType === c.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f, g) : b.physicsType === c.GROUP && this.collideGroupVsTilemapLayer(b, a, d, e, f, g)))) },
            collideSpriteVsSprite: function(a, b, c, d, e, f) { return !(!a.body || !b.body) && (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), this._total++), !0) },
            collideSpriteVsGroup: function(a, b, d, e, f, g) {
                if (0 !== b.length && a.body)
                    if (this.skipQuadTree || a.body.skipQuadTree)
                        for (var h = {}, i = 0; i < b.hash.length; i++) { var j = b.hash[i]; if (j && j.exists && j.body) { if (h = j.body.getBounds(h), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) { if (a.body.right < h.x) break; if (h.right < a.body.x) continue } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) { if (a.body.x > h.right) break; if (h.x > a.body.right) continue } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) { if (a.body.bottom < h.y) break; if (h.bottom < a.body.y) continue } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) { if (a.body.y > h.bottom) break; if (h.y > a.body.bottom) continue } this.collideSpriteVsSprite(a, j, d, e, f, g) } }
                else { this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(b); for (var k = this.quadTree.retrieve(a), i = 0; i < k.length; i++) this.separate(a.body, k[i], e, f, g) && (d && d.call(f, a, k[i].sprite), this._total++) }
            },
            collideGroupVsSelf: function(a, b, d, e, f) {
                if (0 !== a.length)
                    for (var g = 0; g < a.hash.length; g++) {
                        var h = {},
                            i = a.hash[g];
                        if (i && i.exists && i.body) {
                            h = i.body.getBounds(h);
                            for (var j = g + 1; j < a.hash.length; j++) {
                                var k = {},
                                    l = a.hash[j];
                                if (l && l.exists && l.body) { if (k = l.body.getBounds(k), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT) { if (h.right < k.x) break; if (k.right < h.x) continue } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) { if (h.x > k.right) continue; if (k.x > h.right) break } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) { if (h.bottom < k.y) continue; if (k.bottom < h.y) break } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) { if (h.y > k.bottom) continue; if (k.y > i.body.bottom) break } this.collideSpriteVsSprite(i, l, b, d, e, f) }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(a, b, d, e, f, g) {
                if (0 !== a.length && 0 !== b.length)
                    for (var h = 0; h < a.children.length; h++) a.children[h].exists && (a.children[h].physicsType === c.GROUP ? this.collideGroupVsGroup(a.children[h], b, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], b, d, e, f, g))
            },
            separate: function(a, b, c, d, e) {
                if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b)) return !1;
                if (c && c.call(d, a.sprite, b.sprite) === !1) return !1;
                if (a.isCircle && b.isCircle) return this.separateCircle(a, b, e);
                if (a.isCircle !== b.isCircle) {
                    var f = a.isCircle ? b : a,
                        g = a.isCircle ? a : b,
                        h = { x: f.x, y: f.y, right: f.right, bottom: f.bottom },
                        i = { x: g.x + g.radius, y: g.y + g.radius };
                    if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right)) return this.separateCircle(a, b, e)
                }
                var j = !1,
                    k = !1;
                this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? (j = this.separateX(a, b, e), this.intersects(a, b) && (k = this.separateY(a, b, e))) : (k = this.separateY(a, b, e), this.intersects(a, b) && (j = this.separateX(a, b, e)));
                var l = j || k;
                return l && (e ? (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)) : (a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite))), l
            },
            intersects: function(a, b) { return a !== b && (a.isCircle ? b.isCircle ? c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y) <= a.radius + b.radius : this.circleBodyIntersects(a, b) : b.isCircle ? this.circleBodyIntersects(b, a) : !(a.right <= b.position.x) && (!(a.bottom <= b.position.y) && (!(a.position.x >= b.right) && !(a.position.y >= b.bottom)))) },
            circleBodyIntersects: function(a, b) {
                var d = c.Math.clamp(a.center.x, b.left, b.right),
                    e = c.Math.clamp(a.center.y, b.top, b.bottom),
                    f = (a.center.x - d) * (a.center.x - d),
                    g = (a.center.y - e) * (a.center.y - e);
                return f + g <= a.radius * a.radius
            },
            separateCircle: function(a, b, d) {
                this.getOverlapX(a, b), this.getOverlapY(a, b);
                var e = b.center.x - a.center.x,
                    f = b.center.y - a.center.y,
                    g = Math.atan2(f, e),
                    h = 0;
                if (a.isCircle !== b.isCircle) {
                    var i = { x: b.isCircle ? a.position.x : b.position.x, y: b.isCircle ? a.position.y : b.position.y, right: b.isCircle ? a.right : b.right, bottom: b.isCircle ? a.bottom : b.bottom },
                        j = { x: a.isCircle ? a.position.x + a.radius : b.position.x + b.radius, y: a.isCircle ? a.position.y + a.radius : b.position.y + b.radius, radius: a.isCircle ? a.radius : b.radius };
                    j.y < i.y ? j.x < i.x ? h = c.Math.distance(j.x, j.y, i.x, i.y) - j.radius : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.y) - j.radius) : j.y > i.bottom && (j.x < i.x ? h = c.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius)), h *= -1
                }
                else h = a.radius + b.radius - c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y);
                if (d || 0 === h || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== h && (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)), 0 !== h;
                var k = { x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g), y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g) },
                    l = { x: b.velocity.x * Math.cos(g) + b.velocity.y * Math.sin(g), y: b.velocity.x * Math.sin(g) - b.velocity.y * Math.cos(g) },
                    m = ((a.mass - b.mass) * k.x + 2 * b.mass * l.x) / (a.mass + b.mass),
                    n = (2 * a.mass * k.x + (b.mass - a.mass) * l.x) / (a.mass + b.mass);
                return a.immovable || (a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x, a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y), b.immovable || (b.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * b.bounce.x, b.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * b.bounce.y), Math.abs(g) < Math.PI / 2 ? a.velocity.x > 0 && !a.immovable && b.velocity.x > a.velocity.x ? a.velocity.x *= -1 : b.velocity.x < 0 && !b.immovable && a.velocity.x < b.velocity.x ? b.velocity.x *= -1 : a.velocity.y > 0 && !a.immovable && b.velocity.y > a.velocity.y ? a.velocity.y *= -1 : b.velocity.y < 0 && !b.immovable && a.velocity.y < b.velocity.y && (b.velocity.y *= -1) : Math.abs(g) > Math.PI / 2 && (a.velocity.x < 0 && !a.immovable && b.velocity.x < a.velocity.x ? a.velocity.x *= -1 : b.velocity.x > 0 && !b.immovable && a.velocity.x > b.velocity.x ? b.velocity.x *= -1 : a.velocity.y < 0 && !a.immovable && b.velocity.y < a.velocity.y ? a.velocity.y *= -1 : b.velocity.y > 0 && !b.immovable && a.velocity.x > b.velocity.y && (b.velocity.y *= -1)), a.immovable || (a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g), a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g)), b.immovable || (b.x += b.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g), b.y += b.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g)), a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite), !0
            },
            getOverlapX: function(a, b, c) {
                var d = 0,
                    e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0, b.embedded = !0) : a.deltaX() > b.deltaX() ? (d = a.right - b.x, d > e && !c || a.checkCollision.right === !1 || b.checkCollision.left === !1 ? d = 0 : (a.touching.none = !1, a.touching.right = !0, b.touching.none = !1, b.touching.left = !0)) : a.deltaX() < b.deltaX() && (d = a.x - b.width - b.x, -d > e && !c || a.checkCollision.left === !1 || b.checkCollision.right === !1 ? d = 0 : (a.touching.none = !1, a.touching.left = !0, b.touching.none = !1, b.touching.right = !0)), a.overlapX = d, b.overlapX = d, d
            },
            getOverlapY: function(a, b, c) {
                var d = 0,
                    e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0, b.embedded = !0) : a.deltaY() > b.deltaY() ? (d = a.bottom - b.y, d > e && !c || a.checkCollision.down === !1 || b.checkCollision.up === !1 ? d = 0 : (a.touching.none = !1, a.touching.down = !0, b.touching.none = !1, b.touching.up = !0)) : a.deltaY() < b.deltaY() && (d = a.y - b.bottom, -d > e && !c || a.checkCollision.up === !1 || b.checkCollision.down === !1 ? d = 0 : (a.touching.none = !1, a.touching.up = !0, b.touching.none = !1, b.touching.down = !0)), a.overlapY = d, b.overlapY = d, d
            },
            separateX: function(a, b, c) {
                var d = this.getOverlapX(a, b, c);
                if (c || 0 === d || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) return 0 !== d || a.embedded && b.embedded;
                var e = a.velocity.x,
                    f = b.velocity.x;
                if (a.immovable || b.immovable) a.immovable ? (b.x += d, b.velocity.x = e - f * b.bounce.x, a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : (a.x -= d, a.velocity.x = f - e * a.bounce.x, b.moves && (a.y += (b.y - b.prev.y) * b.friction.y));
                else {
                    d *= .5, a.x -= d, b.x += d;
                    var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1),
                        h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1),
                        i = .5 * (g + h);
                    g -= i, h -= i, a.velocity.x = i + g * a.bounce.x, b.velocity.x = i + h * b.bounce.x
                }
                return !0
            },
            separateY: function(a, b, c) {
                var d = this.getOverlapY(a, b, c);
                if (c || 0 === d || a.immovable && b.immovable || a.customSeparateY || b.customSeparateY) return 0 !== d || a.embedded && b.embedded;
                var e = a.velocity.y,
                    f = b.velocity.y;
                if (a.immovable || b.immovable) a.immovable ? (b.y += d, b.velocity.y = e - f * b.bounce.y, a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : (a.y -= d, a.velocity.y = f - e * a.bounce.y, b.moves && (a.x += (b.x - b.prev.x) * b.friction.x));
                else {
                    d *= .5, a.y -= d, b.y += d;
                    var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1),
                        h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1),
                        i = .5 * (g + h);
                    g -= i, h -= i, a.velocity.y = i + g * a.bounce.y, b.velocity.y = i + h * b.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(a, b, c, d) { if (0 !== b.length && a.exists) return this.getObjectsAtLocation(a.x, a.y, b, c, d, a) },
            getObjectsAtLocation: function(a, b, d, e, f, g) { this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(d); for (var h = new c.Rectangle(a, b, 1, 1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++) j[k].hitTest(a, b) && (e && e.call(f, g, j[k].sprite), i.push(j[k].sprite)); return i },
            moveToObject: function(a, b, c, d) { void 0 === c && (c = 60), void 0 === d && (d = 0); var e = Math.atan2(b.y - a.y, b.x - a.x); return d > 0 && (c = this.distanceBetween(a, b) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * c, a.body.velocity.y = Math.sin(e) * c, e },
            moveToPointer: function(a, b, c, d) { void 0 === b && (b = 60), c = c || this.game.input.activePointer, void 0 === d && (d = 0); var e = this.angleToPointer(a, c); return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1e3)), a.body.velocity.x = Math.cos(e) * b, a.body.velocity.y = Math.sin(e) * b, e },
            moveToXY: function(a, b, c, d, e) { void 0 === d && (d = 60), void 0 === e && (e = 0); var f = Math.atan2(c - a.y, b - a.x); return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1e3)), a.body.velocity.x = Math.cos(f) * d, a.body.velocity.y = Math.sin(f) * d, f },
            velocityFromAngle: function(a, b, d) { return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b) },
            velocityFromRotation: function(a, b, d) { return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(a) * b, Math.sin(a) * b) },
            accelerationFromRotation: function(a, b, d) { return void 0 === b && (b = 60), d = d || new c.Point, d.setTo(Math.cos(a) * b, Math.sin(a) * b) },
            accelerateToObject: function(a, b, c, d, e) { void 0 === c && (c = 60), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3); var f = this.angleBetween(a, b); return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f },
            accelerateToPointer: function(a, b, c, d, e) { void 0 === c && (c = 60), void 0 === b && (b = this.game.input.activePointer), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3); var f = this.angleToPointer(a, b); return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f },
            accelerateToXY: function(a, b, c, d, e, f) { void 0 === d && (d = 60), void 0 === e && (e = 1e3), void 0 === f && (f = 1e3); var g = this.angleToXY(a, b, c); return a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d), a.body.maxVelocity.setTo(e, f), g },
            distanceBetween: function(a, b, c) {
                void 0 === c && (c = !1);
                var d = c ? a.world.x - b.world.x : a.x - b.x,
                    e = c ? a.world.y - b.world.y : a.y - b.y;
                return Math.sqrt(d * d + e * e)
            },
            distanceToXY: function(a, b, c, d) {
                void 0 === d && (d = !1);
                var e = d ? a.world.x - b : a.x - b,
                    f = d ? a.world.y - c : a.y - c;
                return Math.sqrt(e * e + f * f)
            },
            distanceToPointer: function(a, b, c) {
                void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1);
                var d = c ? a.world.x - b.worldX : a.x - b.worldX,
                    e = c ? a.world.y - b.worldY : a.y - b.worldY;
                return Math.sqrt(d * d + e * e)
            },
            angleBetween: function(a, b, c) { return void 0 === c && (c = !1), c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x) },
            angleBetweenCenters: function(a, b) {
                var c = b.centerX - a.centerX,
                    d = b.centerY - a.centerY;
                return Math.atan2(d, c)
            },
            angleToXY: function(a, b, c, d) { return void 0 === d && (d = !1), d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x) },
            angleToPointer: function(a, b, c) { return void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1), c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x) },
            worldAngleToPointer: function(a, b) { return this.angleToPointer(a, b, !0) }
        }, c.Physics.Arcade.Body = function(a) { this.sprite = a, this.game = a.game, this.type = c.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new c.Point, this.position = new c.Point(a.x, a.y), this.prev = new c.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = a.angle, this.preRotation = a.angle, this.width = a.width, this.height = a.height, this.sourceWidth = a.width, this.sourceHeight = a.height, a.texture && (this.sourceWidth = a.texture.frame.width, this.sourceHeight = a.texture.frame.height), this.halfWidth = Math.abs(a.width / 2), this.halfHeight = Math.abs(a.height / 2), this.center = new c.Point(a.x + this.halfWidth, a.y + this.halfHeight), this.velocity = new c.Point, this.newVelocity = new c.Point, this.deltaMax = new c.Point, this.acceleration = new c.Point, this.drag = new c.Point, this.allowGravity = !0, this.gravity = new c.Point, this.bounce = new c.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new c.Point(1e4, 1e4), this.friction = new c.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = c.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = { none: !1, any: !0, up: !0, down: !0, left: !0, right: !0 }, this.touching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.wasTouching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.blocked = { up: !1, down: !1, left: !1, right: !1 }, this.tilePadding = new c.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new c.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = a.scale.x, this._sy = a.scale.y, this._dx = 0, this._dy = 0 }, c.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var a = this.sprite.getBounds();
                    a.ceilAll(), a.width === this.width && a.height === this.height || (this.width = a.width, this.height = a.height, this._reset = !0)
                }
                else {
                    var b = Math.abs(this.sprite.scale.x),
                        c = Math.abs(this.sprite.scale.y);
                    b === this._sx && c === this._sy || (this.width = this.sourceWidth * b, this.height = this.sourceHeight * c, this._sx = b, this._sy = c, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1,
                    this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var a = 0,
                    b = 0 !== this.overlapX || 0 !== this.overlapY;
                if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, a = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), a = this.moveTarget.length / this.moveDistance), this.movementCallback) var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
                return !(b || a >= 1 || void 0 !== c && c !== !0) || (this.stopMovement(a >= 1 || this.stopVelocityOnCollide && b), !1)
            },
            stopMovement: function(a) { this.isMoving && (this.isMoving = !1, a && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY)) },
            postUpdate: function() { this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = c.LEFT : this.deltaX() > 0 && (this.facing = c.RIGHT), this.deltaY() < 0 ? this.facing = c.UP : this.deltaY() > 0 && (this.facing = c.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y) },
            checkWorldBounds: function() {
                var a = this.position,
                    b = this.game.physics.arcade.bounds,
                    c = this.game.physics.arcade.checkCollision,
                    d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var f = { x: this.center.x - this.radius, y: this.center.y - this.radius, right: this.center.x + this.radius, bottom: this.center.y + this.radius };
                    f.x < b.x && c.left ? (a.x = b.x - this.halfWidth + this.radius, this.velocity.x *= d, this.blocked.left = !0) : f.right > b.right && c.right && (a.x = b.right - this.halfWidth - this.radius, this.velocity.x *= d, this.blocked.right = !0), f.y < b.y && c.up ? (a.y = b.y - this.halfHeight + this.radius, this.velocity.y *= e, this.blocked.up = !0) : f.bottom > b.bottom && c.down && (a.y = b.bottom - this.halfHeight - this.radius, this.velocity.y *= e, this.blocked.down = !0)
                }
                else a.x < b.x && c.left ? (a.x = b.x, this.velocity.x *= d, this.blocked.left = !0) : this.right > b.right && c.right && (a.x = b.right - this.width, this.velocity.x *= d, this.blocked.right = !0), a.y < b.y && c.up ? (a.y = b.y, this.velocity.y *= e, this.blocked.up = !0) : this.bottom > b.bottom && c.down && (a.y = b.bottom - this.height, this.velocity.y *= e, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(a, b, c) { if (void 0 === b && (b = this.speed), 0 === b) return !1; var d; return void 0 === c ? (d = this.angle, c = this.game.math.radToDeg(d)) : d = this.game.math.degToRad(c), this.moveTimer = 0, this.moveDuration = a, 0 === c || 180 === c ? this.velocity.set(Math.cos(d) * b, 0) : 90 === c || 270 === c ? this.velocity.set(0, Math.sin(d) * b) : this.velocity.set(Math.cos(d) * b, Math.sin(d) * b), this.isMoving = !0, !0 },
            moveTo: function(a, b, d) { var e = b / (a / 1e3); if (0 === e) return !1; var f; return void 0 === d ? (f = this.angle, d = this.game.math.radToDeg(f)) : f = this.game.math.degToRad(d), b = Math.abs(b), this.moveDuration = 0, this.moveDistance = b, null === this.moveTarget && (this.moveTarget = new c.Line, this.moveEnd = new c.Point), this.moveTarget.fromAngle(this.x, this.y, f, b), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === d || 180 === d ? this.velocity.set(Math.cos(f) * e, 0) : 90 === d || 270 === d ? this.velocity.set(0, Math.sin(f) * e) : this.velocity.set(Math.cos(f) * e, Math.sin(f) * e), this.isMoving = !0, !0 },
            setSize: function(a, b, c, d) { void 0 === c && (c = this.offset.x), void 0 === d && (d = this.offset.y), this.sourceWidth = a, this.sourceHeight = b, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(c, d), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0 },
            setCircle: function(a, b, c) { void 0 === b && (b = this.offset.x), void 0 === c && (c = this.offset.y), a > 0 ? (this.isCircle = !0, this.radius = a, this.sourceWidth = 2 * a, this.sourceHeight = 2 * a, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(b, c), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1 },
            reset: function(a, b) { this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight) },
            getBounds: function(a) { return this.isCircle ? (a.x = this.center.x - this.radius, a.y = this.center.y - this.radius, a.right = this.center.x + this.radius, a.bottom = this.center.y + this.radius) : (a.x = this.x, a.y = this.y, a.right = this.right, a.bottom = this.bottom), a },
            hitTest: function(a, b) { return this.isCircle ? c.Circle.contains(this, a, b) : c.Rectangle.contains(this, a, b) },
            onFloor: function() { return this.blocked.down },
            onCeiling: function() { return this.blocked.up },
            onWall: function() { return this.blocked.left || this.blocked.right },
            deltaAbsX: function() { return this.deltaX() > 0 ? this.deltaX() : -this.deltaX() },
            deltaAbsY: function() { return this.deltaY() > 0 ? this.deltaY() : -this.deltaY() },
            deltaX: function() { return this.position.x - this.prev.x },
            deltaY: function() { return this.position.y - this.prev.y },
            deltaZ: function() { return this.rotation - this.preRotation },
            destroy: function() { this.sprite.parent && this.sprite.parent instanceof c.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null }
        }, Object.defineProperty(c.Physics.Arcade.Body.prototype, "left", { get: function() { return this.position.x } }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "right", { get: function() { return this.position.x + this.width } }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "top", { get: function() { return this.position.y } }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", { get: function() { return this.position.y + this.height } }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "x", { get: function() { return this.position.x }, set: function(a) { this.position.x = a } }), Object.defineProperty(c.Physics.Arcade.Body.prototype, "y", { get: function() { return this.position.y }, set: function(a) { this.position.y = a } }), c.Physics.Arcade.Body.render = function(a, b, c, d) { void 0 === d && (d = !0), c = c || "rgba(0,255,0,0.4)", a.fillStyle = c, a.strokeStyle = c, b.isCircle ? (a.beginPath(), a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.radius, 0, 2 * Math.PI), d ? a.fill() : a.stroke()) : d ? a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height) : a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height) }, c.Physics.Arcade.Body.renderBodyInfo = function(a, b) { a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height), a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)), a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)), a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)), a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down), a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down) }, c.Physics.Arcade.Body.prototype.constructor = c.Physics.Arcade.Body, c.Physics.Arcade.TilemapCollision = function() {}, c.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(a, b, c, d, e, f) {
                if (a.body) {
                    var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
                    if (0 !== g.length)
                        for (var h = 0; h < g.length; h++) d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h]))
                }
            },
            collideGroupVsTilemapLayer: function(a, b, c, d, e, f) {
                if (0 !== a.length)
                    for (var g = 0; g < a.children.length; g++) a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f)
            },
            separateTile: function(a, b, c, d, e) {
                if (!b.enable) return !1;
                var f = d.fixedToCamera ? 0 : d.position.x,
                    g = d.fixedToCamera ? 0 : d.position.y;
                if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !1;
                if (e) return !0;
                if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) return !1;
                if ("undefined" != typeof c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) return !1;
                if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) return !1;
                var h = 0,
                    i = 0,
                    j = 0,
                    k = 1;
                if (b.deltaAbsX() > b.deltaAbsY() ? j = -1 : b.deltaAbsX() < b.deltaAbsY() && (k = -1), 0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom) && (j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left)), k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top))), j < k) {
                    if ((c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d), 0 !== h && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
                    (c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d))
                }
                else {
                    if ((c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d), 0 !== i && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
                    (c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d))
                }
                return 0 !== h || 0 !== i
            },
            tileCheckX: function(a, b, c) {
                var d = 0,
                    e = c.fixedToCamera ? 0 : c.position.x;
                return a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left ? b.faceRight && a.x - e < b.right && (d = a.x - e - b.right, d < -this.TILE_BIAS && (d = 0)) : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && (d = a.right - e - b.left, d > this.TILE_BIAS && (d = 0)), 0 !== d && (a.customSeparateX ? a.overlapX = d : this.processTileSeparationX(a, d)), d
            },
            tileCheckY: function(a, b, c) {
                var d = 0,
                    e = c.fixedToCamera ? 0 : c.position.y;
                return a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up ? b.faceBottom && a.y - e < b.bottom && (d = a.y - e - b.bottom, d < -this.TILE_BIAS && (d = 0)) : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && (d = a.bottom - e - b.top, d > this.TILE_BIAS && (d = 0)), 0 !== d && (a.customSeparateY ? a.overlapY = d : this.processTileSeparationY(a, d)), d
            },
            processTileSeparationX: function(a, b) { b < 0 ? a.blocked.left = !0 : b > 0 && (a.blocked.right = !0), a.position.x -= b, 0 === a.bounce.x ? a.velocity.x = 0 : a.velocity.x = -a.velocity.x * a.bounce.x },
            processTileSeparationY: function(a, b) { b < 0 ? a.blocked.up = !0 : b > 0 && (a.blocked.down = !0), a.position.y -= b, 0 === a.bounce.y ? a.velocity.y = 0 : a.velocity.y = -a.velocity.y * a.bounce.y }
        }, c.Utils.mixinPrototype(c.Physics.Arcade.prototype, c.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, c.Physics.P2 = function(a, b) { this.game = a, void 0 === b ? b = { gravity: [0, 0], broadphase: new p2.SAPBroadphase } : (b.hasOwnProperty("gravity") || (b.gravity = [0, 0]), b.hasOwnProperty("broadphase") || (b.broadphase = new p2.SAPBroadphase)), this.config = b, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new c.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = { left: null, right: null, top: null, bottom: null }, this.onBodyAdded = new c.Signal, this.onBodyRemoved = new c.Signal, this.onSpringAdded = new c.Signal, this.onSpringRemoved = new c.Signal, this.onConstraintAdded = new c.Signal, this.onConstraintRemoved = new c.Signal, this.onContactMaterialAdded = new c.Signal, this.onContactMaterialRemoved = new c.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new c.Signal, this.onEndContact = new c.Signal, b.hasOwnProperty("mpx") && b.hasOwnProperty("pxm") && b.hasOwnProperty("mpxi") && b.hasOwnProperty("pxmi") && (this.mpx = b.mpx, this.mpxi = b.mpxi, this.pxm = b.pxm, this.pxmi = b.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1) }, c.Physics.P2.prototype = {
            removeBodyNextStep: function(a) { this._toRemove.push(a) },
            preUpdate: function() {
                for (var a = this._toRemove.length; a--;) this.removeBody(this._toRemove[a]);
                this._toRemove.length = 0
            },
            enable: function(a, b, d) {
                void 0 === b && (b = !1), void 0 === d && (d = !0);
                var e = 1;
                if (Array.isArray(a))
                    for (e = a.length; e--;) a[e] instanceof c.Group ? this.enable(a[e].children, b, d) : (this.enableBody(a[e], b), d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], b, !0));
                else a instanceof c.Group ? this.enable(a.children, b, d) : (this.enableBody(a, b), d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, b, !0))
            },
            enableBody: function(a, b) { a.hasOwnProperty("body") && null === a.body && (a.body = new c.Physics.P2.Body(this.game, a, a.x, a.y, 1), a.body.debug = b, "undefined" != typeof a.anchor && a.anchor.set(.5)) },
            setImpactEvents: function(a) { a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this) },
            setPostBroadphaseCallback: function(a, b) { this.postBroadphaseCallback = a, this.callbackContext = b, null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this) },
            postBroadphaseHandler: function(a) {
                if (this.postBroadphaseCallback && 0 !== a.pairs.length)
                    for (var b = a.pairs.length - 2; b >= 0; b -= 2) a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2)
            },
            impactHandler: function(a) {
                if (a.bodyA.parent && a.bodyB.parent) {
                    var b = a.bodyA.parent,
                        c = a.bodyB.parent;
                    b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB), c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA), b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB), c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA)
                }
            },
            beginContactHandler: function(a) { a.bodyA && a.bodyB && (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations), a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations)) },
            endContactHandler: function(a) { a.bodyA && a.bodyB && (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB), a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB), a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA)) },
            setBoundsToWorld: function(a, b, c, d, e) { this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e) },
            setWorldMaterial: function(a, b, c, d, e) { void 0 === b && (b = !0), void 0 === c && (c = !0), void 0 === d && (d = !0), void 0 === e && (e = !0), b && this.walls.left && (this.walls.left.shapes[0].material = a), c && this.walls.right && (this.walls.right.shapes[0].material = a), d && this.walls.top && (this.walls.top.shapes[0].material = a), e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a) },
            updateBoundsCollisionGroup: function(a) {
                void 0 === a && (a = !0);
                var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = b), this.walls.right && (this.walls.right.shapes[0].collisionGroup = b), this.walls.top && (this.walls.top.shapes[0].collisionGroup = b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b), this._boundsOwnGroup = a
            },
            setBounds: function(a, b, c, d, e, f, g, h, i) { void 0 === e && (e = this._boundsLeft), void 0 === f && (f = this._boundsRight), void 0 === g && (g = this._boundsTop), void 0 === h && (h = this._boundsBottom), void 0 === i && (i = this._boundsOwnGroup), this.setupWall(e, "left", a, b, 1.5707963267948966, i), this.setupWall(f, "right", a + c, b, -1.5707963267948966, i), this.setupWall(g, "top", a, b, -3.141592653589793, i), this.setupWall(h, "bottom", a, b + d, 0, i), this._boundsLeft = e, this._boundsRight = f, this._boundsTop = g, this._boundsBottom = h, this._boundsOwnGroup = i },
            setupWall: function(a, b, c, d, e, f) { a ? (this.walls[b] ? this.walls[b].position = [this.pxmi(c), this.pxmi(d)] : (this.walls[b] = new p2.Body({ mass: 0, position: [this.pxmi(c), this.pxmi(d)], angle: e }), this.walls[b].addShape(new p2.Plane), this.world.addBody(this.walls[b])), f && (this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[b] && (this.world.removeBody(this.walls[b]), this.walls[b] = null) },
            pause: function() { this.paused = !0 },
            resume: function() { this.paused = !1 },
            update: function() { this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate)) },
            reset: function() { this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1) },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var a = this.world.constraints, b = a.length - 1; b >= 0; b--) this.world.removeConstraint(a[b]);
                for (var c = this.world.bodies, b = c.length - 1; b >= 0; b--) this.world.removeBody(c[b]);
                for (var d = this.world.springs, b = d.length - 1; b >= 0; b--) this.world.removeSpring(d[b]);
                for (var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--) this.world.removeContactMaterial(e[b]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = { left: null, right: null, top: null, bottom: null }
            },
            destroy: function() { this.clear(), this.game = null },
            addBody: function(a) { return !a.data.world && (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), !0) },
            removeBody: function(a) { return a.data.world === this.world && (this.world.removeBody(a.data), this.onBodyRemoved.dispatch(a)), a },
            addSpring: function(a) { return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.addSpring(a.data) : this.world.addSpring(a), this.onSpringAdded.dispatch(a), a },
            removeSpring: function(a) { return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.removeSpring(a.data) : this.world.removeSpring(a), this.onSpringRemoved.dispatch(a), a },
            createDistanceConstraint: function(a, b, d, e, f, g) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c.Physics.P2.DistanceConstraint(this, a, b, d, e, f, g)) },
            createGearConstraint: function(a, b, d, e) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c.Physics.P2.GearConstraint(this, a, b, d, e)) },
            createRevoluteConstraint: function(a, b, d, e, f, g) { if (a = this.getBody(a), d = this.getBody(d), a && d) return this.addConstraint(new c.Physics.P2.RevoluteConstraint(this, a, b, d, e, f, g)) },
            createLockConstraint: function(a, b, d, e, f) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c.Physics.P2.LockConstraint(this, a, b, d, e, f)) },
            createPrismaticConstraint: function(a, b, d, e, f, g, h) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addConstraint(new c.Physics.P2.PrismaticConstraint(this, a, b, d, e, f, g, h)) },
            addConstraint: function(a) { return this.world.addConstraint(a), this.onConstraintAdded.dispatch(a), a },
            removeConstraint: function(a) { return this.world.removeConstraint(a), this.onConstraintRemoved.dispatch(a), a },
            addContactMaterial: function(a) { return this.world.addContactMaterial(a), this.onContactMaterialAdded.dispatch(a), a },
            removeContactMaterial: function(a) { return this.world.removeContactMaterial(a), this.onContactMaterialRemoved.dispatch(a), a },
            getContactMaterial: function(a, b) { return this.world.getContactMaterial(a, b) },
            setMaterial: function(a, b) { for (var c = b.length; c--;) b[c].setMaterial(a) },
            createMaterial: function(a, b) { a = a || ""; var d = new c.Physics.P2.Material(a); return this.materials.push(d), "undefined" != typeof b && b.setMaterial(d), d },
            createContactMaterial: function(a, b, d) { void 0 === a && (a = this.createMaterial()), void 0 === b && (b = this.createMaterial()); var e = new c.Physics.P2.ContactMaterial(a, b, d); return this.addContactMaterial(e) },
            getBodies: function() { for (var a = [], b = this.world.bodies.length; b--;) a.push(this.world.bodies[b].parent); return a },
            getBody: function(a) { return a instanceof p2.Body ? a : a instanceof c.Physics.P2.Body ? a.data : a.body && a.body.type === c.Physics.P2JS ? a.body.data : null },
            getSprings: function() { for (var a = [], b = this.world.springs.length; b--;) a.push(this.world.springs[b].parent); return a },
            getConstraints: function() { for (var a = [], b = this.world.constraints.length; b--;) a.push(this.world.constraints[b]); return a },
            hitTest: function(a, b, d, e) { void 0 === b && (b = this.world.bodies), void 0 === d && (d = 5), void 0 === e && (e = !1); for (var f = [this.pxmi(a.x), this.pxmi(a.y)], g = [], h = b.length; h--;) b[h] instanceof c.Physics.P2.Body && (!e || b[h].data.type !== p2.Body.STATIC) ? g.push(b[h].data) : b[h] instanceof p2.Body && b[h].parent && (!e || b[h].type !== p2.Body.STATIC) ? g.push(b[h]) : b[h] instanceof c.Sprite && b[h].hasOwnProperty("body") && (!e || b[h].body.data.type !== p2.Body.STATIC) && g.push(b[h].body.data); return this.world.hitTest(f, g, d) },
            toJSON: function() { return this.world.toJSON() },
            createCollisionGroup: function(a) {
                var b = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | b), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | b), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | b), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | b), this._collisionGroupID++;
                var d = new c.Physics.P2.CollisionGroup(b);
                return this.collisionGroups.push(d), a && this.setCollisionGroup(a, d), d
            },
            setCollisionGroup: function(a, b) {
                if (a instanceof c.Group)
                    for (var d = 0; d < a.total; d++) a.children[d].body && a.children[d].body.type === c.Physics.P2JS && a.children[d].body.setCollisionGroup(b);
                else a.body.setCollisionGroup(b)
            },
            createSpring: function(a, b, d, e, f, g, h, i, j) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addSpring(new c.Physics.P2.Spring(this, a, b, d, e, f, g, h, i, j)) },
            createRotationalSpring: function(a, b, d, e, f) { if (a = this.getBody(a), b = this.getBody(b), a && b) return this.addSpring(new c.Physics.P2.RotationalSpring(this, a, b, d, e, f)) },
            createBody: function(a, b, d, e, f, g) { void 0 === e && (e = !1); var h = new c.Physics.P2.Body(this.game, null, a, b, d); if (g) { var i = h.addPolygon(f, g); if (!i) return !1 } return e && this.world.addBody(h.data), h },
            createParticle: function(a, b, d, e, f, g) { void 0 === e && (e = !1); var h = new c.Physics.P2.Body(this.game, null, a, b, d); if (g) { var i = h.addPolygon(f, g); if (!i) return !1 } return e && this.world.addBody(h.data), h },
            convertCollisionObjects: function(a, b, c) {
                void 0 === c && (c = !0);
                for (var d = [], e = 0, f = a.collision[b].length; e < f; e++) {
                    var g = a.collision[b][e],
                        h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
                    h && d.push(h)
                }
                return d
            },
            clearTilemapLayerBodies: function(a, b) {
                b = a.getLayer(b);
                for (var c = a.layers[b].bodies.length; c--;) a.layers[b].bodies[c].destroy();
                a.layers[b].bodies.length = 0
            },
            convertTilemap: function(a, b, c, d) {
                b = a.getLayer(b), void 0 === c && (c = !0), void 0 === d && (d = !0), this.clearTilemapLayerBodies(a, b);
                for (var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; h < i; h++) {
                    e = 0;
                    for (var j = 0, k = a.layers[b].width; j < k; j++) {
                        var l = a.layers[b].data[h][j];
                        if (l && l.index > -1 && l.collides)
                            if (d) {
                                var m = a.getTileRight(b, j, h);
                                if (0 === e && (f = l.x * l.width, g = l.y * l.height, e = l.width), m && m.collides) e += l.width;
                                else {
                                    var n = this.createBody(f, g, 0, !1);
                                    n.addRectangle(e, l.height, e / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n), e = 0
                                }
                            }
                        else {
                            var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                            n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n)
                        }
                    }
                }
                return a.layers[b].bodies
            },
            mpx: function(a) { return a *= 20 },
            pxm: function(a) { return .05 * a },
            mpxi: function(a) { return a *= -20 },
            pxmi: function(a) { return a * -.05 }
        }, Object.defineProperty(c.Physics.P2.prototype, "friction", { get: function() { return this.world.defaultContactMaterial.friction }, set: function(a) { this.world.defaultContactMaterial.friction = a } }), Object.defineProperty(c.Physics.P2.prototype, "restitution", { get: function() { return this.world.defaultContactMaterial.restitution }, set: function(a) { this.world.defaultContactMaterial.restitution = a } }), Object.defineProperty(c.Physics.P2.prototype, "contactMaterial", { get: function() { return this.world.defaultContactMaterial }, set: function(a) { this.world.defaultContactMaterial = a } }), Object.defineProperty(c.Physics.P2.prototype, "applySpringForces", { get: function() { return this.world.applySpringForces }, set: function(a) { this.world.applySpringForces = a } }), Object.defineProperty(c.Physics.P2.prototype, "applyDamping", { get: function() { return this.world.applyDamping }, set: function(a) { this.world.applyDamping = a } }), Object.defineProperty(c.Physics.P2.prototype, "applyGravity", { get: function() { return this.world.applyGravity }, set: function(a) { this.world.applyGravity = a } }), Object.defineProperty(c.Physics.P2.prototype, "solveConstraints", { get: function() { return this.world.solveConstraints }, set: function(a) { this.world.solveConstraints = a } }), Object.defineProperty(c.Physics.P2.prototype, "time", { get: function() { return this.world.time } }), Object.defineProperty(c.Physics.P2.prototype, "emitImpactEvent", { get: function() { return this.world.emitImpactEvent }, set: function(a) { this.world.emitImpactEvent = a } }), Object.defineProperty(c.Physics.P2.prototype, "sleepMode", { get: function() { return this.world.sleepMode }, set: function(a) { this.world.sleepMode = a } }), Object.defineProperty(c.Physics.P2.prototype, "total", { get: function() { return this.world.bodies.length } }), c.Physics.P2.FixtureList = function(a) { Array.isArray(a) || (a = [a]), this.rawList = a, this.init(), this.parse(this.rawList) }, c.Physics.P2.FixtureList.prototype = {
            init: function() { this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = [] },
            setCategory: function(a, b) {
                var c = function(b) { b.collisionGroup = a };
                this.getFixtures(b).forEach(c)
            },
            setMask: function(a, b) {
                var c = function(b) { b.collisionMask = a };
                this.getFixtures(b).forEach(c)
            },
            setSensor: function(a, b) {
                var c = function(b) { b.sensor = a };
                this.getFixtures(b).forEach(c)
            },
            setMaterial: function(a, b) {
                var c = function(b) { b.material = a };
                this.getFixtures(b).forEach(c)
            },
            getFixtures: function(a) { var b = []; if (a) { a instanceof Array || (a = [a]); var c = this; return a.forEach(function(a) { c.namedFixtures[a] && b.push(c.namedFixtures[a]) }), this.flatten(b) } return this.allFixtures },
            getFixtureByKey: function(a) { return this.namedFixtures[a] },
            getGroup: function(a) { return this.groupedFixtures[a] },
            parse: function() {
                var a, b, c, d;
                c = this.rawList, d = [];
                for (a in c) b = c[a], isNaN(a - 0) ? this.namedFixtures[a] = this.flatten(b) : (this.groupedFixtures[a] = this.groupedFixtures[a] || [], this.groupedFixtures[a] = this.groupedFixtures[a].concat(b)), d.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(a) { var b, c; return b = [], c = arguments.callee, a.forEach(function(a) { return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [a]) }), b }
        }, c.Physics.P2.PointProxy = function(a, b) { this.world = a, this.destination = b }, c.Physics.P2.PointProxy.prototype.constructor = c.Physics.P2.PointProxy, Object.defineProperty(c.Physics.P2.PointProxy.prototype, "x", { get: function() { return this.world.mpx(this.destination[0]) }, set: function(a) { this.destination[0] = this.world.pxm(a) } }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "y", { get: function() { return this.world.mpx(this.destination[1]) }, set: function(a) { this.destination[1] = this.world.pxm(a) } }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "mx", { get: function() { return this.destination[0] }, set: function(a) { this.destination[0] = a } }), Object.defineProperty(c.Physics.P2.PointProxy.prototype, "my", { get: function() { return this.destination[1] }, set: function(a) { this.destination[1] = a } }), c.Physics.P2.InversePointProxy = function(a, b) { this.world = a, this.destination = b }, c.Physics.P2.InversePointProxy.prototype.constructor = c.Physics.P2.InversePointProxy, Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "x", { get: function() { return this.world.mpxi(this.destination[0]) }, set: function(a) { this.destination[0] = this.world.pxmi(a) } }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "y", { get: function() { return this.world.mpxi(this.destination[1]) }, set: function(a) { this.destination[1] = this.world.pxmi(a) } }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "mx", { get: function() { return this.destination[0] }, set: function(a) { this.destination[0] = -a } }), Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "my", { get: function() { return this.destination[1] }, set: function(a) { this.destination[1] = -a } }), c.Physics.P2.Body = function(a, b, d, e, f) {
            b = b || null, d = d || 0, e = e || 0, void 0 === f && (f = 1), this.game = a, this.world = a.physics.p2, this.sprite = b, this.type = c.Physics.P2JS, this.offset = new c.Point, this.data = new p2.Body({ position: [this.world.pxmi(d), this.world.pxmi(e)], mass: f }), this.data.parent = this, this.velocity = new c.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new c.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new c.Point, this.onBeginContact = new c.Signal, this.onEndContact = new c.Signal, this.collidesWith = [], this.removeNextStep = !1,
                this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, b && (this.setRectangleFromSprite(b), b.exists && this.game.physics.p2.addBody(this))
        }, c.Physics.P2.Body.prototype = {
            createBodyCallback: function(a, b, c) {
                var d = -1;
                a.id ? d = a.id : a.body && (d = a.body.id), d > -1 && (null === b ? (delete this._bodyCallbacks[d], delete this._bodyCallbackContext[d]) : (this._bodyCallbacks[d] = b, this._bodyCallbackContext[d] = c))
            },
            createGroupCallback: function(a, b, c) { null === b ? (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]) : (this._groupCallbacks[a.mask] = b, this._groupCallbackContext[a.mask] = c) },
            getCollisionMask: function() {
                var a = 0;
                this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var b = 0; b < this.collidesWith.length; b++) a |= this.collidesWith[b].mask;
                return a
            },
            updateCollisionMask: function(a) {
                var b = this.getCollisionMask();
                if (void 0 === a)
                    for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].collisionMask = b;
                else a.collisionMask = b
            },
            setCollisionGroup: function(a, b) {
                var c = this.getCollisionMask();
                if (void 0 === b)
                    for (var d = this.data.shapes.length - 1; d >= 0; d--) this.data.shapes[d].collisionGroup = a.mask, this.data.shapes[d].collisionMask = c;
                else b.collisionGroup = a.mask, b.collisionMask = c
            },
            clearCollision: function(a, b, c) {
                if (void 0 === a && (a = !0), void 0 === b && (b = !0), void 0 === c)
                    for (var d = this.data.shapes.length - 1; d >= 0; d--) a && (this.data.shapes[d].collisionGroup = null), b && (this.data.shapes[d].collisionMask = null);
                else a && (c.collisionGroup = null), b && (c.collisionMask = null);
                a && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(a, b, c) {
                void 0 === b && (b = !0);
                var d;
                if (Array.isArray(a))
                    for (var e = 0; e < a.length; e++) d = this.collidesWith.indexOf(a[e]), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
                else d = this.collidesWith.indexOf(a), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
                var f = this.getCollisionMask();
                if (void 0 === c)
                    for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
                else c.collisionMask = f
            },
            collides: function(a, b, c, d) {
                if (Array.isArray(a))
                    for (var e = 0; e < a.length; e++) this.collidesWith.indexOf(a[e]) === -1 && (this.collidesWith.push(a[e]), b && this.createGroupCallback(a[e], b, c));
                else this.collidesWith.indexOf(a) === -1 && (this.collidesWith.push(a), b && this.createGroupCallback(a, b, c));
                var f = this.getCollisionMask();
                if (void 0 === d)
                    for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
                else d.collisionMask = f
            },
            adjustCenterOfMass: function() { this.data.adjustCenterOfMass(), this.shapeChanged() },
            getVelocityAtPoint: function(a, b) { return this.data.getVelocityAtPoint(a, b) },
            applyDamping: function(a) { this.data.applyDamping(a) },
            applyImpulse: function(a, b, c) { this.data.applyImpulse(a, [this.world.pxmi(b), this.world.pxmi(c)]) },
            applyImpulseLocal: function(a, b, c) { this.data.applyImpulseLocal(a, [this.world.pxmi(b), this.world.pxmi(c)]) },
            applyForce: function(a, b, c) { this.data.applyForce(a, [this.world.pxmi(b), this.world.pxmi(c)]) },
            setZeroForce: function() { this.data.setZeroForce() },
            setZeroRotation: function() { this.data.angularVelocity = 0 },
            setZeroVelocity: function() { this.data.velocity[0] = 0, this.data.velocity[1] = 0 },
            setZeroDamping: function() { this.data.damping = 0, this.data.angularDamping = 0 },
            toLocalFrame: function(a, b) { return this.data.toLocalFrame(a, b) },
            toWorldFrame: function(a, b) { return this.data.toWorldFrame(a, b) },
            rotateLeft: function(a) { this.data.angularVelocity = this.world.pxm(-a) },
            rotateRight: function(a) { this.data.angularVelocity = this.world.pxm(a) },
            moveForward: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = b * Math.cos(c), this.data.velocity[1] = b * Math.sin(c)
            },
            moveBackward: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -(b * Math.cos(c)), this.data.velocity[1] = -(b * Math.sin(c))
            },
            thrust: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c)
            },
            thrustLeft: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle;
                this.data.force[0] += b * Math.cos(c), this.data.force[1] += b * Math.sin(c)
            },
            thrustRight: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle;
                this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c)
            },
            reverse: function(a) {
                var b = this.world.pxmi(-a),
                    c = this.data.angle + Math.PI / 2;
                this.data.force[0] -= b * Math.cos(c), this.data.force[1] -= b * Math.sin(c)
            },
            moveLeft: function(a) { this.data.velocity[0] = this.world.pxmi(-a) },
            moveRight: function(a) { this.data.velocity[0] = this.world.pxmi(a) },
            moveUp: function(a) { this.data.velocity[1] = this.world.pxmi(-a) },
            moveDown: function(a) { this.data.velocity[1] = this.world.pxmi(a) },
            preUpdate: function() { this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1) },
            postUpdate: function() { this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1 },
            reset: function(a, b, c, d) { void 0 === c && (c = !1), void 0 === d && (d = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), c && this.setZeroDamping(), d && (this.mass = 1), this.x = a, this.y = b },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var a = 0; a < this.game.physics.p2._toRemove.length; a++) this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() { this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this) },
            destroy: function() { this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null) },
            clearShapes: function() {
                for (var a = this.data.shapes.length; a--;) this.data.removeShape(this.data.shapes[a]);
                this.shapeChanged()
            },
            addShape: function(a, b, c, d) { return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.data.addShape(a, [this.world.pxmi(b), this.world.pxmi(c)], d), this.shapeChanged(), a },
            addCircle: function(a, b, c, d) { var e = new p2.Circle({ radius: this.world.pxm(a) }); return this.addShape(e, b, c, d) },
            addRectangle: function(a, b, c, d, e) { var f = new p2.Box({ width: this.world.pxm(a), height: this.world.pxm(b) }); return this.addShape(f, c, d, e) },
            addPlane: function(a, b, c) { var d = new p2.Plane; return this.addShape(d, a, b, c) },
            addParticle: function(a, b, c) { var d = new p2.Particle; return this.addShape(d, a, b, c) },
            addLine: function(a, b, c, d) { var e = new p2.Line({ length: this.world.pxm(a) }); return this.addShape(e, b, c, d) },
            addCapsule: function(a, b, c, d, e) { var f = new p2.Capsule({ length: this.world.pxm(a), radius: this.world.pxm(b) }); return this.addShape(f, c, d, e) },
            addPolygon: function(a, b) {
                a = a || {}, Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
                var c = [];
                if (1 === b.length && Array.isArray(b[0])) c = b[0].slice(0);
                else if (Array.isArray(b[0])) c = b.slice();
                else if ("number" == typeof b[0])
                    for (var d = 0, e = b.length; d < e; d += 2) c.push([b[d], b[d + 1]]);
                var f = c.length - 1;
                c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
                for (var g = 0; g < c.length; g++) c[g][0] = this.world.pxmi(c[g][0]), c[g][1] = this.world.pxmi(c[g][1]);
                var h = this.data.fromPolygon(c, a);
                return this.shapeChanged(), h
            },
            removeShape: function(a) { var b = this.data.removeShape(a); return this.shapeChanged(), b },
            setCircle: function(a, b, c, d) { return this.clearShapes(), this.addCircle(a, b, c, d) },
            setRectangle: function(a, b, c, d, e) { return void 0 === a && (a = 16), void 0 === b && (b = 16), this.clearShapes(), this.addRectangle(a, b, c, d, e) },
            setRectangleFromSprite: function(a) { return void 0 === a && (a = this.sprite), this.clearShapes(), this.addRectangle(a.width, a.height, 0, 0, a.rotation) },
            setMaterial: function(a, b) {
                if (void 0 === b)
                    for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].material = a;
                else b.material = a
            },
            shapeChanged: function() { this.debugBody && this.debugBody.draw() },
            addPhaserPolygon: function(a, b) {
                for (var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++) {
                    var f = c[e],
                        g = this.addFixture(f);
                    d[f.filter.group] = d[f.filter.group] || [], d[f.filter.group] = d[f.filter.group].concat(g), f.fixtureKey && (d[f.fixtureKey] = g)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), d
            },
            addFixture: function(a) {
                var b = [];
                if (a.circle) {
                    var c = new p2.Circle({ radius: this.world.pxm(a.circle.radius) });
                    c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor;
                    var d = p2.vec2.create();
                    d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2), d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2), this.data.addShape(c, d), b.push(c)
                }
                else
                    for (var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++) {
                        for (var h = e[g], i = [], j = 0; j < h.length; j += 2) i.push([this.world.pxmi(h[j]), this.world.pxmi(h[j + 1])]);
                        for (var c = new p2.Convex({ vertices: i }), k = 0; k !== c.vertices.length; k++) {
                            var l = c.vertices[k];
                            p2.vec2.sub(l, l, c.centerOfMass)
                        }
                        p2.vec2.scale(f, c.centerOfMass, 1), f[0] -= this.world.pxmi(this.sprite.width / 2), f[1] -= this.world.pxmi(this.sprite.height / 2), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), c.collisionGroup = a.filter.categoryBits, c.collisionMask = a.filter.maskBits, c.sensor = a.isSensor, this.data.addShape(c, f), b.push(c)
                    }
                return b
            },
            loadPolygon: function(a, b) {
                if (null === a) var c = b;
                else var c = this.game.cache.getPhysicsData(a, b);
                for (var d = p2.vec2.create(), e = 0; e < c.length; e++) {
                    for (var f = [], g = 0; g < c[e].shape.length; g += 2) f.push([this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1])]);
                    for (var h = new p2.Convex({ vertices: f }), i = 0; i !== h.vertices.length; i++) {
                        var j = h.vertices[i];
                        p2.vec2.sub(j, j, h.centerOfMass)
                    }
                    p2.vec2.scale(d, h.centerOfMass, 1), d[0] -= this.world.pxmi(this.sprite.width / 2), d[1] -= this.world.pxmi(this.sprite.height / 2), h.updateTriangles(), h.updateCenterOfMass(), h.updateBoundingRadius(), this.data.addShape(h, d)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, c.Physics.P2.Body.prototype.constructor = c.Physics.P2.Body, c.Physics.P2.Body.DYNAMIC = 1, c.Physics.P2.Body.STATIC = 2, c.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(c.Physics.P2.Body.prototype, "static", { get: function() { return this.data.type === c.Physics.P2.Body.STATIC }, set: function(a) { a && this.data.type !== c.Physics.P2.Body.STATIC ? (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0) : a || this.data.type !== c.Physics.P2.Body.STATIC || (this.data.type = c.Physics.P2.Body.DYNAMIC, this.mass = 1) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "dynamic", { get: function() { return this.data.type === c.Physics.P2.Body.DYNAMIC }, set: function(a) { a && this.data.type !== c.Physics.P2.Body.DYNAMIC ? (this.data.type = c.Physics.P2.Body.DYNAMIC, this.mass = 1) : a || this.data.type !== c.Physics.P2.Body.DYNAMIC || (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "kinematic", { get: function() { return this.data.type === c.Physics.P2.Body.KINEMATIC }, set: function(a) { a && this.data.type !== c.Physics.P2.Body.KINEMATIC ? (this.data.type = c.Physics.P2.Body.KINEMATIC, this.mass = 4) : a || this.data.type !== c.Physics.P2.Body.KINEMATIC || (this.data.type = c.Physics.P2.Body.STATIC, this.mass = 0) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "allowSleep", { get: function() { return this.data.allowSleep }, set: function(a) { a !== this.data.allowSleep && (this.data.allowSleep = a) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "angle", { get: function() { return c.Math.wrapAngle(c.Math.radToDeg(this.data.angle)) }, set: function(a) { this.data.angle = c.Math.degToRad(c.Math.wrapAngle(a)) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularDamping", { get: function() { return this.data.angularDamping }, set: function(a) { this.data.angularDamping = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularForce", { get: function() { return this.data.angularForce }, set: function(a) { this.data.angularForce = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "angularVelocity", { get: function() { return this.data.angularVelocity }, set: function(a) { this.data.angularVelocity = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "damping", { get: function() { return this.data.damping }, set: function(a) { this.data.damping = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "fixedRotation", { get: function() { return this.data.fixedRotation }, set: function(a) { a !== this.data.fixedRotation && (this.data.fixedRotation = a) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "inertia", { get: function() { return this.data.inertia }, set: function(a) { this.data.inertia = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "mass", { get: function() { return this.data.mass }, set: function(a) { a !== this.data.mass && (this.data.mass = a, this.data.updateMassProperties()) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "motionState", { get: function() { return this.data.type }, set: function(a) { a !== this.data.type && (this.data.type = a) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "rotation", { get: function() { return this.data.angle }, set: function(a) { this.data.angle = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "sleepSpeedLimit", { get: function() { return this.data.sleepSpeedLimit }, set: function(a) { this.data.sleepSpeedLimit = a } }), Object.defineProperty(c.Physics.P2.Body.prototype, "x", { get: function() { return this.world.mpxi(this.data.position[0]) }, set: function(a) { this.data.position[0] = this.world.pxmi(a) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "y", { get: function() { return this.world.mpxi(this.data.position[1]) }, set: function(a) { this.data.position[1] = this.world.pxmi(a) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "id", { get: function() { return this.data.id } }), Object.defineProperty(c.Physics.P2.Body.prototype, "debug", { get: function() { return null !== this.debugBody }, set: function(a) { a && !this.debugBody ? this.debugBody = new c.Physics.P2.BodyDebug(this.game, this.data) : !a && this.debugBody && (this.debugBody.destroy(), this.debugBody = null) } }), Object.defineProperty(c.Physics.P2.Body.prototype, "collideWorldBounds", { get: function() { return this._collideWorldBounds }, set: function(a) { a && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !a && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask()) } }), c.Physics.P2.BodyDebug = function(a, b, d) {
            c.Group.call(this, a);
            var e = { pixelsPerLengthUnit: a.physics.p2.mpx(1), debugPolygons: !1, lineWidth: 1, alpha: .5 };
            this.settings = c.Utils.extend(e, d), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = b, this.canvas = new c.Graphics(a), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, c.Physics.P2.BodyDebug.prototype = Object.create(c.Group.prototype), c.Physics.P2.BodyDebug.prototype.constructor = c.Physics.P2.BodyDebug, c.Utils.extend(c.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() { this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle },
            draw: function() {
                var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
                if (h = this.body, j = this.canvas, j.clear(), c = parseInt(this.randomPastelHex(), 16), f = 16711680, g = this.lineWidth, h instanceof p2.Body && h.shapes.length) {
                    var p = h.shapes.length;
                    for (d = 0; d !== p;) {
                        if (b = h.shapes[d], i = b.position || 0, a = b.angle || 0, b instanceof p2.Circle) this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
                        else if (b instanceof p2.Capsule) this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g);
                        else if (b instanceof p2.Plane) this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
                        else if (b instanceof p2.Line) this.drawLine(j, b.length * this.ppu, f, g);
                        else if (b instanceof p2.Box) this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g);
                        else if (b instanceof p2.Convex) {
                            for (l = [], m = p2.vec2.create(), e = n = 0, o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n) k = b.vertices[e], p2.vec2.rotate(m, k, a), l.push([(m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu]);
                            this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [i[0] * this.ppu, -i[1] * this.ppu])
                        }
                        d++
                    }
                }
            },
            drawRectangle: function(a, b, c, d, e, f, g, h, i) { void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1), a.beginFill(h), a.drawRect(b - e / 2, c - f / 2, e, f) },
            drawCircle: function(a, b, c, d, e, f, g) { void 0 === g && (g = 1), void 0 === f && (f = 16777215), a.lineStyle(g, 0, 1), a.beginFill(f, 1), a.drawCircle(b, c, 2 * -e), a.endFill(), a.moveTo(b, c), a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d)) },
            drawLine: function(a, b, c, d) { void 0 === d && (d = 1), void 0 === c && (c = 0), a.lineStyle(5 * d, c, 1), a.moveTo(-b / 2, 0), a.lineTo(b / 2, 0) },
            drawConvex: function(a, b, c, d, e, f, g, h) { var i, j, k, l, m, n, o, p, q, r, s; if (void 0 === f && (f = 1), void 0 === d && (d = 0), g) { for (i = [16711680, 65280, 255], j = 0; j !== b.length + 1;) l = b[j % b.length], m = b[(j + 1) % b.length], o = l[0], r = l[1], p = m[0], s = m[1], a.lineStyle(f, i[j % i.length], 1), a.moveTo(o, -r), a.lineTo(p, -s), a.drawCircle(o, -r, 2 * f), j++; return a.lineStyle(f, 0, 1), a.drawCircle(h[0], h[1], 2 * f) } for (a.lineStyle(f, d, 1), a.beginFill(e), j = 0; j !== b.length;) k = b[j], n = k[0], q = k[1], 0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q), j++; if (a.endFill(), b.length > 2) return a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]), a.lineTo(b[0][0], -b[0][1]) },
            drawPath: function(a, b, c, d, e) { var f, g, h, i, j, k, l, m, n, o, p, q, r; for (void 0 === e && (e = 1), void 0 === c && (c = 0), a.lineStyle(e, c, 1), "number" == typeof d && a.beginFill(d), h = null, i = null, g = 0; g < b.length;) p = b[g], q = p[0], r = p[1], q === h && r === i || (0 === g ? a.moveTo(q, r) : (j = h, k = i, l = q, m = r, n = b[(g + 1) % b.length][0], o = b[(g + 1) % b.length][1], f = (l - j) * (o - k) - (n - j) * (m - k), 0 !== f && a.lineTo(q, r)), h = q, i = r), g++; "number" == typeof d && a.endFill(), b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]), a.lineTo(b[0][0], b[0][1])) },
            drawPlane: function(a, b, c, d, e, f, g, h, i, j) {
                var k, l, m;
                void 0 === f && (f = 1), void 0 === d && (d = 16777215), a.lineStyle(f, e, 11), a.beginFill(d), k = i, a.moveTo(b, -c), l = b + Math.cos(j) * this.game.width, m = c + Math.sin(j) * this.game.height, a.lineTo(l, -m), a.moveTo(b, -c), l = b + Math.cos(j) * -this.game.width, m = c + Math.sin(j) * -this.game.height, a.lineTo(l, -m)
            },
            drawCapsule: function(a, b, c, d, e, f, g, h, i) {
                void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1);
                var j = Math.cos(d),
                    k = Math.sin(d);
                a.beginFill(h, 1), a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f), a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f), a.endFill(), a.lineStyle(i, g, 0), a.beginFill(h, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c), a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.endFill(), a.lineStyle(i, g, 1), a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c), a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c), a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c), a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c)
            },
            randomPastelHex: function() { var a, b, c, d; return c = [255, 255, 255], d = Math.floor(256 * Math.random()), b = Math.floor(256 * Math.random()), a = Math.floor(256 * Math.random()), d = Math.floor((d + 3 * c[0]) / 4), b = Math.floor((b + 3 * c[1]) / 4), a = Math.floor((a + 3 * c[2]) / 4), this.rgbToHex(d, b, a) },
            rgbToHex: function(a, b, c) { return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c) },
            componentToHex: function(a) { var b; return b = a.toString(16), 2 === b.length ? b : b + "0" }
        }), c.Physics.P2.Spring = function(a, b, c, d, e, f, g, h, i, j) { this.game = a.game, this.world = a, void 0 === d && (d = 1), void 0 === e && (e = 100), void 0 === f && (f = 1), d = a.pxm(d); var k = { restLength: d, stiffness: e, damping: f }; "undefined" != typeof g && null !== g && (k.worldAnchorA = [a.pxm(g[0]), a.pxm(g[1])]), "undefined" != typeof h && null !== h && (k.worldAnchorB = [a.pxm(h[0]), a.pxm(h[1])]), "undefined" != typeof i && null !== i && (k.localAnchorA = [a.pxm(i[0]), a.pxm(i[1])]), "undefined" != typeof j && null !== j && (k.localAnchorB = [a.pxm(j[0]), a.pxm(j[1])]), this.data = new p2.LinearSpring(b, c, k), this.data.parent = this }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.RotationalSpring = function(a, b, c, d, e, f) {
            this.game = a.game, this.world = a, void 0 === d && (d = null), void 0 === e && (e = 100), void 0 === f && (f = 1), d && (d = a.pxm(d));
            var g = { restAngle: d, stiffness: e, damping: f };
            this.data = new p2.RotationalSpring(b, c, g), this.data.parent = this
        }, c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring, c.Physics.P2.Material = function(a) { this.name = a, p2.Material.call(this) }, c.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), c.Physics.P2.Material.prototype.constructor = c.Physics.P2.Material, c.Physics.P2.ContactMaterial = function(a, b, c) { p2.ContactMaterial.call(this, a, b, c) }, c.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), c.Physics.P2.ContactMaterial.prototype.constructor = c.Physics.P2.ContactMaterial, c.Physics.P2.CollisionGroup = function(a) { this.mask = a }, c.Physics.P2.DistanceConstraint = function(a, b, c, d, e, f, g) {
            void 0 === d && (d = 100), void 0 === e && (e = [0, 0]), void 0 === f && (f = [0, 0]), void 0 === g && (g = Number.MAX_VALUE), this.game = a.game, this.world = a, d = a.pxm(d), e = [a.pxmi(e[0]), a.pxmi(e[1])], f = [a.pxmi(f[0]), a.pxmi(f[1])];
            var h = { distance: d, localAnchorA: e, localAnchorB: f, maxForce: g };
            p2.DistanceConstraint.call(this, b, c, h)
        }, c.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), c.Physics.P2.DistanceConstraint.prototype.constructor = c.Physics.P2.DistanceConstraint, c.Physics.P2.GearConstraint = function(a, b, c, d, e) {
            void 0 === d && (d = 0), void 0 === e && (e = 1), this.game = a.game, this.world = a;
            var f = { angle: d, ratio: e };
            p2.GearConstraint.call(this, b, c, f)
        }, c.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), c.Physics.P2.GearConstraint.prototype.constructor = c.Physics.P2.GearConstraint, c.Physics.P2.LockConstraint = function(a, b, c, d, e, f) {
            void 0 === d && (d = [0, 0]), void 0 === e && (e = 0), void 0 === f && (f = Number.MAX_VALUE), this.game = a.game, this.world = a, d = [a.pxm(d[0]), a.pxm(d[1])];
            var g = { localOffsetB: d, localAngleB: e, maxForce: f };
            p2.LockConstraint.call(this, b, c, g)
        }, c.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), c.Physics.P2.LockConstraint.prototype.constructor = c.Physics.P2.LockConstraint, c.Physics.P2.PrismaticConstraint = function(a, b, c, d, e, f, g, h) {
            void 0 === d && (d = !0), void 0 === e && (e = [0, 0]), void 0 === f && (f = [0, 0]), void 0 === g && (g = [0, 0]), void 0 === h && (h = Number.MAX_VALUE), this.game = a.game, this.world = a, e = [a.pxmi(e[0]), a.pxmi(e[1])], f = [a.pxmi(f[0]), a.pxmi(f[1])];
            var i = { localAnchorA: e, localAnchorB: f, localAxisA: g, maxForce: h, disableRotationalLock: !d };
            p2.PrismaticConstraint.call(this, b, c, i)
        }, c.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), c.Physics.P2.PrismaticConstraint.prototype.constructor = c.Physics.P2.PrismaticConstraint, c.Physics.P2.RevoluteConstraint = function(a, b, c, d, e, f, g) {
            void 0 === f && (f = Number.MAX_VALUE), void 0 === g && (g = null), this.game = a.game, this.world = a, c = [a.pxmi(c[0]), a.pxmi(c[1])], e = [a.pxmi(e[0]), a.pxmi(e[1])], g && (g = [a.pxmi(g[0]), a.pxmi(g[1])]);
            var h = { worldPivot: g, localPivotA: c, localPivotB: e, maxForce: f };
            p2.RevoluteConstraint.call(this, b, d, h)
        }, c.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), c.Physics.P2.RevoluteConstraint.prototype.constructor = c.Physics.P2.RevoluteConstraint, c.ImageCollection = function(a, b, c, d, e, f, g) {
            (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.imageWidth = 0 | c, this.imageHeight = 0 | d, this.imageMargin = 0 | e, this.imageSpacing = 0 | f, this.properties = g || {}, this.images = [], this.total = 0
        }, c.ImageCollection.prototype = { containsImageIndex: function(a) { return a >= this.firstgid && a < this.firstgid + this.total }, addImage: function(a, b) { this.images.push({ gid: a, image: b }), this.total++ } }, c.ImageCollection.prototype.constructor = c.ImageCollection, c.Tile = function(a, b, c, d, e, f) { this.layer = a, this.index = b, this.x = c, this.y = d, this.rotation = 0, this.flipped = !1, this.worldX = c * e, this.worldY = d * f, this.width = e, this.height = f, this.centerX = Math.abs(e / 2), this.centerY = Math.abs(f / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this }, c.Tile.prototype = { containsPoint: function(a, b) { return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom) }, intersects: function(a, b, c, d) { return !(c <= this.worldX) && (!(d <= this.worldY) && (!(a >= this.worldX + this.width) && !(b >= this.worldY + this.height))) }, setCollisionCallback: function(a, b) { this.collisionCallback = a, this.collisionCallbackContext = b }, destroy: function() { this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null }, setCollision: function(a, b, c, d) { this.collideLeft = a, this.collideRight = b, this.collideUp = c, this.collideDown = d, this.faceLeft = a, this.faceRight = b, this.faceTop = c, this.faceBottom = d }, resetCollision: function() { this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1 }, isInteresting: function(a, b) { return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight) }, copy: function(a) { this.index = a.index, this.alpha = a.alpha, this.properties = a.properties, this.collideUp = a.collideUp, this.collideDown = a.collideDown, this.collideLeft = a.collideLeft, this.collideRight = a.collideRight, this.collisionCallback = a.collisionCallback, this.collisionCallbackContext = a.collisionCallbackContext } }, c.Tile.prototype.constructor = c.Tile, Object.defineProperty(c.Tile.prototype, "collides", { get: function() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown } }), Object.defineProperty(c.Tile.prototype, "canCollide", { get: function() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback } }), Object.defineProperty(c.Tile.prototype, "left", { get: function() { return this.worldX } }), Object.defineProperty(c.Tile.prototype, "right", { get: function() { return this.worldX + this.width } }), Object.defineProperty(c.Tile.prototype, "top", { get: function() { return this.worldY } }), Object.defineProperty(c.Tile.prototype, "bottom", { get: function() { return this.worldY + this.height } }), c.Tilemap = function(a, b, d, e, f, g) {
            this.game = a, this.key = b;
            var h = c.TilemapParser.parse(this.game, b, d, e, f, g);
            null !== h && (this.width = h.width, this.height = h.height, this.tileWidth = h.tileWidth, this.tileHeight = h.tileHeight, this.orientation = h.orientation, this.format = h.format, this.version = h.version, this.properties = h.properties, this.widthInPixels = h.widthInPixels, this.heightInPixels = h.heightInPixels, this.layers = h.layers, this.tilesets = h.tilesets, this.imagecollections = h.imagecollections, this.tiles = h.tiles, this.objects = h.objects, this.collideIndexes = [], this.collision = h.collision, this.images = h.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, c.Tilemap.CSV = 0, c.Tilemap.TILED_JSON = 1, c.Tilemap.NORTH = 0, c.Tilemap.EAST = 1, c.Tilemap.SOUTH = 2, c.Tilemap.WEST = 3, c.Tilemap.prototype = {
            create: function(a, b, c, d, e, f) { return void 0 === f && (f = this.game.world), this.width = b, this.height = c, this.setTileSize(d, e), this.layers.length = 0, this.createBlankLayer(a, b, c, d, e, f) },
            setTileSize: function(a, b) { this.tileWidth = a, this.tileHeight = b, this.widthInPixels = this.width * a, this.heightInPixels = this.height * b },
            addTilesetImage: function(a, b, d, e, f, g, h) {
                if (void 0 === a) return null;
                void 0 === d && (d = this.tileWidth), void 0 === e && (e = this.tileHeight), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), 0 === d && (d = 32), 0 === e && (e = 32);
                var i = null;
                if (void 0 !== b && null !== b || (b = a), b instanceof c.BitmapData) i = b.canvas;
                else {
                    if (!this.game.cache.checkImageKey(b)) return null;
                    i = this.game.cache.getImage(b)
                }
                var j = this.getTilesetIndex(a);
                if (null === j && this.format === c.Tilemap.TILED_JSON) return null;
                if (this.tilesets[j]) return this.tilesets[j].setImage(i), this.tilesets[j];
                var k = new c.Tileset(a, h, d, e, f, g, {});
                k.setImage(i), this.tilesets.push(k);
                for (var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h; r < h + k.total && (this.tiles[r] = [m, n, l], m += d + g, o++, o !== k.total) && (p++, p !== k.columns || (m = f, n += e + g, p = 0, q++, q !== k.rows)); r++);
                return k
            },
            createFromObjects: function(a, b, d, e, f, g, h, i, j) {
                if (void 0 === f && (f = !0), void 0 === g && (g = !1), void 0 === h && (h = this.game.world), void 0 === i && (i = c.Sprite), void 0 === j && (j = !0), this.objects[a])
                    for (var k = 0; k < this.objects[a].length; k++) {
                        var l = !1,
                            m = this.objects[a][k];
                        if (void 0 !== m.gid && "number" == typeof b && m.gid === b ? l = !0 : void 0 !== m.id && "number" == typeof b && m.id === b ? l = !0 : void 0 !== m.name && "string" == typeof b && m.name === b && (l = !0), l) {
                            var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
                            n.name = m.name, n.visible = m.visible, n.autoCull = g, n.exists = f, m.width && (n.width = m.width), m.height && (n.height = m.height), m.rotation && (n.angle = m.rotation), j && (n.y -= n.height), h.add(n);
                            for (var o in m.properties) h.set(n, o, m.properties[o], !1, !1, 0, !0)
                        }
                    }
            },
            createFromTiles: function(a, b, d, e, f, g) {
                "number" == typeof a && (a = [a]), void 0 === b || null === b ? b = [] : "number" == typeof b && (b = [b]), e = this.getLayer(e), void 0 === f && (f = this.game.world), void 0 === g && (g = {}), void 0 === g.customClass && (g.customClass = c.Sprite), void 0 === g.adjustY && (g.adjustY = !0);
                var h = this.layers[e].width,
                    i = this.layers[e].height;
                if (this.copy(0, 0, h, i, e), this._results.length < 2) return 0;
                for (var j, k = 0, l = 1, m = this._results.length; l < m; l++)
                    if (a.indexOf(this._results[l].index) !== -1) {
                        j = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
                        for (var n in g) j[n] = g[n];
                        f.add(j), k++
                    }
                if (1 === b.length)
                    for (l = 0; l < a.length; l++) this.replace(a[l], b[0], 0, 0, h, i, e);
                else if (b.length > 1)
                    for (l = 0; l < a.length; l++) this.replace(a[l], b[l], 0, 0, h, i, e);
                return k
            },
            createLayer: function(a, b, d, e) { void 0 === b && (b = this.game.width), void 0 === d && (d = this.game.height), void 0 === e && (e = this.game.world); var f = a; if ("string" == typeof a && (f = this.getLayerIndex(a)), !(null === f || f > this.layers.length)) { void 0 === b || b <= 0 ? b = Math.min(this.game.width, this.layers[f].widthInPixels) : b > this.game.width && (b = this.game.width), void 0 === d || d <= 0 ? d = Math.min(this.game.height, this.layers[f].heightInPixels) : d > this.game.height && (d = this.game.height), this.enableDebug; var g = e.add(new c.TilemapLayer(this.game, this, f, b, d)); return this.enableDebug, g } },
            createBlankLayer: function(a, b, d, e, f, g) {
                if (void 0 === g && (g = this.game.world), null === this.getLayerIndex(a)) {
                    for (var h, i = { name: a, x: 0, y: 0, width: b, height: d, widthInPixels: b * e, heightInPixels: d * f, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: null }, j = [], k = 0; k < d; k++) {
                        h = [];
                        for (var l = 0; l < b; l++) h.push(new c.Tile(i, (-1), l, k, e, f));
                        j.push(h)
                    }
                    i.data = j, this.layers.push(i), this.currentLayer = this.layers.length - 1;
                    var m = i.widthInPixels,
                        n = i.heightInPixels;
                    m > this.game.width && (m = this.game.width), n > this.game.height && (n = this.game.height);
                    var j = new c.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
                    return j.name = a, g.add(j)
                }
            },
            getIndex: function(a, b) {
                for (var c = 0; c < a.length; c++)
                    if (a[c].name === b) return c;
                return null
            },
            getLayerIndex: function(a) { return this.getIndex(this.layers, a) },
            getTilesetIndex: function(a) { return this.getIndex(this.tilesets, a) },
            getImageIndex: function(a) { return this.getIndex(this.images, a) },
            setTileIndexCallback: function(a, b, c, d) {
                if (d = this.getLayer(d), "number" == typeof a) this.layers[d].callbacks[a] = { callback: b, callbackContext: c };
                else
                    for (var e = 0, f = a.length; e < f; e++) this.layers[d].callbacks[a[e]] = { callback: b, callbackContext: c }
            },
            setTileLocationCallback: function(a, b, c, d, e, f, g) {
                if (g = this.getLayer(g), this.copy(a, b, c, d, g), !(this._results.length < 2))
                    for (var h = 1; h < this._results.length; h++) this._results[h].setCollisionCallback(e, f)
            },
            setCollision: function(a, b, c, d) {
                if (void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c), "number" == typeof a) return this.setCollisionByIndex(a, b, c, !0);
                if (Array.isArray(a)) {
                    for (var e = 0; e < a.length; e++) this.setCollisionByIndex(a[e], b, c, !1);
                    d && this.calculateFaces(c)
                }
            },
            setCollisionBetween: function(a, b, c, d, e) {
                if (void 0 === c && (c = !0), void 0 === e && (e = !0), d = this.getLayer(d), !(a > b)) {
                    for (var f = a; f <= b; f++) this.setCollisionByIndex(f, c, d, !1);
                    e && this.calculateFaces(d)
                }
            },
            setCollisionByExclusion: function(a, b, c, d) {
                void 0 === b && (b = !0), void 0 === d && (d = !0), c = this.getLayer(c);
                for (var e = 0, f = this.tiles.length; e < f; e++) a.indexOf(e) === -1 && this.setCollisionByIndex(e, b, c, !1);
                d && this.calculateFaces(c)
            },
            setCollisionByIndex: function(a, b, c, d) {
                if (void 0 === b && (b = !0), void 0 === c && (c = this.currentLayer), void 0 === d && (d = !0), b) this.collideIndexes.push(a);
                else {
                    var e = this.collideIndexes.indexOf(a);
                    e > -1 && this.collideIndexes.splice(e, 1)
                }
                for (var f = 0; f < this.layers[c].height; f++)
                    for (var g = 0; g < this.layers[c].width; g++) {
                        var h = this.layers[c].data[f][g];
                        h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(), h.faceTop = b, h.faceBottom = b, h.faceLeft = b, h.faceRight = b)
                    }
                return d && this.calculateFaces(c), c
            },
            getLayer: function(a) { return void 0 === a ? a = this.currentLayer : "string" == typeof a ? a = this.getLayerIndex(a) : a instanceof c.TilemapLayer && (a = a.index), a },
            setPreventRecalculate: function(a) {
                if (a === !0 && this.preventingRecalculate !== !0 && (this.preventingRecalculate = !0, this.needToRecalculate = {}), a === !1 && this.preventingRecalculate === !0) {
                    this.preventingRecalculate = !1;
                    for (var b in this.needToRecalculate) this.calculateFaces(b);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(a) {
                if (this.preventingRecalculate) return void(this.needToRecalculate[a] = !0);
                for (var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; f < g; f++)
                    for (var h = 0, i = this.layers[a].width; h < i; h++) {
                        var j = this.layers[a].data[f][h];
                        j && (b = this.getTileAbove(a, h, f), c = this.getTileBelow(a, h, f), d = this.getTileLeft(a, h, f), e = this.getTileRight(a, h, f), j.collides && (j.faceTop = !0, j.faceBottom = !0, j.faceLeft = !0, j.faceRight = !0), b && b.collides && (j.faceTop = !1), c && c.collides && (j.faceBottom = !1), d && d.collides && (j.faceLeft = !1), e && e.collides && (j.faceRight = !1))
                    }
            },
            getTileAbove: function(a, b, c) { return c > 0 ? this.layers[a].data[c - 1][b] : null },
            getTileBelow: function(a, b, c) { return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null },
            getTileLeft: function(a, b, c) { return b > 0 ? this.layers[a].data[c][b - 1] : null },
            getTileRight: function(a, b, c) { return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null },
            setLayer: function(a) { a = this.getLayer(a), this.layers[a] && (this.currentLayer = a) },
            hasTile: function(a, b, c) { return c = this.getLayer(c), void 0 !== this.layers[c].data[b] && void 0 !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1 },
            removeTile: function(a, b, d) { if (d = this.getLayer(d), a >= 0 && a < this.layers[d].width && b >= 0 && b < this.layers[d].height && this.hasTile(a, b, d)) { var e = this.layers[d].data[b][a]; return this.layers[d].data[b][a] = new c.Tile(this.layers[d], (-1), a, b, this.tileWidth, this.tileHeight), this.layers[d].dirty = !0, this.calculateFaces(d), e } },
            removeTileWorldXY: function(a, b, c, d, e) { return e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.removeTile(a, b, e) },
            putTile: function(a, b, d, e) { if (null === a) return this.removeTile(b, d, e); if (e = this.getLayer(e), b >= 0 && b < this.layers[e].width && d >= 0 && d < this.layers[e].height) { var f; return a instanceof c.Tile ? (f = a.index, this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : this.layers[e].data[d][b] = new c.Tile(e, f, b, d, a.width, a.height)) : (f = a, this.hasTile(b, d, e) ? this.layers[e].data[d][b].index = f : this.layers[e].data[d][b] = new c.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision(), this.layers[e].dirty = !0, this.calculateFaces(e), this.layers[e].data[d][b] } return null },
            putTileWorldXY: function(a, b, c, d, e, f) { return f = this.getLayer(f), b = this.game.math.snapToFloor(b, d) / d, c = this.game.math.snapToFloor(c, e) / e, this.putTile(a, b, c, f) },
            searchTileIndex: function(a, b, c, d) {
                void 0 === b && (b = 0), void 0 === c && (c = !1), d = this.getLayer(d);
                var e = 0;
                if (c) {
                    for (var f = this.layers[d].height - 1; f >= 0; f--)
                        for (var g = this.layers[d].width - 1; g >= 0; g--)
                            if (this.layers[d].data[f][g].index === a) {
                                if (e === b) return this.layers[d].data[f][g];
                                e++
                            }
                }
                else
                    for (var f = 0; f < this.layers[d].height; f++)
                        for (var g = 0; g < this.layers[d].width; g++)
                            if (this.layers[d].data[f][g].index === a) {
                                if (e === b) return this.layers[d].data[f][g];
                                e++
                            } return null
            },
            getTile: function(a, b, c, d) { return void 0 === d && (d = !1), c = this.getLayer(c), a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? this.layers[c].data[b][a].index === -1 ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null },
            getTileWorldXY: function(a, b, c, d, e, f) { return void 0 === c && (c = this.tileWidth), void 0 === d && (d = this.tileHeight), e = this.getLayer(e), a = this.game.math.snapToFloor(a, c) / c, b = this.game.math.snapToFloor(b, d) / d, this.getTile(a, b, e, f) },
            copy: function(a, b, c, d, e) {
                if (e = this.getLayer(e), !this.layers[e]) return void(this._results.length = 0);
                void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.layers[e].width), void 0 === d && (d = this.layers[e].height), a < 0 && (a = 0), b < 0 && (b = 0), c > this.layers[e].width && (c = this.layers[e].width), d > this.layers[e].height && (d = this.layers[e].height), this._results.length = 0, this._results.push({ x: a, y: b, width: c, height: d, layer: e });
                for (var f = b; f < b + d; f++)
                    for (var g = a; g < a + c; g++) this._results.push(this.layers[e].data[f][g]);
                return this._results
            },
            paste: function(a, b, c, d) {
                if (void 0 === a && (a = 0), void 0 === b && (b = 0), d = this.getLayer(d), c && !(c.length < 2)) {
                    for (var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++) this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
                    this.layers[d].dirty = !0, this.calculateFaces(d)
                }
            },
            swap: function(a, b, c, d, e, f, g) { g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._tempA = a, this._tempB = b, this._results.forEach(this.swapHandler, this), this.paste(c, d, this._results, g)) },
            swapHandler: function(a) { a.index === this._tempA ? a.index = this._tempB : a.index === this._tempB && (a.index = this._tempA) },
            forEach: function(a, b, c, d, e, f, g) { g = this.getLayer(g), this.copy(c, d, e, f, g), this._results.length < 2 || (this._results.forEach(a, b), this.paste(c, d, this._results, g)) },
            replace: function(a, b, c, d, e, f, g) {
                if (g = this.getLayer(g), this.copy(c, d, e, f, g), !(this._results.length < 2)) {
                    for (var h = 1; h < this._results.length; h++) this._results[h].index === a && (this._results[h].index = b);
                    this.paste(c, d, this._results, g)
                }
            },
            random: function(a, b, c, d, e) {
                if (e = this.getLayer(e), this.copy(a, b, c, d, e), !(this._results.length < 2)) {
                    for (var f = [], g = 1; g < this._results.length; g++)
                        if (this._results[g].index) {
                            var h = this._results[g].index;
                            f.indexOf(h) === -1 && f.push(h)
                        }
                    for (var i = 1; i < this._results.length; i++) this._results[i].index = this.game.rnd.pick(f);
                    this.paste(a, b, this._results, e)
                }
            },
            shuffle: function(a, b, d, e, f) {
                if (f = this.getLayer(f), this.copy(a, b, d, e, f), !(this._results.length < 2)) {
                    for (var g = [], h = 1; h < this._results.length; h++) this._results[h].index && g.push(this._results[h].index);
                    c.ArrayUtils.shuffle(g);
                    for (var i = 1; i < this._results.length; i++) this._results[i].index = g[i - 1];
                    this.paste(a, b, this._results, f)
                }
            },
            fill: function(a, b, c, d, e, f) {
                if (f = this.getLayer(f), this.copy(b, c, d, e, f), !(this._results.length < 2)) {
                    for (var g = 1; g < this._results.length; g++) this._results[g].index = a;
                    this.paste(b, c, this._results, f)
                }
            },
            removeAllLayers: function() { this.layers.length = 0, this.currentLayer = 0 },
            dump: function() {
                for (var a = "", b = [""], c = 0; c < this.layers[this.currentLayer].height; c++) {
                    for (var d = 0; d < this.layers[this.currentLayer].width; d++) a += "%c  ", this.layers[this.currentLayer].data[c][d] > 1 ? this.debugMap[this.layers[this.currentLayer].data[c][d]] ? b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]]) : b.push("background: #ffffff") : b.push("background: rgb(0, 0, 0)");
                    a += "\n"
                }
                b[0] = a
            },
            destroy: function() { this.removeAllLayers(), this.data = [], this.game = null }
        }, c.Tilemap.prototype.constructor = c.Tilemap, Object.defineProperty(c.Tilemap.prototype, "layer", { get: function() { return this.layers[this.currentLayer] }, set: function(a) { a !== this.currentLayer && this.setLayer(a) } }), c.TilemapLayer = function(a, b, d, e, f) { e |= 0, f |= 0, c.Sprite.call(this, a, 0, 0), this.map = b, this.index = d, this.layer = b.layers[d], this.canvas = PIXI.CanvasPool.create(this, e, f), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = c.TILEMAPLAYER, this.physicsType = c.TILEMAPLAYER, this.renderSettings = { enableScrollDelta: !1, overdrawRatio: .2, copyCanvas: null }, this.debug = !1, this.exists = !0, this.debugSettings = { missingImageFill: "rgb(255,255,255)", debuggedTileOverfill: "rgba(0,255,0,0.4)", forceFullRedraw: !0, debugAlpha: .5, facingEdgeStroke: "rgba(0,255,0,1)", collidingTileOverfill: "rgba(0,255,0,0.2)" }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = { scrollX: 0, scrollY: 0, renderWidth: 0, renderHeight: 0, tileWidth: b.tileWidth, tileHeight: b.tileHeight, cw: b.tileWidth, ch: b.tileHeight, tilesets: [] }, this._scrollX = 0, this._scrollY = 0, this._results = [], a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = c.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0 }, c.TilemapLayer.prototype = Object.create(c.Sprite.prototype), c.TilemapLayer.prototype.constructor = c.TilemapLayer, c.TilemapLayer.prototype.preUpdateCore = c.Component.Core.preUpdate, c.TilemapLayer.sharedCopyCanvas = null, c.TilemapLayer.ensureSharedCopyCanvas = function() { return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas }, c.TilemapLayer.prototype.preUpdate = function() { return this.preUpdateCore() }, c.TilemapLayer.prototype.postUpdate = function() { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y }, c.TilemapLayer.prototype._renderCanvas = function(a) { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, a) }, c.TilemapLayer.prototype._renderWebGL = function(a) { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, a) }, c.TilemapLayer.prototype.destroy = function() { PIXI.CanvasPool.remove(this), c.Component.Destroy.prototype.destroy.call(this) }, c.TilemapLayer.prototype.resize = function(a, b) { this.canvas.width = a, this.canvas.height = b, this.texture.frame.resize(a, b), this.texture.width = a, this.texture.height = b, this.texture.crop.width = a, this.texture.crop.height = b, this.texture.baseTexture.width = a, this.texture.baseTexture.height = b, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0 }, c.TilemapLayer.prototype.resizeWorld = function() { this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y) }, c.TilemapLayer.prototype._fixX = function(a) { return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX) }, c.TilemapLayer.prototype._unfixX = function(a) { return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX) }, c.TilemapLayer.prototype._fixY = function(a) { return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY) }, c.TilemapLayer.prototype._unfixY = function(a) { return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY) }, c.TilemapLayer.prototype.getTileX = function(a) { return Math.floor(this._fixX(a) / this._mc.tileWidth) }, c.TilemapLayer.prototype.getTileY = function(a) { return Math.floor(this._fixY(a) / this._mc.tileHeight) }, c.TilemapLayer.prototype.getTileXY = function(a, b, c) { return c.x = this.getTileX(a), c.y = this.getTileY(b), c }, c.TilemapLayer.prototype.getRayCastTiles = function(a, b, c, d) {
            b || (b = this.rayStepRate), void 0 === c && (c = !1), void 0 === d && (d = !1);
            var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
            if (0 === e.length) return [];
            for (var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++)
                for (var i = 0; i < f.length; i++) {
                    var j = e[h],
                        k = f[i];
                    if (j.containsPoint(k[0], k[1])) { g.push(j); break }
                }
            return g
        }, c.TilemapLayer.prototype.getTiles = function(a, b, c, d, e, f) {
            void 0 === e && (e = !1), void 0 === f && (f = !1);
            var g = !(e || f);
            a = this._fixX(a), b = this._fixY(b);
            for (var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length;) this._results.pop();
            for (var l = i; l < i + k; l++)
                for (var m = h; m < h + j; m++) {
                    var n = this.layer.data[l];
                    n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m])
                }
            return this._results.slice()
        }, c.TilemapLayer.prototype.resolveTileset = function(a) {
            var b = this._mc.tilesets;
            if (a < 2e3)
                for (; b.length < a;) b.push(void 0);
            var c = this.map.tiles[a] && this.map.tiles[a][2];
            if (null !== c) { var d = this.map.tilesets[c]; if (d && d.containsTileIndex(a)) return b[a] = d }
            return b[a] = null
        }, c.TilemapLayer.prototype.resetTilesetCache = function() { for (var a = this._mc.tilesets; a.length;) a.pop() }, c.TilemapLayer.prototype.setScale = function(a, b) {
            a = a || 1, b = b || a;
            for (var c = 0; c < this.layer.data.length; c++)
                for (var d = this.layer.data[c], e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.width = this.map.tileWidth * a, f.height = this.map.tileHeight * b, f.worldX = f.x * f.width, f.worldY = f.y * f.height
                }
            this.scale.setTo(a, b)
        }, c.TilemapLayer.prototype.shiftCanvas = function(a, b, c) {
            var d = a.canvas,
                e = d.width - Math.abs(b),
                f = d.height - Math.abs(c),
                g = 0,
                h = 0,
                i = b,
                j = c;
            b < 0 && (g = -b, i = 0), c < 0 && (h = -c, j = 0);
            var k = this.renderSettings.copyCanvas;
            if (k) {
                (k.width < e || k.height < f) && (k.width = e, k.height = f);
                var l = k.getContext("2d");
                l.clearRect(0, 0, e, f), l.drawImage(d, g, h, e, f, 0, 0, e, f), a.clearRect(i, j, e, f), a.drawImage(k, 0, 0, e, f, i, j, e, f)
            }
            else a.save(), a.globalCompositeOperation = "copy", a.drawImage(d, g, h, e, f, i, j, e, f), a.restore()
        }, c.TilemapLayer.prototype.renderRegion = function(a, b, c, d, e, f) {
            var g = this.context,
                h = this.layer.width,
                i = this.layer.height,
                j = this._mc.tileWidth,
                k = this._mc.tileHeight,
                l = this._mc.tilesets,
                m = NaN;
            this._wrap || (c <= e && (c = Math.max(0, c), e = Math.min(h - 1, e)), d <= f && (d = Math.max(0, d), f = Math.min(i - 1, f)));
            var n, o, p, q, r, s, t = c * j - a,
                u = d * k - b,
                v = (c + (1 << 20) * h) % h,
                w = (d + (1 << 20) * i) % i;
            for (q = w, s = f - d, o = u; s >= 0; q++, s--, o += k) {
                q >= i && (q -= i);
                var x = this.layer.data[q];
                for (p = v, r = e - c, n = t; r >= 0; p++, r--, n += j) {
                    p >= h && (p -= h);
                    var y = x[p];
                    if (y && !(y.index < 0)) {
                        var z = y.index,
                            A = l[z];
                        void 0 === A && (A = this.resolveTileset(z)), y.alpha === m || this.debug || (g.globalAlpha = y.alpha, m = y.alpha), A ? y.rotation || y.flipped ? (g.save(), g.translate(n + y.centerX, o + y.centerY), g.rotate(y.rotation), y.flipped && g.scale(-1, 1), A.draw(g, -y.centerX, -y.centerY, z), g.restore()) : A.draw(g, n, o, z) : this.debugSettings.missingImageFill && (g.fillStyle = this.debugSettings.missingImageFill, g.fillRect(n, o, j, k)), y.debug && this.debugSettings.debuggedTileOverfill && (g.fillStyle = this.debugSettings.debuggedTileOverfill, g.fillRect(n, o, j, k))
                    }
                }
            }
        }, c.TilemapLayer.prototype.renderDeltaScroll = function(a, b) {
            var c = this._mc.scrollX,
                d = this._mc.scrollY,
                e = this.canvas.width,
                f = this.canvas.height,
                g = this._mc.tileWidth,
                h = this._mc.tileHeight,
                i = 0,
                j = -g,
                k = 0,
                l = -h;
            if (a < 0 ? (i = e + a, j = e - 1) : a > 0 && (j = a), b < 0 ? (k = f + b, l = f - 1) : b > 0 && (l = b), this.shiftCanvas(this.context, a, b), i = Math.floor((i + c) / g), j = Math.floor((j + c) / g), k = Math.floor((k + d) / h), l = Math.floor((l + d) / h), i <= j) {
                this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
                var m = Math.floor((0 + d) / h),
                    n = Math.floor((f - 1 + d) / h);
                this.renderRegion(c, d, i, m, j, n)
            }
            if (k <= l) {
                this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
                var o = Math.floor((0 + c) / g),
                    p = Math.floor((e - 1 + c) / g);
                this.renderRegion(c, d, o, k, p, l)
            }
        }, c.TilemapLayer.prototype.renderFull = function() {
            var a = this._mc.scrollX,
                b = this._mc.scrollY,
                c = this.canvas.width,
                d = this.canvas.height,
                e = this._mc.tileWidth,
                f = this._mc.tileHeight,
                g = Math.floor(a / e),
                h = Math.floor((c - 1 + a) / e),
                i = Math.floor(b / f),
                j = Math.floor((d - 1 + b) / f);
            this.context.clearRect(0, 0, c, d), this.renderRegion(a, b, g, i, h, j)
        }, c.TilemapLayer.prototype.render = function() {
            var a = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, a = !0);
                var b = this.canvas.width,
                    c = this.canvas.height,
                    d = 0 | this._scrollX,
                    e = 0 | this._scrollY,
                    f = this._mc,
                    g = f.scrollX - d,
                    h = f.scrollY - e;
                if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c) return this.context.save(), f.scrollX = d, f.scrollY = e, f.renderWidth === b && f.renderHeight === c || (f.renderWidth = b, f.renderHeight = c), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (a = !0)), !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, c.TilemapLayer.prototype.renderDebug = function() {
            var a, b, c, d, e, f, g = this._mc.scrollX,
                h = this._mc.scrollY,
                i = this.context,
                j = this.canvas.width,
                k = this.canvas.height,
                l = this.layer.width,
                m = this.layer.height,
                n = this._mc.tileWidth,
                o = this._mc.tileHeight,
                p = Math.floor(g / n),
                q = Math.floor((j - 1 + g) / n),
                r = Math.floor(h / o),
                s = Math.floor((k - 1 + h) / o),
                t = p * n - g,
                u = r * o - h,
                v = (p + (1 << 20) * l) % l,
                w = (r + (1 << 20) * m) % m;
            for (i.strokeStyle = this.debugSettings.facingEdgeStroke, d = w, f = s - r, b = u; f >= 0; d++, f--, b += o) { d >= m && (d -= m); var x = this.layer.data[d]; for (c = v, e = q - p, a = t; e >= 0; c++, e--, a += n) { c >= l && (c -= l); var y = x[c];!y || y.index < 0 || !y.collides || (this.debugSettings.collidingTileOverfill && (i.fillStyle = this.debugSettings.collidingTileOverfill, i.fillRect(a, b, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (i.beginPath(), y.faceTop && (i.moveTo(a, b), i.lineTo(a + this._mc.cw, b)), y.faceBottom && (i.moveTo(a, b + this._mc.ch), i.lineTo(a + this._mc.cw, b + this._mc.ch)), y.faceLeft && (i.moveTo(a, b), i.lineTo(a, b + this._mc.ch)), y.faceRight && (i.moveTo(a + this._mc.cw, b), i.lineTo(a + this._mc.cw, b + this._mc.ch)), i.closePath(), i.stroke())) } }
        }, Object.defineProperty(c.TilemapLayer.prototype, "wrap", { get: function() { return this._wrap }, set: function(a) { this._wrap = a, this.dirty = !0 } }), Object.defineProperty(c.TilemapLayer.prototype, "scrollX", { get: function() { return this._scrollX }, set: function(a) { this._scrollX = a } }), Object.defineProperty(c.TilemapLayer.prototype, "scrollY", { get: function() { return this._scrollY }, set: function(a) { this._scrollY = a } }), Object.defineProperty(c.TilemapLayer.prototype, "collisionWidth", { get: function() { return this._mc.cw }, set: function(a) { this._mc.cw = 0 | a, this.dirty = !0 } }), Object.defineProperty(c.TilemapLayer.prototype, "collisionHeight", { get: function() { return this._mc.ch }, set: function(a) { this._mc.ch = 0 | a, this.dirty = !0 } }), c.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(a, b, d, e, f, g) { if (void 0 === d && (d = 32), void 0 === e && (e = 32), void 0 === f && (f = 10), void 0 === g && (g = 10), void 0 === b) return this.getEmptyData(); if (null === b) return this.getEmptyData(d, e, f, g); var h = a.cache.getTilemapData(b); if (h) { if (h.format === c.Tilemap.CSV) return this.parseCSV(b, h.data, d, e); if (!h.format || h.format === c.Tilemap.TILED_JSON) return this.parseTiledJSON(h.data) } },
            parseCSV: function(a, b, d, e) {
                var f = this.getEmptyData();
                b = b.trim();
                for (var g = [], h = b.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++) {
                    g[k] = [];
                    for (var l = h[k].split(","), m = 0; m < l.length; m++) g[k][m] = new c.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
                    0 === j && (j = l.length)
                }
                return f.format = c.Tilemap.CSV, f.name = a, f.width = j, f.height = i, f.tileWidth = d, f.tileHeight = e, f.widthInPixels = j * d, f.heightInPixels = i * e, f.layers[0].width = j, f.layers[0].height = i, f.layers[0].widthInPixels = f.widthInPixels, f.layers[0].heightInPixels = f.heightInPixels, f.layers[0].data = g, f
            },
            getEmptyData: function(a, b, c, d) { return { width: void 0 !== c && null !== c ? c : 0, height: void 0 !== d && null !== d ? d : 0, tileWidth: void 0 !== a && null !== a ? a : 0, tileHeight: void 0 !== b && null !== b ? b : 0, orientation: "orthogonal", version: "1", properties: {}, widthInPixels: 0, heightInPixels: 0, layers: [{ name: "layer", x: 0, y: 0, width: 0, height: 0, widthInPixels: 0, heightInPixels: 0, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: [] }], images: [], objects: {}, collision: {}, tilesets: [], tiles: [] } },
            parseTiledJSON: function(a) {
                function b(a, b) { var c = {}; for (var d in b) { var e = b[d]; "undefined" != typeof a[e] && (c[e] = a[e]) } return c }
                if ("orthogonal" !== a.orientation) return null;
                for (var d = { width: a.width, height: a.height, tileWidth: a.tilewidth, tileHeight: a.tileheight, orientation: a.orientation, format: c.Tilemap.TILED_JSON, version: a.version, properties: a.properties, widthInPixels: a.width * a.tilewidth, heightInPixels: a.height * a.tileheight }, e = [], f = 0; f < a.layers.length; f++)
                    if ("tilelayer" === a.layers[f].type) {
                        var g = a.layers[f];
                        if (!g.compression && g.encoding && "base64" === g.encoding) {
                            for (var h = window.atob(g.data), i = h.length, j = new Array(i), k = 0; k < i; k += 4) j[k / 4] = (h.charCodeAt(k) | h.charCodeAt(k + 1) << 8 | h.charCodeAt(k + 2) << 16 | h.charCodeAt(k + 3) << 24) >>> 0;
                            g.data = j, delete g.encoding
                        }
                        else if (g.compression) continue;
                        var l = { name: g.name, x: g.x, y: g.y, width: g.width, height: g.height, widthInPixels: g.width * a.tilewidth, heightInPixels: g.height * a.tileheight, alpha: g.opacity, visible: g.visible, properties: {}, indexes: [], callbacks: [], bodies: [] };
                        g.properties && (l.properties = g.properties);
                        for (var m, n, o, p, q = 0, r = [], s = [], t = 0, i = g.data.length; t < i; t++) {
                            if (m = 0, n = !1, p = g.data[t], o = 0, p > 536870912) switch (p > 2147483648 && (p -= 2147483648, o += 4), p > 1073741824 && (p -= 1073741824, o += 2), p > 536870912 && (p -= 536870912, o += 1), o) {
                                case 5:
                                    m = Math.PI / 2;
                                    break;
                                case 6:
                                    m = Math.PI;
                                    break;
                                case 3:
                                    m = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    m = 0, n = !0;
                                    break;
                                case 7:
                                    m = Math.PI / 2, n = !0;
                                    break;
                                case 2:
                                    m = Math.PI, n = !0;
                                    break;
                                case 1:
                                    m = 3 * Math.PI / 2, n = !0
                            }
                            if (p > 0) {
                                var u = new c.Tile(l, p, q, s.length, a.tilewidth, a.tileheight);
                                u.rotation = m, u.flipped = n, 0 !== o && (u.flippedVal = o), r.push(u)
                            }
                            else c.TilemapParser.INSERT_NULL ? r.push(null) : r.push(new c.Tile(l, (-1), q, s.length, a.tilewidth, a.tileheight));
                            q++, q === g.width && (s.push(r), q = 0, r = [])
                        }
                        l.data = s, e.push(l)
                    }
                d.layers = e;
                for (var v = [], f = 0; f < a.layers.length; f++)
                    if ("imagelayer" === a.layers[f].type) {
                        var w = a.layers[f],
                            x = { name: w.name, image: w.image, x: w.x, y: w.y, alpha: w.opacity, visible: w.visible, properties: {} };
                        w.properties && (x.properties = w.properties), v.push(x)
                    }
                d.images = v;
                for (var y = [], z = [], A = null, f = 0; f < a.tilesets.length; f++) {
                    var B = a.tilesets[f];
                    if (B.image) {
                        var C = new c.Tileset(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                        B.tileproperties && (C.tileProperties = B.tileproperties), C.updateTileData(B.imagewidth, B.imageheight), y.push(C)
                    }
                    else {
                        var D = new c.ImageCollection(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
                        for (var E in B.tiles) {
                            var x = B.tiles[E].image,
                                p = B.firstgid + parseInt(E, 10);
                            D.addImage(p, x)
                        }
                        z.push(D)
                    }
                    A && (A.lastgid = B.firstgid - 1), A = B
                }
                d.tilesets = y, d.imagecollections = z;
                for (var F = {}, G = {}, f = 0; f < a.layers.length; f++)
                    if ("objectgroup" === a.layers[f].type) {
                        var H = a.layers[f];
                        F[H.name] = [], G[H.name] = [];
                        for (var I = 0, i = H.objects.length; I < i; I++)
                            if (H.objects[I].gid) {
                                var J = { gid: H.objects[I].gid, name: H.objects[I].name, type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "", x: H.objects[I].x, y: H.objects[I].y, visible: H.objects[I].visible, properties: H.objects[I].properties };
                                H.objects[I].rotation && (J.rotation = H.objects[I].rotation), F[H.name].push(J)
                            }
                        else if (H.objects[I].polyline) {
                            var J = { name: H.objects[I].name, type: H.objects[I].type, x: H.objects[I].x, y: H.objects[I].y, width: H.objects[I].width, height: H.objects[I].height, visible: H.objects[I].visible, properties: H.objects[I].properties };
                            H.objects[I].rotation && (J.rotation = H.objects[I].rotation), J.polyline = [];
                            for (var K = 0; K < H.objects[I].polyline.length; K++) J.polyline.push([H.objects[I].polyline[K].x, H.objects[I].polyline[K].y]);
                            G[H.name].push(J), F[H.name].push(J)
                        }
                        else if (H.objects[I].polygon) {
                            var J = b(H.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                            J.polygon = [];
                            for (var K = 0; K < H.objects[I].polygon.length; K++) J.polygon.push([H.objects[I].polygon[K].x, H.objects[I].polygon[K].y]);
                            F[H.name].push(J)
                        }
                        else if (H.objects[I].ellipse) {
                            var J = b(H.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            F[H.name].push(J)
                        }
                        else {
                            var J = b(H.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            J.rectangle = !0, F[H.name].push(J)
                        }
                    }
                d.objects = F, d.collision = G, d.tiles = [];
                for (var f = 0; f < d.tilesets.length; f++)
                    for (var B = d.tilesets[f], q = B.tileMargin, L = B.tileMargin, M = 0, N = 0, O = 0, t = B.firstgid; t < B.firstgid + B.total && (d.tiles[t] = [q, L, f], q += B.tileWidth + B.tileSpacing, M++, M !== B.total) && (N++, N !== B.columns || (q = B.tileMargin, L += B.tileHeight + B.tileSpacing, N = 0, O++, O !== B.rows)); t++);
                for (var l, u, P, B, f = 0; f < d.layers.length; f++) { l = d.layers[f], B = null; for (var k = 0; k < l.data.length; k++) { r = l.data[k]; for (var Q = 0; Q < r.length; Q++) u = r[Q], null === u || u.index < 0 || (P = d.tiles[u.index][2], B = d.tilesets[P], B.tileProperties && B.tileProperties[u.index - B.firstgid] && (u.properties = c.Utils.mixin(B.tileProperties[u.index - B.firstgid], u.properties))) } }
                return d
            }
        }, c.Tileset = function(a, b, c, d, e, f, g) {
            (void 0 === c || c <= 0) && (c = 32), (void 0 === d || d <= 0) && (d = 32), void 0 === e && (e = 0), void 0 === f && (f = 0), this.name = a, this.firstgid = 0 | b, this.tileWidth = 0 | c, this.tileHeight = 0 | d, this.tileMargin = 0 | e, this.tileSpacing = 0 | f, this.properties = g || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, c.Tileset.prototype = {
            draw: function(a, b, c, d) {
                var e = d - this.firstgid << 1;
                e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(a) { return a >= this.firstgid && a < this.firstgid + this.total },
            setImage: function(a) { this.image = a, this.updateTileData(a.width, a.height) },
            setSpacing: function(a, b) { this.tileMargin = 0 | a, this.tileSpacing = 0 | b, this.image && this.updateTileData(this.image.width, this.image.height) },
            updateTileData: function(a, b) {
                var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                c = Math.floor(c), d = Math.floor(d), this.rows && this.rows !== c || this.columns && this.columns !== d, this.rows = c, this.columns = d, this.total = c * d, this.drawCoords.length = 0;
                for (var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++) {
                    for (var h = 0; h < this.columns; h++) this.drawCoords.push(e), this.drawCoords.push(f), e += this.tileWidth + this.tileSpacing;
                    e = this.tileMargin, f += this.tileHeight + this.tileSpacing
                }
            }
        }, c.Tileset.prototype.constructor = c.Tileset, c.Particle = function(a, b, d, e, f) { c.Sprite.call(this, a, b, d, e, f), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0 }, c.Particle.prototype = Object.create(c.Sprite.prototype), c.Particle.prototype.constructor = c.Particle, c.Particle.prototype.update = function() { this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1) }, c.Particle.prototype.onEmit = function() {}, c.Particle.prototype.setAlphaData = function(a) { this.alphaData = a, this._a = a.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0 }, c.Particle.prototype.setScaleData = function(a) { this.scaleData = a, this._s = a.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0 }, c.Particle.prototype.reset = function(a, b, d) { return c.Component.Reset.prototype.reset.call(this, a, b, d), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this }, c.Particles = function(a) { this.game = a, this.emitters = {}, this.ID = 0 }, c.Particles.prototype = { add: function(a) { return this.emitters[a.name] = a, a }, remove: function(a) { delete this.emitters[a.name] }, update: function() { for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update() } }, c.Particles.prototype.constructor = c.Particles, c.Particles.Arcade = {}, c.Particles.Arcade.Emitter = function(a, b, d, e) { this.maxParticles = e || 50, c.Group.call(this, a), this.name = "emitter" + this.game.particles.ID++, this.type = c.EMITTER, this.physicsType = c.GROUP, this.area = new c.Rectangle(b, d, 1, 1), this.minParticleSpeed = new c.Point((-100), (-100)), this.maxParticleSpeed = new c.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = c.Particle, this.particleDrag = new c.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new c.Point, this.on = !1, this.particleAnchor = new c.Point(.5, .5), this.blendMode = c.blendModes.NORMAL, this.emitX = b, this.emitY = d, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new c.Point(1, 1), this._maxParticleScale = new c.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null }, c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype), c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter, c.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) {
                        for (var a = 0; a < this._flowQuantity; a++)
                            if (this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal)) { this.on = !1; break }
                    }
            else this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
            for (var a = this.children.length; a--;) this.children[a].exists && this.children[a].update()
        }, c.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, c, d, e) {
            void 0 === b && (b = 0), void 0 === c && (c = this.maxParticles), void 0 === d && (d = !1), void 0 === e && (e = !1);
            var f, g = 0,
                h = a,
                i = b;
            for (this._frames = b, c > this.maxParticles && (this.maxParticles = c); g < c;) Array.isArray(a) && (h = this.game.rnd.pick(a)), Array.isArray(b) && (i = this.game.rnd.pick(b)), f = new this.particleClass(this.game, 0, 0, h, i), this.game.physics.arcade.enable(f, !1), d ? (f.body.checkCollision.any = !0, f.body.checkCollision.none = !1) : f.body.checkCollision.none = !0, f.body.collideWorldBounds = e, f.body.skipQuadTree = !0, f.exists = !1, f.visible = !1, f.anchor.copyFrom(this.particleAnchor), this.add(f), g++;
            return this
        }, c.Particles.Arcade.Emitter.prototype.kill = function() { return this.on = !1, this.alive = !1, this.exists = !1, this }, c.Particles.Arcade.Emitter.prototype.revive = function() { return this.alive = !0, this.exists = !0, this }, c.Particles.Arcade.Emitter.prototype.explode = function(a, b) { return this._flowTotal = 0, this.start(!0, a, 0, b, !1), this }, c.Particles.Arcade.Emitter.prototype.flow = function(a, b, c, d, e) { return void 0 !== c && 0 !== c || (c = 1), void 0 === d && (d = -1), void 0 === e && (e = !0), c > this.maxParticles && (c = this.maxParticles), this._counter = 0, this._flowQuantity = c, this._flowTotal = d, e ? (this.start(!0, a, b, c), this._counter += c, this.on = !0, this._timer = this.game.time.time + b * this.game.time.slowMotion) : this.start(!1, a, b, c), this }, c.Particles.Arcade.Emitter.prototype.start = function(a, b, c, d, e) {
            if (void 0 === a && (a = !0), void 0 === b && (b = 0), void 0 !== c && null !== c || (c = 250), void 0 === d && (d = 0), void 0 === e && (e = !1), d > this.maxParticles && (d = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = b, this.frequency = c, a || e)
                for (var f = 0; f < d; f++) this.emitParticle();
            else this.on = !0, this._quantity = d, this._counter = 0, this._timer = this.game.time.time + c * this.game.time.slowMotion;
            return this
        }, c.Particles.Arcade.Emitter.prototype.emitParticle = function(a, b, c, d) {
            void 0 === a && (a = null), void 0 === b && (b = null);
            var e = this.getFirstExists(!1);
            if (null === e) return !1;
            var f = this.game.rnd;
            void 0 !== c && void 0 !== d ? e.loadTexture(c, d) : void 0 !== c && e.loadTexture(c);
            var g = this.emitX,
                h = this.emitY;
            null !== a ? g = a : this.width > 1 && (g = f.between(this.left, this.right)), null !== b ? h = b : this.height > 1 && (h = f.between(this.top, this.bottom)), e.reset(g, h), e.angle = 0, e.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(e) : this.particleSendToBack && this.sendToBack(e), this.autoScale ? e.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y)),
                void 0 === d && (Array.isArray(this._frames) ? e.frame = this.game.rnd.pick(this._frames) : e.frame = this._frames), this.autoAlpha ? e.setAlphaData(this.alphaData) : e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha), e.blendMode = this.blendMode;
            var i = e.body;
            return i.updateBounds(), i.bounce.copyFrom(this.bounce), i.drag.copyFrom(this.particleDrag), i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), i.angularVelocity = f.between(this.minRotation, this.maxRotation), i.gravity.y = this.gravity, i.angularDrag = this.angularDrag, e.onEmit(), !0
        }, c.Particles.Arcade.Emitter.prototype.destroy = function() { this.game.particles.remove(this), c.Group.prototype.destroy.call(this, !0, !1) }, c.Particles.Arcade.Emitter.prototype.setSize = function(a, b) { return this.area.width = a, this.area.height = b, this }, c.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) { return a = a || 0, b = b || 0, this.minParticleSpeed.x = a, this.maxParticleSpeed.x = b, this }, c.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) { return a = a || 0, b = b || 0, this.minParticleSpeed.y = a, this.maxParticleSpeed.y = b, this }, c.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) { return a = a || 0, b = b || 0, this.minRotation = a, this.maxRotation = b, this }, c.Particles.Arcade.Emitter.prototype.setAlpha = function(a, b, d, e, f) {
            if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 0), void 0 === e && (e = c.Easing.Linear.None), void 0 === f && (f = !1), this.minParticleAlpha = a, this.maxParticleAlpha = b, this.autoAlpha = !1, d > 0 && a !== b) {
                var g = { v: a },
                    h = this.game.make.tween(g).to({ v: b }, d, e);
                h.yoyo(f), this.alphaData = h.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, c.Particles.Arcade.Emitter.prototype.setScale = function(a, b, d, e, f, g, h) {
            if (void 0 === a && (a = 1), void 0 === b && (b = 1), void 0 === d && (d = 1), void 0 === e && (e = 1), void 0 === f && (f = 0), void 0 === g && (g = c.Easing.Linear.None), void 0 === h && (h = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(a, d), this._maxParticleScale.set(b, e), this.autoScale = !1, f > 0 && (a !== b || d !== e)) {
                var i = { x: a, y: d },
                    j = this.game.make.tween(i).to({ x: b, y: e }, f, g);
                j.yoyo(h), this.scaleData = j.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, c.Particles.Arcade.Emitter.prototype.at = function(a) { return a.center ? (this.emitX = a.center.x, this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width, this.emitY = a.world.y + a.anchor.y * a.height), this }, Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "width", { get: function() { return this.area.width }, set: function(a) { this.area.width = a } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "height", { get: function() { return this.area.height }, set: function(a) { this.area.height = a } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", { get: function() { return this.emitX }, set: function(a) { this.emitX = a } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", { get: function() { return this.emitY }, set: function(a) { this.emitY = a } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", { get: function() { return Math.floor(this.x - this.area.width / 2) } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "right", { get: function() { return Math.floor(this.x + this.area.width / 2) } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", { get: function() { return Math.floor(this.y - this.area.height / 2) } }), Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", { get: function() { return Math.floor(this.y + this.area.height / 2) } }), c.Weapon = function(a, b) { c.Plugin.call(this, a, b), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new c.Rectangle(0, 0, 1, 1), this.fireAngle = c.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new c.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = c.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = c.Weapon.KILL_WORLD_BOUNDS, this._data = { customBody: !1, width: 0, height: 0, offsetX: 0, offsetY: 0 }, this.bounds = new c.Rectangle, this.bulletBounds = a.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new c.Signal, this.onKill = new c.Signal, this.onFireLimit = new c.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new c.Point, this._nextFire = 0, this._rotatedPoint = new c.Point }, c.Weapon.prototype = Object.create(c.Plugin.prototype), c.Weapon.prototype.constructor = c.Weapon, c.Weapon.KILL_NEVER = 0, c.Weapon.KILL_LIFESPAN = 1, c.Weapon.KILL_DISTANCE = 2, c.Weapon.KILL_WEAPON_BOUNDS = 3, c.Weapon.KILL_CAMERA_BOUNDS = 4, c.Weapon.KILL_WORLD_BOUNDS = 5, c.Weapon.KILL_STATIC_BOUNDS = 6, c.Weapon.prototype.createBullets = function(a, b, d, e) { return void 0 === a && (a = 1), void 0 === e && (e = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(c.Physics.ARCADE, e), this.bullets.classType = this._bulletClass), 0 !== a && (a === -1 && (this.autoExpandBulletsGroup = !0, a = 1), this.bullets.createMultiple(a, b, d), this.bullets.setAll("data.bulletManager", this), this.bulletKey = b, this.bulletFrame = d), this }, c.Weapon.prototype.forEach = function(a, b) { return this.bullets.forEachExists(a, b, arguments), this }, c.Weapon.prototype.pauseAll = function() { return this.bullets.setAll("body.enable", !1), this }, c.Weapon.prototype.resumeAll = function() { return this.bullets.setAll("body.enable", !0), this }, c.Weapon.prototype.killAll = function() { return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this }, c.Weapon.prototype.resetShots = function(a) { return this.shots = 0, void 0 !== a && (this.fireLimit = a), this }, c.Weapon.prototype.destroy = function() { this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1 }, c.Weapon.prototype.update = function() { this._bulletKillType === c.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire() }, c.Weapon.prototype.trackSprite = function(a, b, c, d) { return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = !1), this.trackedPointer = null, this.trackedSprite = a, this.trackRotation = d, this.trackOffset.set(b, c), this }, c.Weapon.prototype.trackPointer = function(a, b, c) { return void 0 === a && (a = this.game.input.activePointer), void 0 === b && (b = 0), void 0 === c && (c = 0), this.trackedPointer = a, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(b, c), this }, c.Weapon.prototype.fire = function(a, b, d) {
            if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
            var e = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (e += c.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), a ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(a.x, a.y) : (this.fireFrom.x = a.x, this.fireFrom.y = a.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (e += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
            var f = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                g = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== b && void 0 !== d && (h = this.game.math.radToDeg(Math.atan2(d - g, b - f))), 0 !== this.bulletAngleVariance && (h += c.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var i = 0,
                j = 0;
            0 === h || 180 === h ? i = Math.cos(this.game.math.degToRad(h)) * e : 90 === h || 270 === h ? j = Math.sin(this.game.math.degToRad(h)) * e : (i = Math.cos(this.game.math.degToRad(h)) * e, j = Math.sin(this.game.math.degToRad(h)) * e);
            var k = null;
            if (this.autoExpandBulletsGroup ? (k = this.bullets.getFirstExists(!1, !0, f, g, this.bulletKey, this.bulletFrame), k.data.bulletManager = this) : k = this.bullets.getFirstExists(!1), k) {
                if (k.reset(f, g), k.data.fromX = f, k.data.fromY = g, k.data.killType = this.bulletKillType, k.data.killDistance = this.bulletKillDistance, k.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === c.Weapon.KILL_LIFESPAN && (k.lifespan = this.bulletLifespan), k.angle = h + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === k.animations.getAnimation(this.bulletAnimation)) {
                        var l = this.anims[this.bulletAnimation];
                        k.animations.add(l.name, l.frames, l.frameRate, l.loop, l.useNumericIndex)
                    }
                    k.animations.play(this.bulletAnimation)
                }
                else this.bulletFrameCycle ? (k.frame = this.bulletFrames[this.bulletFrameIndex], this.bulletFrameIndex++, this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (k.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                if (k.data.bodyDirty && (this._data.customBody && k.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), k.body.collideWorldBounds = this.bulletCollideWorldBounds, k.data.bodyDirty = !1), k.body.velocity.set(i, j), k.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                    var m = this.fireRate;
                    m += c.Math.between(-this.fireRateVariance, this.fireRateVariance), m < 0 && (m = 0), this._nextFire = this.game.time.now + m
                }
                else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(k, this, e), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return k
        }, c.Weapon.prototype.fireAtPointer = function(a) { return void 0 === a && (a = this.game.input.activePointer), this.fire(null, a.worldX, a.worldY) }, c.Weapon.prototype.fireAtSprite = function(a) { return this.fire(null, a.world.x, a.world.y) }, c.Weapon.prototype.fireAtXY = function(a, b) { return this.fire(null, a, b) }, c.Weapon.prototype.setBulletBodyOffset = function(a, b, c, d) { return void 0 === c && (c = 0), void 0 === d && (d = 0), this._data.customBody = !0, this._data.width = a, this._data.height = b, this._data.offsetX = c, this._data.offsetY = d, this.bullets.callAll("body.setSize", "body", a, b, c, d), this.bullets.setAll("data.bodyDirty", !1), this }, c.Weapon.prototype.setBulletFrames = function(a, b, d, e) { return void 0 === d && (d = !0), void 0 === e && (e = !1), this.bulletFrames = c.ArrayUtils.numberArray(a, b), this.bulletFrameIndex = 0, this.bulletFrameCycle = d, this.bulletFrameRandom = e, this }, c.Weapon.prototype.addBulletAnimation = function(a, b, c, d, e) { return this.anims[a] = { name: a, frames: b, frameRate: c, loop: d, useNumericIndex: e }, this.bullets.callAll("animations.add", "animations", a, b, c, d, e), this.bulletAnimation = a, this }, c.Weapon.prototype.debug = function(a, b, c) { void 0 === a && (a = 16), void 0 === b && (b = 32), void 0 === c && (c = !1), this.game.debug.text("Weapon Plugin", a, b), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24), c && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)") }, Object.defineProperty(c.Weapon.prototype, "bulletClass", { get: function() { return this._bulletClass }, set: function(a) { this._bulletClass = a, this.bullets.classType = this._bulletClass } }), Object.defineProperty(c.Weapon.prototype, "bulletKillType", {
            get: function() { return this._bulletKillType },
            set: function(a) {
                switch (a) {
                    case c.Weapon.KILL_STATIC_BOUNDS:
                    case c.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case c.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case c.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = a
            }
        }), Object.defineProperty(c.Weapon.prototype, "bulletCollideWorldBounds", { get: function() { return this._bulletCollideWorldBounds }, set: function(a) { this._bulletCollideWorldBounds = a, this.bullets.setAll("body.collideWorldBounds", a), this.bullets.setAll("data.bodyDirty", !1) } }), Object.defineProperty(c.Weapon.prototype, "x", { get: function() { return this.fireFrom.x }, set: function(a) { this.fireFrom.x = a } }), Object.defineProperty(c.Weapon.prototype, "y", { get: function() { return this.fireFrom.y }, set: function(a) { this.fireFrom.y = a } }), c.Bullet = function(a, b, d, e, f) { c.Sprite.call(this, a, b, d, e, f), this.anchor.set(.5), this.data = { bulletManager: null, fromX: 0, fromY: 0, bodyDirty: !0, rotateToVelocity: !1, killType: 0, killDistance: 0 } }, c.Bullet.prototype = Object.create(c.Sprite.prototype), c.Bullet.prototype.constructor = c.Bullet, c.Bullet.prototype.kill = function() { return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this }, c.Bullet.prototype.update = function() { this.exists && (this.data.killType > c.Weapon.KILL_LIFESPAN && (this.data.killType === c.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding)) }, c.Video = function(a, b, d) {
            if (void 0 === b && (b = null), void 0 === d && (d = null), this.game = a, this.key = b, this.width = 0, this.height = 0, this.type = c.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new c.Signal, this.onChangeSource = new c.Signal, this.onComplete = new c.Signal, this.onAccess = new c.Signal, this.onError = new c.Signal, this.onTimeout = new c.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, b && this.game.cache.checkVideoKey(b)) {
                var e = this.game.cache.getVideo(b);
                e.isBlob ? this.createVideoFromBlob(e.data) : this.video = e.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            }
            else d && this.createVideoFromURL(d, !1);
            this.video && !d ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(c.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new c.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== b && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, c.BitmapData && (this.snapshot = new c.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.chrome) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : e && (e.locked = !1)
        }, c.Video.prototype = {
            connectToMediaStream: function(a, b) { return a && b && (this.video = a, this.videoStream = b, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this },
            startMediaStream: function(a, b, c) {
                if (void 0 === a && (a = !1), void 0 === b && (b = null), void 0 === c && (c = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== b && (this.video.width = b), null !== c && (this.video.height = c), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try { navigator.getUserMedia({ audio: a, video: !0 }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this)) }
                catch (d) { this.getUserMediaError(d) }
                return this
            },
            getUserMediaTimeout: function() { clearTimeout(this._timeOutID), this.onTimeout.dispatch(this) },
            getUserMediaError: function(a) { clearTimeout(this._timeOutID), this.onError.dispatch(this, a) },
            getUserMediaSuccess: function(a) {
                clearTimeout(this._timeOutID), this.videoStream = a, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = a : this.video.src = window.URL && window.URL.createObjectURL(a) || a;
                var b = this;
                this.video.onloadeddata = function() {
                    function a() {
                        if (c > 0)
                            if (b.video.videoWidth > 0) {
                                var d = b.video.videoWidth,
                                    e = b.video.videoHeight;
                                isNaN(b.video.videoHeight) && (e = d / (4 / 3)), b.video.play(), b.isStreaming = !0, b.baseTexture.source = b.video, b.updateTexture(null, d, e), b.onAccess.dispatch(b)
                            }
                        else window.setTimeout(a, 500);
                        c--
                    }
                    var c = 10;
                    a()
                }
            },
            createVideoFromBlob: function(a) { var b = this; return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(a) { b.updateTexture(a) }, !0), this.video.src = window.URL.createObjectURL(a), this.video.canplay = !0, this },
            createVideoFromURL: function(a, b) { return void 0 === b && (b = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, b && this.video.setAttribute("autoplay", "autoplay"), this.video.src = a, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = a, this },
            updateTexture: function(a, b, c) {
                var d = !1;
                void 0 !== b && null !== b || (b = this.video.videoWidth, d = !0), void 0 !== c && null !== c || (c = this.video.videoHeight), this.width = b, this.height = c, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(b, c), this.texture.frame.resize(b, c), this.texture.width = b, this.texture.height = c, this.texture.valid = !0, this.snapshot && this.snapshot.resize(b, c), d && null !== this.key && (this.onChangeSource.dispatch(this, b, c), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() { this.onComplete.dispatch(this) },
            play: function(a, b) { return void 0 === a && (a = !1), void 0 === b && (b = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), a ? this.video.loop = "loop" : this.video.loop = "", this.video.playbackRate = b, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, a, b)), this },
            playHandler: function() { this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture() },
            stop: function() { return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(a) { a.stop() }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this },
            add: function(a) {
                if (Array.isArray(a))
                    for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
                else a.loadTexture(this);
                return this
            },
            addToWorld: function(a, b, c, d, e, f) { e = e || 1, f = f || 1; var g = this.game.add.image(a, b, this); return g.anchor.set(c, d), g.scale.set(e, f), g },
            render: function() {!this.disableTextureUpload && this.playing && this.baseTexture.dirty() },
            setMute: function() { this._muted || (this._muted = !0, this.video.muted = !0) },
            unsetMute: function() { this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1) },
            setPause: function() { this._paused || this.touchLocked || (this._paused = !0, this.video.pause()) },
            setResume: function() {!this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play()) },
            changeSource: function(a, b) { return void 0 === b && (b = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = a, this.video.load(), this._autoplay = b, b || (this.paused = !0), this },
            checkVideoProgress: function() { 4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))) },
            setTouchLock: function() { this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0 },
            unlock: function() {
                if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                    var a = this.game.cache.getVideo(this.key);
                    a && !a.isBlob && (a.locked = !1)
                }
                return !0
            },
            grab: function(a, b, c) { if (void 0 === a && (a = !1), void 0 === b && (b = 1), void 0 === c && (c = null), null !== this.snapshot) return a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), this.snapshot },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() { this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID) }
        }, Object.defineProperty(c.Video.prototype, "currentTime", { get: function() { return this.video ? this.video.currentTime : 0 }, set: function(a) { this.video.currentTime = a } }), Object.defineProperty(c.Video.prototype, "duration", { get: function() { return this.video ? this.video.duration : 0 } }), Object.defineProperty(c.Video.prototype, "progress", { get: function() { return this.video ? this.video.currentTime / this.video.duration : 0 } }), Object.defineProperty(c.Video.prototype, "mute", {
            get: function() { return this._muted },
            set: function(a) {
                if (a = a || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                }
                else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(c.Video.prototype, "paused", {
            get: function() { return this._paused },
            set: function(a) {
                if (a = a || null, !this.touchLocked)
                    if (a) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    }
                else {
                    if (!this._paused) return;
                    this._codePaused = !1, this.setResume()
                }
            }
        }), Object.defineProperty(c.Video.prototype, "volume", { get: function() { return this.video ? this.video.volume : 1 }, set: function(a) { a < 0 ? a = 0 : a > 1 && (a = 1), this.video && (this.video.volume = a) } }), Object.defineProperty(c.Video.prototype, "playbackRate", { get: function() { return this.video ? this.video.playbackRate : 1 }, set: function(a) { this.video && (this.video.playbackRate = a) } }), Object.defineProperty(c.Video.prototype, "loop", { get: function() { return !!this.video && this.video.loop }, set: function(a) { a && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "") } }), Object.defineProperty(c.Video.prototype, "playing", { get: function() { return !(this.video.paused && this.video.ended) } }), c.Video.prototype.constructor = c.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = c.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = c.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = c.POLYGON, PIXI.Graphics.RECT = c.RECTANGLE, PIXI.Graphics.CIRC = c.CIRCLE, PIXI.Graphics.ELIP = c.ELLIPSE, PIXI.Graphics.RREC = c.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = c), exports.Phaser = c) : "undefined" != typeof define && define.amd ? define("Phaser", function() { return b.Phaser = c }()) : b.Phaser = c, c
    }.call(this), "function" == typeof define && define.amd ? define(x) : "object" == typeof exports ? module.exports = x() : this.SAT = x();
var __extends = this && this.__extends || function() {
        var a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, b) { a.__proto__ = b } || function(a, b) { for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]) };
        return function(b, c) {
            function d() { this.constructor = b } a(b, c), b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d)
        }
    }(),
    PhaserAds;
! function(a) {
    var b;
    ! function(a) { a[a.start = 0] = "start", a[a.firstQuartile = 1] = "firstQuartile", a[a.midPoint = 2] = "midPoint", a[a.thirdQuartile = 3] = "thirdQuartile", a[a.complete = 4] = "complete" }(b = a.AdEvent || (a.AdEvent = {}));
    var c;
    ! function(a) { a[a.interstitial = 0] = "interstitial", a[a.rewarded = 1] = "rewarded", a[a.banner = 2] = "banner", a[a.video = 3] = "video" }(c = a.AdType || (a.AdType = {}));
    var d = function(a) {
        function b(b, c) { var d = a.call(this, b, c) || this; return d.onContentPaused = new Phaser.Signal, d.onContentResumed = new Phaser.Signal, d.onAdProgression = new Phaser.Signal, d.onAdsDisabled = new Phaser.Signal, d.onAdClicked = new Phaser.Signal, d.onAdRewardGranted = new Phaser.Signal, d.onBannerShown = new Phaser.Signal, d.onBannerHidden = new Phaser.Signal, d.bannerActive = !1, d.provider = null, d.wasMuted = !1, Object.defineProperty(b, "ads", { value: d }), d }
        return __extends(b, a), b.prototype.setAdProvider = function(a) { this.provider = a, this.provider.setManager(this) }, b.prototype.showAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not request an ad without an provider, please attach an ad provider!");
            a[0] !== c.banner && (this.wasMuted = this.game.sound.mute, this.game.sound.mute = !0), this.provider.showAd.apply(this.provider, a)
        }, b.prototype.preloadAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not preload an ad without an provider, please attach an ad provider!");
            this.provider.preloadAd.apply(this.provider, a)
        }, b.prototype.destroyAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not destroy an ad without an provider, please attach an ad provider!");
            this.provider.destroyAd.apply(this.provider, a)
        }, b.prototype.hideAd = function() {
            for (var a = [], b = 0; b < arguments.length; b++) a[b] = arguments[b];
            if (null === this.provider) throw new Error("Can not hide an ad without an provider, please attach an ad provider!");
            this.unMuteAfterAd(), this.provider.hideAd.apply(this.provider, a)
        }, b.prototype.adsEnabled = function() { return this.provider.adsEnabled }, b.prototype.unMuteAfterAd = function() { this.wasMuted || (this.game.sound.mute = !1) }, b
    }(Phaser.Plugin);
    a.AdManager = d
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(b) {
        var c;
        ! function(a) { a[a.AdMob = 0] = "AdMob", a[a.MoPub = 1] = "MoPub", a[a.Chartboost = 2] = "Chartboost", a[a.Heyzap = 3] = "Heyzap" }(c = b.CocoonProvider || (b.CocoonProvider = {}));
        var d = function() {
            function b(a, b, d) {
                if (this.adsEnabled = !1, this.banner = null, this.bannerShowable = !1, this.interstitial = null, this.interstitialShowable = !1, this.rewarded = null, this.rewardedShowable = !1, (a.device.cordova || a.device.crosswalk) && Cocoon && Cocoon.Ad) {
                    switch (this.adsEnabled = !0, b) {
                        default:
                            case c.AdMob:
                            this.cocoonProvider = Cocoon.Ad.AdMob;
                        break;
                        case c.Chartboost:
                                this.cocoonProvider = Cocoon.Ad.Chartboost;
                            break;
                        case c.Heyzap:
                                this.cocoonProvider = Cocoon.Ad.Heyzap;
                            break;
                        case c.MoPub:
                                this.cocoonProvider = Cocoon.Ad.MoPub
                    }
                    this.cocoonProvider.configure(d)
                }
            }
            return b.prototype.setManager = function(a) { this.adManager = a }, b.prototype.showAd = function(b) {
                if (!this.adsEnabled) return this.adManager.unMuteAfterAd(), void(b !== a.AdType.banner && this.adManager.onContentResumed.dispatch());
                if (b === a.AdType.banner) {
                    if (!this.bannerShowable || null === this.banner) return void this.adManager.unMuteAfterAd();
                    this.adManager.onBannerShown.dispatch(this.banner.width, this.banner.height), this.adManager.bannerActive = !0, this.banner.show()
                }
                if (b === a.AdType.interstitial) {
                    if (!this.interstitialShowable || null === this.interstitial) return this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch(a.AdType.interstitial);
                    this.interstitial.show()
                }
                if (b === a.AdType.rewarded) {
                    if (!this.rewardedShowable || null === this.rewarded) return this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch(a.AdType.rewarded);
                    this.rewarded.show()
                }
            }, b.prototype.preloadAd = function(b, c, d) {
                var e = this;
                this.adsEnabled && (this.destroyAd(b), b === a.AdType.banner && (this.banner = this.cocoonProvider.createBanner(c), d && this.banner.setLayout(d), this.banner.on("load", function() { e.bannerShowable = !0 }), this.banner.on("fail", function() { e.bannerShowable = !1, e.banner = null }), this.banner.on("click", function() { e.adManager.onAdClicked.dispatch(a.AdType.banner) }), this.banner.on("show", function() {}), this.banner.on("dismiss", function() {}), this.banner.load()), b === a.AdType.interstitial && (this.interstitial = this.cocoonProvider.createInterstitial(c), this.interstitial.on("load", function() { e.interstitialShowable = !0 }), this.interstitial.on("fail", function() { e.interstitialShowable = !1, e.interstitial = null }), this.interstitial.on("click", function() { e.adManager.onAdClicked.dispatch(a.AdType.interstitial) }), this.interstitial.on("show", function() { e.adManager.onContentPaused.dispatch(a.AdType.interstitial) }), this.interstitial.on("dismiss", function() { e.adManager.unMuteAfterAd(), e.adManager.onContentResumed.dispatch(a.AdType.interstitial), e.interstitialShowable = !1, e.interstitial = null }), this.interstitial.load()), b === a.AdType.rewarded && (this.rewarded = this.cocoonProvider.createRewardedVideo(c), this.rewarded.on("load", function() { e.rewardedShowable = !0 }), this.rewarded.on("fail", function() { e.rewardedShowable = !1, e.rewarded = null }), this.rewarded.on("click", function() { e.adManager.onAdClicked.dispatch(a.AdType.rewarded) }), this.rewarded.on("show", function() { e.adManager.onContentPaused.dispatch(a.AdType.rewarded) }), this.rewarded.on("dismiss", function() { e.adManager.unMuteAfterAd(), e.adManager.onContentResumed.dispatch(a.AdType.rewarded), e.rewardedShowable = !1, e.rewarded = null }), this.rewarded.on("reward", function() { e.adManager.unMuteAfterAd(), e.adManager.onAdRewardGranted.dispatch(a.AdType.rewarded), e.rewardedShowable = !1, e.rewarded = null }), this.rewarded.load()))
            }, b.prototype.destroyAd = function(a) { if (this.adsEnabled) { if (a === b.AdType.banner && null !== this.banner) { try { this.cocoonProvider.releaseBanner(this.banner) } catch (b) {} this.banner = null, this.bannerShowable = !1 } a === b.AdType.interstitial && null !== this.interstitial && (this.cocoonProvider.releaseInterstitial(this.interstitial), this.interstitial = null, this.interstitialShowable = !1) } }, b.prototype.hideAd = function(b) {
                this.adsEnabled && (b === a.AdType.interstitial && null !== this.interstitial && this.interstitial.hide(), b === a.AdType.banner && null !== this.banner && (this.adManager.bannerActive && (this.adManager.bannerActive = !1, this.adManager.onBannerHidden.dispatch(this.banner.width, this.banner.height)),
                    this.banner.hide()), b === a.AdType.rewarded && null !== this.rewarded && this.rewarded.hide())
            }, b
        }();
        b.CocoonAds = d
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b = function() {
            function a(a, b, c, d) { void 0 === d && (d = !1), this.adsEnabled = !1, void 0 === cordova.plugins || void 0 !== cordova.plugins && void 0 === cordova.plugins.gdApi || (d && cordova.plugins.gdApi.enableTestAds(), this.setAdListeners(), cordova.plugins.gdApi.init([b, c], function(a) {}, function(a) {})) }
            return a.prototype.setAdListeners = function() {
                var a = this;
                cordova.plugins.gdApi.setAdListener(function(b) {
                    switch (b.event) {
                        case "BANNER_STARTED":
                            a.adManager.onContentPaused.dispatch();
                            break;
                        case "API_IS_READY":
                            a.adsEnabled = !0;
                            break;
                        case "API_ALREADY_INITIALIZED":
                            break;
                        case "BANNER_CLOSED":
                        case "API_NOT_READY":
                        case "BANNER_FAILED":
                            a.adManager.onContentResumed.dispatch()
                    }
                }, function(b) { a.adsEnabled = !1 })
            }, a.prototype.setManager = function(a) { this.adManager = a }, a.prototype.showAd = function(a) {
                var b = this;
                this.adsEnabled ? cordova.plugins.gdApi.showBanner(function(a) {}, function(a) { b.adManager.onContentResumed.dispatch() }) : this.adManager.onContentResumed.dispatch()
            }, a.prototype.preloadAd = function() {}, a.prototype.destroyAd = function() {}, a.prototype.hideAd = function() {}, a
        }();
        a.CordovaGameDistribution = b
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b;
        ! function(a) { a[a.Interstitial = 0] = "Interstitial", a[a.Video = 1] = "Video", a[a.Rewarded = 2] = "Rewarded", a[a.Banner = 3] = "Banner" }(b = a.HeyzapAdTypes || (a.HeyzapAdTypes = {}));
        var c = function() {
            function a(a, b) {
                var c = this;
                this.adsEnabled = !1, (a.device.cordova || a.device.crosswalk) && (this.adsEnabled = !0, HeyzapAds.start(b).then(function() {}, function(a) { c.adsEnabled = !1 }))
            }
            return a.prototype.setManager = function(a) { this.adManager = a }, a.prototype.showAd = function(a, c) {
                var d = this;
                switch (this.adsEnabled || (this.adManager.unMuteAfterAd(), this.adManager.onContentResumed.dispatch()), a) {
                    case b.Interstitial:
                        HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.HIDE, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.HIDE) }), HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.SHOW_FAILED, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.SHOW_FAILED) }), HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.CLICKED, function() { d.adManager.onAdClicked.dispatch(HeyzapAds.InterstitialAd.Events.CLICKED) }), HeyzapAds.InterstitialAd.show().then(function() { d.adManager.onContentPaused.dispatch() }, function(a) { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch() });
                        break;
                    case b.Video:
                        HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.HIDE, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.HIDE) }), HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.SHOW_FAILED, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.SHOW_FAILED) }), HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.CLICKED, function() { d.adManager.onAdClicked.dispatch(HeyzapAds.VideoAd.Events.CLICKED) }), HeyzapAds.VideoAd.show().then(function() { d.adManager.onContentPaused.dispatch() }, function(a) { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch() });
                        break;
                    case b.Rewarded:
                        HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.HIDE, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.HIDE) }), HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED, function() { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED) }), HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.CLICKED, function() { d.adManager.onAdClicked.dispatch(HeyzapAds.IncentivizedAd.Events.CLICKED) }), HeyzapAds.IncentivizedAd.show().then(function() { d.adManager.onContentPaused.dispatch() }, function(a) { d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch() });
                        break;
                    case b.Banner:
                        HeyzapAds.BannerAd.show(c).then(function() {}, function(a) {})
                }
            }, a.prototype.preloadAd = function(a) { this.adsEnabled && a === b.Rewarded && HeyzapAds.IncentivizedAd.fetch().then(function() {}, function(a) {}) }, a.prototype.destroyAd = function(a) { this.adsEnabled && a === b.Banner && HeyzapAds.BannerAd.destroy().then(function() {}, function(a) {}) }, a.prototype.hideAd = function(a) { this.adsEnabled && a === b.Banner && HeyzapAds.BannerAd.hide().then(function() {}, function(a) {}) }, a
        }();
        a.CordovaHeyzap = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(a) {
        var b;
        ! function(a) { a[a.preroll = 0] = "preroll", a[a.midroll = 1] = "midroll" }(b = a.GameDistributionAdType || (a.GameDistributionAdType = {}));
        var c = function() {
            function a(a, b, c) {
                void 0 === c && (c = "");
                var d = this;
                this.adsEnabled = !0, this.areAdsEnabled(), GD_OPTIONS = {
                        gameId: b,
                        userId: c,
                        advertisementSettings: { autoplay: !1 },
                        onEvent: function(a) {
                            switch (a.name) {
                                case "SDK_GAME_START":
                                    "undefined" != typeof gdApi && gdApi.play(), d.adManager.unMuteAfterAd(), d.adManager.onContentResumed.dispatch();
                                    break;
                                case "SDK_GAME_PAUSE":
                                    d.adManager.onContentPaused.dispatch();
                                    break;
                                case "SDK_READY":
                                    break;
                                case "SDK_ERROR":
                            }
                        }
                    },
                    function(a, b, c) {
                        var d, e = a.getElementsByTagName(b)[0];
                        a.getElementById(c) || (d = a.createElement(b), d.id = c, d.src = "//htmi5.api.gamedistribution.com/main.min.js", e.parentNode.insertBefore(d, e))
                    }(document, "script", "gamedistribution-jssdk")
            }
            return a.prototype.setManager = function(a) { this.adManager = a }, a.prototype.showAd = function() {
                if (this.adsEnabled) {
                    if ("undefined" == typeof gdApi || gdApi && "undefined" == typeof gdApi.showBanner) return this.adsEnabled = !1, this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch();
                    gdApi.showBanner()
                }
                else this.adManager.unMuteAfterAd(), this.adManager.onContentResumed.dispatch()
            }, a.prototype.preloadAd = function() {}, a.prototype.destroyAd = function() {}, a.prototype.hideAd = function() {}, a.prototype.areAdsEnabled = function() {
                var a = this,
                    b = document.createElement("div");
                b.innerHTML = "&nbsp;", b.className = "adsbox", b.style.position = "absolute", b.style.fontSize = "10px", document.body.appendChild(b);
                var c = function() { var a = !0; return 0 === b.offsetHeight && (a = !1), b.parentNode.removeChild(b), a };
                window.setTimeout(function() { a.adsEnabled = c() }, 100)
            }, a
        }();
        a.GameDistributionAds = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {}));
var PhaserAds;
! function(a) {
    var b;
    ! function(b) {
        var c = function() {
            function b(a, b) { this.adsManager = null, this.googleEnabled = !1, this.adsEnabled = !0, this.adTagUrl = "", this.adRequested = !1, this.adManager = null, this.resizeListener = null, this.areAdsEnabled(), "undefined" != typeof google && (this.googleEnabled = !0, this.gameContent = "string" == typeof a.parent ? document.getElementById(a.parent) : a.parent, this.gameContent.style.position = "absolute", this.gameContent.style.width = "100%", this.adContent = this.gameContent.parentNode.appendChild(document.createElement("div")), this.adContent.id = "phaser-ad-container", this.adContent.style.position = "absolute", this.adContent.style.zIndex = "9999", this.adContent.style.display = "none", this.adContent.style.top = "0", this.adContent.style.left = "0", this.adContent.style.width = "100%", this.adContent.style.height = "100%", this.adContent.style.overflow = "hidden", this.adTagUrl = b, this.game = a, this.adDisplay = new google.ima.AdDisplayContainer(this.adContent), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale("nl"), this.adLoader = new google.ima.AdsLoader(this.adDisplay), this.adLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdManagerLoader, !1, this), this.adLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this)) }
            return b.prototype.setManager = function(a) { this.adManager = a }, b.prototype.showAd = function(a) {
                if (!this.adRequested) {
                    if (this.adsEnabled || this.adManager.onAdsDisabled.dispatch(!0), !this.googleEnabled) return void this.onContentResumeRequested();
                    this.adDisplay.initialize();
                    var b = new google.ima.AdsRequest;
                    b.adTagUrl = this.adTagUrl + this.parseCustomParams(a);
                    var c = window.innerWidth,
                        d = window.innerHeight;
                    this.game.scale.isFullScreen && document.body.clientHeight < window.innerHeight && (d = document.body.clientHeight, c = document.body.clientWidth), b.linearAdSlotWidth = c, b.linearAdSlotHeight = d, b.nonLinearAdSlotWidth = c, b.nonLinearAdSlotHeight = d, b.forceNonLinearFullSlot = !0;
                    try { this.adRequested = !0, this.adLoader.requestAds(b) }
                    catch (a) { this.onContentResumeRequested() }
                }
            }, b.prototype.preloadAd = function() {}, b.prototype.destroyAd = function() {}, b.prototype.hideAd = function() {}, b.prototype.onAdManagerLoader = function(a) {
                var b = this,
                    c = new google.ima.AdsRenderingSettings;
                c.restoreCustomPlaybackStateOnAdBreakComplete = !0;
                var d = a.getAdsManager(this.gameContent, c);
                this.adsManager = d, d.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested, !1, this), d.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested, !1, this), d.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this), [google.ima.AdEvent.Type.ALL_ADS_COMPLETED, google.ima.AdEvent.Type.CLICK, google.ima.AdEvent.Type.COMPLETE, google.ima.AdEvent.Type.FIRST_QUARTILE, google.ima.AdEvent.Type.LOADED, google.ima.AdEvent.Type.MIDPOINT, google.ima.AdEvent.Type.PAUSED, google.ima.AdEvent.Type.STARTED, google.ima.AdEvent.Type.THIRD_QUARTILE].forEach(function(a) { d.addEventListener(a, b.onAdEvent, !1, b) });
                try {
                    this.adContent.style.display = "block";
                    var e = window.innerWidth,
                        f = window.innerHeight;
                    this.adsManager.init(e, f, google.ima.ViewMode.NORMAL), this.adsManager.start(), this.resizeListener = function() { null !== b.adsManager && b.adsManager.resize(window.innerWidth, window.innerHeight, google.ima.ViewMode.NORMAL) }, window.addEventListener("resize", this.resizeListener)
                }
                catch (a) { this.onAdError(a) }
            }, b.prototype.onAdEvent = function(b) {
                switch (b.type) {
                    case google.ima.AdEvent.Type.CLICK:
                        this.adManager.onAdClicked.dispatch();
                        break;
                    case google.ima.AdEvent.Type.LOADED:
                        this.adRequested = !1;
                        var c = b.getAd();
                        c.isLinear() || this.onContentResumeRequested();
                        break;
                    case google.ima.AdEvent.Type.STARTED:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.start);
                        break;
                    case google.ima.AdEvent.Type.FIRST_QUARTILE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.firstQuartile);
                        break;
                    case google.ima.AdEvent.Type.MIDPOINT:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.midPoint);
                        break;
                    case google.ima.AdEvent.Type.THIRD_QUARTILE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.thirdQuartile);
                        break;
                    case google.ima.AdEvent.Type.COMPLETE:
                        this.adManager.onAdProgression.dispatch(a.AdEvent.complete);
                        break;
                    case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                        this.onContentResumeRequested()
                }
            }, b.prototype.onAdError = function(a) { null !== this.adsManager && (this.adsManager.destroy(), this.adsManager = null, null !== this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null)), this.adRequested && (this.adRequested = !1), this.onContentResumeRequested() }, b.prototype.onContentPauseRequested = function() { this.adManager.onContentPaused.dispatch() }, b.prototype.onContentResumeRequested = function() { return "undefined" == typeof google ? (this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch()) : (this.adContent.style.display = "none", this.adManager.unMuteAfterAd(), void this.adManager.onContentResumed.dispatch()) }, b.prototype.parseCustomParams = function(a) {
                if (void 0 !== a) {
                    var b = "";
                    for (var c in a)
                        if (a.hasOwnProperty(c)) {
                            b.length > 0 && (b += "&");
                            var d = Array.isArray(a[c]) ? a[c].join(",") : a[c];
                            b += c + "=" + d
                        }
                    return "&cust_params=" + encodeURIComponent(b)
                }
                return ""
            }, b.prototype.areAdsEnabled = function() {
                var a = this,
                    b = document.createElement("div");
                b.innerHTML = "&nbsp;", b.className = "adsbox", b.style.position = "absolute", b.style.fontSize = "10px", document.body.appendChild(b);
                var c = function() { var a = !0; return 0 === b.offsetHeight && (a = !1), b.parentNode.removeChild(b), a };
                window.setTimeout(function() { a.adsEnabled = c() }, 100)
            }, b
        }();
        b.Ima3 = c
    }(b = a.AdProvider || (a.AdProvider = {}))
}(PhaserAds || (PhaserAds = {})),
function() {
    function a(a, b, c) { return a.call.apply(a.bind, arguments) }

    function b(a, b, c) { if (!a) throw Error(); if (2 < arguments.length) { var d = Array.prototype.slice.call(arguments, 2); return function() { var c = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(c, d), a.apply(b, c) } } return function() { return a.apply(b, arguments) } }

    function c(d, e, f) { return c = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? a : b, c.apply(null, arguments) }

    function d(a, b) { this.a = a, this.o = b || a, this.c = this.o.document }

    function e(a, b, c, d) {
        if (b = a.c.createElement(b), c)
            for (var e in c) c.hasOwnProperty(e) && ("style" == e ? b.style.cssText = c[e] : b.setAttribute(e, c[e]));
        return d && b.appendChild(a.c.createTextNode(d)), b
    }

    function f(a, b, c) { a = a.c.getElementsByTagName(b)[0], a || (a = document.documentElement), a.insertBefore(c, a.lastChild) }

    function g(a) { a.parentNode && a.parentNode.removeChild(a) }

    function h(a, b, c) {
        b = b || [], c = c || [];
        for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
            for (var f = !1, g = 0; g < d.length; g += 1)
                if (b[e] === d[g]) { f = !0; break }
            f || d.push(b[e])
        }
        for (b = [], e = 0; e < d.length; e += 1) {
            for (f = !1, g = 0; g < c.length; g += 1)
                if (d[e] === c[g]) { f = !0; break }
            f || b.push(d[e])
        }
        a.className = b.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
    }

    function i(a, b) {
        for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++)
            if (c[d] == b) return !0;
        return !1
    }

    function j(a) { return a.o.location.hostname || a.a.location.hostname }

    function k(a, b, c) {
        function d() { j && g && h && (j(i), j = null) } b = e(a, "link", { rel: "stylesheet", href: b, media: "all" });
        var g = !1,
            h = !0,
            i = null,
            j = c || null;
        ba ? (b.onload = function() { g = !0, d() }, b.onerror = function() { g = !0, i = Error("Stylesheet failed to load"), d() }) : setTimeout(function() { g = !0, d() }, 0), f(a, "head", b)
    }

    function l(a, b, c, d) {
        var f = a.c.getElementsByTagName("head")[0];
        if (f) {
            var g = e(a, "script", { src: b }),
                h = !1;
            return g.onload = g.onreadystatechange = function() { h || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (h = !0, c && c(null), g.onload = g.onreadystatechange = null, "HEAD" == g.parentNode.tagName && f.removeChild(g)) }, f.appendChild(g), setTimeout(function() { h || (h = !0, c && c(Error("Script load timeout"))) }, d || 5e3), g
        }
        return null
    }

    function m() { this.a = 0, this.c = null }

    function n(a) {
        return a.a++,
            function() { a.a--, p(a) }
    }

    function o(a, b) { a.c = b, p(a) }

    function p(a) { 0 == a.a && a.c && (a.c(), a.c = null) }

    function q(a) { this.a = a || "-" }

    function r(a, b) {
        this.c = a, this.f = 4, this.a = "n";
        var c = (b || "n4").match(/^([nio])([1-9])$/i);
        c && (this.a = c[1], this.f = parseInt(c[2], 10))
    }

    function s(a) { return v(a) + " " + (a.f + "00") + " 300px " + t(a.c) }

    function t(a) {
        var b = [];
        a = a.split(/,\s*/);
        for (var c = 0; c < a.length; c++) { var d = a[c].replace(/['"]/g, ""); - 1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d) }
        return b.join(",")
    }

    function u(a) { return a.a + a.f }

    function v(a) { var b = "normal"; return "o" === a.a ? b = "oblique" : "i" === a.a && (b = "italic"), b }

    function w(a) {
        var b = 4,
            c = "n",
            d = null;
        return a && ((d = a.match(/(normal|oblique|italic)/i)) && d[1] && (c = d[1].substr(0, 1).toLowerCase()), (d = a.match(/([1-9]00|normal|bold)/i)) && d[1] && (/bold/i.test(d[1]) ? b = 7 : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10)))), c + b
    }

    function x(a, b) { this.c = a, this.f = a.o.document.documentElement, this.h = b, this.a = new q("-"), this.j = !1 !== b.events, this.g = !1 !== b.classes }

    function y(a) { a.g && h(a.f, [a.a.c("wf", "loading")]), A(a, "loading") }

    function z(a) {
        if (a.g) {
            var b = i(a.f, a.a.c("wf", "active")),
                c = [],
                d = [a.a.c("wf", "loading")];
            b || c.push(a.a.c("wf", "inactive")), h(a.f, c, d)
        }
        A(a, "inactive")
    }

    function A(a, b, c) { a.j && a.h[b] && (c ? a.h[b](c.c, u(c)) : a.h[b]()) }

    function B() { this.c = {} }

    function C(a, b, c) {
        var d, e = [];
        for (d in b)
            if (b.hasOwnProperty(d)) {
                var f = a.c[d];
                f && e.push(f(b[d], c))
            }
        return e
    }

    function D(a, b) { this.c = a, this.f = b, this.a = e(this.c, "span", { "aria-hidden": "true" }, this.f) }

    function E(a) { f(a.c, "body", a.a) }

    function F(a) { return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + t(a.c) + ";" + ("font-style:" + v(a) + ";font-weight:" + (a.f + "00") + ";") }

    function G(a, b, c, d, e, f) { this.g = a, this.j = b, this.a = d, this.c = c, this.f = e || 3e3, this.h = f || void 0 }

    function H(a, b, c, d, e, f, g) { this.v = a, this.B = b, this.c = c, this.a = d, this.s = g || "BESbswy", this.f = {}, this.w = e || 3e3, this.u = f || null, this.m = this.j = this.h = this.g = null, this.g = new D(this.c, this.s), this.h = new D(this.c, this.s), this.j = new D(this.c, this.s), this.m = new D(this.c, this.s), a = new r(this.a.c + ",serif", u(this.a)), a = F(a), this.g.a.style.cssText = a, a = new r(this.a.c + ",sans-serif", u(this.a)), a = F(a), this.h.a.style.cssText = a, a = new r("serif", u(this.a)), a = F(a), this.j.a.style.cssText = a, a = new r("sans-serif", u(this.a)), a = F(a), this.m.a.style.cssText = a, E(this.g), E(this.h), E(this.j), E(this.m) }

    function I() {
        if (null === da) {
            var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
            da = !!a && (536 > parseInt(a[1], 10) || 536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10))
        }
        return da
    }

    function J(a, b, c) {
        for (var d in ca)
            if (ca.hasOwnProperty(d) && b === a.f[ca[d]] && c === a.f[ca[d]]) return !0;
        return !1
    }

    function K(a) {
        var b, c = a.g.a.offsetWidth,
            d = a.h.a.offsetWidth;
        (b = c === a.f.serif && d === a.f["sans-serif"]) || (b = I() && J(a, c, d)), b ? aa() - a.A >= a.w ? I() && J(a, c, d) && (null === a.u || a.u.hasOwnProperty(a.a.c)) ? M(a, a.v) : M(a, a.B) : L(a) : M(a, a.v)
    }

    function L(a) { setTimeout(c(function() { K(this) }, a), 50) }

    function M(a, b) { setTimeout(c(function() { g(this.g.a), g(this.h.a), g(this.j.a), g(this.m.a), b(this.a) }, a), 0) }

    function N(a, b, c) { this.c = a, this.a = b, this.f = 0, this.m = this.j = !1, this.s = c }

    function O(a) { 0 == --a.f && a.j && (a.m ? (a = a.a, a.g && h(a.f, [a.a.c("wf", "active")], [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]), A(a, "active")) : z(a.a)) }

    function P(a) { this.j = a, this.a = new B, this.h = 0, this.f = this.g = !0 }

    function Q(a, b, d, e, f) {
        var g = 0 == --a.h;
        (a.f || a.g) && setTimeout(function() {
            var a = f || null,
                i = e || null || {};
            if (0 === d.length && g) z(b.a);
            else {
                b.f += d.length, g && (b.j = g);
                var j, k = [];
                for (j = 0; j < d.length; j++) {
                    var l = d[j],
                        m = i[l.c],
                        n = b.a,
                        o = l;
                    if (n.g && h(n.f, [n.a.c("wf", o.c, u(o).toString(), "loading")]), A(n, "fontloading", o), n = null, null === ea)
                        if (window.FontFace) {
                            var o = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                p = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                            ea = o ? 42 < parseInt(o[1], 10) : !p
                        }
                    else ea = !1;
                    n = ea ? new G(c(b.g, b), c(b.h, b), b.c, l, b.s, m) : new H(c(b.g, b), c(b.h, b), b.c, l, b.s, a, m), k.push(n)
                }
                for (j = 0; j < k.length; j++) k[j].start()
            }
        }, 0)
    }

    function R(a, b, c) {
        var d = [],
            e = c.timeout;
        y(b);
        var d = C(a.a, c, a.c),
            f = new N(a.c, b, e);
        for (a.h = d.length, b = 0, c = d.length; b < c; b++) d[b].load(function(b, c, d) { Q(a, f, b, c, d) })
    }

    function S(a, b) { this.c = a, this.a = b }

    function T(a, b) { this.c = a, this.a = b }

    function U(a, b) { a ? this.c = a : this.c = fa, this.a = [], this.f = [], this.g = b || "" }

    function V(a, b) {
        for (var c = b.length, d = 0; d < c; d++) {
            var e = b[d].split(":");
            3 == e.length && a.f.push(e.pop());
            var f = "";
            2 == e.length && "" != e[1] && (f = ":"), a.a.push(e.join(f))
        }
    }

    function W(a) { if (0 == a.a.length) throw Error("No fonts to load!"); if (-1 != a.c.indexOf("kit=")) return a.c; for (var b = a.a.length, c = [], d = 0; d < b; d++) c.push(a.a[d].replace(/ /g, "+")); return b = a.c + "?family=" + c.join("%7C"), 0 < a.f.length && (b += "&subset=" + a.f.join(",")), 0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g)), b }

    function X(a) { this.f = a, this.a = [], this.c = {} }

    function Y(a) {
        for (var b = a.f.length, c = 0; c < b; c++) {
            var d = a.f[c].split(":"),
                e = d[0].replace(/\+/g, " "),
                f = ["n4"];
            if (2 <= d.length) {
                var g, h = d[1];
                if (g = [], h)
                    for (var h = h.split(","), i = h.length, j = 0; j < i; j++) {
                        var k;
                        if (k = h[j], k.match(/^[\w-]+$/)) {
                            var l = ja.exec(k.toLowerCase());
                            if (null == l) k = "";
                            else {
                                if (k = l[2], k = null == k || "" == k ? "n" : ia[k], l = l[1], null == l || "" == l) l = "4";
                                else var m = ha[l],
                                    l = m ? m : isNaN(l) ? "4" : l.substr(0, 1);
                                k = [k, l].join("")
                            }
                        }
                        else k = "";
                        k && g.push(k)
                    }
                0 < g.length && (f = g), 3 == d.length && (d = d[2], g = [], d = d ? d.split(",") : g, 0 < d.length && (d = ga[d[0]]) && (a.c[e] = d))
            }
            for (a.c[e] || (d = ga[e]) && (a.c[e] = d), d = 0; d < f.length; d += 1) a.a.push(new r(e, f[d]))
        }
    }

    function Z(a, b) { this.c = a, this.a = b }

    function $(a, b) { this.c = a, this.a = b }

    function _(a, b) { this.c = a, this.f = b, this.a = [] }
    var aa = Date.now || function() { return +new Date },
        ba = !!window.FontFace;
    q.prototype.c = function(a) { for (var b = [], c = 0; c < arguments.length; c++) b.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase()); return b.join(this.a) }, G.prototype.start = function() {
        var a = this.c.o.document,
            b = this,
            c = aa(),
            d = new Promise(function(d, e) {
                function f() { aa() - c >= b.f ? e() : a.fonts.load(s(b.a), b.h).then(function(a) { 1 <= a.length ? d() : setTimeout(f, 25) }, function() { e() }) } f()
            }),
            e = null,
            f = new Promise(function(a, c) { e = setTimeout(c, b.f) });
        Promise.race([f, d]).then(function() { e && (clearTimeout(e), e = null), b.g(b.a) }, function() { b.j(b.a) })
    };
    var ca = { D: "serif", C: "sans-serif" },
        da = null;
    H.prototype.start = function() { this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = aa(), K(this) };
    var ea = null;
    N.prototype.g = function(a) {
        var b = this.a;
        b.g && h(b.f, [b.a.c("wf", a.c, u(a).toString(), "active")], [b.a.c("wf", a.c, u(a).toString(), "loading"), b.a.c("wf", a.c, u(a).toString(), "inactive")]), A(b, "fontactive", a), this.m = !0, O(this)
    }, N.prototype.h = function(a) {
        var b = this.a;
        if (b.g) {
            var c = i(b.f, b.a.c("wf", a.c, u(a).toString(), "active")),
                d = [],
                e = [b.a.c("wf", a.c, u(a).toString(), "loading")];
            c || d.push(b.a.c("wf", a.c, u(a).toString(), "inactive")), h(b.f, d, e)
        }
        A(b, "fontinactive", a), O(this)
    }, P.prototype.load = function(a) { this.c = new d(this.j, a.context || this.j), this.g = !1 !== a.events, this.f = !1 !== a.classes, R(this, new x(this.c, a), a) }, S.prototype.load = function(a) {
        function b() {
            if (f["__mti_fntLst" + d]) {
                var c, e = f["__mti_fntLst" + d](),
                    g = [];
                if (e)
                    for (var h = 0; h < e.length; h++) {
                        var i = e[h].fontfamily;
                        void 0 != e[h].fontStyle && void 0 != e[h].fontWeight ? (c = e[h].fontStyle + e[h].fontWeight, g.push(new r(i, c))) : g.push(new r(i))
                    }
                a(g)
            }
            else setTimeout(function() { b() }, 50)
        }
        var c = this,
            d = c.a.projectId,
            e = c.a.version;
        if (d) {
            var f = c.c.o;
            l(this.c, (c.a.api || "https://fast.fonts.net/jsapi") + "/" + d + ".js" + (e ? "?v=" + e : ""), function(e) { e ? a([]) : (f["__MonotypeConfiguration__" + d] = function() { return c.a }, b()) }).id = "__MonotypeAPIScript__" + d
        }
        else a([])
    }, T.prototype.load = function(a) {
        var b, c, d = this.a.urls || [],
            e = this.a.families || [],
            f = this.a.testStrings || {},
            g = new m;
        for (b = 0, c = d.length; b < c; b++) k(this.c, d[b], n(g));
        var h = [];
        for (b = 0, c = e.length; b < c; b++)
            if (d = e[b].split(":"), d[1])
                for (var i = d[1].split(","), j = 0; j < i.length; j += 1) h.push(new r(d[0], i[j]));
            else h.push(new r(d[0]));
        o(g, function() { a(h, f) })
    };
    var fa = "https://fonts.googleapis.com/css",
        ga = { latin: "BESbswy", "latin-ext": "Ã§Ã¶Ã¼ÄÅ", cyrillic: "Ð¹ÑÐ", greek: "Î±Î²Î£", khmer: "ááá", Hanuman: "ááá" },
        ha = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" },
        ia = { i: "i", italic: "i", n: "n", normal: "n" },
        ja = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
        ka = { Arimo: !0, Cousine: !0, Tinos: !0 };
    Z.prototype.load = function(a) {
        var b = new m,
            c = this.c,
            d = new U(this.a.api, this.a.text),
            e = this.a.families;
        V(d, e);
        var f = new X(e);
        Y(f), k(c, W(d), n(b)), o(b, function() { a(f.a, f.c, ka) })
    }, $.prototype.load = function(a) {
        var b = this.a.id,
            c = this.c.o;
        b ? l(this.c, (this.a.api || "https://use.typekit.net") + "/" + b + ".js", function(b) {
            if (b) a([]);
            else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
                b = c.Typekit.config.fn;
                for (var d = [], e = 0; e < b.length; e += 2)
                    for (var f = b[e], g = b[e + 1], h = 0; h < g.length; h++) d.push(new r(f, g[h]));
                try { c.Typekit.load({ events: !1, classes: !1, async: !0 }) }
                catch (i) {} a(d)
            }
        }, 2e3) : a([])
    }, _.prototype.load = function(a) {
        var b = this.f.id,
            c = this.c.o,
            d = this;
        b ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b] = function(b, c) {
            for (var e = 0, f = c.fonts.length; e < f; ++e) {
                var g = c.fonts[e];
                d.a.push(new r(g.name, w("font-weight:" + g.weight + ";font-style:" + g.style)))
            }
            a(d.a)
        }, l(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + j(this.c) + "/" + b + ".js", function(b) { b && a([]) })) : a([])
    };
    var la = new P(window);
    la.a.c.custom = function(a, b) { return new T(b, a) }, la.a.c.fontdeck = function(a, b) { return new _(b, a) }, la.a.c.monotype = function(a, b) { return new S(b, a) }, la.a.c.typekit = function(a, b) { return new $(b, a) }, la.a.c.google = function(a, b) { return new Z(b, a) };
    var ma = { load: c(la.load, la) };
    "function" == typeof define && define.amd ? define(function() { return ma }) : "undefined" != typeof module && module.exports ? module.exports = ma : (window.WebFont = ma, window.WebFontConfig && la.load(window.WebFontConfig))
}();
var __extends = this && this.__extends || function() {
        var a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, b) { a.__proto__ = b } || function(a, b) { for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]) };
        return function(b, c) {
            function d() { this.constructor = b } a(b, c), b.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d)
        }
    }(),
    ControllerButton = function() {
        function a(a, b, c, d, e) { this.game = a, this.sprite = a.add.sprite(b, c, d), this.sprite.alpha = .5, this.sprite.anchor.set(.5, .5), this.sprite.scale.set(1.35, 1.35), this.sprite.fixedToCamera = !0, this.sprite.inputEnabled = !0, e && (this.sprite.events.onInputOver.add(this.onDown, this), this.sprite.events.onInputOut.add(this.onUp, this)), this.sprite.events.onInputDown.add(this.onDown, this), this.sprite.events.onInputUp.add(this.onUp, this), this.pressedDown = new Phaser.Signal, this.isDown = !1, this.isPressed = !1 }
        return a.prototype.onDown = function(a, b) { this.pointer = b, this.isDown = !0 }, a.prototype.onUp = function() { this.isDown && this.pressedDown.dispatch(), this.isDown = !1, this.isPressed = !1 }, a.prototype.hide = function() { this.sprite.visible = !1 }, a.prototype.show = function() { this.sprite.visible = !0 }, a.prototype.buttonPressed = function() { return this.isDown }, a
    }(),
    ControllerStick = function() {
        function a(a, b, c, d, e) { this.game = a, this.sprite = a.add.sprite(b, c, d), this.sprite.alpha = .5, this.sprite.anchor.set(.5, .5), this.sprite.scale.set(1.35, 1.35), this.sprite.fixedToCamera = !0, this.sprite.inputEnabled = !0, this.sprite.events.onInputDown.add(this.onDown, this), this.sprite.events.onInputUp.add(this.onUp, this), this.pressedDown = new Phaser.Signal, this.isDown = !1, this.upDd = !1, this.downDd = !1, this.leftDd = !1, this.oneStick = e }
        return a.prototype.onDown = function(a, b) { this.pointer = b, this.isDown = !0 }, a.prototype.onUp = function() { this.isDown && this.pressedDown.dispatch(), this.isDown = !1, this.upDd = !1, this.downDd = !1, this.leftDd = !1, this.rightDd = !1 }, a.prototype.hide = function() { this.sprite.visible = !1 }, a.prototype.show = function() { this.sprite.visible = !0 }, a.prototype.upIsDown = function() { return this.upDd }, a.prototype.downIsDown = function() { return this.downDd }, a.prototype.leftIsDown = function() { return this.leftDd }, a.prototype.rightIsDown = function() { return this.rightDd }, a.prototype.update = function() {
            if (this.isDown)
                if (this.oneStick) {
                    var a = this.sprite.x - this.game.camera.x;
                    this.pointer.position.x < a ? (this.leftDd = !0, this.rightDd = !1) : (this.rightDd = !0, this.leftDd = !1)
                }
            else {
                var b = this.sprite.position.x - this.game.camera.x,
                    c = this.sprite.position.y - this.game.camera.y,
                    d = Math.pow(this.pointer.position.x - b, 2) + Math.pow(this.pointer.position.y - c, 2);
                if (d < 400) return this.upDd = !1, this.downDd = !1, this.leftDd = !1, void(this.rightDd = !1);
                if (this.pointer.position.x < b) {
                    this.rightDd = !1;
                    var e = (this.pointer.y - c) / (this.pointer.position.x - b);
                    e > 1 ? (this.upDd = !0, this.leftDd = !1, this.downDd = !1) : e < -1 ? (this.upDd = !1, this.leftDd = !1, this.downDd = !0) : (this.upDd = !1, this.leftDd = !0, this.downDd = !1)
                }
                else {
                    this.leftDd = !1;
                    var e = (this.pointer.y - c) / (this.pointer.position.x - b);
                    e > 1 ? (this.upDd = !1, this.rightDd = !1, this.downDd = !0) : e < -1 ? (this.upDd = !0, this.rightDd = !1, this.downDd = !1) : (this.upDd = !1, this.rightDd = !0, this.downDd = !1)
                }
            }
        }, a
    }(),
    Fabrique;
! function(a) {
    var b = function() {
        function a() {}
        return a.show = function() {
            var a = document.getElementById("loader");
            a && (a.style.display = "block")
        }, a.hide = function() {
            var a = document.getElementById("loader");
            a && (a.style.display = "none")
        }, a
    }();
    a.LoaderHelper = b
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = function(a) {
        function b() { var c = null !== a && a.apply(this, arguments) || this; return c.name = b.Name, c }
        return __extends(b, a), b.prototype.create = function() { this.game.analytics.google.sendScreenView(this.name) }, b.Name = "default", b
    }(Phaser.State);
    a.State = b
}(Fabrique || (Fabrique = {}));
var levelData = {};
levelData.levelhub = [{ type: "spawnPoint", x: 579.45, y: 1932.75 }, { type: "spike10x", x: 3005.65, y: 1273.95, rotation: 90 }, { type: "spike", x: 2843.25, y: 1332.8, rotation: 180 }, { type: "spike", x: 2854.3, y: 1332.8, rotation: 180 }, { type: "spike", x: 2865.3, y: 1332.8, rotation: 180 }, { type: "checkpoint", x: 3110.7, y: 1324.3 }, { type: "spike10x", x: 3185.6, y: 1354, rotation: 0 }, { type: "basicBlock", x: 3104.35, y: 1411.9, width: 681.9, height: 100 }, { type: "buzzsawOnStick", x: 2921.4, y: 1198.8, rotation: -90 }, { type: "spike30x", x: 2912.7, y: 1003.85, rotation: 0 }, { type: "basicBlock", x: 2904.55, y: 1056.2, width: 358.4, height: 89 }, { type: "basicBlock", x: 2737.55, y: 1026.4, width: 81.8, height: 308.3 }, { type: "basicBlock", x: 2737.55, y: 1792.3, width: 81.8, height: 1091.6 }, { type: "spike30x", x: 3156.65, y: 1095.35, rotation: 90 }, { type: "spike10x", x: 3282.8, y: 878.9, rotation: 180 }, { type: "spike10x", x: 3099.35, y: 827.75, rotation: 180 }, { type: "spike10x", x: 3098.3, y: 941.6, rotation: 0 }, { type: "spike10x", x: 3279.75, y: 987.75, rotation: 0 }, { type: "blockedWall", x: 2009.55, y: 649.25, width: 443.65, height: 63.65, rotation: 90, actnum: 9 }, { type: "bouncingBuzzsaw", x: 1551.65, y: 735.35, width: 54.7 }, { type: "bouncingBuzzsaw", x: 1414.6, y: 751.35, width: 54.7 }, { type: "blockedWall", x: 1815, y: 502.75, width: 63.65, height: 443.65, rotation: 0, actnum: 8 }, { type: "basicBlock", x: 1812.55, y: 735, width: 100, height: 281 }, { type: "blockedWall", x: 970.7, y: 525.45, width: 63.65, height: 443.65, rotation: 0, actnum: 7 }, { type: "buzzsaw", x: 721.95, y: 556.95, width: 101, height: 102.2 }, { type: "checkpoint", x: 760.5, y: 834 }, { type: "buzzsawHorizontal", x: 894.95, y: 1001.4 }, { type: "blockedWall", x: 872, y: 916.25, width: 443.65, height: 63.65, rotation: -90, actnum: 6 }, { type: "basicBlock", x: 515.05, y: 922, width: 500, height: 100 }, { type: "lockBlock", x: 976, y: 1171, width: 100.05, height: 100 }, { type: "blockedWall", x: 1127.6, y: 1078.55, width: 63.65, height: 443.65, rotation: 0, actnum: 5 }, { type: "basicBlock", x: 1651.25, y: 922, width: 1252.6, height: 100 }, { type: "spike", x: 1902.4, y: 1170, rotation: 90 }, { type: "spike", x: 1902.35, y: 1158.9, rotation: 90 }, { type: "spike", x: 1902.35, y: 1148, rotation: 90 }, { type: "spike", x: 1902.35, y: 1136.9, rotation: 90 }, { type: "spike", x: 1902.35, y: 1191.05, rotation: 90 }, { type: "spike", x: 1902.35, y: 1180.05, rotation: 90 }, { type: "spike", x: 2165.5, y: 1233.9, rotation: -90 }, { type: "spike", x: 2165.5, y: 1244.95, rotation: -90 }, { type: "spike", x: 2165.5, y: 1255.95, rotation: -90 }, { type: "spike", x: 2165.5, y: 1267, rotation: -90 }, { type: "spike", x: 2165.5, y: 1212.85, rotation: -90 }, { type: "spike", x: 2165.5, y: 1223.9, rotation: -90 }, { type: "spike30x", x: 1457.25, y: 1707.05, rotation: 0 }, { type: "buzzsaw", x: 2270.55, y: 1172.5, width: 101, height: 102.2 }, { type: "fallingSpike", x: 2230.9, y: 1280.55, rotation: 180 }, { type: "fallingSpike", x: 2241.95, y: 1280.55, rotation: 180 }, { type: "fallingSpike", x: 2252.95, y: 1280.55, rotation: 180 }, { type: "fallingSpike", x: 2264, y: 1280.55, rotation: 180 }, { type: "shurikanSpawner", x: 2120.3, y: 1400, rotation: 89.99563598632812 }, { type: "pushBlock", x: 2018.15, y: 1487.25, width: 70, height: 69.9 }, { type: "checkpoint", x: 1925, y: 1516.35 }, { type: "ziplinePole", x: 1591.3, y: 1097.55 }, { type: "ziplinePole", x: 1186.7, y: 1186.9 }, { type: "bounceBlock", x: 2168.85, y: 2305.4, width: 50, height: 50 }, { type: "basicBlock", x: 1754.85, y: 2282.45, width: 100, height: 100 }, { type: "horizontalBlock", x: 2208.25, y: 1964.85, width: 45.9, height: 45.9 }, { type: "buzzsaw", x: 1607.75, y: 2069.95, width: 93, height: 94.15 }, { type: "buzzsaw", x: 1811.65, y: 1960.3, width: 93, height: 94.15 }, { type: "blockedWall", x: 1849.65, y: 1390.25, width: 63.65, height: 443.65, rotation: 0, actnum: 4 }, { type: "blockedWall", x: 2018.75, y: 1783, width: 63.65, height: 443.65, rotation: 0, actnum: 3 }, { type: "basicBlock", x: 2057.35, y: 1604.4, width: 499, height: 100 }, { type: "checkpoint", x: 1968.2, y: 1776.95 }, { type: "spike10x", x: 1301.6, y: 1764.95, rotation: -90 }, { type: "spike10x", x: 1262.9, y: 1763.55, rotation: 90 }, { type: "basicBlock", x: 1456.15, y: 1764.95, width: 295, height: 100.05 }, { type: "fallingBlock", x: 634, y: 2216.25, width: 50, height: 50 }, { type: "fallingBlock", x: 1036, y: 2216.25, width: 50, height: 50 }, { type: "buzzsaw", x: 634.2, y: 2331.35, width: 101, height: 102.2 }, {
    type: "buzzsaw",
    x: 710,
    y: 2331.35,
    width: 101,
    height: 102.2
}, { type: "buzzsaw", x: 788.6, y: 2331.35, width: 101, height: 102.2 }, { type: "buzzsaw", x: 864.4, y: 2331.35, width: 101, height: 102.2 }, { type: "buzzsaw", x: 949, y: 2331.35, width: 101, height: 102.2 }, { type: "buzzsaw", x: 1024.8, y: 2331.35, width: 101, height: 102.2 }, { type: "ziplinePole", x: 1650.8, y: 1620.3 }, { type: "ziplinePole", x: 1246.2, y: 1557.45 }, { type: "checkpoint", x: 1045.2, y: 1555.35 }, { type: "basicBlock", x: 235, y: 1170.45, width: 470, height: 2340.9 }, { type: "blockedWall", x: 1204.05, y: 1479.8, width: 63.65, height: 443.65, rotation: 0, actnum: 2 }, { type: "blockedWall", x: 988.95, y: 1469.15, width: 63.65, height: 443.65, rotation: 0, actnum: 1 }, { type: "bounceBlock", x: 1130.5, y: 2166.25, width: 75, height: 75 }, { type: "basicBlock", x: 705.05, y: 1642.3, width: 190, height: 100 }, { type: "basicBlock", x: 585, y: 2001.35, width: 232, height: 100.05 }, { type: "basicBlock", x: 2488.75, y: 1605.35, width: 437.8, height: 1466.2 }, { type: "buzzsaw", x: 520.55, y: 418.5, width: 101, height: 102.2 }, { type: "basicBlock", x: 1370, y: 209.05, width: 2432, height: 420.6 }, { type: "basicBlock", x: 875, y: 1951.25, width: 150, height: 200.1 }, { type: "basicBlock", x: 1e3, y: 1822.4, width: 102, height: 458 }, { type: "basicBlock", x: 849, y: 1692.35, width: 100, height: 200 }, { type: "basicBlock", x: 750, y: 2026.4, width: 100, height: 50 }, { type: "spike10x", x: 749.6, y: 1993.5, rotation: 0 }, { type: "basicBlock", x: 1205, y: 1893, width: 100, height: 602 }, { type: "basicBlock", x: 1158, y: 2261.45, width: 195, height: 140 }, { type: "fallingBlock", x: 835, y: 2216.25, width: 50, height: 50 }, { type: "basicBlock", x: 1397.55, y: 2579.05, width: 2761.8, height: 497.3 }, { type: "checkpoint", x: 1070.5, y: 2153.25 }, { type: "basicBlock", x: 1652.7, y: 1734.95, width: 100, height: 160 }, { type: "actBlock", actNum: "1", x: 540, y: 1623.35 }, { type: "actBlock", actNum: "2", x: 539.95, y: 2262.35 }, { type: "rightSlope", x: 1781.7, y: 1734.95, width: 160, height: 160, rotation: 0 }, { type: "actBlock", actNum: "3", x: 1326, y: 2010 }, { type: "basicBlock", x: 1811.7, y: 1864.25, width: 100, height: 100 }, { type: "basicBlock", x: 1444.05, y: 2088.5, width: 100, height: 299 }, { type: "basicBlock", x: 1739, y: 2188, width: 508, height: 100 }, { type: "basicBlock", x: 1999, y: 2026, width: 100, height: 424 }, { type: "actBlock", actNum: "4", x: 1875.25, y: 2400 }, { type: "swimmingPool", x: 1721.7, y: 2048.45, width: 455.5, height: 179.1 }, { type: "basicBlock", x: 1981.75, y: 1380.4, width: 373.7, height: 100 }, { type: "basicBlock", x: 1843.85, y: 1280.9, width: 100, height: 299 }, { type: "basicBlock", x: 2097.8, y: 1964.25, width: 100, height: 100 }, { type: "basicBlock", x: 2235.6, y: 2167.75, width: 71.95, height: 100 }, { type: "classicLaser", x: 2230.3, y: 2058.3 }, { type: "checkpoint", x: 1988.85, y: 2292 }, { type: "actBlock", actNum: "5", x: 1726, y: 1203 }, { type: "basicBlock", x: 1604.9, y: 1181.4, width: 100, height: 100 }, { type: "basicBlock", x: 2223.4, y: 1222.4, width: 100, height: 100 }, { type: "checkpoint", x: 1956.2, y: 1292.4 }, { type: "pole", x: 1975.9, y: 1190.3 }, { type: "pole", x: 2170.2, y: 1057.6 }, { type: "pole", x: 1974.9, y: 1057.6 }, { type: "actBlock", actNum: "6", x: 541, y: 1153 }, { type: "basicBlock", x: 659, y: 1151, width: 100, height: 141 }, { type: "basicBlock", x: 976, y: 908.75, width: 100, height: 427.7 }, { type: "key", x: 1062.15, y: 1108.4 }, { type: "basicBlock", x: 814, y: 1019.5, width: 100, height: 295 }, { type: "actBlock", actNum: "7", x: 540, y: 614.8 }, { type: "checkpoint", x: 901.1, y: 1183.05 }, { type: "basicBlock", x: 862.4, y: 1270.35, width: 785.2, height: 100.05 }, { type: "circularCannon", x: 702.15, y: 762.9 }, { type: "basicBlock", x: 538, y: 778.2, width: 140, height: 190.8 }, { type: "basicBlock", x: 790, y: 513.75, width: 140, height: 190.8 }, { type: "leftSlope", x: 1074.95, y: 644.9, width: 100, height: 100, rotation: 0 }, { type: "basicBlock", x: 1074.95, y: 783.5, width: 100, height: 178.05 }, { type: "iceBlock", x: 1374.95, y: 644.9, width: 500, height: 100.05 }, { type: "actBlock", actNum: "8", x: 1195, y: 903.05 }, { type: "reaper", x: 1374.8, y: 594.95, width: 352.1, rotation: 0 }, { type: "basicBlock", x: 2110.35, y: 644.9, width: 330, height: 100 }, { type: "windBlaster", x: 1706, y: 872, rotation: -90 }, { type: "checkpoint", x: 1021.75, y: 657.5 }, { type: "actBlock", actNum: "9", x: 2202, y: 625.5 }, { type: "basicBlock", x: 2524.15, y: 346.25, width: 508.6, height: 697.9 }, { type: "checkpoint", x: 1772.65, y: 556.5 }, { type: "checkpoint", x: 2621.3, y: 834.25 }, { type: "ziplinePole", x: 2748.75, y: 836.95 }, { type: "ziplinePole", x: 3474.95, y: 984.65 }, { type: "spike30x", x: 3422.65, y: 956.35, rotation: -90 }, { type: "basicBlock", x: 3684.85, y: 959.2, width: 508.6, height: 1466.2 }, { type: "basicBlock", x: 3282.8, y: 731.35, width: 100, height: 281 }, { type: "basicBlock", x: 3098.75, y: 679.35, width: 100, height: 281 }, { type: "basicBlock", x: 3280.55, y: 1140.4, width: 100, height: 289 }, { type: "basicBlock", x: 3098.75, y: 1096.55, width: 100, height: 295.1 }, { type: "glassBlock", x: 3380.55, y: 1151.95, width: 100, height: 100 }, { type: "classicLaser", x: 2884.65, y: 743.5 }, { type: "classicLaser", x: 2961.65, y: 919.15 }, { type: "actBlock", actNum: "10", x: 2917.75, y: 1244.3 }, { type: "quadrantRight", x: 2725.95, y: 1216.3, rotation: 0, width: 179.5 }, { type: "shurikanDispenser", x: 2041.85, y: 508.95 }], levelData.level1 = [{ type: "basicBlock", x: 9.9, y: 50, width: 300.7, height: 100.05 }, { type: "leftSlope", x: 97, y: 147.85, width: 100, height: 100, rotation: -90 }, { type: "leftSlope", x: -427.1, y: 149.85, width: 100, height: 102, rotation: 180 }, { type: "basicBlock", x: 295.1, y: -90.95, width: 116, height: 100 }, { type: "spike30x", x: -417.1, y: -8.05, rotation: 0 }, { type: "spike30x", x: 5, y: -8.05, rotation: 0 }, { type: "spike10x", x: -263.1, y: 49.85, rotation: 90 }, { type: "spike10x", x: -149.1, y: 50, rotation: -90 }, { type: "basicBlock", x: -423.5, y: 49.85, width: 304.7, height: 100.05 }, { type: "spike10x", x: 137.1, y: -92.35, rotation: -90 }, { type: "basicBlock", x: 820, y: 670, width: 220, height: 100.05 }, { type: "textFade", textNum: "15", x: -588.025, y: 352.75, rotation: 179.99913024902344 }, { type: "textFade", textNum: "15", x: 493.775, y: 246.7, rotation: 0 }, { type: "textFade", textNum: "16", x: 643.375, y: 591.65, rotation: 179.99913024902344 }, { type: "textFade", textNum: "17", x: 62.25, y: 500.225, rotation: -90.00175476074219 }, { type: "textFade", textNum: "17", x: -906.95, y: 261.825, rotation: -90.00175476074219 }, { type: "textFade", textNum: "15", x: 842.75, y: 207.42499999999998, rotation: 90 }, { type: "textFade", textNum: "15", x: -625.075, y: -276.55, rotation: -.0008697509765625 }, { type: "spike", x: -782.55, y: -150.35, rotation: 180 }, { type: "spike", x: -771.55, y: -150.35, rotation: 180 }, { type: "spike", x: -760.55, y: -150.35, rotation: 180 }, { type: "spike", x: -749.55, y: -150.35, rotation: 180 }, { type: "horizontalBlock", x: -765.55, y: -182.85, width: 50, height: 50 }, { type: "spike", x: -877.6, y: -150.35, rotation: 180 }, { type: "spike", x: -866.6, y: -150.35, rotation: 180 }, { type: "spike", x: -855.6, y: -150.35, rotation: 180 }, { type: "spike", x: -844.6, y: -150.35, rotation: 180 }, { type: "horizontalBlock", x: -860.6, y: -182.85, width: 50, height: 50 }, { type: "spike", x: -689.55, y: -150.35, rotation: 180 }, { type: "spike", x: -678.55, y: -150.35, rotation: 180 }, { type: "spike", x: -667.55, y: -150.35, rotation: 180 }, { type: "spike", x: -656.55, y: -150.35, rotation: 180 }, { type: "horizontalBlock", x: -672.55, y: -182.85, width: 50, height: 50 }, { type: "checkpoint", x: -812.7, y: 61.85 }, { type: "spike", x: -910.95, y: 181.45, rotation: 180 }, { type: "spike", x: -899.95, y: 181.45, rotation: 180 }, { type: "spike", x: -888.95, y: 181.45, rotation: 180 }, { type: "spike", x: -877.95, y: 181.45, rotation: 180 }, { type: "horizontalBlock", x: -893.95, y: 148.95, width: 50, height: 50 }, { type: "bounceBlock", x: -903.95, y: 355, width: 50, height: 50 }, { type: "buzzsawVerticalUp", x: -729.8, y: 426.8 }, { type: "checkpoint", x: -494.8, y: 342.55 }, { type: "buzzsaw", x: 478.45, y: 319.4 }, { type: "buzzsaw", x: 587.45, y: 319.4 }, { type: "spike10x", x: 689.3, y: 203.85, rotation: -90 }, { type: "basicBlock", x: 722.2, y: 149.55, width: 50, height: 207.1 }, { type: "basicBlock", x: 620, y: 0, width: 780, height: 100.05 }, { type: "basicBlock", x: 360, y: 320, width: 230, height: 100.05 }, { type: "textFade", textNum: "10", x: 357.525, y: 318.475, rotation: 0 }, { type: "textFade", textNum: "8", x: 360.5, y: 178.89999999999998, rotation: 0 }, { type: "spawnPoint", x: 349.85, y: 260.45 }, { type: "basicBlock", x: 195, y: 188.7, width: 100, height: 659.3 }, { type: "basicBlock", x: 700, y: 320, width: 220, height: 100.05 }, { type: "textFade", textNum: "11", x: 699.9, y: 319.1, rotation: 0 }, { type: "basicBlock", x: 760, y: 445.05, width: 100, height: 150 }, { type: "basicBlock", x: 960, y: 484.75, width: 100, height: 871.5 }, { type: "verticalDownBlock", x: 885, y: 345.05, width: 50, height: 50 }, { type: "verticalUpBlock", x: 835, y: 495, width: 50, height: 50 }, { type: "textFade", textNum: "12", x: 831.875, y: 670.925, rotation: 0 }, { type: "checkpoint", x: 777.85, y: 582.2 }, { type: "fallingBlock", x: 685, y: 645, width: 50, height: 50 }, { type: "fallingBlock", x: 635, y: 645, width: 50, height: 50 }, { type: "basicBlock", x: 150, y: 670, width: 220, height: 100.05 }, { type: "checkpoint", x: 192.05, y: 582.2 }, { type: "textFade", textNum: "14", x: 148.7, y: 675.425, rotation: 0 }, { type: "bounceBlock", x: 65, y: 595.2, width: 50, height: 50 }, { type: "basicBlock", x: -10, y: 612, width: 100, height: 584 }, { type: "ziplinePole", x: -12.95, y: 285.05 }, { type: "ziplinePole", x: -428.9, y: 345.55 }, { type: "basicBlock", x: -464.95, y: 641.1, width: 100, height: 522.1 }, { type: "basicBlock", x: -737.55, y: 150, width: 186, height: 100.05 }, { type: "basicBlock", x: -572, y: 430, width: 116.05, height: 100.05 }, { type: "basicBlock", x: -1e3, y: -155.45, width: 100, height: 523.2 }, { type: "bounceBlock", x: -755.55, y: 75, width: 50, height: 50 }, { type: "basicBlock", x: -538.7, y: -179.55, width: 217.6, height: 100.05 }, { type: "ziplinePole", x: 193.05, y: -176.05 }, { type: "ziplinePole", x: -442.95, y: -264.55 }, { type: "finishPortal", x: 289, y: -170.85 }, { type: "basicBlock", x: 391.45, y: -274.9, width: 100, height: 467.1 }, { type: "basicBlock", x: -354.25, y: -458.45, width: 1391.6, height: 100.05 }, { type: "buzzsawVerticalUp", x: -254.15, y: -260.9 }, { type: "basicBlock", x: -1e3, y: 497.9, width: 100, height: 785.2 }, { type: "textFade", textNum: "18", x: -516.5250000000001, y: 280.5, rotation: 0 }, { type: "basicBlock", x: -892, y: 430, width: 116.05, height: 100.05 }, { type: "basicBlock", x: -562, y: 34, width: 171, height: 332.1 }, { type: "star", x: -206.05, y: 50.05 }, { type: "textFade", textNum: "41", x: -826.85, y: -3.575000000000003, rotation: 0 }, { type: "fallingBlock", x: 585, y: 645.2, width: 50, height: 50 }, { type: "fallingBlock", x: 535, y: 645.2, width: 50, height: 50 }, { type: "fallingBlock", x: 485, y: 645.2, width: 50, height: 50 }, { type: "fallingBlock", x: 435, y: 645.2, width: 50, height: 50 }, { type: "fallingBlock", x: 385, y: 645, width: 50, height: 50 }, { type: "fallingBlock", x: 335, y: 645, width: 50, height: 50 }, { type: "fallingBlock", x: 285, y: 645, width: 50, height: 50 }], levelData.level2 = [{ type: "shurikanSpawner", x: 1231.5, y: -471.35, rotation: 90.0052490234375 }, { type: "shurikanSpawner", x: 1085.85, y: -250, rotation: -89.9947509765625 }, { type: "shurikanSpawner", x: 990.45, y: -471.35, rotation: 90.0052490234375 }, { type: "basicBlock", x: 1085.3, y: -200, width: 460.2, height: 100 }, { type: "checkpoint", x: 1355.1, y: -111 }, { type: "verticalUpBlock", x: 1137.3, y: 25, width: 356.1, height: 100 }, { type: "verticalDownBlock", x: 1137.3, y: 225.05, width: 358, height: 100 }, { type: "basicBlock", x: 739.35, y: 175, width: 48.2, height: 100 }, { type: "ziplinePole", x: 1043.95, y: 530.05 }, { type: "shurikanSpawner", x: 794, y: 820, rotation: -89.9947509765625 }, { type: "shurikanSpawner", x: 795.9, y: 254.95, rotation: 180 }, { type: "basicBlock", x: 809.25, y: 24.7, width: 100, height: 1323 }, { type: "checkpoint", x: 562.35, y: -66 }, { type: "spike10x", x: 265.1, y: 14, rotation: 0 }, { type: "spike10x", x: 361.6, y: 14, rotation: 0 }, { type: "spike10x", x: 457.6, y: 14, rotation: 0 }, { type: "textFade", textNum: "17", x: -87.52499999999999, y: 222.55, rotation: -15.002182006835938 }, { type: "checkpoint", x: -107.8, y: 291.75 }, { type: "textFade", textNum: "20", x: 326.15, y: 487.17499999999995, rotation: 0 }, { type: "spike10x", x: 83.6, y: 461.15, rotation: 180 }, { type: "spike10x", x: 83.6, y: 588.4, rotation: 0 }, { type: "basicBlock", x: 449, y: 320, width: 230, height: 100.05 }, { type: "spawnPoint", x: 348.85, y: 260.45 }, { type: "basicBlock", x: 611, y: 470, width: 94, height: 800 }, { type: "basicBlock", x: 84.05, y: 261.7, width: 100, height: 383.1 }, { type: "basicBlock", x: 195.55, y: 647.05, width: 737.5, height: 100.05 }, { type: "basicBlock", x: -121, y: 464.75, width: 100, height: 272.1 }, { type: "swimmingPool", x: 246, y: 472, width: 636, height: 250 }, { type: "textFade", textNum: "17", x: 269.9, y: 275.025, rotation: 90 }, { type: "basicBlock", x: 254.95, y: 46.8, width: 442.1, height: 50 }, { type: "basicBlock", x: 10, y: 252.7, width: 50, height: 50 }, { type: "basicBlock", x: -221, y: 308.05, width: 100, height: 778 }, { type: "basicBlock", x: 89.5, y: -3, width: 254, height: 50 }, { type: "spike", x: -104, y: 28.8, rotation: 180 }, { type: "spike", x: -115.5, y: 28.8, rotation: 180 }, { type: "spike", x: -115, y: -37.4, rotation: 0 }, { type: "spike", x: -103.5, y: -37.4, rotation: 0 }, { type: "verticalDownBlock", x: -109, y: -4, width: 25, height: 50 }, { type: "checkpoint", x: 45.5, y: -66 }, { type: "basicBlock", x: -121.55, y: 147.65, width: 100, height: 50 }, { type: "basicBlock", x: 591.6, y: 22, width: 235.1, height: 99.5 }, { type: "pushBlock", x: 165, y: -120, width: 50, height: 49.9 }, { type: "basicBlock", x: 295.3, y: -235.55, width: 929.6, height: 100.05 }, { type: "star", x: -223.95, y: -209.95 }, { type: "pushBlock", x: 734.25, y: -2.05, width: 50, height: 49.9 }, { type: "basicBlock", x: 682.2, y: 300, width: 50, height: 50 }, { type: "textFade", textNum: "17", x: 347.975, y: -62.55, rotation: -.00262451171875 }, { type: "basicBlock", x: 735.25, y: 428, width: 50, height: 100 }, { type: "basicBlock", x: 807.45, y: 820, width: 300, height: 100.05 }, { type: "basicBlock", x: 1007.45, y: 716.85, width: 100, height: 305.95 }, { type: "checkpoint", x: 978.1, y: 525.9 }, { type: "swimmingPool", x: 807.95, y: 677.5, width: 299.9, height: 185 }, { type: "textFade", textNum: "21", x: 124.25, y: 16.700000000000003, rotation: 0 }, { type: "textFade", textNum: "22", x: 603.325, y: 48.900000000000006, rotation: 0 }, { type: "ziplinePole", x: 1396.9, y: 576.55 }, { type: "basicBlock", x: 1395.9, y: 761, width: 100, height: 305.05 }, { type: "shurikanSpawner", x: 1210.5, y: 682.5, rotation: -89.9947509765625 }, { type: "basicBlock", x: 1545.9, y: 658.5, width: 200, height: 100 }, { type: "bounceBlock", x: 1538.9, y: 576.5, width: 65, height: 65 }, { type: "checkpoint", x: 1380.1, y: 87 }, { type: "basicBlock", x: 1365.35, y: 175, width: 100, height: 100 }, { type: "basicBlock", x: 909, y: 175, width: 100, height: 100 }, { type: "basicBlock", x: 883.1, y: 75, width: 48.2, height: 100 }, { type: "basicBlock", x: 1365.35, y: -25, width: 100, height: 100 }, { type: "basicBlock", x: 1465.35, y: -112, width: 100, height: 274.1 }, { type: "pushBlock", x: 1273.3, y: -338.6, width: 50, height: 49.9 }, { type: "basicBlock", x: 883.25, y: -336.55, width: 50, height: 175.05 }, { type: "finishPortal", x: 883.25, y: -453.55 }, { type: "basicBlock", x: -146, y: 45.15, width: 50, height: 50 }], levelData.level3 = [{ type: "checkpoint", x: 616.25, y: 420.1 }, { type: "bounceBlock", x: 1587.4, y: 286.1, width: 46, height: 55 }, { type: "buzzsaw", x: -30, y: 213.1 }, { type: "ziplinePole", x: 26.95, y: -86.85 }, { type: "checkpoint", x: -34.1, y: -89.8 }, { type: "basicBlock", x: -7.9, y: 252.7, width: 100, height: 611 }, { type: "spike30x", x: -749.75, y: 368.35, rotation: 180 }, { type: "spike30x", x: -697.7, y: 549.3, rotation: 0 }, { type: "spike30x", x: -456.65, y: 368.35, rotation: 180 }, { type: "spike30x", x: -406.6, y: 549.3, rotation: 0 }, { type: "buzzsaw", x: -188.05, y: 10.95 }, { type: "bounceBlock", x: 987.15, y: 5.1, width: 45, height: 45 }, { type: "checkpoint", x: -107.35, y: 420.1 }, { type: "spike30x", x: 216.7, y: -61.15, rotation: 0 }, { type: "shurikanSpawner", x: 1436.75, y: 216.65, rotation: -90 }, { type: "spike10x", x: 1249.1, y: 77.1, rotation: 90 }, { type: "buzzsaw", x: 201.25, y: 205.45 }, { type: "spike10x", x: 933, y: 79.1, rotation: -90 }, { type: "spike30x", x: 1090.45, y: 134, rotation: 180 }, { type: "basicBlock", x: 1091.05, y: 77.1, width: 300, height: 100.05 }, { type: "checkpoint", x: 1357.55, y: 120.95 }, { type: "checkpoint", x: 815.7, y: 120.95 }, { type: "basicBlock", x: 516.05, y: 208.1, width: 40, height: 40 }, { type: "checkpoint", x: 322.75, y: 120.95 }, { type: "textFade", textNum: "17", x: 175.275, y: 133.25, rotation: 0 }, { type: "bounceBlock", x: 97.05, y: 433.1, width: 50, height: 50 }, { type: "basicBlock", x: 717, y: 707.1, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: 716, y: 537.075, rotation: -90 }, { type: "spawnPoint", x: 721, y: 643.1 }, { type: "basicBlock", x: 617.05, y: 607.1, width: 100, height: 300 }, { type: "basicBlock", x: 817, y: 457.1, width: 100, height: 600 }, { type: "buzzsawOnStick", x: 721.9, y: 705.8, rotation: -90 }, { type: "pole", x: 413.1, y: 393.1 }, { type: "basicBlock", x: 192.1, y: 607.6, width: 100, height: 299 }, { type: "textFade", textNum: "23", x: 412.15, y: 325.975, rotation: 0 }, { type: "textFade", textNum: "24", x: 412.175, y: 499.97499999999997, rotation: 0 }, { type: "basicBlock", x: -60, y: 508.1, width: 404.1, height: 100.05 }, { type: "pole", x: 90.3, y: 100.95 }, { type: "basicBlock", x: 317.05, y: 208.1, width: 100, height: 100.05 }, { type: "textFade", textNum: "25", x: -7.149999999999999, y: 179.075, rotation: 0 }, { type: "fallingBlock", x: 417.05, y: 208.1, width: 100, height: 100 }, { type: "basicBlock", x: 617.05, y: 208.1, width: 100, height: 100 }, { type: "buzzsawOnStick", x: 516.4, y: 203.7, rotation: -90 }, { type: "iceBlock", x: 1087.05, y: 233.1, width: 440, height: 150.05 }, { type: "basicBlock", x: 1357.05, y: 408.1, width: 100, height: 500 }, { type: "textFade", textNum: "26", x: 951.5250000000001, y: 188.64999999999998, rotation: 0 }, { type: "basicBlock", x: 1531.05, y: 213.1, width: 78, height: 200 }, { type: "ziplinePole", x: 853.2, y: -232 }, { type: "basicBlock", x: 891.05, y: -147.95, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: 1152.3249999999998, y: 4.35, rotation: 180 }, { type: "basicBlock", x: -7.9, y: -350.1, width: 100, height: 400 }, { type: "glassBlock", x: -107.9, y: 10.95, width: 100, height: 100.05 }, { type: "basicBlock", x: -208, y: -172.5, width: 100, height: 1065.3 }, { type: "textFade", textNum: "27", x: -208.75, y: -57.9, rotation: 0 }, { type: "glassBlock", x: -107.9, y: 210.95, width: 100, height: 100.05 }, { type: "glassBlock", x: -107.9, y: 408.95, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: -109.6, y: -151.425, rotation: 90 }, { type: "basicBlock", x: 202.2, y: -2.8, width: 321, height: 100.05 }, { type: "basicBlock", x: -600.2, y: 309.95, width: 685.1, height: 100.05 }, { type: "basicBlock", x: -550.3, y: 607, width: 785.3, height: 100.05 }, { type: "basicBlock", x: -892.9, y: 563.35, width: 100, height: 607.1 }, { type: "finishPortal", x: -810.2, y: 470.15 }, { type: "pole", x: -340.1, y: 463.1 }, { type: "pole", x: -551.15, y: 463.1 }, { type: "pole", x: -740.2, y: 463.1 }, { type: "shurikanSpawner", x: -727.4, y: 382.85, rotation: 45 }, { type: "fallingBlock", x: 67.1, y: -525.1, width: 50, height: 50 }, { type: "fallingBlock", x: 219.1, y: -549.1, width: 50, height: 50 }, { type: "fallingBlock", x: 378.75, y: -567.1, width: 50, height: 50 }, { type: "fallingBlock", x: 530.75, y: -591.1, width: 50, height: 50 }, { type: "buzzsawOnStick", x: 142.9, y: -543.1, rotation: -90 }, { type: "buzzsawOnStick", x: 304.75, y: -549.05, rotation: 90 }, { type: "buzzsawOnStick", x: 452.25, y: -581.2, rotation: -90 }, { type: "buzzsawOnStick", x: 614.1, y: -587.15, rotation: 90 }, { type: "star", x: 616.15, y: -678.15 }, { type: "basicBlock", x: 1657.05, y: 102.1, width: 100, height: 422 }, { type: "basicBlock", x: 1073.7, y: -393.9, width: 100, height: 592 }, { type: "basicBlock", x: 1572.6, y: -147.95, width: 269.1, height: 100.05 }, { type: "pushBlock", x: 1581.35, y: 87.9, width: 50, height: 49.9 }, { type: "pole", x: 1448.35, y: -57.85 }], levelData.level4 = [{ type: "fallingSpike", x: -350.65, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -329.15, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -393.75, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -372.25, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -436.75, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -415.25, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -479.85, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -458.35, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -522.9, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -501.4, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -566, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -544.5, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -609, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -587.5, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -652.1, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -630.6, y: -571.35, rotation: 180 }, { type: "spike10x", x: -615.05, y: -465.7, rotation: 0 }, { type: "basicBlock", x: -770.2, y: -567.4, width: 100, height: 225.2 }, { type: "spike30x", x: 200.45, y: -167.85, rotation: 0 }, { type: "spike10x", x: 8.05, y: -168.1, rotation: 0 }, { type: "spike10x", x: -87.45, y: -168.1, rotation: 0 }, { type: "shurikanSpawner", x: 648.7, y: -236.5, rotation: 0 }, { type: "textFade", textNum: "5", x: 37.05, y: 342.975, rotation: -90 }, { type: "textFade", textNum: "4", x: 617.5, y: -5.225000000000001, rotation: 0 }, { type: "spike10x", x: 952.2, y: -167.1, rotation: 0 }, { type: "windBlaster", x: 1249.1, y: 70.95, rotation: -90 }, { type: "buzzsaw", x: 1044.4, y: 340.25 }, { type: "buzzsawHorizontal", x: 1043.95, y: 470.6 }, { type: "glassBlock", x: 943.95, y: 143.65, width: 100, height: 100 }, { type: "basicBlock", x: 1043.95, y: 90.85, width: 100, height: 500 }, { type: "basicBlock", x: 666.85, y: 44.75, width: 50, height: 100 }, { type: "buzzsawHorizontal", x: 423.95, y: 0 }, { type: "spike10x", x: 187.1, y: 318.25, rotation: -90.00175476074219 }, { type: "spike10x", x: 183.05, y: 485.85, rotation: 89.99824523925781 }, { type: "shurikanSpawner", x: 555.4, y: 311.8, rotation: 90 }, { type: "speedBlock", x: 545, y: 320, width: 300, height: 100.05 }, { type: "basicBlock", x: 345, y: 320, width: 100, height: 100.05 }, { type: "spawnPoint", x: 348.85, y: 260.45 }, { type: "basicBlock", x: 345, y: 615.35, width: 100, height: 291.2 }, { type: "basicBlock", x: 956.05, y: 520, width: 522.1, height: 100.05 }, { type: "speedBlockLeft", x: 545, y: 520, width: 300, height: 100.05 }, { type: "checkpoint", x: 347.3, y: 432 }, { type: "basicBlock", x: 844, y: 418, width: 100, height: 696 }, { type: "basicBlock", x: 245, y: 219.85, width: 100, height: 300 }, { type: "textFade", textNum: "5", x: 469.42499999999995, y: 236.05, rotation: 0 }, { type: "basicBlock", x: 87.3, y: 486.85, width: 176.7, height: 100.05 }, { type: "basicBlock", x: 545.05, y: 119.85, width: 500.1, height: 100.05 }, { type: "basicBlock", x: -50, y: 300.9, width: 100, height: 921.7 }, { type: "classicLaser", x: 154.05, y: 240.6 }, { type: "checkpoint", x: 252.35, y: 32 }, { type: "verticalUpBlock", x: 90, y: 194.05, width: 50, height: 100 }, { type: "basicBlock", x: 90, y: 343.1, width: 50, height: 100 }, { type: "textFade", textNum: "28", x: 332.4, y: 323.725, rotation: 0 }, { type: "basicBlock", x: 250, y: -109.75, width: 500.1, height: 100.05 }, { type: "buzzsawVerticalUp", x: 571.9, y: -76 }, { type: "basicBlock", x: 940.9, y: -109, width: 402.1, height: 100.05 }, { type: "star", x: 450.95, y: -204.95 }, { type: "basicBlock", x: 350.05, y: -258.55, width: 100, height: 200 }, { type: "basicBlock", x: 473.05, y: -309, width: 346, height: 100.05 }, { type: "basicBlock", x: 691.85, y: -209, width: 100, height: 300 }, { type: "checkpoint", x: 839.4, y: 32 }, { type: "basicBlock", x: 1249.1, y: 423.1, width: 100, height: 706.3 }, { type: "checkpoint", x: 1081.8, y: -196.95 }, { type: "windBlaster", x: 789.85, y: -157.95, rotation: -90 }, { type: "windBlaster", x: 954.25, y: -341, rotation: 90 }, { type: "basicBlock", x: 948.85, y: -391, width: 198, height: 100.05 }, { type: "checkpoint", x: 401.35, y: -397.05 }, { type: "textFade", textNum: "5", x: 777.125, y: -393.65, rotation: 180 }, { type: "iceBlock", x: 99.55, y: -309, width: 401, height: 100.05 }, { type: "basicBlock", x: -150, y: 202, width: 100, height: 1122 }, { type: "buzzsawOnStick", x: 210.65, y: -299.35, rotation: 90 }, { type: "checkpoint", x: -255.85, y: -496.2 }, { type: "basicBlock", x: -459.9, y: -408.2, width: 720.6, height: 100.05 }, { type: "basicBlock", x: -459.25, y: -630, width: 720.6, height: 100.05 }, { type: "finishPortal", x: -690.05, y: -487.2 }, { type: "buzzsawOnStick", x: -21.199999999999996, y: -309, rotation: -90 }, { type: "textFade", textNum: "5", x: 248.175, y: 425.8, rotation: -165.00189208984375 }, { type: "swimmingPool", x: 1046.95, y: 331.8, width: 306, height: 276.3 }], levelData.level5 = [{ type: "laserPoint", x: 543.75, y: 565 }, { type: "laserPoint", x: 1269.1, y: 565 }, { type: "laserPoint", x: 122, y: 146.55 }, { type: "laserPoint", x: 231, y: 146.55 }, { type: "textFade", textNum: "15", x: 65.025, y: 753.4, rotation: .0008697509765625 }, { type: "bounceBlock", x: 1439.4, y: 808.7, width: 50, height: 50 }, { type: "glassBlock", x: 390, y: 157.5, width: 126, height: 100 }, { type: "spike30x", x: -180.55, y: 465.85, rotation: -90 }, { type: "classicLaser", x: 150, y: 54.4 }, { type: "textFade", textNum: "15", x: 386, y: 219.525, rotation: 90.00175476074219 }, { type: "spike10x", x: 135.4, y: 462.45, rotation: 90 }, { type: "checkpoint", x: -95.8, y: 54.65 }, { type: "glassBlock", x: 389, y: -105.3, width: 122, height: 100 }, { type: "quadrantLeft", x: 730.1, y: -192.5, rotation: 0 }, { type: "quadrantLeft", x: 1006.85, y: -192.5, rotation: 0 }, { type: "textFade", textNum: "15", x: 1367.1, y: -10.025000000000006, rotation: -104.99729919433594 }, { type: "bounceBlock", x: 1396, y: 115, width: 50, height: 50 }, { type: "checkpoint", x: 1314.2, y: 102.65 }, { type: "basicBlock", x: 714.1, y: 390.1, width: 100, height: 199.9 }, { type: "spawnPoint", x: 713.45, y: 264.15 }, { type: "finishPortal", x: 1514.6, y: 552.25 }, { type: "basicBlock", x: 914.1, y: 365, width: 100, height: 250.1 }, { type: "basicBlock", x: 1114.1, y: 340.05, width: 100, height: 300 }, { type: "basicBlock", x: 1314.1, y: 387.3, width: 100, height: 495.3 }, { type: "bouncingBuzzsaw", x: 914.1, y: 0 }, { type: "bouncingBuzzsaw", x: 1114.1, y: 0 }, { type: "basicBlock", x: 1414.1, y: 190, width: 100, height: 100 }, { type: "quadrantLeft", x: 1373, y: -83, rotation: 0 }, { type: "basicBlock", x: 1232.85, y: -142.5, width: 100.1, height: 100 }, { type: "textFade", textNum: "15", x: 804.125, y: 230, rotation: -14.99810791015625 }, { type: "checkpoint", x: 1234.6, y: -230.5 }, { type: "iceBlock", x: 905.3, y: -142.5, width: 556.9, height: 100.05 }, { type: "basicBlock", x: 573.8, y: -142.5, width: 106.1, height: 100 }, { type: "checkpoint", x: 578.55, y: -230.5 }, { type: "basicBlock", x: 1514, y: 87.2, width: 100, height: 806.1 }, { type: "basicBlock", x: 497.75, y: 210.55, width: 100, height: 806.1 }, { type: "basicBlock", x: 277, y: 252.95, width: 100, height: 291 }, { type: "basicBlock", x: 226.7, y: 562, width: 200, height: 100 }, { type: "pushBlock", x: 470.15, y: -279.05, width: 50, height: 49.9 }, { type: "basicBlock", x: 26.95, y: 454, width: 200.1, height: 316.05 }, { type: "basicBlock", x: 77, y: -49.65, width: 100, height: 488.1 }, { type: "basicBlock", x: 177.55, y: -225.05, width: 301, height: 462.9 }, { type: "pole", x: 384.1, y: 439.65 }, { type: "rightSlope", x: -22.9, y: 247.55, width: 100, height: 100, rotation: 0 }, { type: "ziplinePole", x: -156.3, y: 58 }, { type: "ziplinePole", x: -599.15, y: 119.2 }, { type: "spike30x", x: -538.25, y: 195.6, rotation: 90 }, { type: "ziplinePole", x: -154.05, y: 379.25 }, { type: "classicLaser", x: -206.3, y: 202.7 }, { type: "ziplinePole", x: -599.15, y: 292.7 }, { type: "ziplinePole", x: -154.05, y: 414.3 }, { type: "ziplinePole", x: -599.15, y: 524.95 }, { type: "classicLaser", x: -512.65, y: 417.9 }, { type: "ziplinePole", x: -599.15, y: 575.95 }, { type: "ziplinePole", x: -135.05, y: 746.15 }, { type: "checkpoint", x: -63.55, y: 743.2 }, { type: "basicBlock", x: -123.1, y: 352, width: 100, height: 520 }, { type: "spike10x", x: -538.25, y: 595.35, rotation: 90 }, { type: "basicBlock", x: -596.15, y: 349.85, width: 100, height: 600.2 }, { type: "buzzsaw", x: 386.1, y: 560.4, width: 121.2, height: 122.65 }, { type: "buzzsaw", x: -271.2, y: 377.8, width: 66.25, height: 67.05 }, { type: "buzzsaw", x: -390.25, y: 550.8, width: 66.25, height: 67.05 }, { type: "quadrantRight", x: 158.25, y: 749.65, rotation: 0 }, { type: "pole", x: 158.05, y: 749.2 }, { type: "quadrantRight", x: 350.3, y: 749.65, rotation: 45 }, { type: "pole", x: 350.1, y: 749.2 }, { type: "quadrantRight", x: 534.3, y: 749.65, rotation: 0 }, { type: "pole", x: 534.1, y: 749.2 }, { type: "basicBlock", x: 725, y: 831, width: 100, height: 100 }, { type: "checkpoint", x: 730.65, y: 743.25 }, { type: "basicBlock", x: -96.45, y: 831, width: 153, height: 100 }, { type: "hazardStrips", x: 538.75, y: 513.9 }, { type: "hazardStrips", x: 1264.1, y: 535.25 }, { type: "hazardStrips", x: 117, y: 93.65 }, { type: "hazardStrips", x: 227, y: 107.45 }, { type: "basicBlock", x: 1216.55, y: 856, width: 503.3, height: 50 }, { type: "basicBlock", x: 1167.3, y: 808.7, width: 236.1, height: 50 }, { type: "basicBlock", x: 1374.35, y: 808.7, width: 80.1, height: 50 }, { type: "basicBlock", x: 1514, y: 731.1, width: 100, height: 298.9 }, { type: "buzzsawHorizontalFast", x: 1310.3, y: 732.7 }, { type: "buzzsawHorizontalFast", x: 1004.25, y: 732.7 }, { type: "fallingBlock", x: 387.95, y: 346, width: 100, height: 100 }, { type: "star", x: -271.05, y: 435.1 }], levelData.level6 = [{ type: "spike10x", x: 672.1, y: -499.25, rotation: -90.00175476074219 }, { type: "checkpoint", x: 311.95, y: -388.05 }, { type: "quadrantRight", x: 385.05, y: -737.25, rotation: 0, width: 179.5 }, { type: "spike10x", x: 28.6, y: 308.75, rotation: 180 }, { type: "spike10x", x: -270.4, y: 207.9, rotation: 180 }, { type: "textFade", textNum: "5", x: 752.425, y: -131, rotation: .0008697509765625 }, { type: "bounceBlock", x: 232, y: -74.5, width: 50, height: 50 }, { type: "lockBlock", x: 230, y: 750, width: 100.05, height: 100 }, { type: "checkpoint", x: 26.85, y: -338 }, { type: "quadrantRight", x: -44, y: -76.5, rotation: 0, width: 211.5 }, { type: "checkpoint", x: 402.8, y: 163.25 }, { type: "quadrantLeft", x: 680.2, y: 401.1, rotation: 0, width: 201.5 }, { type: "key", x: 675.1, y: 403.2 }, { type: "basicBlock", x: 380, y: 300, width: 200, height: 200 }, { type: "spawnPoint", x: 329.35, y: 173.9 }, { type: "finishPortal", x: 424.05, y: 470.2 }, { type: "lockBlock", x: 230, y: 250, width: 100.05, height: 100 }, { type: "lockBlock", x: 230, y: 349.95, width: 100.05, height: 100 }, { type: "lockBlock", x: 230, y: 449.95, width: 100.05, height: 100 }, { type: "lockBlock", x: 330, y: 450, width: 100.05, height: 100 }, { type: "basicBlock", x: 530, y: 398.5, width: 100, height: 397.1 }, { type: "basicBlock", x: 130, y: 550, width: 100, height: 700 }, { type: "basicBlock", x: 630, y: 200, width: 100, height: 200 }, { type: "basicBlock", x: 30, y: 200, width: 100, height: 200 }, { type: "textFade", textNum: "31", x: 336.07500000000005, y: 92.625, rotation: 0 }, { type: "textFade", textNum: "32", x: 333.9, y: 253.325, rotation: 0 }, { type: "basicBlock", x: 630, y: -50, width: 100, height: 100 }, { type: "basicBlock", x: 30, y: -150, width: 100, height: 300.1 }, { type: "basicBlock", x: 330, y: 0, width: 300, height: 100 }, { type: "basicBlock", x: 830, y: 300, width: 100, height: 600 }, { type: "checkpoint", x: 630.3, y: 62 }, { type: "checkpoint", x: 26.85, y: 62 }, { type: "swimmingPool", x: 680, y: 400, width: 200, height: 200 }, { type: "basicBlock", x: -170, y: -125, width: 100, height: 350 }, { type: "basicBlock", x: -169, y: 150, width: 300, height: 100 }, { type: "basicBlock", x: 330, y: 700, width: 100, height: 400 }, { type: "star", x: 230, y: 750.05 }, { type: "basicBlock", x: 580, y: 550, width: 400, height: 100 }, { type: "basicBlock", x: -95, y: 25, width: 50, height: 50 }, { type: "basicBlock", x: -45, y: -75, width: 50, height: 50 }, { type: "key", x: -106.1, y: -174.55 }, { type: "basicBlock", x: -70, y: -250, width: 100, height: 100 }, { type: "basicBlock", x: 330, y: -200, width: 100, height: 300.1 }, { type: "textFade", textNum: "5", x: 128.05, y: 61.975, rotation: -90 }, { type: "textFade", textNum: "5", x: 532.15, y: 56.575, rotation: -90 }, { type: "checkpoint", x: 640.5, y: -138 }, { type: "speedBlock", x: 929.95, y: -49.95, width: 499.9, height: 100 }, { type: "basicBlock", x: 1230, y: -50, width: 100, height: 100 }, { type: "buzzsawOnStick", x: 1004.1, y: -55, rotation: -90 }, { type: "speedBlockLeft", x: 929.95, y: -280, width: 499.9, height: 100 }, { type: "buzzsawOnStick", x: 814.8, y: -274.45, rotation: 90 }, { type: "key", x: 725.05, y: -369.55 }, { type: "bounceBlock", x: 1230.3, y: -124.95, width: 50, height: 50 }, { type: "glassBlock", x: 231, y: 550, width: 100, height: 100 }, { type: "lockBlock", x: 230, y: 650, width: 100.05, height: 100 }, { type: "basicBlock", x: 230, y: 850, width: 100, height: 100 }, { type: "ziplinePole", x: -182.05, y: -335.1 }, { type: "ziplinePole", x: -749.2, y: -185.1 }, { type: "key", x: -504.2, y: -311.95 }, { type: "basicBlock", x: -750, y: -50, width: 100, height: 200 }, { type: "ziplinePole", x: -656.15, y: -84.55 }, { type: "ziplinePole", x: -259.05, y: 64.95 }, { type: "basicBlock", x: -650, y: 0, width: 100, height: 100 }, { type: "classicLaser", x: -249.1, y: -152.75 }, { type: "buzzsaw", x: -504.1, y: -157.75, width: 101, height: 102.2 }, { type: "basicBlock", x: -850, y: -175, width: 100, height: 450 }, { type: "textFade", textNum: "5", x: 732.05, y: 203.125, rotation: 90.00175476074219 }, { type: "textFade", textNum: "5", x: 172.775, y: -317.3, rotation: -179.99913024902344 }, { type: "windBlaster", x: 330, y: -350.05, rotation: -90 }, { type: "fallingBlock", x: 381, y: -548, width: 50, height: 50 }, { type: "fallingBlock", x: 291, y: -640, width: 50, height: 50 }, { type: "fallingBlock", x: 385, y: -734, width: 50, height: 50 }, { type: "fallingBlock", x: 291, y: -821, width: 50, height: 50 }, { type: "key", x: 345.5, y: -916.4 }, { type: "bounceBlock", x: -270, y: 650, width: 70, height: 70 }, { type: "key", x: 31.95, y: 569.3 }, { type: "bounceBlock", x: -116.95, y: 650, width: 70, height: 70 }, { type: "bounceBlock", x: 30, y: 650, width: 70, height: 70 }, { type: "buzzsaw", x: -439.7, y: -13.65, width: 101, height: 102.2 }, { type: "spike10x", x: 730.6, y: -557.55, rotation: 0 }, { type: "spike10x", x: 828, y: -557.55, rotation: 0 }, { type: "basicBlock", x: 780, y: -499.65, width: 200, height: 100 }], levelData.level7 = [{ type: "basicBlock", x: -173, y: 183.6, width: 150, height: 115 }, { type: "buzzsawOnStick", x: 101.19999999999999, y: -297.4, rotation: 90 }, { type: "buzzsawOnStick", x: 102.8, y: -306.6, rotation: -90 }, { type: "quadrantRight", x: 798.2, y: 896.2, rotation: 0, width: 179.5 }, { type: "quadrantRight", x: 584.15, y: 896.2, rotation: 0, width: 179.5 }, { type: "basicBlock", x: 251, y: 367, width: 100, height: 1733 }, { type: "basicBlock", x: 754.2, y: 995.75, width: 906.1, height: 100 }, { type: "checkpoint", x: 364.5, y: 894.2 }, { type: "breatheBlaster", x: 356.85, y: 926.1, rotation: -90 }, { type: "textFade", textNum: "5", x: 714.8, y: 508.67499999999995, rotation: 90.00175476074219 }, { type: "circularCannon", x: 392.15, y: 382.25 }, { type: "spike", x: 860, y: -581.35, rotation: 180 }, { type: "spike", x: 871, y: -581.35, rotation: 180 }, { type: "spike", x: 883, y: -581.35, rotation: 180 }, { type: "spike", x: 894, y: -581.35, rotation: 180 }, { type: "spike10x", x: 643.9, y: -581.65, rotation: 180 }, { type: "basicBlock", x: 643.9, y: -703.5, width: 100, height: 230 }, { type: "spike30x", x: 546.6, y: -507.7, rotation: 0 }, { type: "spike10x", x: 793.1, y: -654.1, rotation: -90 }, { type: "spike10x", x: 792.1, y: -500.2, rotation: -90 }, { type: "fallingSpike", x: -418.05, y: -49.25, rotation: 180 }, { type: "fallingSpike", x: -439.55, y: -49.25, rotation: 180 }, { type: "fallingSpike", x: -396.55, y: -49.25, rotation: 180 }, { type: "textFade", textNum: "5", x: 141.02499999999998, y: -436.525, rotation: -59.99946594238281 }, { type: "bounceBlock", x: 171.05, y: 216.05, width: 60, height: 60 }, { type: "bounceBlock", x: 31, y: 216.05, width: 60, height: 60 }, { type: "spike10x", x: -272.15, y: 376.65, rotation: 90 }, { type: "windBlaster", x: -281.05, y: 477.05, rotation: 0 }, { type: "windBlaster", x: -135.1, y: 380.1, rotation: 180 }, { type: "spike10x", x: -144, y: 480.5, rotation: -90 }, { type: "textFade", textNum: "5", x: 94.8, y: 441.17499999999995, rotation: -89.99824523925781 }, {
    type: "fallingSpike",
    x: -319.3,
    y: 12.45,
    rotation: 180
}, { type: "fallingSpike", x: -361.3, y: 12.45, rotation: 180 }, { type: "fallingSpike", x: -340.8, y: 12.45, rotation: 180 }, { type: "fallingSpike", x: -297.8, y: 12.45, rotation: 180 }, { type: "basicBlock", x: -355.15, y: 109.95, width: 150, height: 115 }, { type: "star", x: -28.45, y: 1185.8 }, { type: "classicLaser", x: -31.05, y: 969.55 }, { type: "buzzsawHorizontal", x: 78.05, y: 615.2, width: 184.8 }, { type: "basicBlock", x: -65.4, y: 665.65, width: 438.1, height: 100 }, { type: "spike", x: -438.15, y: 58, rotation: -90 }, { type: "spike", x: -438.15, y: 68.5, rotation: -90 }, { type: "spike", x: -438.15, y: 78.5, rotation: -90 }, { type: "basicBlock", x: -330.15, y: -32.3, width: 100, height: 73.5 }, { type: "textFade", textNum: "5", x: -770.2, y: 627.125, rotation: 90.00175476074219 }, { type: "buzzsaw", x: -802.6, y: 759.25, width: 76.55, height: 77.5 }, { type: "buzzsaw", x: -736.6, y: 911.3, width: 76.55, height: 77.5 }, { type: "buzzsaw", x: -632, y: 1222.3, width: 77.5, height: 76.55 }, { type: "buzzsaw", x: -479.95, y: 1124.3, width: 77.5, height: 76.55 }, { type: "textFade", textNum: "5", x: -770.2, y: 188.075, rotation: 90.00175476074219 }, { type: "buzzsaw", x: -736.6, y: 442.2, width: 76.55, height: 77.5 }, { type: "buzzsaw", x: -639.35, y: 708.65, width: 184.8, height: 187.05 }, { type: "buzzsaw", x: -639.35, y: 509.6, width: 184.8, height: 187.05 }, { type: "basicBlock", x: -638.2, y: 127, width: 200, height: 768.3 }, { type: "basicBlock", x: -380.15, y: 706.65, width: 200, height: 1087.9 }, { type: "basicBlock", x: -1e3, y: 55, width: 200, height: 300 }, { type: "basicBlock", x: 1400, y: 56, width: 200, height: 300 }, { type: "finishPortal", x: 1236.25, y: 133.95 }, { type: "basicBlock", x: -950, y: 875, width: 300, height: 1425.1 }, { type: "basicBlock", x: 200, y: 1403, width: 2000.2, height: 370 }, { type: "basicBlock", x: 1350.1, y: 875.45, width: 300, height: 1425.1 }, { type: "basicBlock", x: 1200, y: -157.15, width: 600, height: 200 }, { type: "basicBlock", x: -638.2, y: 927.9, width: 200, height: 437.8 }, { type: "checkpoint", x: 230.85, y: -536.8 }, { type: "circularCannon", x: 102, y: -302 }, { type: "checkpoint", x: -469.95, y: 125.65 }, { type: "checkpointSwimming", x: 105.2, y: 182.2 }, { type: "basicBlock", x: -279.35, y: -157.15, width: 520, height: 200 }, { type: "basicBlock", x: -67, y: -104, width: 138, height: 1268.4 }, { type: "basicBlock", x: 351, y: -449, width: 100, height: 100 }, { type: "pushBlock", x: 348.9, y: -561.95, width: 50, height: 50 }, { type: "speedBlock", x: 601, y: -449, width: 400, height: 100 }, { type: "basicBlock", x: 850, y: -473.8, width: 100, height: 150 }, { type: "basicBlock", x: 332.85, y: -782.7, width: 938.4, height: 100 }, { type: "checkpoint", x: 959.1, y: -295.15 }, { type: "basicBlock", x: 850, y: -711.2, width: 100, height: 243.05 }, { type: "classicLaser", x: 746.15, y: -698.9 }, { type: "basicBlock", x: 1069.25, y: -542.8, width: 100, height: 573.1 }, { type: "basicBlock", x: 350.4, y: -207.15, width: 100, height: 100 }, { type: "basicBlock", x: 500, y: 27.85, width: 100, height: 570.7 }, { type: "hazardStrips", x: 540, y: -257.25 }, { type: "hazardStrips", x: 899.1, y: -257.25 }, { type: "classicLaser", x: 726.4, y: -136.3 }, { type: "laserPoint", x: 545, y: -207.25 }, { type: "laserPoint", x: 904.1, y: -207.25 }, { type: "checkpointSwimming", x: 383.25, y: 182.2 }, { type: "textFade", textNum: "5", x: 969.25, y: -475.575, rotation: 90.00175476074219 }, { type: "textFade", textNum: "5", x: 426.1, y: -146.525, rotation: 90.00175476074219 }, { type: "pole", x: 823.2, y: -339.5 }, { type: "pole", x: 642.15, y: -339.5 }, { type: "spawnPoint", x: -849.85, y: 122.6 }, { type: "basicBlock", x: 475.9, y: 539.5, width: 350, height: 100 }, { type: "reaper", x: 647.4, y: 389.05, width: 161.3, rotation: -90 }, { type: "basicBlock", x: 819.2, y: 460, width: 100, height: 750 }, { type: "basicBlock", x: 594.2, y: 785, width: 350, height: 100 }, { type: "reaper", x: 383.95, y: 662.35, width: 126.35, rotation: -90 }, { type: "textFade", textNum: "34", x: 357.25, y: 995.2750000000001, rotation: 0 }, { type: "checkpoint", x: 1042.45, y: 894.2 }, { type: "breatheBlaster", x: 1034.8, y: 926.1, rotation: -90 }, { type: "textFade", textNum: "5", x: 1028.55, y: 777.625, rotation: -89.99824523925781 }, { type: "reaper", x: 1034.15, y: 439.3, width: 276.85, rotation: -90 }, { type: "reaper", x: 1034.15, y: 439.3, width: 130.45, rotation: 180 }, { type: "checkpoint", x: -187.5, y: 88.1 }, { type: "swimmingPool", x: 200, y: 721, width: 2e3, height: 994 }], levelData.level8 = [{ type: "textFade", textNum: "5", x: 38, y: 999.4250000000001, rotation: 90 }, { type: "shurikanSpawner", x: 1783.55, y: 512.7, rotation: 180 }, { type: "basicBlock", x: 1294, y: 383, width: 112, height: 100 }, { type: "basicBlock", x: 738, y: 233.5, width: 100, height: 201 }, { type: "buzzsaw", x: 929.2, y: 338.05, width: 85, height: 86 }, { type: "buzzsaw", x: 929.2, y: 227.05, width: 85, height: 86 }, { type: "textFade", textNum: "5", x: 1589.65, y: 558.275, rotation: -90 }, { type: "textFade", textNum: "5", x: 1693.55, y: 938.775, rotation: -90 }, { type: "checkpoint", x: 481.85, y: 1099.65 }, { type: "laserPoint", x: 532.7, y: 970 }, { type: "laserPoint", x: 952, y: 970 }, { type: "textFade", textNum: "5", x: 190.025, y: 1101.1, rotation: 0 }, { type: "basicBlock", x: 263, y: 691.55, width: 100, height: 100.9 }, { type: "basicBlock", x: 1189.95, y: 884.6, width: 120.1, height: 249.2 }, { type: "finishPortal", x: 835.4, y: 303.25 }, { type: "basicBlock", x: 625.15, y: 383, width: 692.8, height: 100 }, { type: "spawnPoint", x: 335.75, y: 518.5 }, { type: "basicBlock", x: 114, y: 385, width: 330, height: 550 }, { type: "basicBlock", x: 444, y: 610, width: 330, height: 100 }, { type: "sparkBlock", x: 785, y: 610, width: 100, height: 100 }, { type: "basicBlock", x: 1e3, y: 688.6, width: 100, height: 257.4 }, { type: "checkpoint", x: 1046.65, y: 871.2 }, { type: "textFade", textNum: "35", x: 488.22499999999997, y: 615.1, rotation: 0 }, { type: "textFade", textNum: "5", x: 658.025, y: 524.8, rotation: 0 }, { type: "basicBlock", x: 1190, y: 496.45, width: 120, height: 326.8 }, { type: "hazardStrips", x: 599, y: 560.15 }, { type: "hazardStrips", x: 950, y: 560.15 }, { type: "laserPoint", x: 603.85, y: 610.4 }, { type: "laserPoint", x: 955, y: 610 }, { type: "textFade", textNum: "5", x: 1102.1, y: 558.275, rotation: 90 }, { type: "sparkBlock", x: 1190, y: 710, width: 120, height: 120 }, { type: "checkpoint", x: 415.2, y: 899.45 }, { type: "key", x: 1348.9, y: 783.25 }, { type: "ziplinePole", x: 963.5, y: 875.4 }, { type: "ziplinePole", x: 485.8, y: 902.4 }, { type: "basicBlock", x: 1223.25, y: 959.2, width: 553.4, height: 100 }, { type: "basicBlock", x: 320.25, y: 987.45, width: 435.2, height: 100 }, { type: "reaper", x: 719.5, y: 864.25, width: 150.6, rotation: -90 }, { type: "basicBlock", x: 263, y: 937.45, width: 100, height: 200 }, { type: "solarBlock", x: 263, y: 1087.45, width: 100, height: 111.55 }, { type: "lightSwitch", x: 354.7, y: 899.8 }, { type: "checkpoint", x: 147.2, y: 899.45 }, { type: "lightSwitch", x: 73.05, y: 1039.9 }, { type: "sparkBlock", x: 36.7, y: 1167.4, width: 134, height: 134 }, { type: "sparkBlock", x: 263, y: 1187.45, width: 100, height: 100 }, { type: "sparkBlock", x: 396, y: 1173.55, width: 74, height: 74 }, { type: "basicBlock", x: 483, y: 1287, width: 100, height: 300 }, { type: "solarBlock", x: 263, y: 792, width: 100, height: 111.55 }, { type: "basicBlock", x: 263, y: 1387.45, width: 100, height: 300 }, { type: "hazardStrips", x: 527.85, y: 937.75 }, { type: "hazardStrips", x: 946.5, y: 909.5 }, { type: "basicBlock", x: 1400, y: 546.3, width: 100, height: 100 }, { type: "basicBlock", x: 1500, y: 734.3, width: 100, height: 549.8 }, { type: "swimmingPool", x: 1350.5, y: 784.85, width: 201, height: 250 }, { type: "checkpoint", x: 1501.6, y: 421.4 }, { type: "speedBlock", x: 1040.65, y: 1187.15, width: 1015.3, height: 100 }, { type: "quadrantLeft", x: 709.15, y: 1188.25, rotation: 0 }, { type: "quadrantLeft", x: 930.2, y: 1188.25, rotation: 45 }, { type: "quadrantLeft", x: 1137.25, y: 1188.25, rotation: 0 }, { type: "quadrantLeft", x: 1358.3, y: 1188.25, rotation: 45 }, { type: "checkpoint", x: 1598.6, y: 1098.65 }, { type: "basicBlock", x: 1749.5, y: 1187, width: 205, height: 100.9 }, { type: "lockBlock", x: 163, y: 1387.15, width: 100.05, height: 100 }, { type: "basicBlock", x: 163, y: 1487.15, width: 100, height: 100 }, { type: "star", x: 163.05, y: 1388 }, { type: "key", x: 1700.3, y: 1030.4 }, { type: "lightSwitch", x: 1640, y: 1105 }, { type: "bounceBlock", x: 1699.95, y: 1106.55, width: 60, height: 60 }, { type: "shurikanSpawner", x: 1560.9, y: 902.8, rotation: 0 }, { type: "shurikanSpawner", x: 1783.55, y: 855.8, rotation: 180 }, { type: "lockBlock", x: 1700, y: 746.75, width: 100.05, height: 100 }, { type: "basicBlock", x: 1600, y: 747.2, width: 100, height: 100.9 }, { type: "basicBlock", x: 1800, y: 436.75, width: 100, height: 720.2 }, { type: "basicBlock", x: 1598, y: 1286.65, width: 100, height: 300 }, { type: "bounceBlock", x: 1597.4, y: 671.75, width: 50, height: 50 }, { type: "textFade", textNum: "36", x: 402.775, y: 985.625, rotation: 0 }, { type: "textFade", textNum: "37", x: 1451, y: 538.5, rotation: 0 }, { type: "textFade", textNum: "5", x: 619.925, y: 1100.95, rotation: 0 }, { type: "lockBlock", x: 1300, y: 283, width: 100.05, height: 100 }, { type: "textFade", textNum: "5", x: 1394.3, y: 363.625, rotation: -90 }, { type: "basicBlock", x: 1900, y: 968.65, width: 100, height: 537.9 }, { type: "basicBlock", x: 1240, y: 183, width: 219.8, height: 100 }, { type: "basicBlock", x: -101, y: 946, width: 100, height: 1672 }, { type: "checkpoint", x: 1189.85, y: 295 }, { type: "circularCannon", x: 1051.05, y: 286 }, { type: "basicBlock", x: 879.4, y: 183, width: 184.8, height: 100 }], levelData.level9 = [{ type: "buzzsawVerticalUp", x: 1225.1, y: 425.9 }, { type: "buzzsaw", x: 1322.1, y: 459.9, width: 101, height: 102.2 }, { type: "buzzsawVerticalUp", x: 776.15, y: 325.9 }, { type: "buzzsawHorizontal", x: 1053.9, y: 573.95 }, { type: "buzzsaw", x: -265.4, y: -199.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: -26.35, y: -225.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: 29.7, y: -225.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: -119.4, y: -195.95, width: 51, height: 51.6 }, { type: "spike30x", x: -133.85, y: -47.9, rotation: 0 }, { type: "spike30x", x: 415.8, y: -47.9, rotation: 0 }, { type: "spike30x", x: 124.75, y: -47.9, rotation: 0 }, { type: "timedKey", x: 1054.8, y: 115.85 }, { type: "timedKey", x: 1054.8, y: 571.05 }, { type: "fallingBlock", x: 830.95, y: 155.55, width: 50, height: 50 }, { type: "fallingBlock", x: 1054.15, y: 185, width: 50, height: 50 }, { type: "fallingBlock", x: 1232.9, y: 155.55, width: 50, height: 50 }, { type: "bouncingBuzzsaw", x: 592.15, y: 308.35, width: 51 }, { type: "fallingSpike", x: 574.3, y: 564.9, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 542.9, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 521.4, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 499.4, rotation: 90 }, { type: "fallingSpike", x: 659, y: 609.4, rotation: -90 }, { type: "fallingSpike", x: 659, y: 631.4, rotation: -90 }, { type: "fallingSpike", x: 659, y: 652.9, rotation: -90 }, { type: "fallingSpike", x: 659, y: 674.9, rotation: -90 }, { type: "shurikanDispenser", x: 187.9, y: 300 }, { type: "shurikanDispenser", x: 187.9, y: 540 }, { type: "shurikanDispenser", x: 428, y: 542.95 }, { type: "shurikanDispenser", x: 428, y: 816.95 }, { type: "basicBlock", x: 368, y: 401.65, width: 200, height: 100 }, { type: "basicBlock", x: 246.9, y: 646.6, width: 200, height: 100 }, { type: "basicBlock", x: 91.4, y: 10, width: 750, height: 100 }, { type: "fallingSpike", x: 181.35, y: 126.55, rotation: 180 }, { type: "fallingSpike", x: 203.35, y: 126.55, rotation: 180 }, { type: "fallingSpike", x: -64.45, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -86.45, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -107.95, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -129.95, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: 79.55, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: 57.55, y: 152.1, rotation: 0 }, { type: "basicBlock", x: -8.1, y: 210, width: 750, height: 100 }, { type: "basicBlock", x: -118.1, y: 610, width: 330, height: 100 }, { type: "shurikanDispenser", x: -158.3, y: 403.55 }, { type: "shurikanDispenser", x: -1.05, y: 506.05 }, { type: "basicBlock", x: -333.1, y: 510, width: 100, height: 300 }, { type: "basicBlock", x: -233.1, y: 410, width: 100, height: 100 }, { type: "basicBlock", x: 96.9, y: 560.8, width: 100, height: 800 }, { type: "basicBlock", x: -80.1, y: 462, width: 50, height: 50 }, { type: "checkpoint", x: -243.25, y: 322 }, { type: "basicBlock", x: -208.1, y: 489.05, width: 50, height: 58 }, { type: "pole", x: -517.1, y: 304.55 }, { type: "pole", x: -649.1, y: 249.55 }, { type: "pole", x: -489.3, y: 200.55 }, { type: "shurikanDispenser", x: -597.4, y: 172.75 }, { type: "checkpoint", x: -322.6, y: 122 }, { type: "textFade", textNum: "5", x: -167.075, y: 537.3, rotation: .004364013671875 }, { type: "textFade", textNum: "5", x: -421.1, y: 298.17499999999995, rotation: -89.99563598632812 }, { type: "basicBlock", x: -750.05, y: 291.35, width: 100, height: 934.6 }, { type: "fallingSpike", x: -223.65, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -201.65, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -180.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -158.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -36.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -14.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: 7.35, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: 29.35, y: 67.9, rotation: 180 }, { type: "basicBlock", x: 196.9, y: 40, width: 100, height: 159.95 }, { type: "checkpoint", x: 316.35, y: 122.15 }, { type: "textFade", textNum: "5", x: 416.1, y: 249.575, rotation: 90.00436401367188 }, { type: "solarBlock", x: 416.9, y: 210, width: 100, height: 100 }, { type: "basicBlock", x: 516.4, y: 360.05, width: 100, height: 800 }, { type: "solarBlock", x: 616.4, y: 210, width: 100, height: 100 }, { type: "basicBlock", x: 406.9, y: 911, width: 520, height: 100 }, { type: "basicBlock", x: 716.4, y: 561, width: 100, height: 800 }, { type: "checkpoint", x: 741.5, y: 123 }, { type: "lightSwitch", x: 415.15, y: 120.55 }, { type: "swimmingPool", x: 406.9, y: 560.55, width: 520, height: 600.9 }, { type: "basicBlock", x: 1046, y: 676.45, width: 560.1, height: 100 }, { type: "basicBlock", x: 1424, y: -108.1, width: 200, height: 330.1 }, { type: "basicBlock", x: 1574, y: 231.95, width: 300, height: 150 }, { type: "lockBlock", x: 1474, y: 106.95, width: 100.05, height: 100 }, { type: "basicBlock", x: 1374, y: 441.6, width: 100.1, height: 570 }, { type: "bounceBlock", x: 1664.65, y: 126.95, width: 60, height: 60 }, { type: "textFade", textNum: "5", x: 1601.95, y: -1.9749999999999943, rotation: -104.99484252929688 }, { type: "ziplinePole", x: 1341, y: -308.1 }, { type: "ziplinePole", x: 517.1, y: -255 }, { type: "checkpoint", x: 420.15, y: -258 }, { type: "textFade", textNum: "5", x: 645.075, y: 132.6, rotation: .004364013671875 }, { type: "shurikanDispenser", x: 1125.55, y: -315.25 }, { type: "shurikanDispenser", x: 712.95, y: -287.8 }, { type: "basicBlock", x: 516.4, y: -124.8, width: 100, height: 190.25 }, { type: "basicBlock", x: 414.65, y: -169.9, width: 105.1, height: 100 }, { type: "checkpoint", x: 1463.85, y: -310.8 }, { type: "invisBlock", x: 196.9, y: -169.9, width: 100, height: 100 }, { type: "textFade", textNum: "39", x: 464.725, y: -165.175, rotation: 0 }, { type: "textFade", textNum: "40", x: 682.875, y: 61.625, rotation: 0 }, { type: "invisBlockUp", x: -.35, y: -225.95, width: 52, height: 52 }, { type: "invisBlockDown", x: -145.4, y: -195.95, width: 52, height: 52 }, { type: "invisBlockUp", x: -265.4, y: -225.95, width: 52, height: 52 }, { type: "invisBlockDown", x: -391.45, y: -285.95, width: 52, height: 52 }, { type: "invisBlockUp", x: -513.45, y: -193.95, width: 52, height: 52 }, { type: "finishPortal", x: -751.2, y: -205.55 }, { type: "star", x: 1053.25, y: 765.25 }, { type: "invisBlock", x: 1499, y: 751.6, width: 50, height: 50 }, { type: "invisBlock", x: 1449.05, y: 864.95, width: 50, height: 50 }, { type: "lockBlock", x: 1374, y: 106.95, width: 100.05, height: 100 }, { type: "invisBlock", x: 1351.05, y: 804.5, width: 50, height: 50 }, { type: "invisBlock", x: 1255.6, y: 864.95, width: 50, height: 50 }, { type: "invisBlock", x: 1149.6, y: 804.5, width: 50, height: 50 }, { type: "invisBlock", x: 1054.15, y: 864.95, width: 50, height: 50 }, { type: "invisBlock", x: 1556.05, y: 604.1, width: 50, height: 50 }, { type: "basicBlock", x: 923.9, y: 404, width: 100, height: 300 }, { type: "basicBlock", x: 1176.6, y: 404.55, width: 100, height: 300 }, { type: "swimmingPool", x: 1045, y: 410, width: 558, height: 432.9 }, { type: "spawnPoint", x: -258.25, y: 505.15 }, { type: "textFade", textNum: "5", x: 1679.375, y: 357.55, rotation: -179.9947509765625 }, { type: "textFade", textNum: "5", x: 1499.55, y: 647.975, rotation: 97.76797485351562 }, { type: "textFade", textNum: "5", x: 1335.3249999999998, y: 759.95, rotation: 180 }], levelData.level10 = [{ type: "basicBlock", x: 143.1, y: 146.7, width: 56, height: 61 }, { type: "basicBlock", x: 604, y: -164.95, width: 224.1, height: 100 }, { type: "speedBlock", x: 266.95, y: -664.75, width: 50, height: 50 }, { type: "spike10x", x: 283.6, y: -590.15, rotation: -90 }, { type: "buzzsawHorizontal", x: 239, y: -493.95 }, { type: "speedBlock", x: 268.95, y: -518.5, width: 50, height: 50 }, { type: "spike10x", x: 184.05, y: -344.75, rotation: 90 }, { type: "speedBlockLeft", x: 200.15, y: -417.2, width: 50, height: 50 }, { type: "spike10x", x: 184.05, y: -489.75, rotation: 90 }, { type: "speedBlockLeft", x: 266.95, y: -173.15, width: 50, height: 50 }, { type: "bounceBlock", x: 266.95, y: 61.8, width: 50, height: 35 }, { type: "textFade", textNum: "5", x: -1026.25, y: 148.02499999999998, rotation: -74.99945068359375 }, { type: "spike10x", x: -323.25, y: -489.15, rotation: 90 }, { type: "spike10x", x: 67.85, y: -301.8, rotation: -90 }, { type: "reaper", x: -933.45, y: -363.45, width: 459, rotation: 0 }, { type: "reaper", x: -933.5, y: -362.55, width: 135.25, rotation: -45.001312255859375 }, { type: "reaper", x: -933.8, y: -362.05, width: 316.45, rotation: -89.99824523925781 }, { type: "bouncingBuzzsaw", x: -1122.5, y: 530.65, width: 57 }, { type: "bouncingBuzzsaw", x: -1218.35, y: 530.6, width: 56.95 }, { type: "basicBlock", x: -1307, y: -14, width: 100, height: 698 }, { type: "timedKey", x: -792.3, y: 774.25 }, { type: "bouncingBuzzsaw", x: -886.7, y: 598.3, width: 57 }, { type: "bouncingBuzzsaw", x: -708.1, y: 597.05, width: 57 }, { type: "bouncingBuzzsaw", x: -743.55, y: 530.65, width: 57 }, { type: "bouncingBuzzsaw", x: -839.4, y: 530.6, width: 56.95 }, { type: "checkpoint", x: -419.9, y: 593.55 }, { type: "spike30x", x: 159.2, y: 337.25, rotation: -90 }, { type: "spike10x", x: -38.15, y: 322.35, rotation: 0 }, { type: "fallingSpike", x: -104.2, y: 197.05, rotation: -90 }, { type: "fallingSpike", x: -104.2, y: 172.55, rotation: -90 }, { type: "fallingSpike", x: -104.2, y: 185.05, rotation: -90 }, { type: "basicBlock", x: -71, y: 141.4, width: 51, height: 122.65 }, { type: "ziplinePole", x: -445, y: 195.7 }, { type: "spike30x", x: -813.3, y: 259.85, rotation: 0 }, { type: "spike10x", x: -619.1, y: 259.85, rotation: 0 }, { type: "wire", x: 410.9, y: 30.05, rotation: -90 }, { type: "wire", x: 360.9, y: 30.05, rotation: -90 }, { type: "wire", x: 310.9, y: 30.05, rotation: -90 }, { type: "wire", x: 260.9, y: 30.05, rotation: -90 }, { type: "wire", x: 210.9, y: 30.05, rotation: -90 }, { type: "wire", x: 160.9, y: 30.05, rotation: -90 }, { type: "wire", x: 110.9, y: 30.05, rotation: -90 }, { type: "wire", x: 60.9, y: 30.05, rotation: -90 }, { type: "wire", x: 10.9, y: 30.05, rotation: -90 }, { type: "wire", x: -39.1, y: 30.05, rotation: -90 }, { type: "wire", x: -89.1, y: 30.05, rotation: -90 }, { type: "wire", x: -139.1, y: 30.05, rotation: -90 }, { type: "wire", x: -160.1, y: 59.05, rotation: 180 }, { type: "wire", x: -160.1, y: 109.05, rotation: 180 }, { type: "wire", x: -189.1, y: 130.05, rotation: -90 }, { type: "wire", x: -239.1, y: 130.05, rotation: -90 }, { type: "wire", x: -289.1, y: 130.05, rotation: -90 }, { type: "wire", x: -339.1, y: 130.05, rotation: -90 }, { type: "wire", x: -389.1, y: 130.05, rotation: -90 }, { type: "wire", x: -439.1, y: 130.05, rotation: -90 }, { type: "wire", x: -489.1, y: 130.05, rotation: -90 }, { type: "wire", x: -539.1, y: 130.05, rotation: -90 }, { type: "wire", x: -589.1, y: 130.05, rotation: -90 }, { type: "wire", x: -639.1, y: 130.05, rotation: -90 }, { type: "wire", x: -689.1, y: 130.05, rotation: -90 }, { type: "wire", x: -739.1, y: 130.05, rotation: -90 }, { type: "wire", x: -789.1, y: 130.05, rotation: -90 }, { type: "wire", x: -839.1, y: 130.05, rotation: -90 }, { type: "wire", x: -889.1, y: 130.05, rotation: -90 }, { type: "wire", x: -939.1, y: 130.05, rotation: -90 }, { type: "wire", x: -989.1, y: 130.05, rotation: -90 }, { type: "wire", x: -1039.1, y: 130.05, rotation: -90 }, { type: "wire", x: -1089.1, y: 130.05, rotation: -90 }, { type: "wire", x: -1110.1, y: 159.05, rotation: 180 }, { type: "basicBlock", x: 381.05, y: 127.3, width: 330, height: 100 }, { type: "finishPortal", x: 484.9, y: -51.75 }, { type: "explosiveBlock", x: 485.05, y: 27.3, width: 100, height: 100 }, { type: "basicBlock", x: -1222, y: 284, width: 329.9, height: 100 }, { type: "enlargingBuzzsaw", x: -782.2, y: 130.3, width: 124.7 }, { type: "basicBlock", x: -531.15, y: 279.75, width: 200, height: 100 }, { type: "invisBlock", x: -895.3, y: 229.65, width: 50, height: 50 }, { type: "invisBlockUp", x: -946.35, y: 109.65, width: 50, height: 50 }, { type: "basicBlock", x: -895.3, y: -9.25, width: 50, height: 50 }, { type: "basicBlock", x: -683.7, y: -9.25, width: 50, height: 50 }, { type: "checkpoint", x: -513.9, y: 191.75 }, { type: "basicBlock", x: -908, y: -313, width: 700, height: 100 }, { type: "basicBlock", x: -1008.95, y: 531, width: 100, height: 593.2 }, { type: "basicBlock", x: -794.9, y: 317.75, width: 335.9, height: 100 }, { type: "basicBlock", x: -381.15, y: -242, width: 100, height: 597.1 }, { type: "ziplinePole", x: -17.85, y: 294.7 }, { type: "basicBlock", x: -16.55, y: 379.75, width: 60, height: 100 }, { type: "fallingSpike", x: -82.05, y: 286.55, rotation: 0 }, { type: "fallingSpike", x: -57.55, y: 286.55, rotation: 0 }, { type: "fallingSpike", x: -70.05, y: 286.55, rotation: 0 }, { type: "basicBlock", x: -69.3, y: 393.1, width: 51, height: 197.8 }, { type: "ziplinePole", x: 65.75, y: 532.25 }, { type: "basicBlock", x: 113.05, y: 617.3, width: 110, height: 100 }, { type: "basicBlock", x: 193.05, y: 391.75, width: 50, height: 551.1 }, { type: "basicBlock", x: 10.7, y: 127.3, width: 214.8, height: 100 }, { type: "textFade", textNum: "5", x: 93.5, y: 269.275, rotation: 90.00175476074219 }, { type: "ziplinePole", x: -351.95, y: 596.5 }, { type: "basicBlock", x: -440.1, y: 680.55, width: 200, height: 100 }, { type: "basicBlock", x: -581.15, y: 338.35, width: 100, height: 217 }, { type: "buzzsawOnStick", x: -226.2, y: 552.5, rotation: -90 }, { type: "buzzsawOnStick", x: -90.95000000000002, y: 540.3, rotation: 90 }, { type: "laserPoint", x: -436.1, y: 315.1 }, { type: "laserPoint", x: -90.5, y: 315.1 }, { type: "hazardStrips", x: -94.8, y: 294.45 }, { type: "hazardStrips", x: -441.15, y: 229.75 }, { type: "basicBlock", x: -581.15, y: 784.4, width: 100, height: 486.9 }, { type: "lightSwitch", x: -499.1, y: 581.15 }, { type: "basicBlock", x: -958.75, y: 978.2, width: 656.2, height: 100 }, { type: "solarBlock", x: -1009.15, y: 878.2, width: 100, height: 100 }, { type: "basicBlock", x: -1337.15, y: 810, width: 100, height: 436.8 }, { type: "checkpoint", x: -1439.1, y: 554.65 }, { type: "lockBlock", x: -1337.15, y: 542, width: 100.05, height: 100 }, { type: "basicBlock", x: -1337, y: 412.8, width: 100, height: 158.5 }, { type: "basicBlock", x: -1475.65, y: 641.5, width: 178.9, height: 100 }, { type: "bounceBlock", x: -1540.1, y: 566.8, width: 50, height: 50 }, { type: "circularCannon", x: -1535.25, y: 236.3 }, { type: "shurikanDispenser", x: -1425.15, y: 142.65 }, { type: "shurikanDispenser", x: -1644.2, y: 142.65 }, { type: "shurikanDispenser", x: -1425.15, y: 329.7 }, { type: "shurikanDispenser", x: -1644.2, y: 329.7 }, { type: "circularCannon", x: -1535.25, y: -76.75 }, { type: "shurikanDispenser", x: -1425.15, y: -170.4 }, { type: "shurikanDispenser", x: -1644.2, y: -170.4 }, { type: "shurikanDispenser", x: -1425.15, y: 16.65 }, { type: "shurikanDispenser", x: -1644.2, y: 16.65 }, { type: "checkpoint", x: -1307.25, y: -401.35 }, { type: "basicBlock", x: -1756.4, y: 346.75, width: 100, height: 1224.1 }, { type: "textFade", textNum: "5", x: -1540.35, y: 448.07500000000005, rotation: -89.99824523925781 }, { type: "pushBlock", x: -1203.3, y: -427.15, width: 50, height: 49.9 }, { type: "checkpoint", x: -380.65, y: -578.55 }, { type: "shurikanSpawner", x: -263.15, y: -279.5, rotation: -90 }, { type: "shurikanSpawner", x: 29.2, y: -514.7, rotation: 90 }, { type: "shurikanSpawner", x: -153.05, y: -514.7, rotation: 90 }, { type: "iceBlock", x: -181.15, y: -490.55, width: 300, height: 100.05 }, { type: "iceBlock", x: -73.85, y: -303.2, width: 300, height: 100.05 }, { type: "iceBlock", x: -181.15, y: -98.15, width: 300, height: 100.05 }, { type: "shurikanSpawner", x: -301.1, y: -269.7, rotation: 0 }, { type: "shurikanSpawner", x: -80.9, y: -159.6, rotation: 180 }, { type: "shurikanSpawner", x: -318.6, y: -427.4, rotation: 0 }, { type: "spawnPoint", x: -1231.25, y: 209.9 }, { type: "swimmingPool", x: -959.2, y: 767.2, width: 656, height: 322.1 }, { type: "basicBlock", x: 341.95, y: 59.8, width: 100, height: 38 }, { type: "speedBlock", x: 201.15, y: -70.2, width: 50, height: 50 }, { type: "checkpoint", x: 169.25, y: 78.3 }, { type: "spike10x", x: 284.05, y: -97, rotation: -90 }, { type: "basicBlock", x: 341.95, y: -362.55, width: 100, height: 761.1 }, { type: "spike10x", x: 184.05, y: -246.75, rotation: 90 }, { type: "pole", x: 226, y: -342.45 }, { type: "checkpoint", x: 343.15, y: -781.1 }, { type: "basicBlock", x: 763.05, y: -85.8, width: 100, height: 528.8 }, { type: "textFade", textNum: "4", x: -544.8, y: -458.625, rotation: 0 }, { type: "textFade", textNum: "5", x: 254.55, y: -28.025, rotation: -90 }, { type: "basicBlock", x: 415.95, y: -718.1, width: 50, height: 50 }, { type: "basicBlock", x: 466.95, y: -565.25, width: 50, height: 147 }, { type: "basicBlock", x: 416.95, y: -418.35, width: 50, height: 50 }, { type: "lockBlock", x: 441.95, y: -164.95, width: 100.05, height: 100 }, { type: "timedKey", x: 683.85, y: -248.85 }, { type: "fallingBlock", x: 466.95, y: -418.35, width: 50, height: 50 }, { type: "fallingBlock", x: 516.95, y: -418.35, width: 50, height: 50 }, { type: "fallingBlock", x: 566.95, y: -418.35, width: 50, height: 50 }, { type: "fallingBlock", x: 616.95, y: -418.35, width: 50, height: 50 }, { type: "basicBlock", x: 516.95, y: -277.45, width: 50, height: 124.95 }, { type: "classicLaser", x: 423.95, y: -352.7 }, { type: "textFade", textNum: "42", x: -1166.65, y: 287.3, rotation: 0 }, { type: "basicBlock", x: 688.65, y: -324.65, width: 50, height: 50 }, { type: "basicBlock", x: 126, y: -448.8, width: 100, height: 807 }, { type: "lockBlock", x: 763.05, y: -400.4, width: 100.05, height: 100 }, { type: "basicBlock", x: 763.65, y: -714.5, width: 100, height: 528.8 }, { type: "basicBlock", x: 924.1, y: -300.65, width: 224.1, height: 100 }, { type: "timedKey", x: 993.65, y: -398.65 }, { type: "star", x: 942.25, y: -400.05 }, { type: "basicBlock", x: 925.7, y: -500.4, width: 224.1, height: 100 }, { type: "classicLaser", x: 1061.7, y: -404.65 }], levelData.level1c = [{ type: "spike10x", x: 45.9, y: 477.6, rotation: 90 }, { type: "spike10x", x: 145.05, y: 524.4, rotation: 180 }, { type: "spike10x", x: 41.05, y: 416.25, rotation: 180 }, { type: "textFade", textNum: "16", x: 643.375, y: 591.65, rotation: 179.99913024902344 }, { type: "reaper", x: 507.7, y: 552.35, width: 207.1, rotation: 0 }, { type: "leftSlope", x: 97, y: 147.85, width: 100, height: 100, rotation: -90 }, { type: "leftSlope", x: -427.1, y: 149.85, width: 100, height: 102, rotation: 180 }, { type: "basicBlock", x: 295.1, y: -90.95, width: 116, height: 100 }, { type: "spike30x", x: -417.1, y: -8.05, rotation: 0 }, { type: "spike30x", x: 5, y: -8.05, rotation: 0 }, { type: "spike10x", x: -263.1, y: 49.85, rotation: 90 }, { type: "spike10x", x: -149.1, y: 50, rotation: -90 }, { type: "basicBlock", x: -423.5, y: 49.85, width: 304.7, height: 100.05 }, { type: "basicBlock", x: 9.9, y: 50, width: 300.7, height: 100.05 }, { type: "spike10x", x: 137.1, y: -92.35, rotation: -90 }, { type: "basicBlock", x: 820, y: 670, width: 220, height: 100.05 }, { type: "textFade", textNum: "15", x: -588.025, y: 352.75, rotation: 179.99913024902344 }, { type: "textFade", textNum: "15", x: 493.775, y: 246.7, rotation: 0 }, { type: "textFade", textNum: "17", x: 62.25, y: 500.225, rotation: -90.00175476074219 }, { type: "textFade", textNum: "17", x: -906.95, y: 261.825, rotation: -90.00175476074219 }, { type: "textFade", textNum: "15", x: 842.75, y: 207.42499999999998, rotation: 90 }, { type: "textFade", textNum: "15", x: -625.075, y: -276.55, rotation: -.0008697509765625 }, { type: "checkpoint", x: -812.7, y: 61.85 }, { type: "bounceBlock", x: -903.95, y: 355, width: 50, height: 50 }, { type: "buzzsawVerticalUp", x: -787.9, y: 426.8 }, { type: "checkpoint", x: -494.8, y: 342.55 }, { type: "buzzsaw", x: 478.45, y: 319.4, width: 101, height: 102.2 }, { type: "buzzsaw", x: 587.45, y: 319.4, width: 101, height: 102.2 }, { type: "spike10x", x: 689.3, y: 201.85, rotation: -90 }, { type: "basicBlock", x: 722.2, y: 148.5, width: 50, height: 205.1 }, { type: "basicBlock", x: 620, y: 0, width: 780, height: 100.05 }, { type: "basicBlock", x: 360, y: 320, width: 230, height: 100.05 }, { type: "textFade", textNum: "10", x: 357.525, y: 318.475, rotation: 0 }, { type: "textFade", textNum: "8", x: 360.5, y: 178.89999999999998, rotation: 0 }, { type: "spawnPoint", x: 349.85, y: 260.45 }, { type: "basicBlock", x: 195, y: 188.7, width: 100, height: 659.3 }, { type: "basicBlock", x: 700, y: 320, width: 220, height: 100.05 }, { type: "textFade", textNum: "11", x: 699.9, y: 319.1, rotation: 0 }, { type: "basicBlock", x: 760, y: 445.05, width: 100, height: 150 }, { type: "basicBlock", x: 960, y: 484.75, width: 100, height: 871.5 }, { type: "verticalDownBlock", x: 885, y: 345.05, width: 50, height: 50 }, { type: "verticalUpBlock", x: 835, y: 495, width: 50, height: 50 }, { type: "textFade", textNum: "12", x: 831.875, y: 670.925, rotation: 0 }, { type: "checkpoint", x: 777.85, y: 582.2 }, { type: "fallingBlock", x: 685, y: 645, width: 50, height: 50 }, { type: "fallingBlock", x: 635, y: 645, width: 50, height: 50 }, { type: "basicBlock", x: 150, y: 670, width: 220, height: 100.05 }, { type: "checkpoint", x: 192.05, y: 582.2 }, { type: "textFade", textNum: "14", x: 148.7, y: 675.425, rotation: 0 }, { type: "bounceBlock", x: 65, y: 595.2, width: 50, height: 50 }, { type: "basicBlock", x: -10, y: 612, width: 100, height: 584 }, { type: "ziplinePole", x: -12.95, y: 285.05 }, { type: "ziplinePole", x: -428.9, y: 345.55 }, { type: "basicBlock", x: -464.95, y: 641.1, width: 100, height: 522.1 }, { type: "basicBlock", x: -737.55, y: 150, width: 186, height: 100.05 }, { type: "basicBlock", x: -572, y: 430, width: 116.05, height: 100.05 }, { type: "basicBlock", x: -1e3, y: -155.45, width: 100, height: 523.2 }, { type: "bounceBlock", x: -755.55, y: 75, width: 50, height: 50 }, { type: "basicBlock", x: -538.7, y: -179.55, width: 217.6, height: 100.05 }, { type: "ziplinePole", x: 193.05, y: -176.05 }, { type: "ziplinePole", x: -442.95, y: -264.55 }, { type: "finishPortal", x: 289, y: -170.85 }, { type: "basicBlock", x: 391.45, y: -274.9, width: 100, height: 467.1 }, { type: "basicBlock", x: -354.25, y: -458.45, width: 1391.6, height: 100.05 }, { type: "buzzsawVerticalUp", x: -309.3, y: -266.1 }, { type: "basicBlock", x: -1e3, y: 497.9, width: 100, height: 785.2 }, { type: "textFade", textNum: "18", x: -516.5250000000001, y: 280.5, rotation: 0 }, { type: "basicBlock", x: -892, y: 430, width: 116.05, height: 100.05 }, { type: "basicBlock", x: -562, y: 34, width: 171, height: 332.1 }, { type: "star", x: -206.05, y: 50.05 }, { type: "textFade", textNum: "41", x: -826.85, y: -3.575000000000003, rotation: 0 }, { type: "bouncingBuzzsaw", x: 886.5, y: 497.5, width: 39.6 }, { type: "circularCannon", x: 505.9, y: 552.8 }, { type: "basicBlock", x: 65, y: 384.95, width: 50, height: 50 }, { type: "basicBlock", x: 120, y: 493.35, width: 50, height: 50 }, { type: "buzzsawVerticalDown", x: -676.75, y: 426.8 }, { type: "classicLaser", x: -885.35, y: 147.5 }, { type: "classicLaser", x: -897.35, y: -212.7 }, { type: "classicLaser", x: -801.25, y: -212.7 }, { type: "classicLaser", x: -707.1, y: -212.7 }, { type: "buzzsawVerticalDown", x: -121.05, y: -243.05 }, { type: "buzzsawVerticalUp", x: 56.25, y: -218 }], levelData.level2c = [{ type: "shurikanSpawner", x: 918.55, y: -293.8, rotation: .0052490234375 }, { type: "shurikanDispenser", x: 1135.6, y: 141.2 }, { type: "spike30x", x: 1464, y: 232.9, rotation: 180 }, { type: "spike10x", x: 1658.2, y: 232.9, rotation: 180 }, { type: "buzzsaw", x: 716.25, y: 428, width: 71.25, height: 72.1 }, { type: "buzzsaw", x: 707.2, y: 300, width: 49.5, height: 50.1 }, { type: "buzzsaw", x: 715.25, y: 175, width: 71.25, height: 72.1 }, { type: "quadrantRight", x: 537.8, y: 489.7, rotation: 0 }, { type: "spike10x", x: -170.1, y: 77.7, rotation: 180 }, { type: "spike10x", x: -171.55, y: 114.6, rotation: 0 }, { type: "windBlaster", x: 82.2, y: 597.3, rotation: -90 }, { type: "shurikanSpawner", x: 1231.5, y: -471.35, rotation: 90.0052490234375 }, { type: "shurikanSpawner", x: 1085.85, y: -250, rotation: -89.9947509765625 }, { type: "shurikanSpawner", x: 990.45, y: -471.35, rotation: 90.0052490234375 }, { type: "basicBlock", x: 1085.3, y: -200, width: 460.2, height: 100 }, { type: "verticalUpBlock", x: 1137.3, y: -.05, width: 356.1, height: 150.1 }, { type: "verticalDownBlock", x: 1137.3, y: 225.05, width: 358, height: 100 }, { type: "basicBlock", x: 739.35, y: 175, width: 48.2, height: 100 }, { type: "ziplinePole", x: 1043.95, y: 530.05 }, { type: "shurikanSpawner", x: 795.9, y: 254.95, rotation: 180 }, { type: "basicBlock", x: 809.25, y: -128.65, width: 100, height: 1015.2 }, { type: "checkpoint", x: 562.35, y: -66 }, { type: "spike10x", x: 265.1, y: 14, rotation: 0 }, { type: "spike10x", x: 361.6, y: 14, rotation: 0 }, { type: "spike10x", x: 457.6, y: 14, rotation: 0 }, { type: "textFade", textNum: "17", x: -87.52499999999999, y: 222.55, rotation: -15.002182006835938 }, { type: "checkpoint", x: -107.8, y: 291.75 }, { type: "textFade", textNum: "20", x: 326.15, y: 487.17499999999995, rotation: 0 }, { type: "spike10x", x: 83.6, y: 461.15, rotation: 180 }, { type: "spike10x", x: 83.6, y: 588.4, rotation: 0 }, { type: "basicBlock", x: 449, y: 320, width: 230, height: 100.05 }, { type: "spawnPoint", x: 385.9, y: 245 }, { type: "basicBlock", x: 611, y: 470, width: 94, height: 800 }, { type: "basicBlock", x: 84.05, y: 261.7, width: 100, height: 383.1 }, { type: "basicBlock", x: 195.55, y: 647.05, width: 737.5, height: 100.05 }, { type: "basicBlock", x: -118.5, y: 464.75, width: 107, height: 272.1 }, { type: "textFade", textNum: "17", x: 269.9, y: 275.025, rotation: 90 }, { type: "basicBlock", x: 254.95, y: 46.8, width: 442.1, height: 50 }, { type: "basicBlock", x: 10, y: 252.7, width: 50, height: 50 }, { type: "basicBlock", x: -221, y: 308.05, width: 100, height: 778 }, { type: "basicBlock", x: 89.5, y: -3, width: 254, height: 50 }, { type: "spike", x: -104, y: 28.8, rotation: 180 }, { type: "spike", x: -115.5, y: 28.8, rotation: 180 }, { type: "spike", x: -115, y: -37.4, rotation: 0 }, { type: "spike", x: -103.5, y: -37.4, rotation: 0 }, { type: "verticalDownBlock", x: -109, y: -4, width: 25, height: 50 }, { type: "checkpoint", x: 45.5, y: -66 }, { type: "basicBlock", x: -121.55, y: 147.65, width: 100, height: 50 }, { type: "basicBlock", x: 591.6, y: 22, width: 235.1, height: 99.5 }, { type: "pushBlock", x: 165, y: -120, width: 50, height: 49.9 }, { type: "basicBlock", x: 295.3, y: -235.55, width: 929.6, height: 100.05 }, { type: "star", x: -223.95, y: -209.95 }, { type: "pushBlock", x: 734.25, y: -2.05, width: 50, height: 49.9 }, { type: "basicBlock", x: 682.2, y: 300, width: 50, height: 50 }, { type: "textFade", textNum: "17", x: 347.975, y: -62.55, rotation: -.00262451171875 }, { type: "basicBlock", x: 735.25, y: 428, width: 50, height: 100 }, { type: "sparkBlock", x: 809.1, y: 482.1, width: 100, height: 208.2 }, { type: "basicBlock", x: 1007.45, y: 716.85, width: 100, height: 305.95 }, { type: "checkpoint", x: 978.1, y: 525.9 }, { type: "textFade", textNum: "21", x: 124.25, y: 16.700000000000003, rotation: 0 }, { type: "textFade", textNum: "22", x: 603.325, y: 48.900000000000006, rotation: 0 }, { type: "ziplinePole", x: 1396.9, y: 576.55 }, { type: "basicBlock", x: 1395.9, y: 761, width: 100, height: 305.05 }, { type: "shurikanSpawner", x: 1183.45, y: 682.5, rotation: -89.9947509765625 }, { type: "basicBlock", x: 1544.9, y: 658.5, width: 200, height: 100 }, { type: "bounceBlock", x: 1538.9, y: 582.5, width: 52, height: 52 }, { type: "checkpoint", x: 1380.1, y: 87 }, { type: "basicBlock", x: 1516.45, y: 175, width: 400.1, height: 100 }, { type: "basicBlock", x: 909, y: 175, width: 100, height: 100 }, { type: "basicBlock", x: 883.1, y: 75, width: 48.2, height: 100 }, { type: "basicBlock", x: 1365.35, y: -25, width: 100, height: 100 }, { type: "basicBlock", x: 1465.35, y: -112, width: 100, height: 274.1 }, { type: "pushBlock", x: 1273.3, y: -338.6, width: 50, height: 49.9 }, { type: "basicBlock", x: 883.25, y: -336.55, width: 50, height: 175.05 }, { type: "finishPortal", x: 883.25, y: -453.55 }, {
    type: "basicBlock",
    x: 811,
    y: 819,
    width: 306.9,
    height: 100.05
}, { type: "spike", x: -55.5, y: 179.85, rotation: 180 }, { type: "spike", x: -67, y: 179.85, rotation: 180 }, { type: "spike", x: -66.5, y: 113.65, rotation: 0 }, { type: "spike", x: -55, y: 113.65, rotation: 0 }, { type: "verticalUpBlock", x: -60.5, y: 147.05, width: 25, height: 50 }, { type: "lockBlock", x: -15, y: 378.7, width: 100.05, height: 100 }, { type: "timedKey", x: 538.85, y: 489.55 }, { type: "swimmingPool", x: 249.25, y: 472.3, width: 630.5, height: 250 }, { type: "basicBlock", x: 809.1, y: 635.2, width: 100, height: 100 }, { type: "swimmingPool", x: 807.95, y: 677.5, width: 299.9, height: 185 }, { type: "bouncingBuzzsaw", x: 374.85, y: -145.6, width: 69.35 }, { type: "shurikanSpawner", x: 1125.15, y: 460.2, rotation: 90.0052490234375 }, { type: "shurikanSpawner", x: 1312.4, y: 460.2, rotation: 90.0052490234375 }, { type: "basicBlock", x: 1774.65, y: 346, width: 100, height: 100 }, { type: "checkpoint", x: 1445.15, y: 570.5 }, { type: "basicBlock", x: 1653.7, y: 610.05, width: 146.2, height: 196.9 }, { type: "spike10x", x: 1572.7, y: 560.2, rotation: -90 }, { type: "basicBlock", x: 1874.65, y: 296, width: 100, height: 200 }, { type: "checkpoint", x: 1352.15, y: -113 }, { type: "basicBlock", x: -146, y: 45.15, width: 50, height: 50 }], levelData.level3c = [{ type: "shurikanSpawner", x: 1604.95, y: 59.4, rotation: 180 }, { type: "textFade", textNum: "17", x: 175.275, y: 133.25, rotation: 0 }, { type: "buzzsawHorizontal", x: -108, y: 11.05 }, { type: "glassBlock", x: -107.9, y: 10.95, width: 100, height: 100.05 }, { type: "glassBlock", x: -107.9, y: 210.95, width: 100, height: 100.05 }, { type: "basicBlock", x: 715.55, y: 409.4, width: 40, height: 40 }, { type: "checkpoint", x: 616.25, y: 420.1 }, { type: "bounceBlock", x: 1587.4, y: 286.1, width: 46, height: 55 }, { type: "ziplinePole", x: 26.95, y: -86.85 }, { type: "checkpoint", x: -34.1, y: -89.8 }, { type: "basicBlock", x: -7.9, y: 252.7, width: 100, height: 611 }, { type: "spike30x", x: -749.75, y: 368.35, rotation: 180 }, { type: "spike30x", x: -697.7, y: 549.3, rotation: 0 }, { type: "spike30x", x: -456.65, y: 368.35, rotation: 180 }, { type: "spike30x", x: -406.6, y: 549.3, rotation: 0 }, { type: "bounceBlock", x: 987.15, y: 5.1, width: 45, height: 45 }, { type: "checkpoint", x: -107.35, y: 420.1 }, { type: "spike30x", x: 216.7, y: -61.15, rotation: 0 }, { type: "shurikanSpawner", x: 1436.75, y: 216.65, rotation: -90 }, { type: "spike10x", x: 1249.1, y: 77.1, rotation: 90 }, { type: "spike10x", x: 933, y: 79.1, rotation: -90 }, { type: "spike30x", x: 1090.45, y: 134, rotation: 180 }, { type: "basicBlock", x: 1091.05, y: 77.1, width: 300, height: 100.05 }, { type: "checkpoint", x: 1328.55, y: 120.95 }, { type: "basicBlock", x: 516.05, y: 208.1, width: 40, height: 40 }, { type: "checkpoint", x: 322.75, y: 120.95 }, { type: "bounceBlock", x: 97.05, y: 433.1, width: 50, height: 50 }, { type: "fallingBlock", x: 717, y: 707.1, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: 716, y: 537.075, rotation: -90 }, { type: "spawnPoint", x: 721, y: 643.1 }, { type: "basicBlock", x: 617.05, y: 607.1, width: 100, height: 300 }, { type: "basicBlock", x: 817, y: 457.1, width: 100, height: 600 }, { type: "buzzsawOnStick", x: 717.9, y: 705.8, rotation: -90 }, { type: "pole", x: 413.1, y: 393.1 }, { type: "basicBlock", x: 192.1, y: 607.6, width: 100, height: 299 }, { type: "textFade", textNum: "23", x: 412.15, y: 325.975, rotation: 0 }, { type: "textFade", textNum: "24", x: 412.175, y: 499.97499999999997, rotation: 0 }, { type: "basicBlock", x: -60, y: 508.1, width: 404.1, height: 100.05 }, { type: "pole", x: 90.3, y: 100.95 }, { type: "basicBlock", x: 317.05, y: 208.1, width: 100, height: 100.05 }, { type: "textFade", textNum: "25", x: -7.149999999999999, y: 179.075, rotation: 0 }, { type: "fallingBlock", x: 417.05, y: 208.1, width: 100, height: 100 }, { type: "fallingBlock", x: 617.05, y: 208.1, width: 100, height: 100 }, { type: "buzzsawOnStick", x: 516.4, y: 203.7, rotation: -90 }, { type: "iceBlock", x: 1087.05, y: 233.1, width: 440, height: 150.05 }, { type: "basicBlock", x: 1357.05, y: 408.1, width: 100, height: 500 }, { type: "textFade", textNum: "26", x: 951.5250000000001, y: 188.64999999999998, rotation: 0 }, { type: "basicBlock", x: 1531.05, y: 213.1, width: 78, height: 200 }, { type: "ziplinePole", x: 853.2, y: -232 }, { type: "basicBlock", x: 891.05, y: -147.95, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: 1152.3249999999998, y: 4.35, rotation: 180 }, { type: "basicBlock", x: -7.9, y: -350.1, width: 100, height: 400 }, { type: "basicBlock", x: -208, y: -172.5, width: 100, height: 1065.3 }, { type: "textFade", textNum: "27", x: -208.75, y: -57.9, rotation: 0 }, { type: "glassBlock", x: -107.9, y: 408.95, width: 100, height: 100.05 }, { type: "textFade", textNum: "17", x: -109.6, y: -151.425, rotation: 90 }, { type: "basicBlock", x: 202.2, y: -2.8, width: 321, height: 100.05 }, { type: "basicBlock", x: -600.2, y: 309.95, width: 685.1, height: 100.05 }, { type: "basicBlock", x: -550.3, y: 607, width: 785.3, height: 100.05 }, { type: "basicBlock", x: -892.9, y: 563.35, width: 100, height: 607.1 }, { type: "finishPortal", x: -810.2, y: 470.15 }, { type: "pole", x: -340.1, y: 463.1 }, { type: "pole", x: -551.15, y: 463.1 }, { type: "pole", x: -740.2, y: 463.1 }, { type: "shurikanSpawner", x: -727.4, y: 382.85, rotation: 45 }, { type: "fallingBlock", x: 67.1, y: -525.1, width: 50, height: 50 }, { type: "fallingBlock", x: 219.1, y: -549.1, width: 50, height: 50 }, { type: "fallingBlock", x: 378.75, y: -567.1, width: 50, height: 50 }, { type: "fallingBlock", x: 530.75, y: -591.1, width: 50, height: 50 }, { type: "buzzsawOnStick", x: 142.9, y: -543.1, rotation: -90 }, { type: "buzzsawOnStick", x: 304.75, y: -549.05, rotation: 90 }, { type: "buzzsawOnStick", x: 452.25, y: -581.2, rotation: -90 }, { type: "buzzsawOnStick", x: 614.1, y: -587.15, rotation: 90 }, { type: "star", x: 616.15, y: -678.15 }, { type: "basicBlock", x: 1657.05, y: 102.1, width: 100, height: 422 }, { type: "basicBlock", x: 1073.7, y: -393.9, width: 100, height: 592 }, { type: "basicBlock", x: 1572.6, y: -147.95, width: 269.1, height: 100.05 }, { type: "pushBlock", x: 1581.35, y: 87.9, width: 50, height: 49.9 }, { type: "pole", x: 1448.35, y: -57.85 }, { type: "buzzsawOnStick", x: 715.7, y: 414, rotation: 90 }, { type: "shurikanSpawner", x: -397.6, y: 540.5, rotation: -135 }, { type: "classicLaser", x: 414.55, y: 566.15 }, { type: "timedKey", x: 1384.8, y: 133.1 }, { type: "lockBlock", x: 1191.05, y: -22.9, width: 100.05, height: 100 }, { type: "basicBlock", x: 1135.75, y: -147.95, width: 26.3, height: 100.05 }, { type: "basicBlock", x: 1191.05, y: -135.4, width: 100, height: 125 }], levelData.level4c = [{ type: "fallingSpike", x: -587.55, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -609.05, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -501.45, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -522.95, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -415.3, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -436.8, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -329.2, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: -350.7, y: -466.45, rotation: 0 }, { type: "fallingSpike", x: 842.7, y: -369.6, rotation: -90 }, { type: "fallingSpike", x: 842.7, y: -348.1, rotation: -90 }, { type: "fallingSpike", x: 842.7, y: -412.7, rotation: -90 }, { type: "fallingSpike", x: 842.7, y: -391.2, rotation: -90 }, { type: "fallingSpike", x: 842.7, y: -434.2, rotation: -90 }, { type: "fallingSpike", x: 932.15, y: -167.85, rotation: 0 }, { type: "fallingSpike", x: 910.65, y: -167.85, rotation: 0 }, { type: "fallingSpike", x: 975.25, y: -167.85, rotation: 0 }, { type: "fallingSpike", x: 953.75, y: -167.85, rotation: 0 }, { type: "fallingSpike", x: 996.75, y: -167.85, rotation: 0 }, { type: "quadrantLeft", x: 944.25, y: 342.6, rotation: 0 }, { type: "verticalUpBlock", x: 943.25, y: 339.6, width: 32, height: 100 }, { type: "quadrantLeft", x: 1146.3, y: 342.6, rotation: 0 }, { type: "verticalDownBlock", x: 1145.3, y: 339.6, width: 32, height: 100 }, { type: "quadrantLeft", x: 91, y: 197.05, rotation: 0 }, { type: "spike10x", x: 703.05, y: 320, rotation: 89.99824523925781 }, { type: "spike10x", x: 746.5, y: 461.85, rotation: -.0008697509765625 }, { type: "spike10x", x: 786.1, y: 321.4, rotation: -90.00175476074219 }, { type: "fallingSpike", x: -393.75, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -372.25, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -479.85, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -458.35, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -566, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -544.5, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -652.1, y: -571.35, rotation: 180 }, { type: "fallingSpike", x: -630.6, y: -571.35, rotation: 180 }, { type: "basicBlock", x: -770.2, y: -567.4, width: 100, height: 225.2 }, { type: "spike30x", x: 200.45, y: -167.85, rotation: 0 }, { type: "spike10x", x: 8.05, y: -168.1, rotation: 0 }, { type: "spike10x", x: -87.45, y: -168.1, rotation: 0 }, { type: "textFade", textNum: "5", x: 37.05, y: 342.975, rotation: -90 }, { type: "textFade", textNum: "4", x: 617.5, y: -5.225000000000001, rotation: 0 }, { type: "windBlaster", x: 1249.1, y: 70.95, rotation: -90 }, { type: "buzzsaw", x: 1044.4, y: 340.25, width: 101, height: 102.2 }, { type: "glassBlock", x: 943.95, y: 143.65, width: 100, height: 100 }, { type: "basicBlock", x: 1043.95, y: 90.85, width: 100, height: 500 }, { type: "basicBlock", x: 666.85, y: 44.75, width: 50, height: 100 }, { type: "spike10x", x: 187.1, y: 318.25, rotation: -90.00175476074219 }, { type: "spike10x", x: 183.05, y: 485.85, rotation: 89.99824523925781 }, { type: "shurikanSpawner", x: 555.4, y: 311.8, rotation: 90 }, { type: "speedBlock", x: 545, y: 320, width: 300, height: 100.05 }, { type: "basicBlock", x: 345, y: 320, width: 100, height: 100.05 }, { type: "spawnPoint", x: 331.9, y: 240.55 }, { type: "basicBlock", x: 345, y: 615.35, width: 100, height: 291.2 }, { type: "basicBlock", x: 956.05, y: 520, width: 522.1, height: 100.05 }, { type: "speedBlockLeft", x: 545, y: 520, width: 300, height: 100.05 }, { type: "checkpoint", x: 347.3, y: 432 }, { type: "basicBlock", x: 844, y: 418, width: 100, height: 696 }, { type: "basicBlock", x: 245, y: 219.85, width: 100, height: 300 }, { type: "textFade", textNum: "5", x: 469.42499999999995, y: 236.05, rotation: 0 }, { type: "basicBlock", x: 87.3, y: 486.85, width: 176.7, height: 100.05 }, { type: "basicBlock", x: 545.05, y: 119.85, width: 500.1, height: 100.05 }, { type: "basicBlock", x: -50, y: 300.9, width: 100, height: 921.7 }, { type: "classicLaser", x: 154.05, y: 240.6 }, { type: "checkpoint", x: 252.35, y: 32 }, { type: "verticalUpBlock", x: 90, y: 194.05, width: 50, height: 100 }, { type: "basicBlock", x: 90, y: 343.1, width: 50, height: 100 }, { type: "textFade", textNum: "28", x: 332.4, y: 323.725, rotation: 0 }, { type: "basicBlock", x: 250, y: -109.75, width: 500.1, height: 100.05 }, { type: "bouncingBuzzsaw", x: 571.75, y: -75.8, width: 69 }, { type: "basicBlock", x: 940.9, y: -109, width: 402.1, height: 100.05 }, { type: "star", x: 450.95, y: -204.95 }, { type: "basicBlock", x: 350.05, y: -258.55, width: 100, height: 200 }, { type: "basicBlock", x: 473.05, y: -309, width: 346, height: 100.05 }, { type: "basicBlock", x: 691.85, y: -209, width: 100, height: 300 }, { type: "checkpoint", x: 839.4, y: 32 }, { type: "basicBlock", x: 1249.1, y: 423.1, width: 100, height: 706.3 }, { type: "checkpoint", x: 1081.8, y: -196.95 }, { type: "windBlaster", x: 789.85, y: -157.95, rotation: -90 }, { type: "windBlaster", x: 954.25, y: -341, rotation: 90 }, { type: "basicBlock", x: 948.85, y: -391, width: 198, height: 100.05 }, { type: "checkpoint", x: 401.35, y: -397.05 }, { type: "textFade", textNum: "5", x: 777.125, y: -393.65, rotation: 180 }, { type: "basicBlock", x: -150, y: 202, width: 100, height: 1122 }, { type: "buzzsawOnStick", x: 210.65, y: -299.35, rotation: 90 }, { type: "checkpoint", x: -255.85, y: -496.2 }, { type: "basicBlock", x: -459.9, y: -408.2, width: 720.6, height: 100.05 }, { type: "basicBlock", x: -459.25, y: -630, width: 720.6, height: 100.05 }, { type: "finishPortal", x: -690.05, y: -487.2 }, { type: "buzzsawOnStick", x: -21.199999999999996, y: -309, rotation: -90 }, { type: "textFade", textNum: "5", x: 248.175, y: 425.8, rotation: -165.00189208984375 }, { type: "swimmingPool", x: 1046.95, y: 331.8, width: 306, height: 276.3 }, { type: "iceBlock", x: 511.95, y: -396.8, width: 75, height: 75.05 }, { type: "basicBlock", x: 511.95, y: -500.3, width: 75, height: 132 }, { type: "spike30x", x: 46.4, y: -367.2, rotation: 0 }, { type: "iceBlock", x: 99.55, y: -309, width: 401, height: 100.05 }, { type: "pushBlock", x: 326.1, y: -418.15, width: 50, height: 49.9 }], levelData.level5c = [{ type: "laserPoint", x: 543.75, y: 565 }, { type: "laserPoint", x: 1269.1, y: 565 }, { type: "laserPoint", x: 122, y: 146.55 }, { type: "laserPoint", x: 231, y: 146.55 }, { type: "buzzsawOnStick", x: 349.95, y: 800.1, rotation: 90 }, { type: "buzzsawOnStick", x: 534.3, y: 791.4, rotation: -90 }, { type: "buzzsawOnStick", x: 157.9, y: 792.1, rotation: -90 }, { type: "quadrantLeft", x: 730.1, y: -192.5, rotation: 0 }, { type: "quadrantLeft", x: 1006.85, y: -192.5, rotation: 0 }, { type: "bounceBlock", x: 1439.4, y: 808.7, width: 50, height: 50 }, { type: "glassBlock", x: 390, y: 157.5, width: 126, height: 100 }, { type: "spike30x", x: -180.55, y: 465.85, rotation: -90 }, { type: "classicLaser", x: 275.15, y: 54.4 }, { type: "textFade", textNum: "15", x: 386, y: 219.525, rotation: 90.00175476074219 }, { type: "spike10x", x: 135.4, y: 462.45, rotation: 90 }, { type: "checkpoint", x: -95.8, y: 54.65 }, { type: "glassBlock", x: 389, y: -105.3, width: 122, height: 100 }, { type: "quadrantRight", x: 730.1, y: -192.5, rotation: 0 }, { type: "quadrantRight", x: 1006.85, y: -192.5, rotation: 0 }, { type: "textFade", textNum: "15", x: 1367.1, y: -10.025000000000006, rotation: -104.99729919433594 }, { type: "bounceBlock", x: 1396, y: 115, width: 50, height: 50 }, { type: "checkpoint", x: 1314.2, y: 102.65 }, { type: "spawnPoint", x: 715.8, y: 258 }, { type: "finishPortal", x: 1514.6, y: 552.25 }, { type: "basicBlock", x: 1314.1, y: 387.3, width: 100, height: 495.3 }, { type: "bouncingBuzzsaw", x: 914.1, y: 0, width: 101 }, { type: "bouncingBuzzsaw", x: 1114.1, y: 0, width: 101 }, { type: "basicBlock", x: 1414.1, y: 190, width: 100, height: 100 }, { type: "quadrantLeft", x: 1373, y: -83, rotation: 0 }, { type: "basicBlock", x: 1232.85, y: -142.5, width: 100.1, height: 100 }, { type: "textFade", textNum: "15", x: 804.125, y: 230, rotation: -14.99810791015625 }, { type: "checkpoint", x: 1234.6, y: -230.5 }, { type: "iceBlock", x: 905.3, y: -142.5, width: 556.9, height: 100.05 }, { type: "basicBlock", x: 573.8, y: -142.5, width: 106.1, height: 100 }, { type: "checkpoint", x: 578.55, y: -230.5 }, { type: "basicBlock", x: 1514, y: -35.35, width: 100, height: 1051.2 }, { type: "basicBlock", x: 497.75, y: 210.55, width: 100, height: 806.1 }, { type: "basicBlock", x: 277, y: 252.95, width: 100, height: 291 }, { type: "basicBlock", x: 226.7, y: 562, width: 200, height: 100 }, { type: "pushBlock", x: 470.15, y: -279.05, width: 50, height: 49.9 }, { type: "basicBlock", x: 26.95, y: 454, width: 200.1, height: 316.05 }, { type: "basicBlock", x: 77, y: -49.65, width: 100, height: 488.1 }, { type: "basicBlock", x: 177.55, y: -225.05, width: 301, height: 462.9 }, { type: "pole", x: 384.1, y: 439.65 }, { type: "rightSlope", x: -22.9, y: 247.55, width: 100, height: 100, rotation: 0 }, { type: "ziplinePole", x: -156.3, y: 58 }, { type: "ziplinePole", x: -599.15, y: 119.2 }, { type: "spike30x", x: -538.25, y: 195.6, rotation: 90 }, { type: "ziplinePole", x: -154.05, y: 379.25 }, { type: "classicLaser", x: -206.3, y: 202.7 }, { type: "ziplinePole", x: -599.15, y: 292.7 }, { type: "ziplinePole", x: -154.05, y: 414.3 }, { type: "ziplinePole", x: -599.15, y: 524.95 }, { type: "classicLaser", x: -512.65, y: 417.9 }, { type: "ziplinePole", x: -599.15, y: 575.95 }, { type: "ziplinePole", x: -135.05, y: 746.15 }, { type: "checkpoint", x: -63.55, y: 743.2 }, { type: "basicBlock", x: -123.1, y: 352, width: 100, height: 520 }, { type: "spike10x", x: -538.25, y: 595.35, rotation: 90 }, { type: "basicBlock", x: -596.15, y: 349.85, width: 100, height: 600.2 }, { type: "buzzsaw", x: 386.1, y: 560.4, width: 121.2, height: 122.65 }, { type: "buzzsawHorizontal", x: -320.25, y: 377.8 }, { type: "pole", x: 158.05, y: 796.25 }, { type: "pole", x: 350.1, y: 796.25 }, { type: "pole", x: 534.1, y: 796.25 }, { type: "basicBlock", x: 725, y: 831, width: 100, height: 100 }, { type: "checkpoint", x: 730.65, y: 743.25 }, { type: "basicBlock", x: -96.45, y: 831, width: 153, height: 100 }, { type: "hazardStrips", x: 538.75, y: 513.9 }, { type: "hazardStrips", x: 1264.1, y: 535.25 }, { type: "hazardStrips", x: 117, y: 93.65 }, { type: "hazardStrips", x: 227, y: 107.45 }, { type: "basicBlock", x: 1216.55, y: 856, width: 503.3, height: 50 }, { type: "basicBlock", x: 1167.3, y: 808.7, width: 236.1, height: 50 }, { type: "basicBlock", x: 1374.35, y: 808.7, width: 80.1, height: 50 }, { type: "basicBlock", x: 1514, y: 731.1, width: 100, height: 298.9 }, { type: "fallingBlock", x: 387.95, y: 346, width: 100, height: 100 }, { type: "star", x: -271.05, y: 435.1 }, { type: "bouncingBuzzsaw", x: 1210.35, y: 666.8, width: 65.5 }, { type: "quadrantLeft", x: 1373, y: -83, rotation: 45 }, { type: "fallingBlock", x: 714.1, y: 340.1, width: 100, height: 100 }, { type: "fallingBlock", x: 914.1, y: 289.95, width: 100, height: 100 }, { type: "fallingBlock", x: 1114.1, y: 240.15, width: 100, height: 100 }, { type: "basicBlock", x: 901.55, y: -331.8, width: 761.6, height: 100 }, { type: "classicLaser", x: -223.4, y: 548.25 }, { type: "classicLaser", x: -505.75, y: 202.7 }], levelData.level6c = [{ type: "quadrantRight", x: 290.8, y: -852.25, rotation: 0, width: 179.5 }, { type: "quadrantLeft", x: -44, y: -76.5, rotation: 44.99913024902344, width: 211.5 }, { type: "checkpoint", x: 311.95, y: -388.05 }, { type: "quadrantRight", x: 385.05, y: -737.25, rotation: 0, width: 179.5 }, { type: "spike10x", x: 28.6, y: 308.75, rotation: 180 }, { type: "spike30x", x: -171.4, y: 207.9, rotation: 180 }, { type: "textFade", textNum: "5", x: 752.425, y: -131, rotation: .0008697509765625 }, { type: "bounceBlock", x: 232, y: -74.5, width: 50, height: 50 }, { type: "checkpoint", x: 26.85, y: -338 }, { type: "quadrantRight", x: -44, y: -76.5, rotation: 0, width: 211.5 }, { type: "checkpoint", x: 402.8, y: 163.25 }, { type: "quadrantLeft", x: 680.2, y: 401.1, rotation: 0, width: 201.5 }, { type: "key", x: 675.1, y: 403.2 }, { type: "basicBlock", x: 380, y: 350, width: 200, height: 300 }, { type: "spawnPoint", x: 329.35, y: 173.9 }, { type: "finishPortal", x: 225.45, y: 770.5 }, { type: "lockBlock", x: 230, y: 250, width: 100.05, height: 100 }, { type: "lockBlock", x: 230, y: 350, width: 100.05, height: 100 }, { type: "lockBlock", x: 230, y: 450, width: 100.05, height: 100 }, { type: "lockBlock", x: 230, y: 550, width: 100.05, height: 100 }, { type: "basicBlock", x: 530, y: 398.5, width: 100, height: 397.1 }, { type: "basicBlock", x: 130, y: 550, width: 100, height: 700 }, { type: "basicBlock", x: 630, y: 150, width: 100, height: 100 }, { type: "basicBlock", x: 30, y: 200, width: 100, height: 200 }, { type: "textFade", textNum: "31", x: 336.07500000000005, y: 92.625, rotation: 0 }, { type: "textFade", textNum: "32", x: 333.9, y: 253.325, rotation: 0 }, { type: "basicBlock", x: 630, y: -50, width: 100, height: 100 }, { type: "basicBlock", x: 30, y: -150, width: 100, height: 300.1 }, { type: "basicBlock", x: 330, y: 0, width: 300, height: 100 }, { type: "basicBlock", x: 830, y: 300, width: 100, height: 600 }, { type: "checkpoint", x: 630.3, y: 62 }, { type: "checkpoint", x: 26.85, y: 62 }, { type: "swimmingPool", x: 680, y: 400, width: 200, height: 200 }, { type: "basicBlock", x: -170, y: -125, width: 100, height: 350 }, { type: "basicBlock", x: -169, y: 150, width: 300, height: 100 }, { type: "basicBlock", x: 330, y: 700, width: 100, height: 400 }, { type: "basicBlock", x: 580, y: 550, width: 400, height: 100 }, { type: "basicBlock", x: -95, y: 25, width: 50, height: 50 }, { type: "basicBlock", x: -45, y: -75, width: 50, height: 50 }, { type: "key", x: -106.1, y: -174.55 }, { type: "basicBlock", x: -70, y: -250, width: 100, height: 100 }, { type: "basicBlock", x: 330, y: -200, width: 100, height: 300.1 }, { type: "textFade", textNum: "5", x: 128.05, y: 61.975, rotation: -90 }, { type: "textFade", textNum: "5", x: 532.15, y: 56.575, rotation: -90 }, { type: "checkpoint", x: 640.5, y: -138 }, { type: "basicBlock", x: 1230, y: -50, width: 100, height: 100 }, { type: "buzzsawOnStick", x: 1004.1, y: -55, rotation: -90 }, { type: "buzzsawOnStick", x: 814.8, y: -274.45, rotation: 90 }, { type: "key", x: 816, y: -369.55 }, { type: "bounceBlock", x: 1230.3, y: -124.95, width: 50, height: 50 }, { type: "lockBlock", x: 230, y: 650, width: 100.05, height: 100 }, { type: "basicBlock", x: 230, y: 850, width: 100, height: 100 }, { type: "ziplinePole", x: -182.05, y: -335.1 }, { type: "ziplinePole", x: -749.2, y: -185.1 }, { type: "key", x: -504.2, y: -311.95 }, { type: "basicBlock", x: -750, y: -50, width: 100, height: 200 }, { type: "ziplinePole", x: -656.15, y: -84.55 }, { type: "ziplinePole", x: -259.05, y: 64.95 }, { type: "basicBlock", x: -650, y: 0, width: 100, height: 100 }, { type: "classicLaser", x: -249.1, y: -152.75 }, { type: "enlargingBuzzsaw", x: -437.1, y: -140.75, width: 101 }, { type: "basicBlock", x: -850, y: -175, width: 100, height: 450 }, { type: "textFade", textNum: "5", x: 732.05, y: 203.125, rotation: 90.00175476074219 }, { type: "textFade", textNum: "5", x: 172.775, y: -317.3, rotation: -179.99913024902344 }, { type: "windBlaster", x: 330, y: -350.05, rotation: -90 }, { type: "fallingBlock", x: 381, y: -548, width: 50, height: 50 }, { type: "fallingBlock", x: 291, y: -640, width: 50, height: 50 }, { type: "fallingBlock", x: 385, y: -734, width: 50, height: 50 }, { type: "fallingBlock", x: 291, y: -852, width: 50, height: 50 }, { type: "key", x: 345.5, y: -947.4 }, { type: "bounceBlock", x: -270, y: 650, width: 70, height: 70 }, { type: "key", x: 31.95, y: 569.3 }, { type: "bounceBlock", x: 30, y: 650, width: 70, height: 70 }, { type: "sparkBlock", x: 630, y: 250, width: 100, height: 100 }, { type: "speedBlock", x: 780, y: -50, width: 200, height: 100 }, { type: "shurikanDispenser", x: -117.05, y: 454.95 }, { type: "classicLaser", x: -634.05, y: -152.75 }, { type: "spike10x", x: 755.9, y: -499.7, rotation: -90.00175476074219 }, { type: "spike10x", x: 814.4, y: -558, rotation: 0 }, { type: "spike10x", x: 911.8, y: -558, rotation: 0 }, { type: "basicBlock", x: 863.8, y: -500.1, width: 200, height: 100 }, { type: "speedBlockLeft", x: 1080, y: -283.05, width: 200, height: 100 }], levelData.level7c = [{ type: "quadrantLeft", x: 692.15, y: 896.2, rotation: 45 }, { type: "reaper", x: 677.55, y: 654.45, width: 161.3, rotation: -90 }, { type: "horizontalBlockFast", x: 645.3, y: -494.6, width: 100, height: 100 }, { type: "buzzsawOnStick", x: 97.4, y: -302.8, rotation: -180 }, { type: "buzzsawOnStick", x: 106.6, y: -301.2, rotation: 0 }, { type: "fallingSpike", x: -529.8, y: 23.45, rotation: 90 }, { type: "buzzsawVerticalUp", x: -801, y: 1124.3 }, { type: "buzzsawVerticalUp", x: -537.55, y: 911.3 }, { type: "buzzsawVerticalUp", x: -537.55, y: 442.2 }, { type: "basicBlock", x: -173, y: 183.6, width: 150, height: 115 }, { type: "buzzsawOnStick", x: 101.19999999999999, y: -297.4, rotation: 90 }, { type: "buzzsawOnStick", x: 102.8, y: -306.6, rotation: -90 }, { type: "quadrantLeft", x: 798.2, y: 896.2, rotation: 89.99824523925781 }, { type: "quadrantLeft", x: 584.15, y: 896.2, rotation: 0 }, { type: "basicBlock", x: 251, y: 367, width: 100, height: 1733 }, { type: "basicBlock", x: 754.2, y: 995.75, width: 906.1, height: 100 }, { type: "checkpoint", x: 364.5, y: 894.2 }, { type: "breatheBlaster", x: 356.85, y: 926.1, rotation: -90 }, { type: "textFade", textNum: "5", x: 714.8, y: 508.67499999999995, rotation: 90.00175476074219 }, { type: "circularCannon", x: 392.15, y: 382.25 }, { type: "spike", x: 860, y: -581.35, rotation: 180 }, { type: "spike", x: 871, y: -581.35, rotation: 180 }, { type: "spike", x: 883, y: -581.35, rotation: 180 }, { type: "spike", x: 894, y: -581.35, rotation: 180 }, { type: "spike10x", x: 643.9, y: -581.65, rotation: 180 }, { type: "basicBlock", x: 643.9, y: -703.5, width: 100, height: 230 }, { type: "spike30x", x: 546.6, y: -507.7, rotation: 0 }, { type: "spike10x", x: 793.1, y: -654.1, rotation: -90 }, { type: "fallingSpike", x: -418.05, y: -49.25, rotation: 180 }, { type: "fallingSpike", x: -439.55, y: -49.25, rotation: 180 }, { type: "fallingSpike", x: -396.55, y: -49.25, rotation: 180 }, { type: "textFade", textNum: "5", x: 141.02499999999998, y: -436.525, rotation: -59.99946594238281 }, { type: "bounceBlock", x: 171.05, y: 216.05, width: 60, height: 60 }, { type: "bounceBlock", x: 31, y: 216.05, width: 60, height: 60 }, { type: "spike10x", x: -272.15, y: 376.65, rotation: 90 }, { type: "windBlaster", x: -135.1, y: 380.1, rotation: 180 }, { type: "spike10x", x: -144, y: 480.5, rotation: -90 }, { type: "textFade", textNum: "5", x: 94.8, y: 441.17499999999995, rotation: -89.99824523925781 }, { type: "fallingSpike", x: -319.3, y: 12.45, rotation: 180 }, { type: "fallingSpike", x: -361.3, y: 12.45, rotation: 180 }, { type: "fallingSpike", x: -340.8, y: 12.45, rotation: 180 }, { type: "fallingSpike", x: -297.8, y: 12.45, rotation: 180 }, { type: "basicBlock", x: -355.15, y: 109.95, width: 150, height: 115 }, { type: "buzzsawHorizontal", x: 78.05, y: 615.6 }, { type: "basicBlock", x: -41.1, y: 665.65, width: 486.9, height: 100 }, { type: "fallingSpike", x: -438.15, y: 58, rotation: -90 }, { type: "fallingSpike", x: -438.15, y: 78.5, rotation: -90 }, { type: "basicBlock", x: -330.15, y: -32.3, width: 100, height: 73.5 }, { type: "textFade", textNum: "5", x: -770.2, y: 627.125, rotation: 90.00175476074219 }, { type: "buzzsawVerticalUp", x: -736.6, y: 911.3 }, { type: "buzzsawVerticalUp", x: -479.95, y: 1124.3 }, { type: "textFade", textNum: "5", x: -770.2, y: 188.075, rotation: 90.00175476074219 }, { type: "buzzsawVerticalUp", x: -736.6, y: 442.2 }, { type: "basicBlock", x: -638.2, y: 127, width: 200, height: 768.3 }, { type: "basicBlock", x: -380.15, y: 706.65, width: 200, height: 1087.9 }, { type: "basicBlock", x: -1e3, y: 55, width: 200, height: 300 }, { type: "basicBlock", x: 1400, y: 56, width: 200, height: 300 }, { type: "finishPortal", x: 1236.25, y: 133.95 }, { type: "basicBlock", x: -950, y: 875, width: 300, height: 1425.1 }, { type: "basicBlock", x: 200, y: 1403, width: 2000.2, height: 370 }, { type: "basicBlock", x: 1350.1, y: 875.45, width: 300, height: 1425.1 }, { type: "basicBlock", x: 1200, y: -157.15, width: 600, height: 200 }, { type: "basicBlock", x: -638.2, y: 828.3, width: 200, height: 637.4 }, { type: "checkpoint", x: 230.85, y: -536.8 }, { type: "circularCannon", x: 102, y: -302 }, { type: "checkpoint", x: -469.95, y: 125.65 }, { type: "checkpointSwimming", x: 105.2, y: 182.2 }, { type: "basicBlock", x: -279.35, y: -157.15, width: 520, height: 200 }, { type: "basicBlock", x: -67, y: -104, width: 138, height: 1268.4 }, { type: "basicBlock", x: 351, y: -449, width: 100, height: 100 }, { type: "speedBlock", x: 601, y: -449, width: 400, height: 100 }, { type: "basicBlock", x: 850, y: -473.8, width: 100, height: 150 }, { type: "basicBlock", x: 332.85, y: -782.7, width: 938.4, height: 100 }, { type: "checkpoint", x: 959.1, y: -295.15 }, { type: "basicBlock", x: 850, y: -711.2, width: 100, height: 243.05 }, { type: "classicLaser", x: 746.15, y: -698.9 }, { type: "basicBlock", x: 1069.25, y: -542.8, width: 100, height: 573.1 }, { type: "basicBlock", x: 350.4, y: -207.15, width: 100, height: 100 }, { type: "basicBlock", x: 500, y: 27.85, width: 100, height: 570.7 }, { type: "hazardStrips", x: 540, y: -257.25 }, { type: "hazardStrips", x: 899.1, y: -257.25 }, { type: "classicLaser", x: 726.4, y: -136.3 }, { type: "laserPoint", x: 545, y: -207.25 }, { type: "laserPoint", x: 904.1, y: -207.25 }, { type: "checkpointSwimming", x: 383.25, y: 182.2 }, { type: "textFade", textNum: "5", x: 969.25, y: -475.575, rotation: 90.00175476074219 }, { type: "textFade", textNum: "5", x: 426.1, y: -146.525, rotation: 90.00175476074219 }, { type: "pole", x: 823.2, y: -339.5 }, { type: "pole", x: 642.15, y: -339.5 }, { type: "spawnPoint", x: -856.95, y: 127.35 }, { type: "basicBlock", x: 475.9, y: 539.5, width: 350, height: 100 }, { type: "reaper", x: 647.4, y: 389.05, width: 161.3, rotation: -90 }, { type: "basicBlock", x: 819.2, y: 465.65, width: 100, height: 760.9 }, { type: "basicBlock", x: 584.75, y: 785, width: 368.8, height: 100 }, { type: "reaper", x: 383.95, y: 662.35, width: 126.35, rotation: -90 }, { type: "textFade", textNum: "34", x: 357.25, y: 995.2750000000001, rotation: 0 }, { type: "textFade", textNum: "5", x: 1028.55, y: 777.625, rotation: -89.99824523925781 }, { type: "checkpoint", x: -187.5, y: 88.1 }, { type: "bouncingBuzzsaw", x: -239.6, y: 379.4, width: 47 }, { type: "bouncingBuzzsaw", x: 100.55, y: 285.55, width: 47 }, { type: "enlargingBuzzsaw", x: 735.15, y: -324.1, width: 73 }, { type: "solarBlock", x: 350.4, y: 785, width: 100, height: 100 }, { type: "lightSwitch", x: 381.1, y: 290.1 }, { type: "lightSwitch", x: 434.95, y: 902.7 }, { type: "solarBlock", x: 818.4, y: 896.2, width: 100, height: 100 }, { type: "swimmingPool", x: 200, y: 721.4, width: 2e3, height: 994 }], levelData.level8c = [{ type: "bounceBlock", x: 1692.95, y: 1120, width: 60, height: 60 }, { type: "speedBlock", x: 825.25, y: 1188.75, width: 325, height: 100 }, { type: "speedBlock", x: 1249.7, y: 1188, width: 325, height: 100 }, { type: "textFade", textNum: "5", x: 38, y: 999.4250000000001, rotation: 90 }, { type: "shurikanSpawner", x: 1783.55, y: 512.7, rotation: 180 }, { type: "basicBlock", x: 1294, y: 383.05, width: 112, height: 100 }, { type: "basicBlock", x: 738, y: 233.5, width: 100, height: 201 }, { type: "buzzsaw", x: 929.2, y: 338.05, width: 85, height: 86 }, { type: "buzzsaw", x: 929.2, y: 227.05, width: 85, height: 86 }, { type: "textFade", textNum: "5", x: 1589.65, y: 558.275, rotation: -90 }, { type: "textFade", textNum: "5", x: 1693.55, y: 938.775, rotation: -90 }, { type: "checkpoint", x: 481.85, y: 1099.65 }, { type: "laserPoint", x: 532.7, y: 970 }, { type: "laserPoint", x: 952, y: 970 }, { type: "textFade", textNum: "5", x: 190.025, y: 1101.1, rotation: 0 }, { type: "basicBlock", x: 263, y: 691.55, width: 100, height: 100.9 }, { type: "basicBlock", x: 1189.95, y: 884.6, width: 120.1, height: 249.2 }, { type: "finishPortal", x: 835.4, y: 303.25 }, { type: "basicBlock", x: 625.15, y: 383, width: 692.8, height: 100 }, { type: "spawnPoint", x: 315.95, y: 538.55 }, { type: "basicBlock", x: 114, y: 385, width: 330, height: 550 }, { type: "basicBlock", x: 444, y: 610, width: 330, height: 100 }, { type: "sparkBlock", x: 785, y: 610, width: 100, height: 100 }, { type: "basicBlock", x: 1e3, y: 688.6, width: 100, height: 257.4 }, { type: "checkpoint", x: 1046.65, y: 871.2 }, { type: "textFade", textNum: "35", x: 488.22499999999997, y: 615.1, rotation: 0 }, { type: "textFade", textNum: "5", x: 658.025, y: 524.8, rotation: 0 }, { type: "basicBlock", x: 1190, y: 496.45, width: 120, height: 326.8 }, { type: "hazardStrips", x: 599, y: 560.15 }, { type: "hazardStrips", x: 950, y: 560.15 }, { type: "laserPoint", x: 603.85, y: 610.4 }, { type: "laserPoint", x: 955, y: 610 }, { type: "textFade", textNum: "5", x: 1102.1, y: 558.275, rotation: 90 }, { type: "sparkBlock", x: 1190, y: 710, width: 120, height: 120 }, { type: "checkpoint", x: 415.2, y: 899.45 }, { type: "timedKey", x: 1348.9, y: 783.25 }, { type: "ziplinePole", x: 963.5, y: 875.4 }, { type: "ziplinePole", x: 485.8, y: 902.4 }, { type: "basicBlock", x: 1223.25, y: 959.2, width: 553.4, height: 100 }, { type: "basicBlock", x: 320.25, y: 987.45, width: 435.2, height: 100 }, { type: "reaper", x: 815.5, y: 857.25, width: 133.05, rotation: -90 }, { type: "basicBlock", x: 263, y: 937.45, width: 100, height: 200 }, { type: "solarBlock", x: 263, y: 1087.45, width: 100, height: 100 }, { type: "lightSwitch", x: 354.7, y: 899.8 }, { type: "checkpoint", x: 147.2, y: 899.45 }, { type: "lightSwitch", x: 73.05, y: 1039.9 }, { type: "sparkBlock", x: 36.7, y: 1167.4, width: 134, height: 134 }, { type: "sparkBlock", x: 263, y: 1187.45, width: 100, height: 100 }, { type: "sparkBlock", x: 396, y: 1173.55, width: 74, height: 74 }, { type: "basicBlock", x: 483, y: 1287, width: 100, height: 300 }, { type: "solarBlock", x: 263, y: 792, width: 100, height: 100 }, { type: "basicBlock", x: 263, y: 1387.45, width: 100, height: 300 }, { type: "hazardStrips", x: 527.85, y: 937.75 }, { type: "hazardStrips", x: 946.5, y: 909.5 }, { type: "basicBlock", x: 1400, y: 546.3, width: 100, height: 100 }, { type: "basicBlock", x: 1500, y: 734.3, width: 100, height: 549.8 }, { type: "swimmingPool", x: 1350.5, y: 784.85, width: 201, height: 250 }, { type: "checkpoint", x: 1501.6, y: 421.4 }, { type: "quadrantLeft", x: 709.15, y: 1188.25, rotation: 0 }, { type: "quadrantLeft", x: 930.2, y: 1188.25, rotation: 45 }, { type: "quadrantLeft", x: 1137.25, y: 1188.25, rotation: 0 }, { type: "quadrantLeft", x: 1358.3, y: 1188.25, rotation: 45 }, { type: "checkpoint", x: 1598.6, y: 1098.65 }, { type: "basicBlock", x: 1690.95, y: 1187, width: 88, height: 100.9 }, { type: "basicBlock", x: 79.95, y: 1487.15, width: 266.1, height: 100 }, { type: "timedKey", x: 1820.35, y: 1030.4 }, { type: "lightSwitch", x: 1640, y: 1105 }, { type: "bounceBlock", x: 1820, y: 1207.6, width: 60, height: 60 }, { type: "shurikanSpawner", x: 1560.9, y: 902.8, rotation: 0 }, { type: "shurikanSpawner", x: 1838.55, y: 855.8, rotation: 180 }, { type: "lockBlock", x: 1700, y: 746.75, width: 100.05, height: 100 }, { type: "basicBlock", x: 1600, y: 747.2, width: 100, height: 100.9 }, { type: "basicBlock", x: 1800, y: 436.75, width: 100, height: 720.2 }, { type: "basicBlock", x: 1598, y: 1286.65, width: 100, height: 300 }, { type: "bounceBlock", x: 1597.4, y: 671.75, width: 50, height: 50 }, { type: "textFade", textNum: "36", x: 402.775, y: 985.625, rotation: 0 }, { type: "textFade", textNum: "37", x: 1451, y: 538.5, rotation: 0 }, { type: "textFade", textNum: "5", x: 619.925, y: 1100.95, rotation: 0 }, { type: "lockBlock", x: 1300, y: 283, width: 100.05, height: 100 }, { type: "textFade", textNum: "5", x: 1394.3, y: 363.625, rotation: -90 }, { type: "basicBlock", x: 1900, y: 968.65, width: 100, height: 537.9 }, { type: "basicBlock", x: 1240.2, y: 183, width: 219.8, height: 100 }, { type: "basicBlock", x: -101, y: 946, width: 100, height: 1672 }, { type: "checkpoint", x: 1189.85, y: 295 }, { type: "circularCannon", x: 1051.05, y: 286 }, { type: "basicBlock", x: 879.4, y: 183, width: 184.8, height: 100 }, { type: "reaper", x: 625.85, y: 869.35, width: 133.05, rotation: -90 }, { type: "bounceBlock", x: 190.5, y: 1414.15, width: 45, height: 45 }, { type: "basicBlock", x: 127.65, y: 1134.4, width: 50, height: 200 }, { type: "shurikanDispenser", x: 41.95, y: 1337.3 }, { type: "shurikanSpawner", x: 1838.55, y: 992.8, rotation: 180 }], levelData.level9c = [{ type: "buzzsaw", x: -540.5, y: -193.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: -484.45, y: -193.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: -292.45, y: -225.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: -236.4, y: -225.95, width: 51, height: 51.6 }, { type: "enlargingBuzzsaw", x: -391.45, y: -285.95, width: 32.95 }, { type: "windBlaster", x: -194.9, y: 160, rotation: -90 }, { type: "windBlaster", x: -94.9, y: 59, rotation: 90 }, { type: "windBlaster", x: -6.6, y: 160, rotation: -90 }, { type: "windBlaster", x: 93.4, y: 59, rotation: 90 }, { type: "buzzsawVerticalUp", x: 1225.1, y: 425.9 }, { type: "buzzsaw", x: 1322.1, y: 459.9, width: 101, height: 102.2 }, { type: "buzzsawVerticalUp", x: 776.15, y: 325.9 }, { type: "enlargingBuzzsaw", x: 1053.9, y: 573.95, width: 101 }, { type: "buzzsaw", x: -26.35, y: -225.95, width: 51, height: 51.6 }, { type: "buzzsaw", x: 29.7, y: -225.95, width: 51, height: 51.6 }, { type: "enlargingBuzzsaw", x: -145.4, y: -195.95, width: 32.95 }, { type: "spike30x", x: -133.85, y: -47.9, rotation: 0 }, { type: "spike30x", x: 415.8, y: -47.9, rotation: 0 }, { type: "spike30x", x: 124.75, y: -47.9, rotation: 0 }, { type: "timedKey", x: 924.75, y: 590 }, { type: "timedKey", x: 1174.85, y: 590 }, { type: "bouncingBuzzsaw", x: 592.15, y: 308.35, width: 51 }, { type: "fallingSpike", x: 574.3, y: 564.9, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 542.9, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 521.4, rotation: 90 }, { type: "fallingSpike", x: 574.3, y: 499.4, rotation: 90 }, { type: "fallingSpike", x: 659, y: 609.4, rotation: -90 }, { type: "fallingSpike", x: 659, y: 631.4, rotation: -90 }, { type: "fallingSpike", x: 659, y: 652.9, rotation: -90 }, { type: "fallingSpike", x: 659, y: 674.9, rotation: -90 }, { type: "shurikanDispenser", x: 187.9, y: 300 }, { type: "shurikanDispenser", x: 187.9, y: 540 }, { type: "shurikanDispenser", x: 428, y: 542.95 }, { type: "shurikanDispenser", x: 428, y: 816.95 }, { type: "basicBlock", x: 366.4, y: 401.65, width: 200, height: 100 }, { type: "basicBlock", x: 246.9, y: 646.6, width: 200, height: 100 }, { type: "basicBlock", x: 91.4, y: 10, width: 750, height: 100 }, { type: "fallingSpike", x: 181.35, y: 126.55, rotation: 180 }, { type: "fallingSpike", x: 203.35, y: 126.55, rotation: 180 }, { type: "fallingSpike", x: -64.45, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -86.45, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -107.95, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: -129.95, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: 79.55, y: 152.1, rotation: 0 }, { type: "fallingSpike", x: 57.55, y: 152.1, rotation: 0 }, { type: "basicBlock", x: -8.1, y: 210, width: 750, height: 100 }, {
    type: "basicBlock",
    x: -118.1,
    y: 610,
    width: 330,
    height: 100
}, { type: "shurikanDispenser", x: -158.3, y: 403.55 }, { type: "shurikanDispenser", x: -1.05, y: 506.05 }, { type: "basicBlock", x: -333.1, y: 510, width: 100, height: 300 }, { type: "basicBlock", x: -233.1, y: 410, width: 100, height: 100 }, { type: "basicBlock", x: 96.9, y: 560.8, width: 100, height: 800 }, { type: "fallingBlock", x: -80.1, y: 462, width: 50, height: 50 }, { type: "checkpoint", x: -243.25, y: 322 }, { type: "basicBlock", x: -208.1, y: 489.05, width: 50, height: 58 }, { type: "pole", x: -534.1, y: 289.75 }, { type: "pole", x: -597.85, y: 90.75 }, { type: "shurikanDispenser", x: -597.4, y: 172.75 }, { type: "checkpoint", x: -322.6, y: 122 }, { type: "textFade", textNum: "5", x: -167.075, y: 537.3, rotation: .004364013671875 }, { type: "textFade", textNum: "5", x: -421.1, y: 298.17499999999995, rotation: -89.99563598632812 }, { type: "basicBlock", x: -750.05, y: 291.35, width: 100, height: 934.6 }, { type: "fallingSpike", x: -223.65, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -201.65, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -180.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -158.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -36.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: -14.15, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: 7.35, y: 67.9, rotation: 180 }, { type: "fallingSpike", x: 29.35, y: 67.9, rotation: 180 }, { type: "basicBlock", x: 196.9, y: 40, width: 100, height: 159.95 }, { type: "checkpoint", x: 316.35, y: 122.15 }, { type: "textFade", textNum: "5", x: 416.1, y: 249.575, rotation: 90.00436401367188 }, { type: "solarBlock", x: 416.9, y: 210, width: 100, height: 100 }, { type: "basicBlock", x: 516.4, y: 360.05, width: 100, height: 800 }, { type: "solarBlock", x: 616.4, y: 210, width: 100, height: 100 }, { type: "basicBlock", x: 406.9, y: 911, width: 520, height: 100 }, { type: "basicBlock", x: 716.4, y: 561, width: 100, height: 800 }, { type: "checkpoint", x: 741.5, y: 123 }, { type: "lightSwitch", x: 415.15, y: 120.55 }, { type: "swimmingPool", x: 406.9, y: 560.55, width: 520, height: 600.9 }, { type: "basicBlock", x: 1046, y: 676.45, width: 560.1, height: 100 }, { type: "basicBlock", x: 1424, y: -108.1, width: 200, height: 330.1 }, { type: "basicBlock", x: 1574, y: 231.95, width: 300, height: 150 }, { type: "lockBlock", x: 1474, y: 106.95, width: 100.05, height: 100 }, { type: "basicBlock", x: 1374, y: 441.6, width: 100.1, height: 570 }, { type: "bounceBlock", x: 1664.65, y: 126.95, width: 60, height: 60 }, { type: "textFade", textNum: "5", x: 1601.95, y: -1.9749999999999943, rotation: -104.99484252929688 }, { type: "ziplinePole", x: 1341, y: -308.1 }, { type: "ziplinePole", x: 938.25, y: -286 }, { type: "checkpoint", x: 420.15, y: -258 }, { type: "textFade", textNum: "5", x: 645.075, y: 132.6, rotation: .004364013671875 }, { type: "shurikanDispenser", x: 1125.55, y: -315.25 }, { type: "shurikanDispenser", x: 712.95, y: -287.8 }, { type: "basicBlock", x: 516.4, y: -124.8, width: 100, height: 190.25 }, { type: "basicBlock", x: 414.65, y: -169.9, width: 105.1, height: 100 }, { type: "checkpoint", x: 1463.85, y: -310.8 }, { type: "invisBlock", x: 196.9, y: -169.9, width: 100, height: 100 }, { type: "textFade", textNum: "39", x: 464.725, y: -165.175, rotation: 0 }, { type: "textFade", textNum: "40", x: 682.875, y: 61.625, rotation: 0 }, { type: "invisBlockUp", x: -.35, y: -225.95, width: 52, height: 52 }, { type: "invisBlockDown", x: -145.4, y: -195.95, width: 52, height: 52 }, { type: "invisBlockUp", x: -265.4, y: -225.95, width: 52, height: 52 }, { type: "invisBlockDown", x: -391.45, y: -285.95, width: 52, height: 52 }, { type: "invisBlockUp", x: -513.45, y: -193.95, width: 52, height: 52 }, { type: "finishPortal", x: -751.2, y: -205.55 }, { type: "star", x: 1053.25, y: 765.25 }, { type: "invisBlock", x: 1499, y: 751.6, width: 50, height: 50 }, { type: "invisBlock", x: 1449.05, y: 864.95, width: 50, height: 50 }, { type: "lockBlock", x: 1374, y: 106.95, width: 100.05, height: 100 }, { type: "invisBlock", x: 1351.05, y: 804.5, width: 50, height: 50 }, { type: "invisBlock", x: 1255.6, y: 864.95, width: 50, height: 50 }, { type: "invisBlock", x: 1149.6, y: 804.5, width: 50, height: 50 }, { type: "invisBlock", x: 1054.15, y: 864.95, width: 50, height: 50 }, { type: "invisBlock", x: 1556.05, y: 604.1, width: 50, height: 50 }, { type: "basicBlock", x: 923.9, y: 404, width: 100, height: 300 }, { type: "basicBlock", x: 1176.6, y: 404.55, width: 100, height: 300 }, { type: "spawnPoint", x: -258.55, y: 505.35 }, { type: "basicBlock", x: -675.05, y: 229, width: 50, height: 50 }, { type: "swimmingPool", x: 1045, y: 410, width: 558, height: 432.9 }, { type: "ziplinePole", x: 921.9, y: -284.1 }, { type: "ziplinePole", x: 519.15, y: -255 }, { type: "sparkBlock", x: 930.05, y: -230.95, width: 44, height: 44 }];
var allunlocked = !1,
    Level = function() {
        function a(a, b, c, d, e, f, g, h, i) { this.levels = a, this.id = b, this.data = c, this.name = d, this.topTime = e, this.goldTime = 1e3 * f, this.silverTime = 1e3 * g, this.bronzeTime = 1e3 * h, this.gotStar = !1, this.found = !1, this.challengeCompleted = !1, this.hue = i, i && (this.colorFilter = new PIXI.ColorMatrixFilter, this.colorFilter.hue(i)), allunlocked && this.topTime === -1 && (this.topTime = 5), this.topTime > -1 && (this.topTime < this.goldTime ? this.bestRank = 0 : this.topTime < this.silverTime ? this.bestRank = 2 : this.topTime < this.bronzeTime ? this.bestRank = 3 : this.bestRank = 4), "hub" !== this.id && this.loadLevel() }
        return a.prototype.setBestTime = function(a, b) {
            var c = 6;
            a > -1 && (c = a < this.goldTime ? 0 === b ? 0 : 1 : a < this.silverTime ? 2 : a < this.bronzeTime ? 3 : 4), this.topTime !== -1 && c > this.bestRank || (this.topTime = a, this.topTime > a && (this.topTime = a), this.bestRank = c, this.saveLevel())
        }, a.prototype.gotGold = function() { return this.topTime !== -1 && this.topTime <= this.goldTime }, a.prototype.getRankSpriteKey = function() { return this.gotGold() && this.gotStar && this.challengeCompleted ? "clearText" : a.RANK_SPRITE_KEYS[this.bestRank] }, a.prototype.loadLevel = function() {
            var a = parseInt(this.id),
                b = SaveGame.getInstance().getLevel(a - 1);
            this.topTime = b.tt, this.bestRank = b.br, this.gotStar = b.gs, this.challengeCompleted = b.cc
        }, a.prototype.saveLevel = function() {
            var a = { tt: this.topTime, br: this.bestRank, gs: this.gotStar, cc: this.challengeCompleted, fn: this.found };
            SaveGame.getInstance().saveLevels(parseInt(this.id), a)
        }, a.prototype.clearSavedData = function() { SaveGame.getInstance().resetLevels() }, a.RANK_SPRITE_KEYS = { 0: "perfectText", 1: "goldText", 2: "silverText", 3: "bronzeText", 4: "clearText" }, a
    }(),
    Levels = function() {
        function a(a) { this.levels = {}, this.totalLoad = 0, this.loadedNum = 0, this.doneCallback = a, this.latestCompleted = Constants.latestCompleted, this.loadLevel("hub", "levelhub", "Level Hub", -1, -1, -1), this.loadLevel("1", "level1", "Act 1", 25, 45, 60, 130, "level1c"), this.loadLevel("2", "level2", "Act 2", 50, 70, 90, 180, "level2c"), this.loadLevel("3", "level3", "Act 3", 50, 70, 90, 180, "level3c"), this.loadLevel("4", "level4", "Act 4", 60, 80, 100, -150, "level4c"), this.loadLevel("5", "level5", "Act 5", 60, 80, 100, -90, "level5c"), this.loadLevel("6", "level6", "Act 6", 90, 110, 130, -40, "level6c"), this.loadLevel("7", "level7", "Act 7", 90, 110, 130, 1, "level7c"), this.loadLevel("8", "level8", "Act 8", 80, 100, 120, 30, "level8c"), this.loadLevel("9", "level9", "Act 9", 120, 150, 180, 70, "level9c"), this.loadLevel("10", "level10", "Vexation", 180, 210, 240, 100), allunlocked && (this.latestCompleted = 10), a() }
        return a.prototype.getGoldNumber = function() { var a = 0; for (var b in this.levels) { var c = this.levels[b]; "hub" != b && c.gotGold() && a++ } return a }, a.prototype.getPerfectNumber = function() { var a = 0; for (var b in this.levels) { var c = this.levels[b]; "hub" != b && 0 == c.bestRank && a++ } return a }, a.prototype.checkOlympian = function() { for (var a in this.levels) { var b = this.levels[a]; if ("hub" != a && !b.gotGold()) return !1 } return !0 }, a.prototype.checkPerfection = function() { for (var a in this.levels) { var b = this.levels[a]; if ("hub" != a && 0 !== b.bestRank) return !1 } return !0 }, a.prototype.checkAstronomer = function() { for (var a in this.levels) { var b = this.levels[a]; if ("hub" != a && !b.gotStar) return !1 } return !0 }, a.prototype.checkWinner = function() { for (var a in this.levels) { var b = this.levels[a]; if ("hub" != a && "10" != a && !b.challengeCompleted) return !1 } return !0 }, a.prototype.clearAllLevelData = function() {
            for (var a in this.levels) {
                var b = this.levels[a];
                b.clearSavedData()
            }
            this.latestCompleted = 0
        }, a.prototype.loadLevel = function(a, b, c, d, e, f, g, h) { void 0 === g && (g = 0), this.levels[a] = new Level(this, a, levelData[b], c, (-1), d, e, f, g), this.levels[a].challengeData = levelData[h] }, a
    }(),
    Sounds = function() {
        function a(a, b) { this.main = a, this.muted = !1, this.connectHang = b.add.audio("connectHang"), this.fall = b.add.audio("fall", .2), this.downgrade = b.add.audio("downgrade", .7), this.poleSwing = b.add.audio("poleSwing", .7), this.splash1 = b.add.audio("splash1", .7), this.ziplineFull = b.add.audio("ziplineFull", .7), this.cannonEnter = b.add.audio("cannonEnter", .7), this.wallSlide = b.add.audio("wallSlide", .7), this.connectSlide = b.add.audio("connect", .7), this.land = b.add.audio("land", .5), this.slide = b.add.audio("slide", .7), this.death1 = b.add.audio("death1", .7), this.death2 = b.add.audio("death2", .7), this.electricity = b.add.audio("electricity", .5), this.poleWoosh = b.add.audio("poleWoosh", .7), this.bounce1 = b.add.audio("bounce1", .7), this.cannonFire = b.add.audio("cannonFire", .7), this.glassSmash = b.add.audio("glassSmash", .7), this.fallingBlock = b.add.audio("fallingBlock", .7), this.blockDestroy = b.add.audio("blockDestroy", .7), this.buttonClick = b.add.audio("buttonClick", .7), this.achievementUnlocked = b.add.audio("achievementUnlocked", .7), this.footstep = b.add.audio("footstep", .7), this.laserFire = b.add.audio("laserFire", .7), this.ding = b.add.audio("ding", .7), this.kickBlock = b.add.audio("kickBlock", .7), this.starPickup = b.add.audio("starPickup", .7), this.menuSong = b.add.audio("menuSong", .7, !0), this.songs = [], this.vexSong1 = b.add.audio("vexSong1", .7, !0), this.songs.push(this.vexSong1), this.vexSong2 = b.add.audio("vexSong2", .7, !0), this.songs.push(this.vexSong2), this.vexSong3 = b.add.audio("vexSong3", .7, !0), this.songs.push(this.vexSong3), this.vexSong4 = b.add.audio("vexSong4", .7, !0), this.songs.push(this.vexSong4) }
        return a.prototype.playSound = function(a) {
            if (!this.muted) {
                var b = this[a];
                b.play(null, null, .6 * this.main.options.effectVolume)
            }
        }, a.prototype.playRandomMusic = function() {
            for (var a = 0, b = this.songs; a < b.length; a++) {
                var c = b[a];
                c.stop()
            }
            this.menuSong.stop();
            var d = Math.floor(Math.random() * this.songs.length),
                e = this.songs[d];
            e.play(null, null, .6 * this.main.options.musicVolume, !0), this.currentMusic = e
        }, a.prototype.playMenuSong = function() {
            for (var a = 0, b = this.songs; a < b.length; a++) {
                var c = b[a];
                c.stop()
            }
            this.menuSong.play(null, null, .6 * this.main.options.musicVolume, !0), this.currentMusic = this.menuSong
        }, a.prototype.stopAllSounds = function() {}, a
    }(),
    Entity = function() {
        function a(a) { this.main = a }
        return a.prototype.destroy = function() { this.main = null }, a.prototype.reset = function() {}, a.prototype.resetLevel = function() { this.xPos = this.startX, this.yPos = this.startY }, a
    }(),
    Point = Phaser.Point,
    HitBoxInfo = function() {
        function a(a, b, c, d) { this.xOff = a, this.yOff = b, this.width = c, this.height = d }
        return a
    }(),
    PlayerState;
! function(a) { a[a.Idle = 0] = "Idle", a[a.Running = 1] = "Running", a[a.Jumping = 2] = "Jumping", a[a.Falling = 3] = "Falling", a[a.Sliding = 4] = "Sliding", a[a.Crouching = 5] = "Crouching", a[a.Scaling = 6] = "Scaling", a[a.Hanging = 7] = "Hanging", a[a.Zipping = 8] = "Zipping", a[a.Swinging = 9] = "Swinging", a[a.Pushing = 10] = "Pushing", a[a.Kicking = 11] = "Kicking", a[a.Spawning = 12] = "Spawning", a[a.Swimming = 13] = "Swimming", a[a.JumpDown = 14] = "JumpDown", a[a.JumpFrontFlip = 15] = "JumpFrontFlip", a[a.JumpBackFlip = 16] = "JumpBackFlip" }(PlayerState || (PlayerState = {}));
var HitAreas;
! function(a) { a[a.Head = 0] = "Head", a[a.Body = 1] = "Body", a[a.Hands = 2] = "Hands", a[a.Feet = 3] = "Feet" }(HitAreas || (HitAreas = {}));
var Player = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b) || this;
            e.maxVelocity = 6, e.acc = 1, e.fallingMax = 20, e.startWidth = 18, e.maxScaleTime = 45, e.maxHangCoolDown = 10, e.maxBreathe = 600, e.scoreUpdated = !1, e.god = !1, e.game = c, e.container = c.add.group(), d.add(e.container), e.stateSprites = {};
            var f = e.container.create(0, 0, "playerStand");
            f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Idle] = f, f = e.container.create(0, 0, "playerRun"), f.animations.add("run"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Running] = f, f = e.container.create(0, 0, "playerJump"), f.animations.add("jump"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Jumping] = f, f = e.container.create(0, 0, "playerJumpDown"), f.animations.add("jump"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.JumpDown] = f, f = e.container.create(0, 0, "playerJumpFrontFlip"), f.animations.add("jump"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.JumpFrontFlip] = f, f = e.container.create(0, 0, "playerJumpBackFlip"), f.animations.add("jump"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.JumpBackFlip] = f, f = e.container.create(0, 0, "playerSlide"), f.animations.add("slide"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Sliding] = f, f = e.container.create(0, 0, "playerCrouch"), f.animations.add("crouch"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Crouching] = f, f = e.container.create(0, 0, "playerScale"), f.animations.add("scale"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Scaling] = f, f = e.container.create(0, 0, "playerHang"), f.animations.add("hang"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Hanging] = f, f = e.container.create(0, 0, "playerPulley"), f.animations.add("zip"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Zipping] = f, f = e.container.create(0, 0, "playerSwing"), f.animations.add("swing"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Swinging] = f, f = e.container.create(0, 0, "playerPush"), f.animations.add("push"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Pushing] = f, f = e.container.create(0, 0, "playerKick"), f.animations.add("kick"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Kicking] = f, f = e.container.create(0, 0, "playerFall"), f.animations.add("fall"), f.anchor.set(.5, .8), f.visible = !1, e.stateSprites[PlayerState.Falling] = f, f = e.container.create(0, 0, "playerSwimTop"), f.animations.add("swim"), f.anchor.set(.45, 17 / 23), f.y = -10, f.visible = !1, e.stateSprites[PlayerState.Swimming] = f, e.legSprite = e.container.create(0, 0, "playerSwimBottom"), e.legSprite.animations.add("swim"), e.legSprite.animations.play("swim", null, !0), e.legSprite.anchor.set(9 / 16, .15), e.legSprite.y = -10, e.legSprite.visible = !1, f = e.container.create(0, 0, "playerSpawn"), f.animations.add("spawn"), f.anchor.set(.5, 1), f.visible = !1, e.stateSprites[PlayerState.Spawning] = f, e.stateInfos = {};
            var g = {};
            g[HitAreas.Head] = new HitBoxInfo((-3.75), (-32.75), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-5.75), (-23.5), 11.5, 17.3), g[HitAreas.Hands] = new HitBoxInfo(1.4, (-19.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9.75), e.makeTotalBounds(g), e.stateInfos[PlayerState.Idle] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-33), 7.55, 18.1), g[HitAreas.Body] = new HitBoxInfo((-12.55), (-30), 24.1, 26.95), g[HitAreas.Hands] = new HitBoxInfo(1.4, (-19.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9.75), e.makeTotalBounds(g), e.stateInfos[PlayerState.Running] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-32.45), 7.55, 16.9), g[HitAreas.Body] = new HitBoxInfo((-5.05), (-23), 12, 17.3), g[HitAreas.Hands] = new HitBoxInfo(1.05, (-34.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-5.75), (-6.25), 8, 9), e.makeTotalBounds(g), e.stateInfos[PlayerState.Jumping] = g, e.stateInfos[PlayerState.JumpDown] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-16.25), (-10.35), 7.55, 7.2), g[HitAreas.Body] = new HitBoxInfo((-13), (-11.5), 18.25, 9.75), g[HitAreas.Hands] = new HitBoxInfo(.45, (-11.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 10.5), e.makeTotalBounds(g), e.stateInfos[PlayerState.Sliding] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-19), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-4.75), (-11.25), 11.5, 9.75), g[HitAreas.Hands] = new HitBoxInfo(.45, (-14.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9.75), e.makeTotalBounds(g), e.stateInfos[PlayerState.Crouching] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-33.25), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-6.1), (-23.85), 15, 17.3), g[HitAreas.Hands] = new HitBoxInfo(3.95, (-36.65), 7.55, 14.45), g[HitAreas.Feet] = new HitBoxInfo((-5.6), (-6.6), 7, 6.25), e.makeTotalBounds(g), e.stateInfos[PlayerState.Scaling] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-32.75), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-6.25), (-23.5), 11.5, 17.3), g[HitAreas.Hands] = new HitBoxInfo(.35, (-40.15), 9.75, 15.65), g[HitAreas.Feet] = new HitBoxInfo((-9.2), (-6.25), 13, 5.25), e.makeTotalBounds(g), e.stateInfos[PlayerState.Hanging] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-32.45), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-4.8), (-23), 11.5, 17.3), g[HitAreas.Hands] = new HitBoxInfo((-1.2), (-35.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9), e.makeTotalBounds(g), e.stateInfos[PlayerState.Zipping] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-32.45), 7.55, 16.9), g[HitAreas.Body] = new HitBoxInfo((-4.8), (-23), 11.5, 17.3), g[HitAreas.Hands] = new HitBoxInfo((-1.2), (-35.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9), e.makeTotalBounds(g), e.stateInfos[PlayerState.Swinging] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-3.85), (-32.45), 7.55, 16.9), g[HitAreas.Body] = new HitBoxInfo((-4.8), (-23), 11.5, 17.3), g[HitAreas.Hands] = new HitBoxInfo((-1.8), (-25.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9), e.makeTotalBounds(g), e.stateInfos[PlayerState.Pushing] = g, g = {}, g[HitAreas.Head] = new HitBoxInfo((-2.5), (-27.05), 7.55, 9.5), g[HitAreas.Body] = new HitBoxInfo((-5), (-21.4), 11.5, 13.25), g[HitAreas.Hands] = new HitBoxInfo((-1.4), (-19.5), 7.55, 9.5), g[HitAreas.Feet] = new HitBoxInfo((-6.5), (-6.25), 13, 9), e.makeTotalBounds(g), e.stateInfos[PlayerState.Swimming] = g, e.stateInfos[PlayerState.Falling] = e.stateInfos[PlayerState.Jumping], e.stateInfos[PlayerState.Spawning] = e.stateInfos[PlayerState.Idle], e.stateInfos[PlayerState.Kicking] = e.stateInfos[PlayerState.Idle], e.head = new SAT.Box(new SAT.Vector(0, 0), 13, 9.75), e.headInfo = new HitBoxInfo((-3.75), (-32.75), 7.55, 9.5), e.body = new SAT.Box(new SAT.Vector(0, 0), 13, 9.75), e.bodyInfo = new HitBoxInfo((-5.75), (-23.5), 11.5, 17.3), e.hands = new SAT.Box(new SAT.Vector(0, 0), 13, 9.75), e.handsInfo = new HitBoxInfo((-.75), (-19.5), 7.55, 9.5), e.feetInfo = new HitBoxInfo((-20.2), (-6.25), 30.05, 10.75), e.feet = new SAT.Box(new SAT.Vector(0, 0), 13, 9.75), e.pressDown = new PressDown(e.container), e.breatheGroup = c.add.group(e.container), e.breatheBlocks = [];
            for (var h = 0; h < 10; h++) {
                var i = e.breatheGroup.create(10 * (h - 5), -65, "breatheBlock");
                e.breatheBlocks.push(i)
            }
            return e.aniCont = !1, e.keys = b.keys, e.alive = !1, e.deaths = 0, e.lookingAround = !1, c.input.addMoveCallback(function() { e.main.keys.isScreenButtonDown() || e.state !== PlayerState.Idle && e.state !== PlayerState.Swimming && e.state !== PlayerState.Hanging || (e.lookingAround = !0) }, e), e
        }
        return __extends(b, a), b.prototype.makeTotalBounds = function(a) { a.leftEdgeOff = Math.min(a[HitAreas.Hands].xOff, Math.min(a[HitAreas.Feet].xOff, Math.min(a[HitAreas.Head].xOff, a[HitAreas.Body].xOff))), a.topEdgeOff = Math.min(a[HitAreas.Hands].yOff, Math.min(a[HitAreas.Feet].yOff, Math.min(a[HitAreas.Head].yOff, a[HitAreas.Body].yOff))), a.rightEdgeOff = Math.max(a[HitAreas.Hands].xOff + a[HitAreas.Hands].width, Math.max(a[HitAreas.Feet].xOff + a[HitAreas.Feet].width, Math.max(a[HitAreas.Head].xOff + a[HitAreas.Head].width, a[HitAreas.Body].xOff + a[HitAreas.Body].width))), a.bottomEdgeOff = Math.max(a[HitAreas.Hands].yOff + a[HitAreas.Hands].height, Math.max(a[HitAreas.Feet].yOff + a[HitAreas.Feet].height, Math.max(a[HitAreas.Head].yOff + a[HitAreas.Head].height, a[HitAreas.Body].yOff + a[HitAreas.Body].height))) }, b.prototype.spawn = function(a, b) { this.xVelocity = 0, this.yVelocity = 0, this.forcedXVelocity = 0, this.xPos = a, this.yPos = b, this.rotation = 0, this.rotationDest = 0, this.checkpoint = new Phaser.Point(a, b), this.resetpoint = new Phaser.Point(a, b), this.container.scale.set(1, 1), this.container.visible = !0, this.spriteYOff = 0, this.falling = !1, this.crouching = !1, this.scaling = !1, this.kicking = !1, this.hanging = !1, this.pushing = !1, this.swimming = !1, this.bouncing = !1, this.currentHang = null, this.hangTime = 10, this.scaleHistory = 4e3, this.scaleTime = 0, this.currentZipline = null, this.lastZipline = null, this.lastPool = null, this.currentPole = null, this.poleTimer = 0, this.currentCannon = null, this.onIce = !1, this.onSpeedBlock = !1, this.porting = !1, this.breathe = this.maxBreathe, this.poolCoolDown = 0, this.swimmingLegs = [], this.keysObtained = 0, this.heldKeys = [], this.alive = !0, this.setSpawn(), this.faceRight(), this.updatePositions(), this.resetHitBoxes(), this.scoreUpdated = !1 }, b.prototype.resetHitBoxes = function() {
            var a, b, c, d;
            "right" === this.facing ? (a = this.headInfo.xOff, b = this.handsInfo.xOff, c = this.bodyInfo.xOff, d = this.feetInfo.xOff) : (a = -this.headInfo.xOff - this.headInfo.width, b = -this.handsInfo.xOff - this.handsInfo.width, c = -this.bodyInfo.xOff - this.bodyInfo.width, d = -this.feetInfo.xOff - this.feetInfo.width);
            var e = this.rotation * Math.PI / 180;
            this.head.pos.x = this.xPos, this.head.pos.y = this.yPos, this.head.w = this.headInfo.width, this.head.h = this.headInfo.height, this.headPolygon = this.head.toPolygon(), this.headPolygon.setOffset(new SAT.Vector(a, this.headInfo.yOff)), this.headPolygon.setAngle(e), this.hands.pos.x = this.xPos, this.hands.pos.y = this.yPos, this.hands.w = this.handsInfo.width, this.hands.h = this.handsInfo.height, this.handsPolygon = this.hands.toPolygon(), this.handsPolygon.setOffset(new SAT.Vector(b, this.handsInfo.yOff)), this.handsPolygon.setAngle(e), this.body.pos.x = this.xPos, this.body.pos.y = this.yPos, this.body.w = this.bodyInfo.width, this.body.h = this.bodyInfo.height, this.bodyPolygon = this.body.toPolygon(), this.bodyPolygon.setOffset(new SAT.Vector(c, this.bodyInfo.yOff)), this.bodyPolygon.setAngle(e), this.feet.pos.x = this.xPos, this.feet.pos.y = this.yPos, this.feet.w = this.feetInfo.width, this.feet.h = this.feetInfo.height, this.feetPolygon = this.feet.toPolygon(), this.feetPolygon.setOffset(new SAT.Vector(d, this.feetInfo.yOff)), this.feetPolygon.setAngle(e), this.width = this.stateInfos[this.state].rightEdgeOff - this.stateInfos[this.state].leftEdgeOff, this.height = this.stateInfos[this.state].bottomEdgeOff - this.stateInfos[this.state].topEdgeOff;
            var f = new SAT.Box(new SAT.Vector(this.xPos, this.yPos), this.width, this.height);
            this.totalPolygon = f.toPolygon(), this.totalPolygon.setOffset(new SAT.Vector(this.stateInfos[this.state].leftEdgeOff, this.stateInfos[this.state].topEdgeOff))
        }, b.prototype.updateHitBoxesPos = function() {
            this.head.pos.y = this.yPos, this.feet.pos.y = this.yPos, this.hands.pos.y = this.yPos, this.body.pos.y = this.yPos, this.headPolygon.pos.x = this.xPos, this.headPolygon.pos.y = this.yPos, this.bodyPolygon.pos.x = this.xPos, this.bodyPolygon.pos.y = this.yPos, this.handsPolygon.pos.x = this.xPos, this.handsPolygon.pos.y = this.yPos, this.feetPolygon.pos.x = this.xPos, this.feetPolygon.pos.y = this.yPos, this.totalPolygon.pos.x = this.xPos, this.totalPolygon.pos.y = this.yPos;
            var a = this.rotation * Math.PI / 180;
            this.headPolygon.setAngle(a), this.bodyPolygon.setAngle(a), this.handsPolygon.setAngle(a), this.feetPolygon.setAngle(a), this.totalPolygon.setAngle(a)
        }, b.prototype.redrawHitBoxes = function() {
            this.hitGraphics.clear(), this.hitGraphics.beginFill(16711680, .5), this.hitGraphics.moveTo(this.xPos + this.bodyPolygon.calcPoints[0].x, this.yPos + this.bodyPolygon.calcPoints[0].y);
            for (var a = 1; a < 4; a++) this.hitGraphics.lineTo(this.xPos + this.bodyPolygon.calcPoints[a].x, this.yPos + this.bodyPolygon.calcPoints[a].y);
            this.hitGraphics.lineTo(this.xPos + this.bodyPolygon.calcPoints[0].x, this.yPos + this.bodyPolygon.calcPoints[0].y), this.hitGraphics.endFill(), this.hitGraphics.beginFill(65280, .5), this.hitGraphics.moveTo(this.xPos + this.headPolygon.calcPoints[0].x, this.yPos + this.headPolygon.calcPoints[0].y);
            for (var a = 1; a < 4; a++) this.hitGraphics.lineTo(this.xPos + this.headPolygon.calcPoints[a].x, this.yPos + this.headPolygon.calcPoints[a].y);
            this.hitGraphics.lineTo(this.xPos + this.headPolygon.calcPoints[0].x, this.yPos + this.headPolygon.calcPoints[0].y), this.hitGraphics.endFill(), this.hitGraphics.beginFill(255, .5), this.hitGraphics.moveTo(this.xPos + this.handsPolygon.calcPoints[0].x, this.yPos + this.handsPolygon.calcPoints[0].y);
            for (var a = 1; a < 4; a++) this.hitGraphics.lineTo(this.xPos + this.handsPolygon.calcPoints[a].x, this.yPos + this.handsPolygon.calcPoints[a].y);
            this.hitGraphics.lineTo(this.xPos + this.handsPolygon.calcPoints[0].x, this.yPos + this.handsPolygon.calcPoints[0].y), this.hitGraphics.endFill(), this.hitGraphics.beginFill(16776960, .5), this.hitGraphics.moveTo(this.xPos + this.feetPolygon.calcPoints[0].x, this.yPos + this.feetPolygon.calcPoints[0].y);
            for (var a = 1; a < 4; a++) this.hitGraphics.lineTo(this.xPos + this.feetPolygon.calcPoints[a].x, this.yPos + this.feetPolygon.calcPoints[a].y);
            this.hitGraphics.lineTo(this.xPos + this.feetPolygon.calcPoints[0].x, this.yPos + this.feetPolygon.calcPoints[0].y), this.hitGraphics.endFill(), this.hitGraphics.beginFill(65535, .2), this.hitGraphics.moveTo(this.xPos + this.totalPolygon.calcPoints[0].x, this.yPos + this.totalPolygon.calcPoints[0].y);
            for (var a = 1; a < 4; a++) this.hitGraphics.lineTo(this.xPos + this.totalPolygon.calcPoints[a].x, this.yPos + this.totalPolygon.calcPoints[a].y);
            this.hitGraphics.lineTo(this.xPos + this.totalPolygon.calcPoints[0].x, this.yPos + this.totalPolygon.calcPoints[0].y), this.hitGraphics.endFill()
        }, b.prototype.setIdle = function() { this.state = PlayerState.Idle, this.sprite && (this.sprite.visible = !1), this.prevFrame = 0, this.sprite = this.stateSprites[PlayerState.Idle], this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setRun = function() { this.state = PlayerState.Running, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Running], this.sprite.animations.play("run", 60 * this.main.gameSpeed, !0), this.sprite.animations.frame = 0, this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setJump = function(a, b) { void 0 === a && (a = !0), void 0 === b && (b = null), (this.state !== PlayerState.Jumping || b) && (this.state = PlayerState.Jumping, a && (this.sprite && (this.sprite.visible = !1), b ? (this.sprite = this.stateSprites[b], this.jumpState = b) : (this.sprite = this.stateSprites[PlayerState.Jumping], this.jumpState = PlayerState.Jumping), this.sprite.animations.currentAnim.stop(!0), this.sprite.animations.play("jump", 60 * this.main.gameSpeed, !1), this.sprite.animations.frame = 0, this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1), this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.height = this.stateInfos[this.state].height, this.resetHitBoxes()) }, b.prototype.setSlide = function() { this.state !== PlayerState.Sliding && (this.state = PlayerState.Sliding, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Sliding], this.sprite.animations.stop("slide", !0), this.sprite.animations.play("slide", null, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes()) }, b.prototype.setCrouch = function() { this.state = PlayerState.Crouching, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Crouching], this.sprite.animations.stop("crouch", !0), this.sprite.animations.paused = !1, this.sprite.animations.play("crouch", null, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setScale = function() { this.state !== PlayerState.Scaling && (this.state = PlayerState.Scaling, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Scaling], this.sprite.animations.currentAnim.stop(!0), this.sprite.animations.play("scale", null, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes()) }, b.prototype.setHang = function() { this.state = PlayerState.Hanging, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Hanging], this.sprite.animations.frame = 0, this.sprite.animations.refreshFrame(), this.sprite.animations.play("scale", 60 * this.main.gameSpeed, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setZip = function() { this.state = PlayerState.Zipping, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Zipping], this.sprite.frame = 0, this.sprite.animations.stop("zip", !0), this.sprite.animations.refreshFrame(), this.sprite.animations.paused = !1, this.sprite.animations.play("zip", null, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setSwing = function() { this.state = PlayerState.Swinging, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Swinging], this.sprite.animations.stop("swing", !0), this.sprite.animations.paused = !1, this.sprite.animations.play("swing", null, !0), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setPush = function() { this.state = PlayerState.Pushing, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Pushing], this.sprite.animations.frame = 0, this.sprite.animations.refreshFrame(), this.sprite.animations.play("push", 60 * this.main.gameSpeed, !0), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setKick = function() { this.state = PlayerState.Kicking, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Kicking], this.sprite.animations.frame = 0, this.sprite.animations.refreshFrame(), this.sprite.animations.play("kick", 60 * this.main.gameSpeed, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setFall = function() { this.state = PlayerState.Falling, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Falling], this.sprite.animations.frame = 0, this.sprite.animations.refreshFrame(), this.sprite.animations.play("fall", 60 * this.main.gameSpeed, !1), this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.setSwim = function() {
            this.state = PlayerState.Swimming, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Swimming], this.sprite.animations.frame = 0, this.sprite.animations.refreshFrame(), this.sprite.rotation = 0, this.legSprite.rotation = 0, this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !0, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body],
                this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes()
        }, b.prototype.setSpawn = function() { this.state = PlayerState.Spawning, this.sprite && (this.sprite.visible = !1), this.sprite = this.stateSprites[PlayerState.Spawning], this.sprite.animations.stop("spawn", !0), this.sprite.animations.refreshFrame(), this.sprite.animations.play("spawn", 90, !1), this.stateTime = 20, this.prevFrame = 0, this.sprite.visible = !0, this.legSprite.visible = !1, this.headInfo = this.stateInfos[this.state][HitAreas.Head], this.bodyInfo = this.stateInfos[this.state][HitAreas.Body], this.handsInfo = this.stateInfos[this.state][HitAreas.Hands], this.feetInfo = this.stateInfos[this.state][HitAreas.Feet], this.resetHitBoxes() }, b.prototype.faceLeft = function() { "left" !== this.facing && (this.facing = "left", this.container.scale.x > 0 && (this.container.scale.x *= -1), this.resetHitBoxes()) }, b.prototype.faceRight = function() { "right" !== this.facing && (this.facing = "right", this.container.scale.x < 0 && (this.container.scale.x *= -1), this.resetHitBoxes()) }, b.prototype.enterActBlock = function() { this.actBlock && this.crouching && (this.actBlock.hellEnabled ? this.main.changeLevel(this.actBlock.levelNum, -1, !0) : this.main.changeLevel(this.actBlock.levelNum, -1), this.actBlock = null) }, b.prototype.jump = function(a, b, c) { void 0 === b && (b = !0), void 0 === c && (c = null), this.yVelocity = a, this.falling = !0, this.scaling = !1, this.swimming = !1, this.actBlock = null, this.hanging && (this.hanging = !1, this.hangTime = 0, this.currentHang = null), this.currentPole && (this.sprite.frame >= 3 && this.sprite.frame <= 12 ? (this.poleTimer = 0, this.currentPole = null, this.setJump(!0, PlayerState.JumpBackFlip), "right" === this.facing ? (this.xVelocity = 5, this.xPos += 10) : (this.xVelocity = -5, this.xPos -= 10), this.sprite.frame >= 6 && this.sprite.frame <= 9 && ("right" === this.facing ? this.xVelocity = 9 : this.xVelocity = -9), this.main.sounds.playSound("poleSwing"), this.yVelocity -= .2, this.updatePositions()) : (this.poleTimer = 0, this.currentPole = null, this.yVelocity = 0)), this.currentZipline = null, this.setJump(b, c), this.acc = 1, this.updateHitBoxesPos() }, b.prototype.land = function(a) {
            if (this.yVelocity = 0, this.forcedXVelocity *= .8, this.yPos = a.yPos - .5 * a.height + a.yVelocity, this.onIce = !1, this.onSpeedBlock = !1, "ice" === a.blockType ? this.onIce = !0 : "speed" === a.blockType && (this.onSpeedBlock = !0), this.rotationDest = 0, this.state !== PlayerState.Jumping && this.state !== PlayerState.Scaling && this.state !== PlayerState.Hanging || (this.main.sounds.playSound("land"), this.keys.left.isDown() || this.keys.right.isDown() ? this.setRun() : this.setIdle()), this.falling = !1, this.scaling = !1, this.hanging = !1, this.scaleHistory = 4e3, this.currentHang = null, this.lastPool = null, this.actBlock = null, a.landed = new Phaser.Point(this.xPos - a.xPos, this.yPos - a.xPos), "push" === a.blockType && this.crouching && !this.kicking) {
                if ("not trapped" === a.checkTrapped()) return;
                this.kicking = !0, this.kickBlock = a, this.xVelocity = this.forcedXVelocity = 0, this.setKick(), this.sprite.animations.paused = !0, this.stateTime = 10, a.stuckRight ? (this.faceLeft(), this.tarKickX = a.rightEdge - .5 * this.width) : (this.tarKickX = a.leftEdge + .5 * this.width, this.faceRight())
            }
            else if ("act" === a.blockType) {
                var b = a;
                this.actBlock = b, this.game.device.desktop && this.enterActBlock(), this.pressDown.showPressDown = !0
            }
        }, b.prototype.scale = function(a, b) { void 0 === b && (b = !0), this.scaling ? (this.lastPool = null, this.yVelocity > 1 && (this.yVelocity *= .8), this.scaleTime += this.main.gameSpeed, this.scaleTime > this.maxScaleTime && (this.scaling = !1, this.falling = !0, this.setJump(), this.lastScaled = !1), this.xVelocity = this.forcedXVelocity = 0) : (b && this.scaleHistory != a.rightEdge || !b && this.scaleHistory !== a.leftEdge) && (this.scaleTime = 0, this.scaling = !0, this.falling = !1, this.diving = !1, this.rotation = 0, this.rotationDest = 0, this.yVelocity > 5 ? this.main.sounds.playSound("wallSlide") : this.main.sounds.playSound("connectSlide"), this.yVelocity < 0 && (this.yVelocity = 0), b ? this.scaleHistory = a.rightEdge : this.scaleHistory = a.leftEdge, this.setScale(), this.lastScaled = !0, this.xVelocity = this.forcedXVelocity = 0) }, b.prototype.hang = function(a, b) { void 0 === b && (b = !0), this.state !== PlayerState.Hanging && this.setHang(), this.yVelocity = 0, this.yPos = a.topEdge - this.handsInfo.yOff - 4, b ? this.xPos = a.leftEdge - this.handsInfo.xOff - this.handsInfo.width + 4 : this.xPos = a.rightEdge - this.handsInfo.xOff + this.handsInfo.width - 4, this.hanging || (this.main.sounds.playSound("connectHang"), this.rotation = 0, this.rotationDest = 0), this.hanging = !0, this.falling = !1, this.currentHang = a, this.lastPool = null, this.scaleHistory = 4e3, this.lastZipline = !1 }, b.prototype.unhang = function() { this.hanging = !1, this.falling = !0, this.hangTime = 0, this.currentHang = null }, b.prototype.checkForBlock = function(a, b) { for (var c = 0; c < this.main.blocks.length; c++) { var d = this.main.blocks[c]; if (d.alive && SAT.pointInPolygon(new SAT.Vector(a, b), d.totalBoundPolygon)) return !0 } return !1 }, b.prototype.checkBlocks = function() {
            if (!this.bouncing) {
                var a = !1,
                    b = !1,
                    c = !1,
                    d = !1,
                    e = !1,
                    f = !1,
                    g = 0;
                this.pressDown.showPressDown = !1;
                for (var h = 0; h < this.main.blocks.length; h++) {
                    var i = this.main.blocks[h];
                    if (i.alive)
                        if (i.rightEdge < this.xPos - 40 || i.leftEdge > this.xPos + 40 || i.topEdge > this.yPos + 80 || i.bottomEdge < this.yPos - 80) i.landed = null;
                        else {
                            if (g++, this.yVelocity > this.fallingMax && SAT.testPolygonPolygon(this.totalPolygon, i.topBoundPolygon)) { if ("bounce" === i.blockType && SAT.testPolygonPolygon(this.totalPolygon, i.topBoundPolygon)) { this.land(i); continue } return void this.kill(1) }
                            if (this.keysObtained > 0 && "lock" === i.blockType) {
                                var j = i;
                                if (!j.unlocked && SAT.testPolygonPolygon(this.totalPolygon, i.totalBoundPolygon)) {
                                    j.unlock();
                                    var k = this.heldKeys.pop();
                                    k.useKey(), this.keysObtained--;
                                    continue
                                }
                            }
                            if ((this.yVelocity >= 0 || i.yVelocity < 0) && this.yVelocity - i.yVelocity >= -2 && SAT.testPolygonPolygon(this.feetPolygon, i.topBoundPolygon)) {
                                if (this.falling && this.keys.down.isDown() && "glass" === i.blockType) {
                                    var l = i;
                                    l.smash();
                                    continue
                                }
                                this.xPos > i.xPos - .5 * i.width && this.xPos < i.xPos + .5 * i.width && this.land(i), b = !0, f = !0, a = !0
                            }
                            else {
                                if (i.landed = null, SAT.testPolygonPolygon(this.headPolygon, i.bottomBoundPolygon)) { if (this.xPos < i.leftEdge) continue; if (this.xPos > i.rightEdge) continue; if (this.hanging || this.yVelocity - i.yVelocity <= .5) { this.scaling || this.hanging ? (this.setJump(), this.scaling = !1, this.scaleTime = 0, this.hanging = !1, this.hangTime = 0, this.currentHang = null, this.yVelocity = 2, this.falling = !0, this.scaleHistory = 4e3, this.lastZipline = !1) : this.yVelocity *= -.5, "ice" === i.blockType ? this.yPos = i.yPos + .5 * i.height + i.yVelocity + this.height + 2 : this.yPos = i.yPos + .5 * i.height + 2 * i.yVelocity + this.height + 1, this.updateHitBoxesPos(), c = !0, "push" === i.blockType && (f = !0); continue } }
                                if (!this.currentHang && this.poolCoolDown <= 0 && !this.swimming) { if (i.hangable && this.falling && this.hangTime >= this.maxHangCoolDown && (this.yVelocity >= 0 || i.yVelocity < 0)) { if (SAT.testPolygonPolygon(this.handsPolygon, i.lhBoundPolygon) && !this.checkForBlock(i.leftEdge + 3, i.topEdge - 5) && !this.checkForBlock(i.leftEdge - 3, i.topEdge - 5)) { this.hang(i), a = !0, e = !0; continue } if (SAT.testPolygonPolygon(this.handsPolygon, i.rhBoundPolygon) && !this.checkForBlock(i.rightEdge + 3, i.topEdge - 5) && !this.checkForBlock(i.rightEdge + -3, i.topEdge - 5)) { this.hang(i, !1), a = !0, d = !0; continue } } }
                                else { if ("right" === this.facing && this.currentHang === i) { this.hang(this.currentHang), e = !0; continue } if ("left" === this.facing && this.currentHang === i) { this.hang(this.currentHang, !1), d = !0; continue } a = !0 }
                                if (this.xPos > i.rightEdge || this.xPos < i.leftEdge)
                                    if ("right" === this.facing) { if (i.scalable && (this.falling || this.scaling) && this.yVelocity >= -3 && SAT.testPolygonPolygon(this.handsPolygon, i.leftBoundPolygon)) { this.scale(i, !1), this.xPos = i.xPos - .5 * i.width + this.handsInfo.xOff - this.handsInfo.width + 1, a = !0, e = !0; continue } }
                                else if (i.scalable && (this.falling || this.scaling) && this.yVelocity >= -3 && SAT.testPolygonPolygon(this.handsPolygon, i.rightBoundPolygon)) { this.scale(i, !0), this.xPos = i.xPos + .5 * i.width + this.handsInfo.xOff - 1, a = !0, d = !0; continue }
                                if (!this.scaling && (this.xVelocity + this.forcedXVelocity >= 0 || this.currentHang) && SAT.testPolygonPolygon(this.bodyPolygon, i.leftBoundPolygon)) {
                                    if (this.hanging && "right" === this.facing && this.unhang(), "push" !== i.blockType || this.falling || this.crouching || "right" !== this.facing) { this.xVelocity = this.forcedXVelocity = 0, this.xPos = i.xPos - i.width / 2 - this.bodyInfo.xOff - this.bodyInfo.width + 2, e = !0; continue } i.xVelocity < this.xVelocity && (i.xVelocity = this.xVelocity);
                                    var m = i;
                                    this.xPos = i.leftEdge - this.width / 2 + this.xVelocity, m.pushingRight = !0, m.pushed = !0, this.state !== PlayerState.Pushing && this.setPush()
                                }
                                else if ((!this.scaling && this.xVelocity + this.forcedXVelocity <= 0 || this.currentHang) && SAT.testPolygonPolygon(this.bodyPolygon, i.rightBoundPolygon)) {
                                    if (this.hanging && "left" === this.facing && this.unhang(), "push" !== i.blockType || this.crouching || this.falling || "left" !== this.facing) { this.xVelocity = this.forcedXVelocity = 0, this.falling ? this.xPos = i.rightEdge + 4 : this.xPos = i.xPos + i.width / 2 - this.bodyInfo.xOff - 2, this.updatePositions(), d = !0; continue } i.xVelocity > this.xVelocity && (i.xVelocity = this.xVelocity);
                                    var m = i;
                                    this.xPos = i.rightEdge + this.width / 2 + this.xVelocity, m.pushingLeft = !0, m.pushed = !0, this.state !== PlayerState.Pushing && this.setPush()
                                }
                                else;
                            }
                        }
                }
                return d && e || b && c ? (f && this.main.achievements.gotAchievement("headsup"), void this.kill(3)) : void(a || b && this.state !== PlayerState.Pushing || this.currentSlope || this.currentHang || (this.falling = !0, !this.diving && this.yVelocity <= this.fallingMax && (this.rotationDest = 0), this.state === PlayerState.Running || this.state === PlayerState.Idle || this.state === PlayerState.Pushing ? this.setJump() : this.crouching ? (this.setJump(), this.crouching = !1) : (this.scaling || this.hanging) && (this.setJump(), this.scaling = !1, this.scaleTime = 0, this.hanging = !1, this.hangTime = 0)))
            }
        }, b.prototype.checkSlopeCollisions = function() {
            this.currentSlope = null;
            for (var a = 0, b = this.main.slopes; a < b.length; a++) {
                var c = b[a];
                if (c.alive) {
                    if ("left" !== this.facing || c.right) { if ("right" === this.facing && c.right && (this.falling || this.scaling) && this.yPos - .5 * this.height < c.bottomEdge && this.yVelocity > 0 && SAT.testPolygonPolygon(this.handsPolygon, c.wallPoly)) { this.currentSlope = c, this.xPos = c.leftEdge - .5 * this.width - 1; continue } }
                    else if ((this.falling || this.scaling) && this.yPos - .5 * this.height < c.bottomEdge && this.yVelocity > 0 && SAT.testPolygonPolygon(this.handsPolygon, c.wallPoly)) { this.currentSlope = c, this.xPos = c.rightEdge + .5 * this.width + 1; continue }
                    if (!this.hanging && !this.scaling)
                        if (!c.right && this.xVelocity < 0) { if (SAT.testPolygonPolygon(this.bodyPolygon, c.wallPoly)) { this.xPos = c.rightEdge + .5 * this.width + 7, this.xVelocity = this.forcedXVelocity = 0; continue } }
                    else if (c.right && this.xVelocity > 0 && SAT.testPolygonPolygon(this.bodyPolygon, c.wallPoly)) { this.xPos = c.leftEdge - .5 * this.width - 7, this.xVelocity = this.forcedXVelocity = 0; continue }
                    if (this.xPos > c.leftEdge && this.xPos < c.rightEdge && SAT.testPolygonPolygon(this.headPolygon, c.bottomPoly) && this.yPos >= c.bottomEdge + .5 * this.height && this.yVelocity < 0 && (this.yPos = c.bottomEdge + this.height, this.yVelocity *= -.5, this.yPos += this.yVelocity, this.updatePositions(), this.scaleHistory = 4e3, this.currentZipline = null), this.xPos > c.leftEdge && this.xPos < c.rightEdge && this.yPos > c.topEdge && this.yPos < c.bottomEdge)
                        if (c.right) {
                            var d = 1 - (this.xPos - c.leftEdge) / c.width;
                            if (this.yPos >= c.bottomEdge - c.height * d) {
                                var e = c.height / c.width;
                                if (this.yVelocity > -5 - e) {
                                    if (this.yVelocity >= 20) return void this.kill(3);
                                    this.state !== PlayerState.Crouching && (Math.abs(this.xVelocity) > 1 ? this.state !== PlayerState.Running && this.setRun() : this.setIdle()), this.yVelocity = 0, this.rotationDest = 45 * e, this.yPos = c.bottomEdge - c.height * d + 2, this.yPos < c.height && (this.yPos = c.height), this.currentSlope = c, this.scaleHistory = 4e3, this.currentZipline = !1, this.falling = !1, this.scaling = !1, this.hanging = !1
                                }
                            }
                        }
                    else {
                        var d = (this.xPos - c.leftEdge) / c.width;
                        if (this.yPos >= c.bottomEdge - c.height * d) {
                            var e = c.height / c.width;
                            if (this.yVelocity > -5 - e) {
                                if (this.yVelocity >= 20) return void this.kill(3);
                                this.yVelocity > 1 && (this.xVelocity = -this.yVelocity), this.state !== PlayerState.Crouching && (Math.abs(this.xVelocity) > 1 ? this.state !== PlayerState.Running && this.setRun() : this.setIdle()), this.yVelocity = 0, this.rotationDest = -45 * e, this.yPos = c.bottomEdge - c.height * d + 2, this.currentSlope = c, this.scaleHistory = 4e3, this.currentZipline = !1, this.falling = !1, this.scaling = !1, this.hanging = !1
                            }
                        }
                    }
                }
            }
        }, b.prototype.checkCheckpoint = function() { for (var a = 0; a < this.main.checkpoints.length; a++) { var b = this.main.checkpoints[a]; if (SAT.testPolygonPolygon(this.bodyPolygon, b.boxPolygon) && 0 === b.state) return b.trigger(), void this.checkpoint.set(b.xPos, b.yPos) } }, b.prototype.checkKeyObj = function() {
            for (var a = 0, b = this.main.keyObjs; a < b.length; a++) {
                var c = b[a];
                c.alive && (c.following || SAT.testPolygonPolygon(this.bodyPolygon, c.hitBoxPolygon) && (this.heldKeys.push(c), this.keysObtained++, 4 === this.keysObtained && this.main.achievements.gotAchievement("caretaker"), c.follow()))
            }
        }, b.prototype.checkKeyboard = function() { this.bouncing || (this.currentZipline || this.crouching || this.scaling || this.hanging || (this.keys.left.isDown() ? (this.xVelocity > -this.maxVelocity ? (this.xVelocity -= this.acc, this.xVelocity > 0 && (this.xVelocity *= .5)) : this.onIce ? this.xVelocity += .025 * this.acc * this.main.gameSpeed : this.xVelocity += .2 * this.acc, "right" === this.facing && (this.state === PlayerState.Pushing && this.setRun(), this.faceLeft()), this.state === PlayerState.Idle && this.setRun()) : this.keys.right.isDown() ? (this.xVelocity < this.maxVelocity && (this.xVelocity += this.acc, this.xVelocity < 0 ? this.xVelocity *= .5 : this.onIce ? this.xVelocity -= .025 * this.acc * this.main.gameSpeed : this.xVelocity -= .2 * this.acc), "left" === this.facing && (this.state === PlayerState.Pushing && this.setRun(), this.faceRight()), this.state === PlayerState.Idle && this.setRun()) : (this.state !== PlayerState.Running && this.state !== PlayerState.Pushing || this.setIdle(), this.falling ? this.xVelocity *= .75 : this.onIce ? this.xVelocity *= .9 : this.xVelocity > 0 ? (this.xVelocity -= 2 * this.acc, this.xVelocity < 1 && (this.xVelocity = this.forcedXVelocity = 0)) : this.xVelocity < 0 && (this.xVelocity += 2 * this.acc, this.xVelocity > -1 && (this.xVelocity = this.forcedXVelocity = 0)))), this.forcedXVelocity *= .98, !this.keys.up.pressed() || this.crouching || this.falling ? this.keys.up.pressed() && this.falling && !this.crouching && this.jumpState === PlayerState.Jumping && this.setJump(!0, PlayerState.JumpFrontFlip) : this.jump(-8)) }, b.prototype.checkCrouch = function() {
            if (!this.bouncing) {
                if (!this.keys.down.pressed() || !this.falling || this.lastPool || this.diving || this.currentPole || this.state !== PlayerState.Falling && (this.setJump(!0, PlayerState.JumpDown), this.yVelocity < 0 && (this.yVelocity *= .5 * this.main.gameSpeed), this.yPos += .75 * this.yVelocity), !this.keys.down.isDown() && this.falling && this.state === PlayerState.Jumping && this.jumpState === PlayerState.JumpDown && this.setJump(!0, PlayerState.Jumping), !(this.swimming || this.falling || this.scaling || this.hanging || this.kicking))
                    if (this.keys.down.isDown()) {
                        if (this.currentZipline) return this.falling = !0, this.setJump(), this.lastZipline = this.currentZipline, void(this.currentZipline = null);
                        if (this.currentPole) return this.setJump(), this.currentPole = null, void(this.poleTimer = 0);
                        this.crouching ? this.xVelocity < 1 && this.xVelocity > -1 ? (this.state === PlayerState.Sliding && (this.sprite.animations.frame < 8 ? (this.sprite.animations.frame = 8, this.sprite.animations.paused = !1) : this.sprite.animations.currentAnim.isFinished && this.setCrouch()), this.crouching = !0, this.xVelocity = this.forcedXVelocity = 0) : !this.onSpeedBlock || this.keys.left.isDown() || this.keys.right.isDown() ? this.onIce ? this.xVelocity *= .99 : this.xVelocity *= .97 : ((this.sprite.animations.currentAnim.frame > 8 || this.sprite.animations.currentAnim !== this.sprite.animations.getAnimation("crouch")) && this.setCrouch(), this.crouching = !0, this.xVelocity = this.forcedXVelocity = 0) : this.xVelocity < 2 && this.xVelocity > -2 ? (this.setCrouch(), this.crouching = !0, this.xVelocity = this.forcedXVelocity = 0) : (this.currentSlope ? this.keys.down.isDown() ? (this.setCrouch(), this.crouching = !0, this.xVelocity = this.forcedXVelocity = 0) : this.crouching = !0 : this.state != PlayerState.Sliding && (this.main.sounds.playSound("slide"), this.setSlide()), this.crouching = !0)
                    }
                else if ((this.state === PlayerState.Sliding || this.state === PlayerState.Crouching) && (7 === this.sprite.animations.frame && (this.sprite.animations.frame = 8, this.sprite.animations.paused = !1), this.sprite.animations.currentAnim.isFinished)) {
                    this.setIdle(), this.crouching = !1, this.updateHitBoxesPos();
                    for (var a = 0, b = this.main.blocks; a < b.length; a++) {
                        var c = b[a];
                        SAT.testPolygonPolygon(this.bodyPolygon, c.rightBoundPolygon) ? this.xPos = c.rightEdge + 7 : SAT.testPolygonPolygon(this.bodyPolygon, c.leftBoundPolygon) && (this.xPos = c.leftEdge - 7)
                    }
                }(this.scaling || this.hanging) && this.keys.down.isDown() && (this.scaling = !1, this.unhang(), this.setJump())
            }
        }, b.prototype.checkZipline = function() {
            this.currentZipline = null;
            for (var a = 0; a < this.main.ziplines.length; a++) {
                var b = this.main.ziplines[a];
                if (b !== this.lastZipline && !(this.xPos - 40 > b.rightEdge || this.xPos + 40 < b.leftEdge || this.yPos - 80 > b.bottomEdge || this.yPos + 80 < b.topEdge) && SAT.testPolygonPolygon(this.handsPolygon, b.hitPolygon))
                    if ("left" == b.direction) {
                        var c = b.startPos.x - this.xPos,
                            d = c * b.scope + b.startPos.y + 25;
                        this.currentZipline || (this.yVelocity = 0), this.xVelocity < 8, this.yVelocity += 1, this.xVelocity -= 1.5 * b.scope, this.xVelocity < 0 && "right" === this.facing && this.faceLeft(), this.state != PlayerState.Zipping && (this.setZip(), this.main.sounds.playSound("ziplineFull")), this.yPos = d + 5, this.currentZipline = b, this.scaleHistory = 4e3, this.lastZipline = null, this.falling = !1
                    }
                else {
                    var c = this.xPos - b.startPos.x,
                        d = c * b.scope + b.startPos.y + this.height;
                    this.currentZipline || (this.yVelocity = 0), this.xVelocity < 8 && (this.yVelocity += 1, this.xVelocity += 1.3 * b.scope), this.xVelocity > 0 && "left" === this.facing && this.faceRight(), this.state != PlayerState.Zipping && (this.setZip(), this.main.sounds.playSound("ziplineFull")), this.yPos = d - 4, this.currentZipline = b, this.scaleHistory = 4e3, this.lastZipline = null, this.falling = !1
                }
            }
        }, b.prototype.checkPoleCollisions = function() {
            if (this.poleTimer++ >= 10)
                for (var a = 0; a < this.main.poles.length; a++) {
                    var b = this.main.poles[a];
                    SAT.testPolygonPolygon(this.handsPolygon, b.hitBoxPolygon) ? this.currentPole || (this.xVelocity = this.forcedXVelocity = 0, this.yVelocity = 0, this.currentPole = b, this.falling = !1, this.rotation = 0, this.xPos = this.currentPole.xPos - 2, this.yPos = this.currentPole.yPos + 30) : SAT.testPolygonPolygon(this.bodyPolygon, b.hitBoxPolygon) && (this.xVelocity > 0 ? (this.xVelocity = this.forcedXVelocity = 0, this.xPos = b.xPos - 5) : this.xVelocity < 0 && (this.xVelocity = this.forcedXVelocity = 0, this.xPos = b.xPos + 5))
                }
        }, b.prototype.performSwing = function() { this.xPos = this.currentPole.xPos, this.yPos = this.currentPole.yPos + 30, this.xVelocity = this.forcedXVelocity = 0, this.yVelocity = 0, this.rotationDest = 0, this.falling = !1, this.state !== PlayerState.Swinging && this.setSwing(), this.currentPole.redSection.alpha -= .15 * (this.currentPole.redSection.alpha - 1), "right" === this.facing ? this.currentPole.redSection.rotation = 30 * Math.PI / 180 : this.currentPole.redSection.rotation = 150 * Math.PI / 180, this.scaleHistory = 4e3, this.lastZipline = null }, b.prototype.checkDeath = function() {
            this.updateHitBoxesPos();
            for (var a = 0; a < this.main.obstacles.length; a++) {
                var b = this.main.obstacles[a];
                if (b.alive) switch (b.obstacleType) {
                    case "spike":
                        var c = b;
                        (SAT.testPolygonPolygon(this.bodyPolygon, c.deathBoxPolygon) || SAT.testPolygonPolygon(this.headPolygon, c.deathBoxPolygon)) && this.kill();
                        break;
                    case "buzzsaw":
                        var d = b;
                        (SAT.testCirclePolygon(d.deathCircle, this.bodyPolygon) || SAT.testCirclePolygon(d.deathCircle, this.headPolygon)) && this.kill(d.killValue);
                        break;
                    case "shurikan":
                        var e = b;
                        (SAT.testPolygonPolygon(this.bodyPolygon, e.hitBoxPoly) || SAT.testPolygonPolygon(this.headPolygon, e.hitBoxPoly)) && this.kill(9);
                        break;
                    case "quadrant":
                        for (var f = b, g = 0, h = f.deathHitBoxPolygons; g < h.length; g++) {
                            var i = h[g];
                            (SAT.testPolygonPolygon(this.bodyPolygon, i) || SAT.testPolygonPolygon(this.headPolygon, i)) && this.kill(10)
                        }
                        break;
                    case "laser":
                        var j = b;
                        (SAT.testPolygonPolygon(this.bodyPolygon, j.deathHitBoxPolygon) || SAT.testPolygonPolygon(this.headPolygon, j.deathHitBoxPolygon)) && this.kill(14);
                        break;
                    case "reaper":
                        for (var k = b, l = 0, m = k.deathHitBoxes; l < m.length; l++) {
                            var n = m[l];
                            (SAT.testPolygonPolygon(this.bodyPolygon, n) || SAT.testPolygonPolygon(this.headPolygon, n)) && this.kill(8)
                        }
                        break;
                    case "spark":
                        var o = b;
                        (SAT.testPolygonPolygon(this.totalPolygon, o.deathBoxPolygon) || SAT.testPolygonPolygon(this.headPolygon, o.deathBoxPolygon)) && this.kill(11, !0)
                }
            }
        }, b.prototype.performKick = function() { this.kickBlock.stuckRight ? (this.kickBlock.xVelocity = -15, this.xPos -= 10) : (this.kickBlock.xVelocity = 15, this.xPos += 10), this.kickBlock.stuckLeft = this.kickBlock.stuckRight = !1, this.kickBlock.xPos += this.kickBlock.xVelocity, this.kicking = !1, this.kickBlock = null, this.tarKickX = 0, this.crouching = !1, this.main.sounds.playSound("kickBlock"), this.jump(-5, !1) }, b.prototype.updateGravity = function() { this.yVelocity += this.main.gravity * this.main.gameSpeed, this.yVelocity > this.fallingMax ? (this.state != PlayerState.Falling && (this.setFall(), this.diving = !1), this.rotationDest += -this.container.scale.x * this.yVelocity * .25 * this.main.gameSpeed, (this.rotation < -150 || this.rotation > 150) && (this.kill(5), this.main.sounds.fall.play())) : this.falling && this.yVelocity > 0, this.state !== PlayerState.Zipping || this.currentZipline || (this.setJump(), this.falling = !0) }, b.prototype.checkPoolCollisions = function() {
            for (var a = !1, b = 0; b < this.main.pools.length; b++) {
                var c = this.main.pools[b];
                if (SAT.testPolygonPolygon(this.bodyPolygon, c.totalPolygon)) {
                    if (a = !0, c.prevElec) return void this.kill(12, !0);
                    if (this.state !== PlayerState.Swimming && this.yVelocity >= 0) {
                        this.main.sounds.playSound("splash1");
                        for (var d = 0; d < 5; d++) this.main.createColorParticle(this.xPos + 10 * Math.random() - 5, this.yPos - this.height / 2, 10 * Math.random() - 5, Math.random() * -10, 56814, 4, !0, !0);
                        this.currentPool = c, this.swimming = !0, this.scaling = !1, this.hanging = !1, this.falling = !1, this.crouching = !1, this.diving = !1, this.faceRight(), this.setSwim(), this.main.playerUnderLayer.addChild(this.container), this.rotation = 0, this.scaleHistory = 4e3, this.lastZipline = null, this.rotationDest = 0
                    }
                }
                if (this.yVelocity < 0 && SAT.testPolygonPolygon(this.feetPolygon, c.topPolygon)) {
                    this.main.sounds.playSound("splash1"), this.lastPool = c, this.state === PlayerState.Swimming && (this.jump(-6), this.poolCoolDown = 15, this.main.playerLayer.addChild(this.container)), this.rotation = 0;
                    for (var e = 0; e < 5; e++) this.main.createColorParticle(this.xPos + 10 * Math.random() - 5, this.yPos - this.height / 2, 10 * Math.random() - 5, Math.random() * -10, 56814, 4, !0, !0);
                    this.breathe < 90 && this.main.achievements.gotAchievement("gasping")
                }
            }
            a || (this.swimming = !1, this.state === PlayerState.Swimming && (this.setJump(), this.falling = !0), this.currentPool = null, this.poolCoolDown > 0 && this.poolCoolDown--)
        }, b.prototype.getSwim = function() {
            if (this.state == PlayerState.Swimming) {
                if (this.keys.up.isDown() || this.keys.down.isDown() || (this.xVelocity *= .85, this.yVelocity *= .85, this.xVelocity < 1 && this.xVelocity > -1 && (this.xVelocity = this.forcedXVelocity = 0), this.yVelocity < 1 && this.yVelocity > -1 && (this.yVelocity = 0)), this.currentCannon || (this.keys.left.isDown() ? this.sprite.rotation -= 7 * Math.PI / 180 : this.keys.right.isDown() && (this.sprite.rotation += 7 * Math.PI / 180), this.swimmingLegs.push(this.sprite.rotation), this.swimmingLegs.length > 4 && (this.legSprite.rotation = this.swimmingLegs.shift())), !this.currentCannon && this.keys.up.isDown()) {
                    this.keys.up.pressed() && (this.sprite.animations.currentAnim.stop(!0), this.sprite.animations.play("swim", null, !1));
                    var a = this.sprite.rotation - Math.PI / 2,
                        b = Math.cos(a),
                        c = Math.sin(a),
                        d = 3;
                    this.xVelocity += b, this.yVelocity += c, b > 0 && this.xVelocity > b * d ? this.xVelocity = b * d : b < 0 && this.xVelocity < b * d && (this.xVelocity = b * d), c > 0 && this.yVelocity > c * d ? this.yVelocity = c * d : c < 0 && this.yVelocity < c * d && (this.yVelocity = c * d), Math.random() < .3 && this.main.createColorParticle(this.xPos + 10 * Math.random() - 5, this.yPos - .5 * this.height + 10 * Math.random() - 5, -this.xVelocity / 2 + Math.random(), -this.yVelocity / 2 + Math.random(), 56814, 4, !0, !0)
                }
                else 4 === this.sprite.frame && (this.sprite.animations.paused = !1);
                if (!this.currentCannon && this.keys.down.isDown()) {
                    var a = this.sprite.rotation - Math.PI / 2,
                        b = -Math.cos(a),
                        c = -Math.sin(a),
                        d = 2;
                    this.xVelocity += b, this.yVelocity += c, b > 0 && this.xVelocity > b * d ? this.xVelocity = b * d : b < 0 && this.xVelocity < b * d && (this.xVelocity = b * d), c > 0 && this.yVelocity > c * d ? this.yVelocity = c * d : c < 0 && this.yVelocity < c * d && (this.yVelocity = c * d)
                }
                this.xPos += this.xVelocity, this.yPos += this.yVelocity
            }
        }, b.prototype.checkSwimBlockCollisions = function() {
            for (var a = 0; a < this.main.blocks.length; a++) {
                var b = this.main.blocks[a];
                if (b.alive && !(b.rightEdge < this.xPos - 40 || b.leftEdge > this.xPos + 40 || b.topEdge > this.yPos + 80 || b.bottomEdge < this.yPos - 80)) {
                    if (this.keysObtained > 0 && "lock" === b.blockType) {
                        var c = b;
                        if (!c.unlocked && SAT.testPolygonPolygon(this.totalPolygon, b.totalBoundPolygon)) {
                            c.unlock();
                            var d = this.heldKeys.pop();
                            d.useKey(), this.keysObtained--;
                            continue
                        }
                    }
                    var e = !1;
                    SAT.testPolygonPolygon(this.totalPolygon, b.topBoundPolygon) ? (this.yPos = b.topEdge - 3, this.yVelocity *= -0, e = !0) : SAT.testPolygonPolygon(this.totalPolygon, b.bottomBoundPolygon) ? (this.yVelocity *= -.5, this.yPos = b.bottomEdge + this.height - 2) : SAT.testPolygonPolygon(this.totalPolygon, b.leftBoundPolygon) ? (this.xVelocity *= -.5, this.xPos = b.leftEdge - 7) : SAT.testPolygonPolygon(this.totalPolygon, b.rightBoundPolygon) && (this.xVelocity *= -.5, this.xPos = b.rightEdge + 7)
                }
            }
        }, b.prototype.cannonLogic = function() {
            this.swimming ? (this.sprite.rotation = this.currentCannon.rad + 90, this.sprite.rotation > 360 && (this.sprite.rotation -= 360)) : (this.rotation = 180 * this.currentCannon.rad / Math.PI + 90, this.rotationDest = this.rotation, this.rotation > 360 && (this.rotation -= 360), this.rotationDest > 360 && (this.rotationDest -= 360)), this.falling = !1, this.yVelocity = this.xVelocity = this.forcedXVelocity = 0;
            var a = 50;
            this.xPos = this.currentCannon.xPos + Math.cos(this.currentCannon.rad) * a, this.yPos = this.currentCannon.yPos + Math.sin(this.currentCannon.rad) * a, this.swimming || this.setIdle(), this.keys.up.pressed() && (this.currentCannon.firing = !0)
        }, b.prototype.checkCannonCollisions = function() { for (var a = 0, b = this.main.cannons; a < b.length; a++) { var c = b[a]; if (!c.alive) return; var d = Math.pow(c.xPos - this.xPos, 2) + Math.pow(c.yPos - this.yPos, 2); if (d < 7225) { this.currentCannon || (this.container.parent.removeChild(this.container), this.main.playerUnderLayer.addChild(this.container)), this.main.sounds.playSound("cannonEnter"), this.currentCannon = c; break } } }, b.prototype.respawn = function() { this.main.resetDeath(), this.xVelocity = this.forcedXVelocity = 0, this.yVelocity = 0, this.spriteYOff = 0, this.xPos = this.checkpoint.x, this.yPos = this.checkpoint.y, this.container.scale.set(1, 1), this.rotation = 0, this.rotationDest = 0, this.falling = !0, this.hanging = !1, this.scaling = !1, this.crouching = !1, this.bouncing = !1, this.swimming = !1, this.kicking = !1, this.diving = !1, this.currentHang = null, this.lastPool = null, this.currentPole = null, this.poleTimer = 0, this.currentCannon = null, this.scaleHistory = 4e3, this.lastZipline = null, this.breathe = this.maxBreathe, this.container.visible = !0, this.faceRight(), this.setSpawn(), this.alive = !1; for (var a = 0, b = this.main.blocks; a < b.length; a++) { var c = b[a]; "bounce" === c.blockType && (c.landed = null) } }, b.prototype.kill = function(a, b) {
            if (void 0 === a && (a = 0), void 0 === b && (b = !1), !this.god) {
                this.currentZipline = null;
                b ? this.main.sounds.playSound("electricity") : Math.random() < .5 ? this.main.sounds.playSound("death1") : this.main.sounds.playSound("death2"), this.main.playerDeath();
                for (var c = 0; c < 5; c++) this.main.createColorParticle(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, 16711680);
                this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerHead"), this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerBody", 2 * Math.random() * Math.PI, -4 + 8 * Math.random()), this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerArm", 2 * Math.random() * Math.PI, -4 + 8 * Math.random()), this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerArm", 2 * Math.random() * Math.PI, -4 + 8 * Math.random()), this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerLeg", 2 * Math.random() * Math.PI, -4 + 8 * Math.random()), this.main.createPlayerGib(this.xPos + 10 * Math.random() - 5, this.yPos - this.height * Math.random(), 10 * Math.random() - 5, Math.random() * -10, "playerLeg", 2 * Math.random() * Math.PI, -4 + 8 * Math.random()), this.container.visible = !1, this.keysObtained = 0, this.heldKeys = [], this.respawn(), this.main.deathText.show(this.xPos, this.yPos, getDeathText(a))
            }
        }, b.prototype.checkStar = function() { for (var a = 0; a < this.main.stars.length; a++) { var b = this.main.stars[a]; if (!b.alive) return; if (SAT.testPolygonPolygon(this.totalPolygon, b.hitBoxPolygon)) { b.getStar(); for (var c = 0; c < 15; c++) this.main.createColorParticle(b.xPos, b.yPos, 10 * Math.random() - 5, Math.random() * -10, 16763904) } } }, b.prototype.animationTick = function() {
            switch (this.state) {
                case PlayerState.Running:
                    this.sprite.animations.frame >= 5 && this.prevFrame < 5 && this.main.sounds.playSound("footstep"), this.sprite.animations.frame >= 11 && this.prevFrame < 11 && this.main.sounds.playSound("footstep"), this.sprite.animations.frame >= 17 && this.prevFrame < 17 && this.main.sounds.playSound("footstep");
                    break;
                case PlayerState.Sliding:
                    this.sprite.animations.frame >= 7 && this.prevFrame < 7 && (this.sprite.animations.paused = !0, this.sprite.animations.frame = 7);
                    break;
                case PlayerState.Crouching:
                    this.sprite.frame >= 7 && this.prevFrame < 7 && (this.sprite.animations.paused = !0, this.sprite.animations.frame = 7);
                    break;
                case PlayerState.Spawning:
                    this.stateTime <= 0 ? (this.setIdle(), this.alive = !0, this.main.firstSpawn && (this.main.firstSpawn = !1, this.main.followingWire || (this.main.timerLive = !0))) : this.stateTime--;
                    break;
                case PlayerState.Kicking:
                    if (this.stateTime <= 0) this.performKick(), this.sprite.animations.paused = !1;
                    else {
                        var a = this.tarKickX - this.xPos;
                        this.xPos += a / 5, Math.abs(a) < .5 && (this.xPos = this.tarKickX), this.stateTime--
                    }
                    break;
                case PlayerState.Swinging:
                    this.sprite.frame >= 32 && this.sprite.animations.currentAnim.setFrame(2), this.sprite.frame >= 4 && this.prevFrame < 4 && this.main.sounds.playSound("poleWoosh");
                    break;
                case PlayerState.Swimming:
                    this.sprite.frame >= 4 && this.prevFrame < 4 && (this.sprite.animations.paused = !0, this.sprite.animations.frame = 4)
            }
            this.prevFrame = this.sprite.frame
        }, b.prototype.cameraLogic = function() {
            if (this.alive || !this.alive) {
                var a = this.game.width / 2,
                    b = this.game.height / 2;
                if (this.lookingAround)
                    if (this.state !== PlayerState.Idle && this.state !== PlayerState.Swimming && this.state !== PlayerState.Hanging && (this.lookingAround = !1), this.main.keys.isScreenButtonDown()) this.lookingAround = !1;
                    else {
                        var c = this.game.device.desktop ? this.game.width / 4 : this.game.width / 2,
                            d = this.game.device.desktop ? this.game.height / 4 : this.game.height / 2,
                            e = (this.game.input.activePointer.position.x - a) / a * c + this.xPos,
                            f = (this.game.input.activePointer.position.y - b) / b * d + this.yPos,
                            g = e - this.game.camera.x - a,
                            h = f - this.game.camera.y - b,
                            i = Math.sqrt(Math.pow(this.game.camera.y - f, 2) + Math.pow(this.game.camera.x - e, 2));
                        i < .5 ? (this.game.camera.x = e, this.game.camera.y = f) : (this.game.camera.x += g / 15, this.game.camera.y += h / 15)
                    }
                else {
                    var j = 0;
                    this.yVelocity > 10 && (j = Math.random() * this.yVelocity * 2);
                    var e = this.xPos - a + j,
                        f = this.yPos - b + j,
                        i = Math.sqrt(Math.pow(this.game.camera.y - f, 2) + Math.pow(this.game.camera.x - e, 2)),
                        g = e - this.game.camera.x,
                        h = f - this.game.camera.y;
                    i < .5 ? (this.game.camera.x = e, this.game.camera.y = f) : (this.game.camera.x += g / 4, this.game.camera.y += h / 4)
                }
            }
        }, b.prototype.getRotation = function() {
            var a = 5 + Math.abs(this.xVelocity);
            this.rotationDest = this.rotationDest % 360, this.rotation = this.rotation % 360, Math.abs(this.rotationDest - this.rotation) <= a && (this.rotation = this.rotationDest), Math.abs(this.rotationDest - this.rotation) > 180 && (this.rotationDest < this.rotation ? this.rotationDest += 360 : this.rotationDest -= 360), this.rotationDest > this.rotation ? this.rotation += a + (this.rotationDest - this.rotation) / 3 : this.rotationDest < this.rotation && (this.rotation -= a - (this.rotationDest - this.rotation) / 3)
        }, b.prototype.incVelocities = function() { this.currentCannon || (this.xPos += (this.xVelocity + this.forcedXVelocity) * this.main.gameSpeed, this.yPos += this.yVelocity * this.main.gameSpeed, this.currentSlope && (this.currentSlope.right ? this.yPos += this.xVelocity * this.main.gameSpeed + 1 : this.yPos -= this.xVelocity * this.main.gameSpeed + 1)) }, b.prototype.loseKey = function(a) {
            var b = this.heldKeys.indexOf(a);
            this.heldKeys.splice(b, 1), this.keysObtained--
        }, b.prototype.update = function() {
            var a = this.xPos,
                b = this.yPos,
                c = this.rotation;
            if (this.animationTick(), this.alive) {
                if (this.porting) {
                    var d = this.main.finishPortal.xPos - this.xPos,
                        e = this.main.finishPortal.yPos - this.yPos;
                    this.xPos += d / 10, this.yPos += e / 10, this.container.rotation += 8 - this.container.scale.x, this.container.scale.x *= .95, this.container.scale.y *= .95, Math.abs(this.container.scale.x) < .3 && this.main.finishLevel(), this.updatePositions()
                }
                else if (this.main.finishPortal && SAT.testPolygonPolygon(this.totalPolygon, this.main.finishPortal.hitBoxPolygon)) this.porting = !0, this.main.timerLive = !1, this.setFall(), this.scoreUpdated || (Constants.actFinishTime = Date.now() - Constants.actStartTime, this.scoreUpdated = !0);
                else if (this.state === PlayerState.Spawning);
                else {
                    this.swimming || this.kicking || this.currentCannon || this.main.followingWire || this.checkKeyboard(), this.checkCrouch(), this.swimming || this.currentCannon || this.updateGravity(), this.incVelocities(), this.hangTime < this.maxHangCoolDown && this.hangTime++, this.checkPoolCollisions(), this.swimming ? (this.getSwim(), this.checkSwimBlockCollisions(), this.breathe -= this.main.gameSpeed, this.breathe <= 0 && this.kill(4)) : (this.currentCannon || (this.checkBlocks(), this.checkSlopeCollisions(), this.currentPole ? this.performSwing() : this.checkPoleCollisions()), (this.falling || this.currentZipline) && this.yVelocity > 0 && this.checkZipline(), this.breathe < this.maxBreathe ? this.breathe += 4 * this.main.gameSpeed : this.breathe = this.maxBreathe), this.currentCannon ? this.cannonLogic() : this.checkCannonCollisions(), this.checkKeyObj(), this.checkCheckpoint(), this.checkDeath(), this.checkStar();
                    for (var f = 0, g = this.main.lightSwitches; f < g.length; f++) {
                        var h = g[f];
                        SAT.testPolygonPolygon(this.totalPolygon, h.hitBoxPolygon) && this.main.goDark()
                    }
                    this.swimming ? this.rotation = 0 : this.getRotation(), this.xPos === a && this.yPos === b && this.rotation === c || this.updatePositions(), this.swimming || (this.sprite.position.y = this.spriteYOff), !this.currentZipline && this.main.sounds.ziplineFull.isPlaying && this.main.sounds.ziplineFull.stop()
                }
                for (var i = 0, j = this.main.breatheBlasters; i < j.length; i++) {
                    var k = j[i];
                    SAT.testPolygonPolygon(this.totalPolygon, k.hitPoly) && (this.breathe += 5, this.breathe > this.maxBreathe && (this.breathe = this.maxBreathe))
                }
                this.breatheBar(), this.game.device.desktop && this.pressDown.blink()
            }
            this.main.followingWire || this.cameraLogic()
        }, b.prototype.breatheBar = function() {
            if (this.swimming) {
                this.breatheGroup.visible = !0, this.breatheGroup.rotation = -this.container.rotation, this.breatheGroup.scale.x < 1 && (this.breatheGroup.scale.x += -.1, this.breatheGroup.scale.x > 1 && (this.breatheGroup.scale.x = 1), this.breatheGroup.scale.y = this.breatheGroup.scale.x, this.breatheGroup.alpha = this.breatheGroup.scale.x);
                for (var a = Math.floor(this.breathe / 60), b = 0; b < 10; b++) {
                    var c = this.breatheBlocks[b];
                    b > a ? c.alpha > 0 && (c.alpha -= .1, c.y -= .5, c.alpha < 0 && (c.alpha = 0, c.y = -85)) : c.alpha < 1 && (c.alpha += .1, c.y = -65, c.alpha > 1 && (c.alpha = 1, c.y = -65))
                }
            }
            else this.breatheGroup.visible = !1
        }, b.prototype.pause = function() { this.sprite && this.sprite.animations && this.sprite.animations.currentAnim && (this.sprite.animations.paused = !0) }, b.prototype.resume = function() { this.sprite.animations.currentAnim && (this.sprite.animations.paused = !1) }, b.prototype.hide = function() { this.container.visible = !1, this.alive = !1 }, b.prototype.updatePositions = function() { this.container.x = this.xPos, this.container.y = this.yPos, this.container.rotation = this.rotation * Math.PI / 180, this.updateHitBoxesPos() }, b
    }(Entity),
    Block = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.scalable = !0, e.hangable = !0, e.main = b, e.game = c, e.layer = d, e.passable = !1, e }
        return __extends(b, a), b.prototype.update = function() { this.landed && this.specificLand() }, b.prototype.specificLand = function() {}, b.prototype.levelStart = function() {}, b.prototype.destroy = function() { this.topBound = null, this.topBoundPolygon = null, this.bottomBound = null, this.bottomBoundPolygon = null, this.leftBound = null, this.leftBoundPolygon = null, this.rightBound = null, this.rightBoundPolygon = null, this.lhBound = null, this.lhBoundPolygon = null, this.rhBound = null, this.rhBoundPolygon = null, this.totalBound = null, this.totalBoundPolygon = null, this.game = null, this.layer = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.landed = null }, b.prototype.reset = function() { this.landed = null }, b
    }(Entity),
    BasicBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "basicBlockColors"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, c, d, e) {
            this.xPos = a, this.yPos = c, this.prevX = a, this.prevY = c, this.width = d, this.height = e, this.sprite.position.set(a, c), this.sprite.scale.set(d / this.sprite.width, e / this.sprite.height), this.sprite.anchor.set(.5, .5), this.sprite.frame = parseInt(this.main.currentLevelID), this.sprite.visible = !0, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * d, this.rightEdge = a + .5 * d, this.topEdge = c - .5 * e, this.bottomEdge = c + .5 * e, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var f = .5 * this.width,
                g = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, c), d, e), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.topBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.lhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.leftBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rightBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.bottomBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-f), g - b.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    LeftSlope = function(a) {
        function b(b, c, d, e) { void 0 === e && (e = !1); var f = a.call(this, b) || this; return f.game = c, f.layer = d, f.right = e, f.sprite = d.create(0, 0, "leftSlopeColors"), f.sprite.autoCull = !0, f.alive = !1, f }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) {
            this.xPos = a, this.yPos = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.right && (this.sprite.scale.x = -this.sprite.scale.x), this.sprite.anchor.set(.5, .5), this.sprite.rotation = e * Math.PI / 180;
            var f = parseInt(this.main.currentLevelID);
            f < 8 && (this.sprite.frame = f), this.alive = !0, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.wallPoly = new SAT.Box(new SAT.Vector(a, b), 10, d - 20).toPolygon(), this.bottomPoly = new SAT.Box(new SAT.Vector(a, b), c, 10).toPolygon(), this.right ? this.wallPoly.setOffset(new SAT.Vector(-c / 2, -d / 2 + 20)) : this.wallPoly.setOffset(new SAT.Vector(c / 2, -d / 2 + 20)), this.bottomPoly.setOffset(new SAT.Vector(c / 2, d / 2))
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    VerticalUpBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.maxMoveDist = 100, e.sprite = d.create(0, 0, "verticalUpBlock"), e.sprite.autoCull = !0, e.sprite.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.startY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = -2, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.alive = !0, this.attachmentOffsets = [], this.attachments = [];
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - BasicBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.levelStart = function() {
            for (var a = new SAT.Box(new SAT.Vector(this.leftEdge, this.topEdge - 10), this.width, this.height + 20).toPolygon(), b = 0; b < this.main.obstacles.length; b++) {
                var c = this.main.obstacles[b];
                if ("spike" === c.obstacleType) {
                    var d = c;
                    SAT.testPolygonPolygon(a, d.deathBoxPolygon) && (this.attachments.push(d), this.attachmentOffsets.push(new Phaser.Point(d.xPos - this.xPos, d.yPos - this.yPos)))
                }
                else if ("quadrant" === c.obstacleType) {
                    var e = c;
                    SAT.testPolygonPolygon(a, e.attachHitBoxPolygon) && (this.attachments.push(c), this.attachmentOffsets.push(new Phaser.Point(c.xPos - this.xPos, c.yPos - this.yPos)))
                }
            }
        }, b.prototype.updatePosition = function() {
            this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos, this.sprite.y = this.yPos;
            for (var a = 0; a < this.attachments.length; a++) {
                var b = this.attachments[a],
                    c = this.attachmentOffsets[a];
                b.xPos = this.xPos + c.x, b.yPos = this.yPos + c.y, b.updatePosition()
            }
        }, b.prototype.update = function() { this.prevY = this.yPos, this.yVelocity < 0 ? this.yPos < this.startY - this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()) : this.yPos > this.startY + this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()), this.yPos += this.yVelocity, this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.attachments = null, this.attachmentOffsets = null, a.prototype.destroy.call(this) }, b
    }(Block),
    VerticalDownBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.maxMoveDist = 100, e.sprite = d.create(0, 0, "verticalDownBlock"), e.sprite.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.levelStart = function() {
            for (var a = new SAT.Box(new SAT.Vector(this.leftEdge, this.topEdge - 10), this.width, this.height + 20).toPolygon(), b = 0; b < this.main.obstacles.length; b++) {
                var c = this.main.obstacles[b];
                if ("spike" === c.obstacleType) {
                    var d = c;
                    SAT.testPolygonPolygon(a, d.deathBoxPolygon) && (this.attachments.push(d), this.attachmentOffsets.push(new Phaser.Point(d.xPos - this.xPos, d.yPos - this.yPos)))
                }
                else if ("quadrant" === c.obstacleType) {
                    var e = c;
                    SAT.testPolygonPolygon(a, e.attachHitBoxPolygon) && (this.attachments.push(c), this.attachmentOffsets.push(new Phaser.Point(c.xPos - this.xPos, c.yPos - this.yPos)))
                }
            }
        }, b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.startY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 2, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.alive = !0, this.attachmentOffsets = [], this.attachments = [];
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - BasicBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() {
            this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos, this.sprite.y = this.yPos;
            for (var a = 0; a < this.attachments.length; a++) {
                var b = this.attachments[a],
                    c = this.attachmentOffsets[a];
                b.xPos = this.xPos + c.x, b.yPos = this.yPos + c.y, b.updatePosition()
            }
        }, b.prototype.update = function() { this.prevY = this.yPos, this.yVelocity > 0 ? this.yPos > this.startY + this.maxMoveDist && (this.yVelocity = -this.yVelocity) : this.yPos < this.startY - this.maxMoveDist && (this.yVelocity = -this.yVelocity), this.yPos += this.yVelocity, this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.attachments = null, this.attachmentOffsets = null, a.prototype.destroy.call(this) }, b
    }(Block),
    Obstacle = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.alive = !1, e }
        return __extends(b, a), b.prototype.levelStart = function() {}, b.prototype.update = function() {}, b.prototype.destroy = function() { this.main = null, this.game = null, this.layer = null, a.prototype.destroy.call(this) }, b.prototype.updatePosition = function() {}, b
    }(Entity),
    Spike = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.obstacleType = "spike", e.init(), e }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "spike"), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5), this.graphics = this.game.add.graphics(0, 0, this.layer), this.graphics.visible = !1, this.width = 7.5, this.height = 14.75, this.spikeNum = 1 }, b.prototype.levelStart = function() {
            for (var a = 0, b = this.main.pools; a < b.length; a++) {
                var c = b[a];
                SAT.testPolygonPolygon(this.deathBoxPolygon, c.totalPolygon) && this.main.underPoolLayer.addChild(this.sprite)
            }
        }, b.prototype.spawn = function(a, b, c) {
            this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.alive = !0, this.sprite.visible = !0;
            var d = .5 * this.width,
                e = .5 * this.height,
                f = c * Math.PI / 180;
            this.rad = f, this.sprite.rotation = f;
            var g = new Phaser.Point(-d * Math.cos(this.rad) - -e * Math.sin(this.rad), -d * Math.sin(this.rad) + -e * Math.cos(this.rad)),
                h = new Phaser.Point(d * Math.cos(this.rad) - -e * Math.sin(this.rad), d * Math.sin(this.rad) + -e * Math.cos(this.rad)),
                i = new Phaser.Point(-d * Math.cos(this.rad) - e * Math.sin(this.rad), -d * Math.sin(this.rad) + e * Math.cos(this.rad)),
                j = new Phaser.Point(d * Math.cos(this.rad) - e * Math.sin(this.rad), d * Math.sin(this.rad) + e * Math.cos(this.rad));
            this.deathBoxPolygon = new SAT.Polygon(new SAT.Vector(a, b), [new SAT.Vector(g.x, g.y), new SAT.Vector(h.x, h.y), new SAT.Vector(j.x, j.y), new SAT.Vector(i.x, i.y)]), this.graphics.beginFill(16711680, .5), this.graphics.moveTo(this.deathBoxPolygon.points[0].x, this.deathBoxPolygon.points[0].y), this.graphics.lineTo(this.deathBoxPolygon.points[1].x, this.deathBoxPolygon.points[1].y), this.graphics.lineTo(this.deathBoxPolygon.points[2].x, this.deathBoxPolygon.points[2].y), this.graphics.lineTo(this.deathBoxPolygon.points[3].x, this.deathBoxPolygon.points[3].y), this.graphics.endFill(), this.graphics.position.set(a, b)
        }, b.prototype.update = function() {}, b.prototype.updatePosition = function() {
            this.sprite.position.set(this.xPos, this.yPos);
            var a = .5 * this.width,
                b = .5 * this.height,
                c = new Phaser.Point(-a * Math.cos(this.rad) - -b * Math.sin(this.rad), -a * Math.sin(this.rad) + -b * Math.cos(this.rad)),
                d = new Phaser.Point(a * Math.cos(this.rad) - -b * Math.sin(this.rad), a * Math.sin(this.rad) + -b * Math.cos(this.rad)),
                e = new Phaser.Point(-a * Math.cos(this.rad) - b * Math.sin(this.rad), -a * Math.sin(this.rad) + b * Math.cos(this.rad)),
                f = new Phaser.Point(a * Math.cos(this.rad) - b * Math.sin(this.rad), a * Math.sin(this.rad) + b * Math.cos(this.rad));
            this.deathBoxPolygon = new SAT.Polygon(new SAT.Vector(this.xPos, this.yPos), [new SAT.Vector(c.x, c.y), new SAT.Vector(d.x, d.y), new SAT.Vector(f.x, f.y), new SAT.Vector(e.x, e.y)]), this.graphics.clear(), this.graphics.beginFill(16711680, .5), this.graphics.moveTo(this.deathBoxPolygon.points[0].x, this.deathBoxPolygon.points[0].y), this.graphics.lineTo(this.deathBoxPolygon.points[1].x, this.deathBoxPolygon.points[1].y), this.graphics.lineTo(this.deathBoxPolygon.points[2].x, this.deathBoxPolygon.points[2].y), this.graphics.lineTo(this.deathBoxPolygon.points[3].x, this.deathBoxPolygon.points[3].y), this.graphics.endFill(), this.graphics.position.set(this.xPos, this.yPos)
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathBoxPolygon = null, this.graphics.destroy(), this.graphics = null }, b
    }(Obstacle),
    HorizontalBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.maxMoveDist = 100, e.sprite = d.create(0, 0, "horizontalBlock"), e.sprite.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) {
            void 0 === e && (e = -2), this.xPos = a, this.yPos = b, this.startX = a, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = e, this.startXVelocity = e, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.attachmentOffsets = [], this.attachments = [], this.landed = null, this.alive = !0;
            var f = .5 * this.width,
                g = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), f, BasicBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), f, BasicBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), f, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), f, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-f), g - BasicBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.levelStart = function() {
            for (var a = new SAT.Box(new SAT.Vector(this.leftEdge, this.topEdge), this.width, this.height + 10).toPolygon(), b = 0; b < this.main.obstacles.length; b++) {
                var c = this.main.obstacles[b];
                if ("spike" === c.obstacleType) {
                    var d = c;
                    if (1 != d.spikeNum) continue;
                    SAT.testPolygonPolygon(a, d.deathBoxPolygon) && (this.attachments.push(d), this.attachmentOffsets.push(new Phaser.Point(d.xPos - this.xPos, d.yPos - this.yPos)))
                }
            }
        }, b.prototype.updatePosition = function() {
            this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos, this.sprite.x = this.xPos;
            for (var a = 0; a < this.attachments.length; a++) {
                var b = this.attachments[a],
                    c = this.attachmentOffsets[a];
                b.xPos = this.xPos + c.x, b.yPos = this.yPos + c.y, b.updatePosition()
            }
        }, b.prototype.update = function() {
            var a = this.xPos;
            if (this.xVelocity > 0 ? this.xPos > this.startX + this.maxMoveDist && (this.xVelocity = -this.xVelocity) : this.xPos < this.startX - this.maxMoveDist && (this.xVelocity = -this.xVelocity), this.xPos += this.xVelocity, this.xPos != a && this.updatePosition(), this.landed) {
                var b = this.main.player.xPos - a - this.landed.x;
                this.landed.x += b, this.main.player.xPos = this.xPos + this.landed.x, this.main.player.updatePositions()
            }
        }, b.prototype.reset = function() { this.xPos = this.startX, this.xVelocity = this.startXVelocity }, b.prototype.resetLevel = function() { this.reset() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.attachments = null, this.attachmentOffsets = null }, b
    }(Block),
    BounceBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.bounceStr = 4, e.container = e.game.add.group(d), e.sprite = e.container.create(0, 0, "bounceBlock"), e.sprite.autoCull = !0, e.arrowAnimation = e.container.create(0, 0, "arrowAnimation"), e.arrowAnimation.autoCull = !0, e.sprite.anchor.set(.5, .5), e.arrowAnimation.anchor.set(.5, .5), e.alive = !1, e.hangable = !0, e.scalable = !0, e.blockType = "bounce", e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.startY = b, this.spriteYOff = 0, this.width = c, this.height = d, this.container.position.set(a, b), this.container.scale.set(c / 100, d / 100), this.arrowMask = this.game.add.graphics(0, 0, this.container), this.main.options.blend ? (this.arrowMask.beginFill(0), this.arrowMask.drawRect(-50, -50, 100, 100), this.arrowMask.endFill(), this.arrowAnimation.mask = this.arrowMask, this.arrowAnimation.animations.add("arrow"), this.arrowAnimation.play("arrow", 60 * this.main.gameSpeed, !0)) : this.arrowAnimation.loadTexture("arrowStatic"), this.startScaleX = c / 100, this.startScaleY = d / 100, this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.bouncing = !1, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height,
                g = a - e,
                h = b - f;
            this.totalBound = new SAT.Box(new SAT.Vector(g, h), c, d), this.topBound = new SAT.Box(new SAT.Vector(g, h), c, BasicBlock.TOP_BOUND_HEIGHT), this.lhBound = new SAT.Box(new SAT.Vector(g, h), e, BasicBlock.TOP_BOUND_HEIGHT), this.rhBound = new SAT.Box(new SAT.Vector(a, h), e, BasicBlock.TOP_BOUND_HEIGHT), this.leftBound = new SAT.Box(new SAT.Vector(g, h), e, d), this.rightBound = new SAT.Box(new SAT.Vector(a, h), e, d), this.bottomBound = new SAT.Box(new SAT.Vector(g, b + f - BasicBlock.TOP_BOUND_HEIGHT), c, BasicBlock.TOP_BOUND_HEIGHT), this.totalBoundPolygon = this.totalBound.toPolygon(), this.topBoundPolygon = this.topBound.toPolygon(), this.lhBoundPolygon = this.lhBound.toPolygon(), this.rhBoundPolygon = this.rhBound.toPolygon(), this.leftBoundPolygon = this.leftBound.toPolygon(), this.rightBoundPolygon = this.rightBound.toPolygon(), this.bottomBoundPolygon = this.bottomBound.toPolygon()
        }, b.prototype.updatePosition = function() {
            this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height;
            var a = .5 * this.width,
                b = .5 * this.height,
                c = this.xPos - a,
                d = this.yPos - b;
            this.totalBound.pos.x = c, this.totalBound.pos.y = d, this.topBound.pos.x = c, this.topBound.pos.y = d, this.lhBound.pos.x = c, this.lhBound.pos.y = d, this.rhBound.pos.x = this.xPos, this.rhBound.pos.y = d, this.leftBound.pos.x = c, this.leftBound.pos.y = d, this.rightBound.pos.x = this.xPos, this.rightBound.pos.y = d, this.bottomBound.pos.x = c, this.bottomBound.pos.y = this.yPos + this.height - BasicBlock.TOP_BOUND_HEIGHT, this.topBoundPolygon = this.topBound.toPolygon(), this.lhBoundPolygon = this.lhBound.toPolygon(), this.rhBoundPolygon = this.rhBound.toPolygon(), this.leftBoundPolygon = this.leftBound.toPolygon(), this.rightBoundPolygon = this.rightBound.toPolygon(), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.container.y = this.yPos
        }, b.prototype.update = function() { this.landed ? this.specificLand() : 1 == this.container.scale.x && 1 == this.container.scale.y || (this.container.scale.y -= (this.container.scale.y - this.startScaleY) * (.15 * this.main.gameSpeed), this.container.scale.x -= (this.container.scale.x - this.startScaleX) * (.15 * this.main.gameSpeed), this.spriteYOff = (this.startScaleY - this.container.scale.y) * this.height * .5), this.container.position.y = this.yPos + 2 * this.spriteYOff }, b.prototype.specificLand = function() { this.container.scale.x += .01 * this.bounceStr * this.main.gameSpeed, this.container.scale.y -= .01 * this.bounceStr * this.main.gameSpeed, this.spriteYOff = (this.startScaleY - this.container.scale.y) * this.height * .5, this.bouncing ? (this.main.player.xPos = this.lockX, this.main.player.spriteYOff = 2 * this.spriteYOff + 5, this.main.player.updatePositions()) : (this.lockX = this.main.player.xPos, this.main.player.setCrouch(), this.main.player.bouncing = !0, this.bouncing = !0), this.container.scale.y < .25 && (this.main.player.yPos -= .5 * this.height, this.main.player.xPos = this.lockX, this.main.player.jump(-35 * this.height * .01), this.main.player.bouncing = !1, this.main.player.spriteYOff = 0, this.bouncing = !1, this.main.sounds.playSound("bounce1")) }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.arrowAnimation.destroy(), this.arrowAnimation = null, this.arrowMask && (this.arrowMask.destroy(), this.arrowMask = null), this.container.destroy(), this.container = null, a.prototype.destroy.call(this) }, b
    }(Block),
    FallingBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.container = e.game.add.group(d), e.sprite = e.container.create(0, 0, "fallingBlock"), e.sprite.autoCull = !0, e.arrowAnimation = e.container.create(0, 0, "arrowAnimation"), e.arrowAnimation.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e.container.visible = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.startY = b, this.width = c, this.height = d, this.container.position.set(a, b), this.container.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.arrowAnimation.anchor.set(.5, .5), this.arrowAnimation.scale.set(1, -1), this.main.options.blend ? (this.arrowMask = this.game.add.graphics(0, 0, this.container), this.arrowMask.beginFill(0), this.arrowMask.drawRect(-50, -50, 100, 100), this.arrowMask.endFill(), this.arrowAnimation.mask = this.arrowMask, this.arrowAnimation.animations.add("arrow"), this.arrowAnimation.play("arrow", 60 * this.main.gameSpeed, !0)) : this.arrowAnimation.loadTexture("arrowStatic"), this.container.visible = !0, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.falling = !1, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, BasicBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, BasicBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, BasicBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - BasicBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos, this.container.position.y = this.yPos }, b.prototype.update = function() {
            if (!this.alive) {
                if (SAT.testPolygonPolygon(this.totalBoundPolygon, this.main.player.bodyPolygon)) return;
                this.alive = !0
            }
            this.prevY = this.yPos, this.falling ? (this.yVelocity += this.main.gravity * this.main.gameSpeed, this.container.alpha -= .01 * this.main.gameSpeed, this.yVelocity >= 20 && (this.main.sounds.playSound("blockDestroy"), this.alive = !1, this.container.alpha = 0, this.yPos = this.startY, this.yVelocity = 0, this.falling = !1)) : this.landed ? (this.falling = !0,
                this.yVelocity = -2, this.main.sounds.playSound("fallingBlock")) : this.container.alpha < 1 && (this.container.alpha += .02), this.yPos += this.yVelocity * this.main.gameSpeed, this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition()
        }, b.prototype.reset = function() { this.yPos = this.startY, this.yVelocity = 0, this.falling = !1, this.alive = !0, this.container.alpha = 1, this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.arrowAnimation.destroy(), this.arrowAnimation = null, this.arrowMask && (this.arrowMask.destroy(), this.arrowMask = null), this.container.destroy(), this.container = null, a.prototype.destroy.call(this) }, b
    }(Block),
    PushBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "pushBlock"), e.sprite.autoCull = !0, e.alive = !1, e.blockType = "push", e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, c, d, e) {
            this.xPos = a, this.yPos = c, this.startX = a, this.startY = c, this.prevX = a, this.prevY = c, this.width = d, this.height = e, this.sprite.position.set(a, c), this.sprite.scale.set(d / 100, e / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * d, this.rightEdge = a + .5 * d, this.topEdge = c - .5 * e, this.bottomEdge = c + .5 * e, this.landed = null, this.pushingRight = !1, this.pushingLeft = !1, this.pushed = !1, this.inWater = !1, this.onIce = !1, this.stuckLeft = !1, this.stuckRight = !1, this.land = !1, this.alive = !0;
            var f = .5 * this.width,
                g = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, c), d, e), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.topBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.lhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.leftBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rightBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.bottomBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-f), g - b.TOP_BOUND_HEIGHT))
        }, b.prototype.checkBlockCollisions = function() {
            this.land = !1, this.onIce = !1;
            for (var a = 0; a < this.main.blocks.length; a++) {
                var b = this.main.blocks[a];
                if (b.alive)
                    if (SAT.testPolygonPolygon(b.topBoundPolygon, this.bottomBoundPolygon)) {
                        if (this.yVelocity >= 3, "ice" === b.blockType && (this.onIce = !0), this.yVelocity = b.yVelocity, this.inWater ? (this.yVelocity *= -1, this.yPos = b.topEdge - .5 * this.height) : this.yVelocity > 0 ? this.yPos = b.topEdge - .5 * this.height + this.yVelocity : this.yPos = b.topEdge - .5 * this.height + 1, this.land = !0, this.updatePositions(), "speed" === b.blockType) {
                            var c = b;
                            this.xVelocity += .4 * c.speedInc
                        }
                        else if ("falling" === b.blockType) {
                            var d = b;
                            d.falling || (d.falling = !0, d.yVelocity = -2)
                        }
                    }
                else(this.yVelocity < 0 || b.yVelocity > 0) && SAT.testPolygonPolygon(this.topBoundPolygon, b.bottomBoundPolygon) ? (this.yVelocity < 0 && (this.yVelocity *= .5), this.yPos = b.bottomEdge + .5 * this.height) : this.xVelocity - b.xVelocity < 0 && SAT.testPolygonPolygon(this.leftBoundPolygon, b.rightBoundPolygon) ? (this.xVelocity = 0, this.xPos = b.rightEdge + .5 * this.width) : this.xVelocity - b.xVelocity > 0 && SAT.testPolygonPolygon(this.rightBoundPolygon, b.leftBoundPolygon) && (this.xVelocity = 0, this.xPos = b.leftEdge - .5 * this.width)
            }
        }, b.prototype.checkWaterCollisions = function() {
            var a = this.inWater;
            this.inWater = !1;
            for (var b = 0; b < this.main.pools.length; b++) {
                var c = this.main.pools[b];
                SAT.testPolygonPolygon(this.totalBoundPolygon, c.totalPolygon) && (this.main.underPoolLayer.addChild(this.sprite), this.yPos > c.yPos - .5 * c.height && (!a && this.yVelocity > 5, this.yVelocity -= this.main.gameSpeed, this.yVelocity < -3 && (this.yVelocity = -3), this.inWater = !0))
            }
        }, b.prototype.checkTrapped = function() { for (var a = new SAT.Vector(this.leftEdge - 5, this.topEdge + 10), b = new SAT.Vector(this.rightEdge + 5, this.topEdge + 10), c = 0; c < this.main.blocks.length; c++) { var d = this.main.blocks[c]; if (d.alive) { if (SAT.pointInPolygon(a, d.totalBoundPolygon)) return this.stuckLeft = !0, "left"; if (SAT.pointInPolygon(b, d.totalBoundPolygon)) return this.stuckRight = !0, "right" } } return "not trapped" }, b.prototype.update = function() { this.land || (this.yVelocity += this.main.gravity * this.main.gameSpeed), this.xPos += this.xVelocity, this.yPos += this.yVelocity, this.landed && (this.main.player.xPos += this.xVelocity, this.main.player.updatePositions()), this.onIce ? this.xVelocity -= .01 * this.xVelocity : this.xVelocity -= .25 * this.xVelocity, this.checkBlockCollisions(), this.checkWaterCollisions(), this.updatePositions() }, b.prototype.updatePositions = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.reset = function() { this.main.levelLayer.addChild(this.sprite), this.xPos = this.startX, this.yPos = this.startY, this.pushed = !1, this.pushingLeft = !1, this.pushingRight = !1, this.updatePositions() }, b.prototype.resetLevel = function() { this.reset() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    IceBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "iceBlock"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e.blockType = "ice", e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, c, d, e) {
            this.xPos = a, this.yPos = c, this.prevX = a, this.prevY = c, this.startX = a, this.startY = c, this.width = d, this.height = e, this.startHeight = e, this.sprite.position.set(a, c), this.sprite.scale.set(d / 100, e / 100), this.startXScale = d / 100, this.startYScale = e / 100, this.sprite.anchor.set(.5, .5), this.sprite.visible = !0, this.main.options.blend && (this.maskGraphic = this.game.add.graphics(0, 0, this.layer), this.maskGraphic.beginFill(0), this.maskGraphic.drawRect(.5 * -d, .5 * -e, d, e), this.maskGraphic.endFill(), this.maskGraphic.position.set(a, c), this.sprite.mask = this.maskGraphic), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * d, this.rightEdge = a + .5 * d, this.topEdge = c - .5 * e, this.bottomEdge = c + .5 * e, this.depletionRate = .001, this.meltScale = 1, this.landed = null, this.alive = !0;
            var f = .5 * this.width,
                g = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, c), d, e), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.topBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.lhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rhBound = new SAT.Box(new SAT.Vector(a, c), f, b.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.leftBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rightBound = new SAT.Box(new SAT.Vector(a, c), f, e), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.bottomBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-f), g - b.TOP_BOUND_HEIGHT)), this.hitGraphics = this.game.add.graphics(0, 0), this.hitGraphics.visible = !1, this.layer.add(this.hitGraphics), this.hitGraphics.clear(), this.hitGraphics.beginFill(16711680, .5), this.hitGraphics.moveTo(this.xPos + this.rhBoundPolygon.calcPoints[0].x, this.yPos + this.rhBoundPolygon.calcPoints[0].y);
            for (var h = 1; h < 4; h++) this.hitGraphics.lineTo(this.xPos + this.rhBoundPolygon.calcPoints[h].x, this.yPos + this.rhBoundPolygon.calcPoints[h].y);
            this.hitGraphics.lineTo(this.xPos + this.rhBoundPolygon.calcPoints[0].x, this.yPos + this.rhBoundPolygon.calcPoints[0].y), this.hitGraphics.endFill()
        }, b.prototype.update = function() {
            if (this.alive) {
                if (!this.melted, this.rightEdge < this.game.camera.x || this.leftEdge > this.game.camera.x + 640 || this.bottomEdge < this.game.camera.y || this.topEdge > this.game.camera.y + 560) return;
                this.meltScale -= this.depletionRate, this.maskGraphic ? (this.maskGraphic.scale.y = this.meltScale, this.maskGraphic.y -= this.depletionRate * this.startHeight / 2) : (this.sprite.scale.y = this.height / 100 * this.meltScale, this.sprite.position.y = this.yPos - this.height / 2 * (1 - this.meltScale));
                var a = .5 * this.width,
                    c = .5 * this.height,
                    d = (this.width, this.height),
                    e = this.xPos,
                    f = this.yPos;
                this.totalBound = new SAT.Box(new SAT.Vector(this.xPos, this.yPos), this.width, this.height * this.meltScale), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-a), (-c))), this.leftBound = new SAT.Box(new SAT.Vector(e, f), a, d * this.meltScale), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-a), (-c))), this.rightBound = new SAT.Box(new SAT.Vector(e, f), a, d * this.meltScale), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-c))), this.bottomBoundPolygon.setOffset(new SAT.Vector((-a), this.meltScale * c - b.TOP_BOUND_HEIGHT)), this.meltScale <= 0 && (this.melted = !0, this.alive = !1, this.sprite.visible = !1)
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.maskGraphic && (this.maskGraphic.destroy(), this.maskGraphic = null), this.hitGraphics.destroy(), delete this.hitGraphics, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.reset() }, b.prototype.reset = function() { this.meltScale = 1, this.maskGraphic && (this.maskGraphic.scale.y = 1, this.maskGraphic.y = this.startY), this.sprite.scale.set(this.startXScale, this.startYScale), this.sprite.visible = !0, this.alive = !0, this.melted = !1 }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    GlassBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "glassBlock"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e.blockType = "glass", e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.sprite.visible = !0, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, IceBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, IceBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, IceBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, IceBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - IceBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.smash = function() {
            this.sprite.visible = !1, this.main.sounds.playSound("glassSmash");
            for (var a = 0; a < .25 * this.width; a++) {
                var b = this.xPos - this.width / 2 + Math.random() * this.width,
                    c = this.yPos - .5 * this.height + Math.random() * this.height;
                this.main.createColorParticle(b, c, 5 * Math.random() - 2.5, this.main.player.yVelocity * Math.random(), 12185594, 8), this.alive = !1, this.main.player.yVelocity > 10 && (this.main.player.yVelocity = 10)
            }
        }, b.prototype.resetLevel = function() { this.reset() }, b.prototype.reset = function() { "3" != this.main.currentLevelID && (this.alive = !0, this.sprite.visible = !0) }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    SpeedBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.container = c.add.group(d), e.sprite = e.container.create(0, 0, "speedBlock"), e.sprite.anchor.set(.5, .5), e.sprite.autoCull = !0, e.arrowAnimation = e.container.create(0, 0, "arrowAnimation"), e.arrowAnimation.animations.add("arrow"), e.arrowAnimation.anchor.set(.5, .5), e.arrowAnimation.autoCull = !0, e.alive = !1, e.blockType = "speed", e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.speedInc = e, this.container.position.set(a, b), this.container.scale.set(c / 100, d / 100), this.main.options.blend ? (this.arrowMask = this.game.add.graphics(0, 0, this.container), this.arrowMask.beginFill(0), this.arrowMask.drawRect(-50, -50, 100, 100), this.arrowMask.endFill(), this.arrowAnimation.mask = this.arrowMask, this.arrowAnimation.play("arrow", null, !0)) : this.arrowAnimation.loadTexture("arrowStatic"), this.speedInc > 0 ? this.arrowAnimation.rotation = Math.PI / 2 : this.arrowAnimation.rotation = -Math.PI / 2, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var f = .5 * this.width,
                g = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), f, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), f, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), f, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-f), (-g))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), f, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-g))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-f), g - PushBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.container.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.landed && this.land(), this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.land = function() {
            (this.speedInc > 0 && this.main.player.xVelocity < 5 * this.speedInc || this.speedInc < 0 && this.main.player.xVelocity > 5 * this.speedInc) && (this.main.player.xVelocity += this.speedInc, this.main.player.xVelocity === this.speedInc && (this.main.player.xVelocity += .75 * this.speedInc))
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.arrowMask && (this.arrowMask.destroy(), this.arrowMask = null), this.container.destroy(), this.container = null, a.prototype.destroy.call(this) }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    LB = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "lockBlock"), e.sprite.autoCull = !0, e.alive = !1, e.blockType = "lock", e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - PushBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.unlock = function() { this.unlocked = !0, this.passable = !0, this.alive = !1, this.sprite.visible = !1 }, b.prototype.update = function() {}, b.prototype.updatePositions = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.reset = function() {}, b.prototype.resetLevel = function() { this.alive = !0, this.unlocked = !1, this.passable = !1, this.sprite.visible = !0 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    SparkBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "sparkBlock"), e.sprite.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e.spark = new Spark(b, c, d, e), e.main.obstacles.push(e.spark), e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - PushBlock.TOP_BOUND_HEIGHT)), this.spark.spawn()
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() {}, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    SolarBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "solarBlock"), e.sprite.autoCull = !0, e.alive = !1, e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - PushBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.goDark = function() { this.alive = !1, this.sprite.visible = !1 }, b.prototype.goLight = function() { this.alive = !0, this.sprite.visible = !0 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    InvisBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.init(), e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "invisBlock"), this.sprite.autoCull = !0, this.alive = !1 }, b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.startX = a, this.startY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - PushBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() {
            if (this.alive) {
                var a = this.main.player,
                    c = Math.sqrt(Math.pow(a.xPos - this.xPos, 2) + Math.pow(a.yPos - this.yPos, 2));
                this.sprite.alpha -= .25 * (this.sprite.alpha - (c - b.RANGE) / b.RANGE), this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition(), this.prevX = this.xPos, this.prevY = this.yPos
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b.RANGE = 200, b
    }(Block),
    InvisBlockUp = function(a) {
        function b() { var b = null !== a && a.apply(this, arguments) || this; return b.maxMoveDist = 100, b }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "invisBlockUp"), this.sprite.autoCull = !0, this.alive = !1 }, b.prototype.levelStart = function() {
            this.attachments = [], this.attachmentOffsets = [];
            for (var a = new SAT.Box(new SAT.Vector(this.leftEdge, this.topEdge - 10), this.width, this.height + 20).toPolygon(), b = 0; b < this.main.obstacles.length; b++) {
                var c = this.main.obstacles[b];
                if ("spike" === c.obstacleType) {
                    var d = c;
                    SAT.testPolygonPolygon(a, d.deathBoxPolygon) && (this.attachments.push(d), this.attachmentOffsets.push(new Phaser.Point(d.xPos - this.xPos, d.yPos - this.yPos)))
                }
                else if ("buzzsaw" === c.obstacleType) {
                    var e = c;
                    SAT.testCirclePolygon(e.deathCircle, a) && (this.attachments.push(e), this.attachmentOffsets.push(new Phaser.Point(e.xPos - this.xPos, e.yPos - this.yPos)))
                }
            }
        }, b.prototype.spawn = function(b, c, d, e) { a.prototype.spawn.call(this, b, c, d, e), this.yVelocity = -2 }, b.prototype.update = function() {
            this.yVelocity < 0 ? this.yPos < this.startY - this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()) : this.yPos > this.startY + this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()), this.yPos += this.yVelocity;
            for (var b = 0; b < this.attachments.length; b++) {
                var c = this.attachments[b],
                    d = this.attachmentOffsets[b];
                c.xPos = this.xPos + d.x, c.yPos = this.yPos + d.y, c.updatePosition()
            }
            a.prototype.update.call(this)
        }, b
    }(InvisBlock),
    InvisBlockDown = function(a) {
        function b() { var b = null !== a && a.apply(this, arguments) || this; return b.maxMoveDist = 100, b }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "invisBlockDown"), this.sprite.autoCull = !0, this.alive = !1 }, b.prototype.levelStart = function() {
            this.attachments = [], this.attachmentOffsets = [];
            for (var a = new SAT.Box(new SAT.Vector(this.leftEdge, this.topEdge - 10), this.width, this.height + 20).toPolygon(), b = 0; b < this.main.obstacles.length; b++) {
                var c = this.main.obstacles[b];
                if ("spike" === c.obstacleType) {
                    var d = c;
                    SAT.testPolygonPolygon(a, d.deathBoxPolygon) && (this.attachments.push(d), this.attachmentOffsets.push(new Phaser.Point(d.xPos - this.xPos, d.yPos - this.yPos)))
                }
                else if ("buzzsaw" === c.obstacleType) {
                    var e = c;
                    SAT.testCirclePolygon(e.deathCircle, a) && (this.attachments.push(e), this.attachmentOffsets.push(new Phaser.Point(e.xPos - this.xPos, e.yPos - this.yPos)));
                }
            }
        }, b.prototype.spawn = function(b, c, d, e) { a.prototype.spawn.call(this, b, c, d, e), this.yVelocity = 2 }, b.prototype.update = function() {
            this.yVelocity < 0 ? this.yPos < this.startY - this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()) : this.yPos > this.startY + this.maxMoveDist && (this.yVelocity = -this.yVelocity, this.landed && (this.main.player.yPos += 2 * this.yVelocity), this.main.player.updatePositions()), this.yPos += this.yVelocity;
            for (var b = 0; b < this.attachments.length; b++) {
                var c = this.attachments[b],
                    d = this.attachmentOffsets[b];
                c.xPos = this.xPos + d.x, c.yPos = this.yPos + d.y, c.updatePosition()
            }
            a.prototype.update.call(this)
        }, b
    }(InvisBlock),
    ExplosiveBlock = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "explosiveBlock"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e.explodingOverlay = c.add.graphics(0, 0, e.layer), e.sprite.addChild(e.explodingOverlay), e.hangable = !0, e.scalable = !0, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 100, d / 100), this.sprite.anchor.set(.5, .5), this.sprite.visible = !0, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.explodingOverlay.beginFill(16777215, 1), this.explodingOverlay.drawRect(0, 0, c, d), this.explodingOverlay.visible = !0, this.explodingOverlay.position.set(-this.width / 2, -this.height / 2), this.explodingOverlay.alpha = 0, this.xVelocity = 0, this.yVelocity = 0, this.landed = null, this.alive = !0;
            var e = .5 * this.width,
                f = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), e, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-e), (-f))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), e, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-f))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-e), f - PushBlock.TOP_BOUND_HEIGHT))
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.exploding && (this.sprite.scale.x -= .1 * (this.sprite.scale.x - 1.5), this.sprite.scale.y = this.sprite.scale.x, this.explodingOverlay.alpha += .05, this.explodingOverlay.alpha >= 1 && (this.main.exploding || this.main.explode())), this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.explodingOverlay.destroy(), this.explodingOverlay = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.explodingOverlay.visible = !1, this.exploding = !1, this.explodingOverlay.scale.set(1, 1), this.explodingOverlay.alpha = 1, this.sprite.scale.set(1, 1) }, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    BlockedWall = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "blockedWall"), e.sprite.animations.add("blockedwall"), e.sprite.animations.play("blockedwall", null, !0), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e.hangable = !0, e.scalable = !0, e.hangable = !1, e.scalable = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e, f) {
            this.xPos = a, this.yPos = b, this.prevX = a, this.prevY = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.angle = e, this.sprite.anchor.set(.5, .5), this.sprite.frame = parseInt(this.main.currentLevelID), this.sprite.visible = !0, this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * c, this.rightEdge = a + .5 * c, this.topEdge = b - .5 * d, this.bottomEdge = b + .5 * d, this.xVelocity = 0, this.yVelocity = 0, f.colorFilter && this.main.options.blend ? this.sprite.filters = [f.colorFilter] : this.sprite.filters = null, this.landed = null, this.alive = !0;
            var g = .5 * this.width,
                h = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, b), c, d), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-g), (-h))), this.topBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-g), (-h))), this.lhBound = new SAT.Box(new SAT.Vector(a, b), g, PushBlock.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-g), (-h))), this.rhBound = new SAT.Box(new SAT.Vector(a, b), g, PushBlock.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-h))), this.leftBound = new SAT.Box(new SAT.Vector(a, b), g, d), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-g), (-h))), this.rightBound = new SAT.Box(new SAT.Vector(a, b), g, d), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-h))), this.bottomBound = new SAT.Box(new SAT.Vector(a, b), c, PushBlock.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-g), h - PushBlock.TOP_BOUND_HEIGHT)), f.topTime !== -1 && (this.alive = !1, this.sprite.visible = !1)
        }, b.prototype.updatePosition = function() { this.leftEdge = this.xPos - .5 * this.width, this.rightEdge = this.xPos + .5 * this.width, this.topEdge = this.yPos - .5 * this.height, this.bottomEdge = this.yPos + .5 * this.height, this.sprite.position.set(this.xPos, this.yPos), this.totalBoundPolygon.pos.x = this.xPos, this.totalBoundPolygon.pos.y = this.yPos, this.topBoundPolygon.pos.x = this.xPos, this.topBoundPolygon.pos.y = this.yPos, this.lhBoundPolygon.pos.x = this.xPos, this.lhBoundPolygon.pos.y = this.yPos, this.rhBoundPolygon.pos.x = this.xPos, this.rhBoundPolygon.pos.y = this.yPos, this.leftBoundPolygon.pos.x = this.xPos, this.leftBoundPolygon.pos.y = this.yPos, this.rightBoundPolygon.pos.x = this.xPos, this.rightBoundPolygon.pos.y = this.yPos, this.bottomBoundPolygon.pos.x = this.xPos, this.bottomBoundPolygon.pos.y = this.yPos }, b.prototype.update = function() { this.xPos == this.prevX && this.yPos == this.prevY || this.updatePosition() }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.reset = function() {}, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    ActState;
! function(a) { a[a.Locked = 0] = "Locked", a[a.NotPlayed = 1] = "NotPlayed", a[a.Played = 2] = "Played", a[a.Challenge = 3] = "Challenge" }(ActState || (ActState = {}));
var ActBlock = function(a) {
        function b(b, c, d, e, f) {
            var g = a.call(this, b, c, d) || this;
            g.hellEnabled = !1, g.level = f, g.levelNum = e, g.container = c.add.group(d, "container" + e), g.sprite = g.container.create(0, 0, "actBlock" + e), g.sprite.visible = !1, g.sprite.autoCull = !0;
            var h = g.main.levels.levels[e].name;
            if (g.titleText = c.add.bitmapText(0, 0, "grob24", h, 28), g.titleText.anchor.set(.5, .5), g.titleText.visible = !1, f.topTime != -1) {
                var i = c.add.sprite(55, 0, "actCheck");
                i.anchor.set(.5, .5), g.titleText.addChild(i), "10" == f.id && (i.x = 65)
            }
            return g.container.addChild(g.titleText), g.enterStage = g.container.create(0, 0, "enterLevelText"), g.enterStage.anchor.set(.5, 0), g.enterStage.visible = !1, g.downArrow = g.container.create(0, 0, "actDownArrow"), g.downArrow.visible = !1, g.timeText = c.add.bitmapText(0, 0, "grob24", "00:00", 20), g.timeText.position.set(-30, 0), g.timeText.visible = !1, g.container.add(g.timeText), g.fastestTimeText = g.container.create(0, 0, "fastestTimeText"), g.fastestTimeText.anchor.set(.5, .5), g.fastestTimeText.visible = !1, g.fastestTimeText.autoCull = !0, g.rankText = g.container.create(0, 0, f.getRankSpriteKey()), g.rankText.anchor.set(.5, .5), g.rankText.scale.set(.5, .5), g.rankText.visible = !1, g.rankText.autoCull = !0, g.completedText = g.container.create(0, 0, "completedText"), g.completedText.anchor.set(.5, .5), g.completedText.visible = !1, g.completedText.autoCull = !0, g.completeIcon = g.container.create(0, 0, "completedIcon"), g.completeIcon.anchor.set(.5, .5), g.completeIcon.visible = !1, g.completeIcon.autoCull = !0, g.starIcon = g.container.create(0, 0, "starIcon"), g.starIcon.anchor.set(.5, .5), g.starIcon.visible = !1, g.starIcon.autoCull = !0, g.challengeIcon = g.container.create(0, 0, "challengeIcon"), g.challengeIcon.anchor.set(.5, .5), g.challengeIcon.visible = !1, g.challengeIcon.autoCull = !0, g.hellBtn = new Phaser.Sprite(g.game, 0, 0, "hellNormal"), g.container.addChild(g.hellBtn), g.hellBtn.scale.set(.5, .5), g.hellBtn.anchor.set(.5, .5), g.hellCheckBox = new Phaser.Sprite(g.game, 0, 0, "tickboxWhite"), g.hellCheckBox.anchor.set(.5, .5), g.hellCheckBox.frame = 1, g.container.addChild(g.hellCheckBox), g.hellCheckBox.inputEnabled = !0, g.hellCheckBox.events.onInputUp.add(function() { g.toggleTickBox() }), g.alive = !1, g.blockType = "act", g.hangable = !0, g.scalable = !0, g.setHellBtnPos(), g.toggleHellBtnInput(!1, .5), g
        }
        return __extends(b, a), b.prototype.toggleTickBox = function() { this.hellCheckBox.frame = 1 == this.hellCheckBox.frame ? 0 : 1, this.hellEnabled ? this.hellEnabled = !1 : this.hellEnabled = !0 }, b.prototype.getHellText = function() { return this.hellEnabled ? "clickHellTxt" : "hellText" }, b.prototype.spawn = function(a, c) {
            this.xPos = a, this.yPos = c, this.prevX = a, this.prevY = c, this.width = 140, this.height = 140, this.container.position.set(a, c), 10 == this.levelNum ? (this.width = 160, this.height = 160) : (this.width = 140, this.height = 140), this.sprite.anchor.set(.5, .5), this.sprite.visible = !0, this.titleText.position.set(0, -25), this.titleText.visible = !0, this.enterStage.position.set(0, -25.5), this.enterStage.visible = !0, this.downArrow.position.set(-7, 14), this.level.topTime != -1 ? (Constants.actFinishTime = -1, this.state = ActState.Played, this.completedText.visible = !1, this.completedText.position.y = 40, this.timeText.setText(timeDecoratorActBlock(this.level.topTime)), this.timeText.position.set(-62, 40), this.timeText.visible = !0, this.rankText.position.set(35, 53), this.rankText.visible = !0, this.fastestTimeText.position.set(0, 35), this.fastestTimeText.visible = !0, this.starIcon.visible = !0, this.starIcon.position.set(0, 0), "10" != this.level.id ? (this.challengeIcon.visible = !0, this.challengeIcon.position.set(45, 0), this.level.challengeCompleted && (this.challengeIcon.frame = 1)) : this.starIcon.position.set(45, 0), this.level.gotStar && (this.starIcon.frame = 1), this.titleText.position.y = -50, this.completeIcon.visible = !0, this.completeIcon.position.set(-45, 0), this.level.gotGold() && (this.completeIcon.frame = 1, "10" != this.level.id && (this.state = ActState.Challenge, this.downArrow.visible = !1))) : (this.state = ActState.NotPlayed, this.downArrow.visible = !0), this.xVelocity = 0, this.yVelocity = 0, this.leftEdge = a - .5 * this.width, this.rightEdge = a + .5 * this.width, this.topEdge = c - .5 * this.height, this.bottomEdge = c + .5 * this.height, this.alive = !0, this.prevLand = !1;
            var d = .5 * this.width,
                e = .5 * this.height;
            this.totalBound = new SAT.Box(new SAT.Vector(a, c), this.width, this.height), this.totalBoundPolygon = this.totalBound.toPolygon(), this.totalBoundPolygon.setOffset(new SAT.Vector((-d), (-e))), this.topBound = new SAT.Box(new SAT.Vector(a, c), this.width, b.TOP_BOUND_HEIGHT), this.topBoundPolygon = this.topBound.toPolygon(), this.topBoundPolygon.setOffset(new SAT.Vector((-d), (-e))), this.lhBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.lhBoundPolygon = this.lhBound.toPolygon(), this.lhBoundPolygon.setOffset(new SAT.Vector((-d), (-e))), this.rhBound = new SAT.Box(new SAT.Vector(a, c), d, b.TOP_BOUND_HEIGHT), this.rhBoundPolygon = this.rhBound.toPolygon(), this.rhBoundPolygon.setOffset(new SAT.Vector(0, (-e))), this.leftBound = new SAT.Box(new SAT.Vector(a, c), d, this.height), this.leftBoundPolygon = this.leftBound.toPolygon(), this.leftBoundPolygon.setOffset(new SAT.Vector((-d), (-e))), this.rightBound = new SAT.Box(new SAT.Vector(a, c), d, this.height), this.rightBoundPolygon = this.rightBound.toPolygon(), this.rightBoundPolygon.setOffset(new SAT.Vector(0, (-e))), this.bottomBound = new SAT.Box(new SAT.Vector(a, c), this.width, b.TOP_BOUND_HEIGHT), this.bottomBoundPolygon = this.bottomBound.toPolygon(), this.bottomBoundPolygon.setOffset(new SAT.Vector((-d), e - BasicBlock.TOP_BOUND_HEIGHT)), this.setHellBtnPos()
        }, b.prototype.toggleHellBtnInput = function(a, b) { this.hellBtn.alpha = b, this.hellCheckBox.inputEnabled = a, this.hellCheckBox.alpha = b }, b.prototype.toggleHellBtnVisibility = function(a) { this.hellBtn.visible = a, this.hellCheckBox.visible = a }, b.prototype.setHellBtnPos = function() { this.hellBtn.x = this.enterStage.x + this.enterStage.width / 2 - 12, this.hellBtn.y = this.enterStage.y + this.enterStage.height + 15, this.hellCheckBox.x = this.hellBtn.x - this.hellBtn.width + 10, this.hellCheckBox.y = this.hellBtn.y + this.hellBtn.height + 2 }, b.prototype.playerOffBlock = function() {
            if (this.enterStage.alpha > 0 && (this.enterStage.alpha -= .1), this.completedText.alpha = this.enterStage.alpha, this.enterStage.alpha <= 0) {
                switch (this.state) {
                    case ActState.NotPlayed:
                        var a = 0 - this.titleText.position.y;
                        this.titleText.position.y = this.titleText.position.y + a / 10, this.downArrow.alpha = this.enterStage.alpha;
                        break;
                    case ActState.Played:
                        this.timeText.alpha < 1 && (this.timeText.alpha += .1), this.rankText.alpha = this.fastestTimeText.alpha = this.completeIcon.alpha = this.starIcon.alpha = this.challengeIcon.alpha = this.timeText.alpha, this.downArrow.alpha = this.enterStage.alpha;
                        break;
                    case ActState.Challenge:
                        this.timeText.alpha < 1 && (this.timeText.alpha += .1), this.rankText.alpha = this.fastestTimeText.alpha = this.completeIcon.alpha = this.starIcon.alpha = this.challengeIcon.alpha = this.timeText.alpha, this.main.enableHellButton = !1
                }
                this.toggleHellBtnVisibility(!1)
            }
        }, b.prototype.playerOnBlock = function() {
            switch (this.toggleHellBtnVisibility(!0), this.setHellBtnPos(), this.state) {
                case ActState.NotPlayed:
                    var a = -40 - this.titleText.position.y;
                    Math.abs(a) < 1 ? this.titleText.position.y = -40 : this.titleText.position.y = this.titleText.position.y + a / 8, 0 === a && (this.enterStage.alpha < 1 && (this.enterStage.alpha += .1), this.downArrow.alpha = this.enterStage.alpha);
                    break;
                case ActState.Played:
                    this.timeText.alpha > 0 && (this.timeText.alpha -= .1), this.rankText.alpha = this.fastestTimeText.alpha = this.completeIcon.alpha = this.starIcon.alpha = this.challengeIcon.alpha = this.timeText.alpha, this.timeText.alpha <= 0 && (this.enterStage.alpha < 1 && (this.enterStage.alpha += .1), this.completedText.alpha = this.enterStage.alpha);
                    break;
                case ActState.Challenge:
                    this.timeText.alpha > 0 && (this.timeText.alpha -= .1), this.rankText.alpha = this.fastestTimeText.alpha = this.completeIcon.alpha = this.starIcon.alpha = this.challengeIcon.alpha = this.timeText.alpha, this.timeText.alpha <= 0 && this.enterStage.alpha < 1 && (this.enterStage.alpha += .1), this.main.enableHellButton || (this.toggleHellBtnInput(!0, 1), this.main.enableHellButton = !0)
            }
        }, b.prototype.update = function() { this.landed ? (this.playerOnBlock(), this.prevLand || this.main.rankTime.show(this.level)) : (this.playerOffBlock(), this.prevLand && this.main.rankTime.hide()), this.prevLand = !!this.landed }, b.prototype.destroy = function() { this.titleText.destroy(), this.titleText = null, this.enterStage.destroy(), this.enterStage = null, this.downArrow.destroy(), this.downArrow = null, this.fastestTimeText.destroy(), this.fastestTimeText = null, this.timeText.destroy(), this.timeText = null, this.completedText.destroy(), this.completedText = null, this.completeIcon.destroy(), this.completeIcon = null, this.starIcon.destroy(), this.starIcon = null, this.challengeIcon.destroy(), this.challengeIcon = null, this.sprite.destroy(!1), this.sprite = null, this.container.destroy(), this.container = null }, b.TOP_BOUND_HEIGHT = 12, b
    }(Block),
    SwimmingPool = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "swimmingPool"), e.sprite.anchor.set(.5, .5), e.sprite.alpha = .6, e.topMask = c.add.graphics(0, 0, e.layer), e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) { this.xPos = a, this.yPos = b, this.width = c, this.height = d, this.sprite.position.set(a, b), this.sprite.scale.set(c / 250, d / 250), this.electric = !1, this.prevElec = !1, this.totalPolygon = new SAT.Box(new SAT.Vector(a - c / 2, b - d / 2), c, d).toPolygon(), this.topPolygon = new SAT.Box(new SAT.Vector(a - c / 2, b - d / 2), c, 12).toPolygon(), this.topMask.beginFill(16776960, .5), this.topMask.drawRect(0, 0, c, d), this.topMask.endFill(), this.topMask.position.set(a - this.width / 2, b - this.height / 2) }, b.prototype.update = function() { this.electric ? (this.topMask.visible = !0, this.prevElec = !0) : (this.topMask.visible = !1, this.prevElec = !1), this.electric = !1 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.topMask.destroy(), this.topMask = null, this.game = null, this.layer = null, this.totalPolygon = null, this.topPolygon = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Zipline = function(a) {
        function b(b, c, d, e, f) { var g = a.call(this, b) || this; return e.y < f.y ? (g.startPos = e, g.endPos = f, g.topEdge = e.y, g.bottomEdge = f.y) : (g.startPos = f, g.endPos = e, g.topEdge = f.y, g.bottomEdge = e.y), g.startPos.x < g.endPos.x ? (g.direction = "right", g.leftEdge = g.startPos.x, g.rightEdge = g.endPos.x) : (g.direction = "left", g.leftEdge = g.endPos.x, g.rightEdge = g.startPos.x), g.width = Math.abs(g.endPos.x - g.startPos.x), g.height = Math.abs(g.endPos.y - g.startPos.y), g.scope = g.height / g.width, g.wire = c.add.graphics(0, 0, d), g.wire.lineStyle(2, 16737792), g.wire.moveTo(g.startPos.x, g.startPos.y), g.wire.lineTo(g.endPos.x, g.endPos.y), g.hitPolygon = new SAT.Polygon(new SAT.Vector(g.startPos.x, g.startPos.y), [new SAT.Vector(0, 5), new SAT.Vector(g.endPos.x - g.startPos.x, g.endPos.y - g.startPos.y + 5), new SAT.Vector(g.endPos.x - g.startPos.x, g.endPos.y - g.startPos.y - 5), new SAT.Vector(0, (-5))]), g }
        return __extends(b, a), b.prototype.destroy = function() { this.wire.destroy(), this.wire = null, this.hitPolygon = null, this.startPos = null, this.endPos = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Vector = SAT.Vector,
    ZiplinePole = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "ziplinePole"), e.sprite.autoCull = !0, e.sprite.anchor.set(3 / 9.8, 29.2 / 64.25), e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b) }, b.prototype.attach = function(a) { return this.attachedZiplinePole = a, a.attachedZiplinePole = this, this.zipline = new Zipline(this.main, this.game, this.layer, new Point(this.xPos, this.yPos - 25), new Point(a.xPos, a.yPos - 25)), a.zipline = this.zipline, this.zipline }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.game = null, this.layer = null, this.attachedZiplinePole = null, this.zipline = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Checkpoint = function(a) {
        function b(b, c, d, e) { var f = a.call(this, b) || this; return f.game = c, f.layer = d, f.container = c.add.group(f.layer), f.floating = e, e ? (f.sprite = f.container.create(0, 0, "checkpointSwimming"), f.sprite.anchor.set(.5, .5)) : (f.sprite = f.container.create(0, 0, "checkpoint"), f.sprite.anchor.set(8 / 21.15, 17 / 55)), f.sprite.autoCull = !0, f }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.startY = b, this.container.position.set(a, b), this.boxPolygon = new SAT.Box(new SAT.Vector(a - 60, b - 40), 120, 80).toPolygon(), this.state = 0, this.floatRad = 0 }, b.prototype.trigger = function() {
            this.sprite.frame = 1, this.state = 1;
            for (var a = 0; a < 10; a++) this.main.createColorParticle(this.xPos, this.yPos, -5 + 10 * Math.random(), -6 - 4 * Math.random(), 65280);
            this.main.checkpointText.spawn(this.xPos, this.yPos - 30), this.main.dark && this.main.goLight(), this.main.sounds.playSound("ding"), this.main.checkpointTriggered(this)
        }, b.prototype.gray = function() { this.sprite.frame = 2, this.state = 2 }, b.prototype.resetLevel = function() { this.sprite.frame = 0, this.state = 0 }, b.prototype.update = function() { this.floating && (this.floatRad += .1, this.floatRad %= 8 * Math.PI, this.sprite.position.y = 25 + 10 * Math.sin(this.floatRad / 4), this.sprite.rotation = Math.cos(this.floatRad / 4) * Math.PI / 8) }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.boxPolygon = null, this.container.destroy(), this.container = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    CheckPointText = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.alive = !1, e.sprite = d.create(0, 0, "checkpointText"), e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.alive = !0, this.displayTime = 60, this.moveDist = 0 }, b.prototype.update = function() { this.alive && this.displayTime > 0 && (this.moveDist > -30 && (this.moveDist -= 2), this.sprite.position.y = this.yPos + this.moveDist, this.displayTime--, this.displayTime <= 0 && (this.sprite.visible = !1, this.alive = !1)) }, b
    }(Entity),
    Pole = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "pole"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.redSection = d.create(0, 0, "poleRedSection"), e.redSection.anchor.set(0, .5), e.redSection.autoCull = !0, e.redSection.visible = !1, e.sprite.anchor.set(.5, .5), e.hitBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 10, 10).toPolygon(), e.hitBoxPolygon.setOffset(new SAT.Vector((-5), (-5))), e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.redSection.position.set(a, b), this.redSection.alpha = 0, this.redSection.visible = !0, this.hitBoxPolygon.pos.x = a, this.hitBoxPolygon.pos.y = b }, b.prototype.update = function() { this.main.player.currentPole != this && (this.redSection.alpha -= .5 * this.redSection.alpha) }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.redSection.destroy(), this.redSection = null, this.hitBoxPolygon = null, this.game = null, this.layer = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Star = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "star"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e.hitBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 40, 40).toPolygon(), e.hitBoxPolygon.setOffset(new SAT.Vector((-20), (-20))), e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.main.currentLevel.gotStar || (this.xPos = a, this.yPos = b, this.sprite.visible = !0, this.sprite.position.set(a, b), this.hitBoxPolygon.pos.x = a, this.hitBoxPolygon.pos.y = b, this.alive = !0) }, b.prototype.getStar = function() { this.main.currentLevel.gotStar = !0, this.main.achievements.gotAchievement("star" + this.main.currentLevelID), this.main.levels.checkAstronomer() && this.main.achievements.gotAchievement("astronomer"), this.main.sounds.playSound("starPickup"), this.main.currentLevel.saveLevel(), this.die() }, b.prototype.die = function() { this.alive = !1, this.sprite.visible = !1 }, b.prototype.reset = function() {}, b.prototype.resetLevel = function() {}, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.hitBoxPolygon = null, this.game, this.layer, a.prototype.destroy.call(this) }, b
    }(Entity),
    WindBlaster = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b) || this;
            e.game = c, e.layer = d, e.container = c.add.group(d), e.windGraphics = [];
            var f = c.make.graphics(0, 0);
            f.lineStyle(1, 2236962), f.moveTo(0, 0), f.lineTo(27, 0);
            var g = f.generateTexture();
            f.destroy();
            for (var h = 0; h < 6; h++) {
                var i = e.game.add.sprite(0, 0, g, null, e.container);
                i.visible = !1, e.windGraphics.push(i)
            }
            return e.sprite = e.container.create(0, 0, "windBlaster"), e.sprite.autoCull = !0, e.sprite.anchor.set(0, .5), e.fanSprite = c.add.sprite(0, 0, "windFan"), e.fanSprite.anchor.set(0, .5), e.fanSprite.animations.add("fan"), e.fanSprite.play("fan", null, !0), e.sprite.addChild(e.fanSprite), e.fanMask = new SAT.Box(new SAT.Vector(0, 0), 180, 50).toPolygon(), e.fanMask.setOffset(new SAT.Vector(0, (-25))), e.alive = !1, e
        }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) {
            this.xPos = a, this.yPos = b, this.container.position.set(a, b), this.container.angle = c, this.rotation = c, this.fanMask.pos.x = a, this.fanMask.pos.y = b, this.fanMask.setAngle(c * Math.PI / 180), this.alive = !0, this.inc = 0;
            for (var d = 0, e = this.windGraphics; d < e.length; d++) {
                var f = e[d];
                f.position.set(130 * Math.random(), 46 * Math.random() - 23), f.visible = !0
            }
        }, b.prototype.update = function() {
            var a = this.main.player;
            if (a && a.alive)
                if (SAT.testPolygonPolygon(this.fanMask, this.main.player.totalPolygon)) {
                    var b = this.rotation * Math.PI / 180,
                        c = .15 * Math.sin(b);
                    c < -.12 && (this.inc = Math.max(2, this.inc)), this.main.player.yVelocity += .25 * Math.sin(b) * this.inc, this.main.player.xVelocity += .25 * Math.cos(b) * this.inc, c < -.12 && this.main.player.yPos > this.yPos - 5 && (this.main.player.yPos = this.yPos - 5, this.main.player.yVelocity = -4, this.main.player.updateHitBoxesPos(), this.main.player.falling = !0), this.inc < 2.5 ? this.inc += .25 : this.inc = 2.5
                }
            else this.inc -= .25, this.inc < 0 && (this.inc = 0);
            for (var d = 0, e = this.windGraphics; d < e.length; d++) {
                var f = e[d];
                f.position.x += 6, f.alpha -= .05, f.position.x > 130 && (f.position.x = 0, f.position.y = 46 * Math.random() - 23, f.alpha = 1)
            }
        }, b.prototype.die = function() { this.alive = !1, this.container.visible = !1 }, b.prototype.destroy = function() {
            this.container.destroy(), this.container = null, this.fanSprite.destroy(), this.fanSprite = null;
            for (var b = 0, c = this.windGraphics; b < c.length; b++) {
                var d = c[b];
                d.destroy(!0, !0)
            }
            a.prototype.destroy.call(this)
        }, b
    }(Entity),
    FinishPortal = function(a) {
        function b(c, d, e) { var f = a.call(this, c) || this; return f.particleSpawnRate = 3, f.game = d, f.layer = e, f.sprite = e.create(0, 0, "finishPortal"), f.sprite.autoCull = !0, f.sprite.animations.add("animate"), f.sprite.animations.play("animate", 30, !0), f.sprite.anchor.set(.5, .5), f.main.options.blend && (b.BlurFilterX || (b.BlurFilterX = d.add.filter("BlurX"), b.BlurFilterX.blur = 20), b.BlurFilterY || (b.BlurFilterY = d.add.filter("BlurY"), b.BlurFilterY.blur = 20), f.sprite.filters = [b.BlurFilterX, b.BlurFilterY]), f.hitBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 60, 60).toPolygon(), f.hitBoxPolygon.setOffset(new SAT.Vector((-30), (-30))), f }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.hitBoxPolygon.pos.x = a, this.hitBoxPolygon.pos.y = b, this.particleTimer = 0 }, b.prototype.update = function() {
            this.particleTimer++, this.particleTimer > this.particleSpawnRate && (this.main.createColorParticle(this.xPos - 80 + 160 * Math.random(), this.yPos - 80 + 160 * Math.random(), 0, 0, 4649252, 4, !1), this.particleTimer = 0);
            for (var a = 0, b = this.main.particles; a < b.length; a++) {
                var c = b[a];
                if (!c.alive) return;
                var d = Math.pow(c.xPos - this.xPos, 2) + Math.pow(c.yPos - this.yPos, 2);
                d < 62500 && (d < 2500 && (c.fadeTime = 150, c.multAlpha(.5)), c.yPos < this.yPos ? c.yVelocity += .75 : c.yPos > this.yPos && (c.yVelocity -= .75), c.xPos < this.xPos ? c.xVelocity += .75 : c.xPos > this.xPos && (c.xVelocity -= .75))
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.hitBoxPolygon = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    HazardStrips = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "hazardStrips"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.alive = !0 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Key = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.init(), e.hitBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 20, 40).toPolygon(), e.hitBoxPolygon.setOffset(new SAT.Vector((-10), (-20))), e.alive = !1, e.lineColor = 16763904, e }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "key"), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5), this.lineGraphic = this.game.add.graphics(0, 0, this.layer) }, b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.xVelocity = 0, this.yVelocity = 0, this.sprite.position.set(a, b), this.hitBoxPolygon.pos.x = a, this.hitBoxPolygon.pos.y = b, this.alive = !0, this.used = !1, this.keyNum = 0, this.saveUse = !1, this.following = !1, this.rad = 0 }, b.prototype.useKey = function() { this.used = !0, this.lineGraphic.clear(), this.sprite.visible = !1, this.alive = !1 }, b.prototype.followPlayer = function() {
            var a = 10 * (this.keyNum - 1);
            this.rad = this.player.xVelocity * -4 * Math.PI / 180, this.yVelocity < 0 && (this.yVelocity += .5), this.yPos += this.yVelocity;
            var b, c;
            this.player.swimming ? (b = this.player.xPos, c = this.player.yPos - a) : "right" === this.player.facing ? (b = this.player.xPos - 30, c = this.player.yPos - 6 - a) : (b = this.player.xPos + 30, c = this.player.yPos - 6 - a);
            var d = b - this.xPos,
                e = c - this.yPos;
            this.xPos += d / 5, this.yPos += e / 5, Math.abs(d) < 1 && (this.xPos = b), Math.abs(e) < 1 && (this.yPos = c), this.hitBoxPolygon.pos.x = this.xPos, this.hitBoxPolygon.pos.y = this.yPos
        }, b.prototype.runCollisions = function() { for (var a = 0, b = this.main.blocks; a < b.length; a++) { var c = b[a]; if (c.alive) { if (SAT.testPolygonPolygon(c.topBoundPolygon, this.hitBoxPolygon)) { this.player.xVelocity < 5 ? this.yVelocity = this.player.xVelocity * this.player.xVelocity * -.2 : this.yVelocity = -5, this.yPos = c.topEdge - 20, this.hitBoxPolygon.pos.y = this.yPos; continue } if (SAT.testPolygonPolygon(c.rightBoundPolygon, this.hitBoxPolygon)) { this.xPos = c.rightEdge + 11; continue } if (SAT.testPolygonPolygon(c.leftBoundPolygon, this.hitBoxPolygon)) { this.xPos = c.leftEdge - 11; continue } SAT.testPolygonPolygon(c.bottomBoundPolygon, this.hitBoxPolygon) && (this.yVelocity *= -1, this.yPos = c.bottomEdge + 21) } } }, b.prototype.drawLineToPlayer = function() { this.lineGraphic.clear(), this.lineGraphic.lineStyle(2, this.lineColor), this.lineGraphic.moveTo(this.xPos, this.yPos), this.player.currentPole ? this.lineGraphic.lineTo(this.player.xPos, this.player.yPos - 31) : this.player.crouching ? this.lineGraphic.lineTo(this.player.xPos, this.player.yPos - 6) : this.lineGraphic.lineTo(this.player.xPos, this.player.yPos - 16) }, b.prototype.follow = function() { this.following = !0 }, b.prototype.update = function() { if (this.alive) return this.player = this.main.player, this.used ? void(this.sprite.scale.x > .1 ? (this.sprite.scale.x -= .1, this.sprite.scale.y = this.sprite.scale.x, this.rad -= 5 * Math.PI / 180, this.sprite.rotation = this.rad) : (this.alive = !1, this.sprite.visible = !1)) : void(this.following && (this.followPlayer(), this.runCollisions(), this.drawLineToPlayer(), this.updatePositions())) }, b.prototype.die = function() { this.alive = !1, this.sprite.visible = !1 }, b.prototype.reset = function() { this.used || (this.xPos = this.startX, this.yPos = this.startY, this.updatePositions(), this.following && (this.following = !1, this.lineGraphic.clear())) }, b.prototype.resetLevel = function() { this.xPos = this.startX, this.yPos = this.startY, this.updatePositions(), this.sprite.scale.set(1, 1), this.used = !1, this.alive = !0, this.sprite.visible = !0, this.following = !1 }, b.prototype.updatePositions = function() { this.sprite.position.set(this.xPos, this.yPos), this.hitBoxPolygon.pos.x = this.xPos, this.hitBoxPolygon.pos.y = this.yPos }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.hitBoxPolygon = null, this.lineGraphic.destroy(), this.lineGraphic = null, this.game = null, this.layer = null, this.player = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    TimedKey = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.lineColor = 16711680, e }
        return __extends(b, a), b.prototype.spawn = function(b, c) { a.prototype.spawn.call(this, b, c), this.timer = 0 }, b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "timedKey"), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5), this.lineGraphic = this.game.add.graphics(0, 0, this.layer) }, b.prototype.follow = function() { this.following = !0, this.timer = 0 }, b.prototype.update = function() {
            this.following && !this.used && (this.timer >= b.TIMER_MAX ? (this.main.player.loseKey(this),
                this.reset()) : this.timer++), a.prototype.update.call(this)
        }, b.TIMER_MAX = 180, b
    }(Key),
    CircularCannon = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.container = c.add.group(d), e.baseSprite = e.container.create(0, 0, "cannonBase"), e.baseSprite.autoCull = !0, e.baseSprite.anchor.set(.5, .5), e.tubeSprite = e.container.create(0, 0, "cannonTube"), e.tubeSprite.autoCull = !0, e.tubeSprite.anchor.set(3 / 37, .5), e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.container.position.set(a, b), this.alive = !0, this.rad = 0, this.cannonSpeed = 4 * Math.PI / 180, this.firing = !1, this.power = 15 }, b.prototype.fire = function() {
            var a = this.main.player;
            a.currentCannon = null;
            var b = Math.cos(this.rad) * this.power,
                c = Math.sin(this.rad) * this.power;
            a.swimming ? a.xVelocity = b : a.forcedXVelocity = b, a.yVelocity = c, a.xPos = this.xPos + 80 * Math.cos(this.rad), a.yPos = this.yPos + 80 * Math.sin(this.rad), a.rotationDest = 0, this.main.sounds.playSound("cannonFire");
            for (var d = 0; d < 10; d++) this.main.createColorParticle(a.xPos, a.yPos, b * (Math.random() + .25), c * (Math.random() + .25), 16759552, 4);
            a.swimming || (a.falling = !0, a.setJump()), a.container.parent.removeChild(a.container), this.main.playerUnderLayer.addChild(a.container), a.updateHitBoxesPos(), this.firing = !1
        }, b.prototype.update = function() {
            var a = this.main.player;
            this.firing ? (this.tubeSprite.scale.x -= .15 * (this.tubeSprite.scale.x - .75), this.tubeSprite.scale.y -= .15 * (this.tubeSprite.scale.y - 1.35), this.tubeSprite.scale.x < .9 && this.fire()) : (this.tubeSprite.scale.x -= .3 * (this.tubeSprite.scale.x - 1), this.tubeSprite.scale.y -= .3 * (this.tubeSprite.scale.y - 1), a.currentCannon !== this ? this.rad = Math.atan2(a.yPos - this.yPos, a.xPos - this.xPos) : (this.rad += this.cannonSpeed, this.rad %= 360), this.tubeSprite.rotation = this.rad)
        }, b.prototype.die = function() { this.alive = !1, this.container.visible = !1 }, b.prototype.destroy = function() { this.baseSprite.destroy(), this.baseSprite = null, this.tubeSprite.destroy(), this.tubeSprite = null, this.container.destroy(), this.container = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    BreatheBlaster = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "breatheBlaster"), e.sprite.anchor.set(1, .5), e.sprite.autoCull = !0, e.sprite.visible = !1, e.sprite.scale.set(1, .5), e.alive = !1, e.hitPoly = new SAT.Box(new SAT.Vector(0, 0), 100, 50).toPolygon(), e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.angle = c, this.sprite.visible = !0, this.alive = !0, this.rad = c * Math.PI / 180, this.hitPoly.pos.x = a, this.hitPoly.pos.y = b, this.hitPoly.setAngle(c * Math.PI / 180) }, b.prototype.update = function() {
            if (Math.random() < .25) {
                var a = 4 * Math.random(),
                    b = this.rad - 2 + 4 * Math.random();
                this.main.createColorParticle(this.xPos, this.yPos, Math.cos(b) * a, Math.sin(b) * a, 3394815, 4, !0, !0, 100)
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this), this.game = null, this.layer = null }, b
    }(Entity),
    LightSwitch = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "lightSwitch"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.hitBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 20, 20).toPolygon(), e.hitBoxPolygon.setOffset(new SAT.Vector((-10), (-10))), e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.hitBoxPolygon.pos.x = a, this.hitBoxPolygon.pos.y = b }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    Wire = function(a) {
        function b(b, c, d) { var e = a.call(this, b) || this; return e.game = c, e.layer = d, e.sprite = d.create(0, 0, "wire"), e.sprite.autoCull = !0, e.sprite.visible = !1, e.sprite.anchor.set(1, .5), e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { this.xPos = a, this.yPos = b, this.rad = (c + 90) * Math.PI / 180, this.sprite.position.set(a + 25 * Math.cos(this.rad), b + 25 * Math.sin(this.rad)), this.sprite.rotation = this.rad, this.sprite.visible = !0, this.alive = !0 }, b.prototype.resetLevel = function() { this.sprite.scale.x = 1 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.game = null, this.layer = null, a.prototype.destroy.call(this) }, b
    }(Entity),
    WireTrail = function() {
        function a(a, b) { this.sparkSpeed = .15, this.main = a, this.wires = b, this.spark = new Spark(a, a.game, a.obstacleLayer, null), this.currentInd = b.length, this.spark.spawn(0, 0), this.nextWire(), this.main.obstacles.push(this.spark), this.burning = !1 }
        return a.prototype.nextWire = function() { return 0 === this.currentInd ? (this.main.explosiveBlock.exploding = !0, void(this.burning = !1)) : (this.currentInd--, this.currentWire = this.wires[this.currentInd], this.spark.xPos = this.currentWire.xPos - 25 * Math.cos(this.currentWire.rad), this.spark.yPos = this.currentWire.yPos - 25 * Math.sin(this.currentWire.rad), this.sparkXSpeed = Math.cos(this.currentWire.rad) * this.sparkSpeed, void(this.sparkYSpeed = Math.sin(this.currentWire.rad) * this.sparkSpeed)) }, a.prototype.update = function() { this.burning && (this.spark.xPos += this.sparkXSpeed, this.spark.yPos += this.sparkYSpeed, this.currentWire.sprite.scale.x -= this.sparkSpeed / 50, this.currentWire.sprite.scale.x <= 0 && (this.currentWire.sprite.scale.x = 0, this.nextWire())) }, a.prototype.startFollow = function() { this.followInd = 0, this.followWire = this.wires[this.followInd], this.followDist = 0, this.followX = this.followWire.xPos + 25 * Math.cos(this.followWire.rad) - this.main.game.width / 2, this.followY = this.followWire.yPos + 25 * Math.sin(this.followWire.rad) - this.main.game.height / 2, this.followXSpeed = Math.cos(this.followWire.rad) * -8, this.followYSpeed = Math.sin(this.followWire.rad) * -8 }, a.prototype.followTick = function() {
            if (this.followX += this.followXSpeed, this.followY += this.followYSpeed, this.followDist += 8, this.followDist >= 50) {
                if (this.followInd++, this.followInd >= this.wires.length - 4) return !0;
                this.followWire = this.wires[this.followInd], this.followDist = 0, this.followX = this.followWire.xPos + 25 * Math.cos(this.followWire.rad) - this.main.game.width / 2, this.followY = this.followWire.yPos + 25 * Math.sin(this.followWire.rad) - this.main.game.height / 2, this.followXSpeed = Math.cos(this.followWire.rad) * -8, this.followYSpeed = Math.sin(this.followWire.rad) * -8
            }
            return this.main.game.camera.x = this.followX, this.main.game.camera.y = this.followY, !1
        }, a.prototype.destroy = function() { this.burning = !1, this.main = null, this.wires = null, this.spark = null }, a.prototype.resetLevel = function() {
            for (var a = 0, b = this.wires; a < b.length; a++) {
                var c = b[a];
                c.sprite.scale.set(1, 1)
            }
            this.currentInd = this.wires.length, this.nextWire()
        }, a
    }(),
    Buzzsaw = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "buzzsaw"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e.deathCircle = new SAT.Circle(new SAT.Vector(0, 0), 44), e.obstacleType = "buzzsaw", e.killValue = 2, e }
        return __extends(b, a), b.prototype.levelStart = function() {
            for (var a = 0, b = this.main.pools; a < b.length; a++) {
                var c = b[a];
                SAT.testCirclePolygon(this.deathCircle, c.totalPolygon) && this.main.underPoolLayer.addChild(this.sprite)
            }
        }, b.prototype.spawn = function(a, b, c) { void 0 === c && (c = 1), this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.deathCircle.pos.x = a, this.deathCircle.pos.y = b, this.alive = !0, 1 != c && (this.sprite.scale.set(c, c), this.deathCircle.r = 44 * c) }, b.prototype.update = function() { this.sprite.rotation += 4 * Math.PI / 180 }, b.prototype.updatePosition = function() { this.sprite.position.set(this.xPos, this.yPos), this.deathCircle.pos.x = this.xPos, this.deathCircle.pos.y = this.yPos }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathCircle = null, a.prototype.destroy.call(this) }, b
    }(Obstacle),
    BuzzsawVerticalUp = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.maxMoveDist = 100, e.obstacleType = "buzzsaw", e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { void 0 === c && (c = -2), this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.yVelocity = c, this.startY = b, this.deathCircle.pos.x = a, this.deathCircle.pos.y = b, this.alive = !0 }, b.prototype.update = function() {
            a.prototype.update.call(this);
            var b = this.yPos;
            this.yVelocity < 0 ? this.yPos < this.startY - this.maxMoveDist && (this.yVelocity = -this.yVelocity) : this.yPos > this.startY + this.maxMoveDist && (this.yVelocity = -this.yVelocity), this.yPos += this.yVelocity, this.yPos != b && this.updatePosition()
        }, b.prototype.updatePosition = function() { this.sprite.position.set(this.xPos, this.yPos), this.deathCircle.pos.y = this.yPos }, b.prototype.reset = function() { this.yVelocity = -2, this.updatePosition() }, b.prototype.resetLevel = function() { this.reset() }, b
    }(Buzzsaw),
    BuzzsawHorizontal = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.maxMoveDist = 100, e.obstacleType = "buzzsaw", e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) { void 0 === d && (d = 1), this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.xVelocity = -c, this.startSpeed = c, this.startX = a, this.startY = b, this.deathCircle.pos.x = a, this.deathCircle.pos.y = b, this.alive = !0, 1 != d && (this.sprite.scale.set(d, d), this.deathCircle.r = 45 * d) }, b.prototype.update = function() {
            a.prototype.update.call(this);
            var b = this.xPos;
            this.xVelocity > 0 ? this.xPos > this.startX + this.maxMoveDist && (this.xVelocity = -this.xVelocity) : this.xPos < this.startX - this.maxMoveDist && (this.xVelocity = -this.xVelocity), this.xPos += this.xVelocity, this.xPos != b && (this.sprite.position.x = this.xPos, this.deathCircle.pos.x = this.xPos)
        }, b.prototype.reset = function() { this.xVelocity = -this.startSpeed, this.xPos = this.startX, this.yPos = this.startY, this.updatePosition() }, b.prototype.resetLevel = function() { this.reset() }, b
    }(Buzzsaw),
    BouncingBuzzsaw = function(a) {
        function b(b, c, d) { return a.call(this, b, c, d) || this }
        return __extends(b, a), b.prototype.spawn = function(b, c, d) { void 0 === d && (d = 1), a.prototype.spawn.call(this, b, c, d), this.yVelocity = 0 }, b.prototype.update = function() { this.alive && (this.yVelocity += this.main.gravity * this.main.gameSpeed, this.yPos += this.yVelocity, this.updatePosition(), this.checkBlockCollisions()), a.prototype.update.call(this) }, b.prototype.checkBlockCollisions = function() {
            for (var a = 0, b = this.main.blocks; a < b.length; a++) {
                var c = b[a];
                c.alive && SAT.testPolygonCircle(c.topBoundPolygon, this.deathCircle) && (this.yVelocity *= -1, this.yPos += this.yVelocity)
            }
        }, b.prototype.reset = function() { this.yPos = this.startY, this.yVelocity = 0, this.updatePosition() }, b.prototype.resetLevel = function() { this.reset(), a.prototype.resetLevel.call(this) }, b
    }(Buzzsaw),
    EnlargingBuzzsaw = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.obstacleType = "buzzsaw", e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { void 0 === c && (c = 1), this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.visible = !0, this.enlarging = !0, this.deathCircle.pos.x = a, this.deathCircle.pos.y = b, this.scaleXStart = c, this.scaleYStart = c, this.scale = c, this.alive = !0 }, b.prototype.update = function() { this.enlarging ? (this.scale += .02 * this.scaleXStart * this.main.gameSpeed, this.scale > 2.5 * this.scaleXStart && (this.scale = 2.5 * this.scaleXStart, this.enlarging = !1)) : (this.scale -= .02 * this.scaleXStart * this.main.gameSpeed, this.scale < .5 * this.scaleXStart && (this.scale = .5 * this.scaleXStart, this.enlarging = !0)), a.prototype.update.call(this), this.updatePosition() }, b.prototype.updatePosition = function() { this.sprite.scale.set(this.scale, this.scale), this.sprite.position.set(this.xPos, this.yPos), this.deathCircle.pos.y = this.yPos, this.deathCircle.r = 42 * this.scale }, b.prototype.resetLevel = function() {}, b
    }(Buzzsaw),
    BuzzsawOnStick = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "buzzsawOnStick"), e.sprite.autoCull = !0, e.sprite.anchor.set(.1, .5), e.sprite.visible = !1, e.obstacleType = "misc", e.buzzsaw = new Buzzsaw(e.main, e.game, e.layer), e.main.obstacles.push(e.buzzsaw), e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) {
            this.xPos = a, this.yPos = b, this.rotation = c, this.startRotation = c, this.sprite.position.set(a, b), this.sprite.rotation = c, this.sprite.visible = !0, this.alive = !0;
            var d = this.rotation * Math.PI / 180;
            this.buzzsaw.spawn(this.xPos + 130 * Math.cos(d), this.yPos + 130 * Math.sin(d), .5)
        }, b.prototype.update = function() { this.rotation += 8, this.updatePosition() }, b.prototype.updatePosition = function() {
            var a = this.rotation * Math.PI / 180;
            this.sprite.rotation = a, this.buzzsaw.xPos = this.xPos + 130 * Math.cos(a), this.buzzsaw.yPos = this.yPos + 130 * Math.sin(a), this.buzzsaw.updatePosition()
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.buzzsaw = null }, b.prototype.resetLevel = function() { this.rotation = this.startRotation, this.updatePosition() }, b
    }(Obstacle),
    Spike10x = function(a) {
        function b(b, c, d) { return a.call(this, b, c, d) || this }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "spike10x"), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5), this.sprite.visible = !1, this.graphics = this.game.add.graphics(0, 0, this.layer), this.graphics.visible = !1, this.width = 97.2, this.height = 17.6 }, b
    }(Spike),
    Spike30x = function(a) {
        function b(b, c, d) { return a.call(this, b, c, d) || this }
        return __extends(b, a), b.prototype.init = function() { this.sprite = this.layer.create(0, 0, "spike30x"), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5), this.sprite.visible = !1, this.graphics = this.game.add.graphics(0, 0, this.layer), this.graphics.visible = !1, this.width = 291.2, this.height = 14.75, this.spikeNum = 30 }, b
    }(Spike),
    FallingSpike = function(a) {
        function b(b, c, d, e) {
            void 0 === e && (e = !1);
            var f = a.call(this, b, c, d) || this;
            f.game = c, f.layer = d, f.obstacleType = "spike", f.sprite = f.layer.create(0, 0, "fallingSpike"), f.sprite.autoCull = !0, f.sprite.anchor.set(.5, .5), f.sprite.visible = !1, f.alive = !1, f.dispenser = e, f.graphics = f.game.add.graphics(0, 0, f.layer), f.graphics.visible = !0, f.width = 7.5, f.height = 14.75, f.deathBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), f.width, f.height).toPolygon();
            var g = .5 * f.width,
                h = .5 * f.height;
            return f.deathBoxPolygon.setOffset(new SAT.Vector((-g), (-h))), f
        }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.rotation = c, this.rad = c * Math.PI / 180, this.xVelocity = 0, this.yVelocity = 0, this.sprite.position.set(a, b), this.sprite.angle = c, this.dispenser || (this.sprite.visible = !0), this.alive = !0, this.deathBoxPolygon.pos.x = a, this.deathBoxPolygon.pos.y = b, this.falling = !1, this.fallDist = 0, this.speed = 0 }, b.prototype.levelStart = function() {
            this.range = 350;
            for (var a = this.rotation * Math.PI / 180, b = 0, c = 10; c <= this.range;) {
                for (var d = new SAT.Polygon(new SAT.Vector(this.xPos, this.yPos), [new SAT.Vector(0, 0), new SAT.Vector(Math.cos(a) * c, Math.sin(a) * c)]), e = 0, f = this.main.blocks; e < f.length; e++) {
                    var g = f[e],
                        h = new SAT.Response;
                    SAT.testPolygonPolygon(d, g.totalBoundPolygon, h) && Math.abs(h.overlap) > b && (b = Math.abs(h.overlap))
                }
                if (b > 0) { c -= b; break }
                if (c === this.range) break;
                c += 20, c > this.range && (c = this.range)
            }
            this.hitDist = c, this.searchHitBox = new SAT.Box(new SAT.Vector(this.xPos, this.yPos), this.hitDist, 16).toPolygon(), this.searchHitBox.offset = new SAT.Vector(0, (-8)), this.searchHitBox.setAngle(a)
        }, b.prototype.update = function() {
            if (this.alive)
                if (this.falling) this.xVelocity += Math.cos(this.rad) * this.main.gravity, this.yVelocity += Math.sin(this.rad) * this.main.gravity, this.speed += this.main.gravity, this.xPos += this.xVelocity, this.yPos += this.yVelocity, this.fallDist += this.speed, this.updatePositions(), this.fallDist > this.hitDist && this.reset();
                else {
                    if (this.xPos != this.startX || this.yPos != this.startY) {
                        var a = this.startX - this.xPos,
                            b = this.startY - this.yPos;
                        Math.abs(a) < 1 ? this.xPos = this.startX : this.xPos += a / 5, Math.abs(b) < 1 ? this.yPos = this.startY : this.yPos += (this.startY - this.yPos) / 5, this.updatePositions()
                    }
                    var c = this.main.player;
                    SAT.testPolygonPolygon(this.searchHitBox, c.totalPolygon) && (this.falling = !0)
                }
        }, b.prototype.updatePositions = function() { this.sprite.position.set(this.xPos, this.yPos), this.deathBoxPolygon.pos.x = this.xPos, this.deathBoxPolygon.pos.y = this.yPos }, b.prototype.reset = function() { this.dispenser ? this.die() : (this.falling = !1, this.xPos = this.startX - 15 * Math.cos(this.rad), this.yPos = this.startY - 15 * Math.sin(this.rad), this.xVelocity = 0, this.yVelocity = 0, this.sprite.position.set(this.xPos, this.yPos), this.deathBoxPolygon.pos.x = this.xPos, this.deathBoxPolygon.pos.y = this.yPos, this.fallDist = 0, this.speed = 0) }, b.prototype.dispenserFire = function() { this.falling = !0, this.alive = !0, this.xPos = this.startX + 15 * Math.cos(this.rad), this.yPos = this.startY + 15 * Math.sin(this.rad), this.xVelocity = 0, this.yVelocity = 0, this.sprite.position.set(this.xPos, this.yPos), this.sprite.visible = !0, this.deathBoxPolygon.pos.x = this.xPos, this.deathBoxPolygon.pos.y = this.yPos, this.fallDist = 0, this.speed = 0 }, b.prototype.die = function() { this.sprite.visible = !1, this.alive = !1 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.searchHitBox = null, this.deathBoxPolygon = null, this.graphics.destroy(), this.graphics = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.reset() }, b
    }(Obstacle),
    ShurikanHorizontal = function(a) {
        function b(b, c, d, e) { var f = a.call(this, b, c, d) || this; return f.spawner = e, f.sprite = d.create(0, 0, "shurikanHorizontal"), f.sprite.autoCull = !0, f.sprite.anchor.set(.5, .5), f.sprite.visible = !1, f.obstacleType = "shurikan", f.alive = !1, f.hitBoxPoly = new SAT.Box(new Vector(0, 0), 20, 20).toPolygon(), f.hitBoxPoly.setOffset(new SAT.Vector((-10), (-10))), f }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) { void 0 === e && (e = 0), this.xPos = a, this.yPos = b, this.xVelocity = c, this.yVelocity = d, this.speed = Math.sqrt(c * c + d * d), this.dist = 0, this.sprite.position.set(a, b), this.sprite.scale.set(1, 1), this.sprite.frame = e, this.sprite.visible = !0, this.alive = !0, this.rotation = 0 }, b.prototype.update = function() { this.alive && (this.rotation += 15 * this.main.gameSpeed, this.dist > 200 ? (this.sprite.scale.x -= .1 * this.main.gameSpeed, this.sprite.scale.y = this.sprite.scale.x, this.sprite.scale.x <= .1 && (this.alive = !1, this.sprite.visible = !1, this.spawner.shurikanPool.push(this), this.spawner.spawned--)) : (this.xPos += this.xVelocity, this.yPos += this.yVelocity, this.dist += this.speed), this.sprite.position.set(this.xPos, this.yPos), this.hitBoxPoly.pos.x = this.xPos, this.hitBoxPoly.pos.y = this.yPos, this.sprite.rotation = this.rotation * Math.PI / 180) }, b.prototype.resetLevel = function() { this.alive = !1, this.sprite.visible = !1, this.spawner.shurikanPool.push(this) }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.spawner = null, this.hitBoxPoly = null, a.prototype.destroy.call(this) }, b
    }(Obstacle),
    ShurikanSpawner = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b, c, d) || this;
            e.sprite = d.create(0, 0, "shurikanSpawner"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.obstacleType = "spawner", e.alive = !1, e.shurikanPool = [];
            for (var f = 0; f < 3; f++) {
                var g = new ShurikanHorizontal(e.main, e.game, e.layer, e);
                e.shurikanPool.push(g), e.main.obstacles.push(g)
            }
            return e
        }
        return __extends(b, a), b.prototype.spawn = function(a, b, c) { this.xPos = a, this.yPos = b, this.rotation = c, this.sprite.position.set(a, b), this.sprite.rotation = c * Math.PI / 180, this.cooldown = 0, this.spawned = 0, this.alive = !0 }, b.prototype.update = function() {
            if (this.alive && this.spawned < 3 && (this.cooldown += this.main.gameSpeed, this.cooldown > b.fireTimer)) {
                this.cooldown = 0;
                var a = this.shurikanPool.pop();
                if (!a) return;
                var c = 1.3 * Math.cos(this.rotation * Math.PI / 180),
                    d = 1.3 * Math.sin(this.rotation * Math.PI / 180),
                    e = 0;
                90 == this.rotation || this.rotation == -90 ? e = 1 : 0 != this.rotation && this.rotation != -180 && 180 != this.rotation && (e = 2), a.spawn(this.xPos, this.yPos, c, d, e), this.spawned++, 3 === this.spawned && (this.cooldown = -60)
            }
        }, b.prototype.resetLevel = function() { this.spawned = 0, this.cooldown = 0 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.shurikanPool = null, a.prototype.destroy.call(this) }, b.fireTimer = 30, b
    }(Obstacle),
    Bullet = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.game = c, e.layer = d, e.obstacleType = "bullet", e.sprite = e.layer.create(0, 0, "bullet"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e.deathBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 8, 8).toPolygon(), e.deathBoxPolygon.setOffset(new SAT.Vector((-4), (-4))), e.graphics = e.game.add.graphics(0, 0, e.layer), e.graphics.visible = !0, e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) { this.xPos = a, this.yPos = b, this.xVelocity = c, this.yVelocity = d, this.rad = e, this.sprite.position.set(a, b), this.sprite.rotation = e, this.deathBoxPolygon.pos.x = a, this.deathBoxPolygon.pos.y = b, this.deathBoxPolygon.setAngle(e), this.alive = !0, this.sprite.visible = !0 }, b.prototype.update = function() {
            if (this.alive) {
                this.xPos += this.xVelocity * this.main.gameSpeed, this.yPos += this.yVelocity * this.main.gameSpeed, this.updatePositions();
                for (var a = 0, b = this.main.blocks; a < b.length; a++) {
                    var c = b[a];
                    if (SAT.testPolygonPolygon(c.totalBoundPolygon, this.deathBoxPolygon)) {
                        for (var d = 0; d < 10; d++) this.main.createColorParticle(this.xPos, this.yPos, 16 * Math.random() - 8, 16 * Math.random() - 8, 16711680);
                        this.die()
                    }
                }
                SAT.testPolygonPolygon(this.deathBoxPolygon, this.main.player.totalPolygon) && (this.main.player.kill(14), this.die())
            }
        }, b.prototype.updatePositions = function() { this.sprite.position.set(this.xPos, this.yPos), this.deathBoxPolygon.pos.x = this.xPos, this.deathBoxPolygon.pos.y = this.yPos }, b.prototype.die = function() { this.alive = !1, this.sprite.visible = !1 }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathBoxPolygon = null, this.graphics.destroy(), this.graphics = null }, b.prototype.resetLevel = function() { this.die() }, b
    }(Obstacle),
    ClassicLaser = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "classicLaser"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.bullet = new Bullet(b, c, b.obstacleLayer), e.main.obstacles.push(e.bullet), e.alive = !1, e }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.rad = Math.PI / 2, this.sprite.position.set(a, b), this.sprite.rotation = this.rad, this.spinDest = Math.PI / 2, this.shootTimer = 0 }, b.prototype.levelStart = function() { this.storeNearbyPlatforms() }, b.prototype.storeNearbyPlatforms = function() {
            this.platforms = [];
            for (var a = new SAT.Circle(new SAT.Vector(this.xPos, this.yPos), 250), b = 0, c = this.main.blocks; b < c.length; b++) {
                var d = c[b];
                SAT.testCirclePolygon(a, d.totalBoundPolygon) && this.platforms.push(d)
            }
        }, b.prototype.update = function() {
            var a = this.main.player;
            if (a && a.alive) {
                var c = !0;
                if (Math.pow(this.xPos - a.xPos, 2) + Math.pow(this.yPos - a.yPos, 2) <= b.RANGE_SQ) { for (var d = new SAT.Polygon(new Vector(0, 0), [new SAT.Vector(this.xPos, this.yPos), new SAT.Vector(a.xPos, a.yPos)]), e = new SAT.Polygon(new Vector(0, 0), [new SAT.Vector(this.xPos, this.yPos), new SAT.Vector(a.xPos, a.yPos - a.height)]), f = 0, g = this.platforms; f < g.length; f++) { var h = g[f]; if (SAT.testPolygonPolygon(d, h.totalBoundPolygon) && SAT.testPolygonPolygon(e, h.totalBoundPolygon)) { c = !1; break } } c && (this.spinDest = Math.atan2(a.yPos - this.yPos, a.xPos - this.xPos), this.shootTimer++, this.shootTimer >= b.FIRE_RATE && (this.shootTimer = 0, this.bullet.spawn(this.xPos, this.yPos, 25 * Math.cos(this.rad), 25 * Math.sin(this.rad), this.rad), this.main.sounds.playSound("laserFire"))) }
                else this.spinDest = Math.PI / 2;
                var i = this.rad - this.spinDest;
                Math.abs(i) < .5 * Math.PI / 180 ? this.rad = this.spinDest : i > 200 * Math.PI / 180 ? this.rad = this.spinDest : this.rad -= .25 * i, this.sprite.rotation = this.rad
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, a.prototype.destroy.call(this) }, b.prototype.reset = function() { this.shootTimer = 0 }, b.prototype.resetLevel = function() { this.reset(), this.rad = Math.PI / 2, this.spinDest = Math.PI / 2 }, b.FIRE_RATE = 40, b.RANGE_SQ = 62500, b
    }(Obstacle),
    Quadrant = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "quadrant"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e.obstacleType = "quadrant", e.deathHitBoxPolygons = [], e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d, e) {
            void 0 === e && (e = 1), this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.rad = c * Math.PI / 180, this.startRad = this.rad, this.rotSpeed = d, this.sprite.position.set(a, b), this.sprite.visible = !0, this.sprite.scale.set(e, e), this.alive = !0, this.attachHitBoxPolygon = new SAT.Box(new SAT.Vector(a, b), 10, 10).toPolygon(), this.attachHitBoxPolygon.setOffset(new SAT.Vector((-5), (-5)));
            var f;
            f = new SAT.Box(new SAT.Vector(0, 0), 10 * e, 10 * e).toPolygon(), f.setOffset(new SAT.Vector(75 * e, 0)), this.deathHitBoxPolygons.push(f), f = new SAT.Box(new SAT.Vector(0, 0), 10 * e, 10 * e).toPolygon(), f.setOffset(new SAT.Vector(0, 75 * e)), this.deathHitBoxPolygons.push(f), f = new SAT.Box(new SAT.Vector(0, 0), 10 * e, 10 * e).toPolygon(), f.setOffset(new SAT.Vector(-75 * e, 0)), this.deathHitBoxPolygons.push(f), f = new SAT.Box(new SAT.Vector(0, 0), 10 * e, 10 * e).toPolygon(), f.setOffset(new SAT.Vector(0, -75 * e)), this.deathHitBoxPolygons.push(f)
        }, b.prototype.update = function() { this.rad += this.rotSpeed, this.updatePosition() }, b.prototype.updatePosition = function() {
            this.sprite.position.set(this.xPos, this.yPos), this.sprite.rotation = this.rad;
            for (var a = 0, b = this.deathHitBoxPolygons; a < b.length; a++) {
                var c = b[a];
                c.pos.x = this.xPos, c.pos.y = this.yPos, c.setAngle(this.rad)
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathHitBoxPolygons = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.rad = this.startRad, this.updatePosition() }, b
    }(Obstacle),
    LaserPoint = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.laserGraphic = c.add.graphics(0, 0, d), e.obstacleType = "laser", e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) { this.xPos = a, this.yPos = b, this.xLength = c - a, this.yLength = d - b, this.alive = !0, this.deathHitBoxPolygon = new SAT.Polygon(new SAT.Vector(this.xPos, this.yPos), [new SAT.Vector(0, 0), new SAT.Vector(c - a, d - b)]), this.laserGraphic.position.set(this.xPos, this.yPos), this.laserGraphic.lineStyle(2, 16724787), this.laserGraphic.moveTo(0, 0), this.laserGraphic.lineTo(c - a, d - b) }, b.prototype.update = function() {
            if (Math.random() < .05) {
                var a = Math.random(),
                    b = this.xPos + this.xLength * a,
                    c = this.yPos + this.yLength * a;
                this.main.createColorParticle(b, c, 10 * Math.random() - 5, Math.random() * -5, 16711680, 4, !1, !1, 10, !0)
            }
        }, b.prototype.destroy = function() { this.game = null, this.layer = null, this.laserGraphic.destroy(), this.laserGraphic = null, a.prototype.destroy.call(this) }, b
    }(Obstacle),
    Reaper = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.sprite = d.create(0, 0, "reaper"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.visible = !1, e.obstacleType = "reaper", e.killValue = 2, e.deathHitBoxes = [], e }
        return __extends(b, a), b.prototype.spawn = function(a, b, c, d) {
            void 0 === d && (d = 1), this.xPos = a, this.yPos = b, this.startX = a, this.startY = b, this.rad = c * Math.PI / 180, this.startRad = this.rad, this.sprite.position.set(a, b), this.sprite.scale.set(d / 2, d / 2), this.sprite.visible = !0, this.alive = !0;
            var e = new SAT.Box(new SAT.Vector(a, b), 13.4 * d, 8.6 * d).toPolygon();
            e.setOffset(new SAT.Vector(-13.4 * d, -75 * d)), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 6.35 * d, 6.3 * d).toPolygon(), e.setOffset(new SAT.Vector(-42 * d, -65 * d)), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 2.9 * d, 2.9 * d).toPolygon(), e.setOffset(new SAT.Vector(-59 * d, -46 * d)), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 1.5 * d, 1.5 * d).toPolygon(), e.setOffset(new SAT.Vector(-66 * d, -26 * d)), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 13.4 * d, 8.6 * d).toPolygon(), e.setOffset(new SAT.Vector(-13.4 * d, -75 * d)), e.setAngle(Math.PI), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 6.35 * d, 6.3 * d).toPolygon(), e.setOffset(new SAT.Vector(-42 * d, -65 * d)), e.setAngle(Math.PI), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 2.9 * d, 2.9 * d).toPolygon(), e.setOffset(new SAT.Vector(-59 * d, -46 * d)), e.setAngle(Math.PI), this.deathHitBoxes.push(e), e = new SAT.Box(new SAT.Vector(a, b), 1.5 * d, 1.5 * d).toPolygon(), e.setOffset(new SAT.Vector(-66 * d, -26 * d)), e.setAngle(Math.PI), this.deathHitBoxes.push(e)
        }, b.prototype.update = function() { this.rad += -5 * Math.PI / 180, this.updatePositions() }, b.prototype.updatePositions = function() {
            this.sprite.position.set(this.xPos, this.yPos), this.sprite.rotation = this.rad;
            for (var a = 0; a < this.deathHitBoxes.length; a++) {
                var b = this.deathHitBoxes[a];
                a < 4 ? b.setAngle(this.rad) : b.setAngle(this.rad + Math.PI)
            }
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathHitBoxes = null, a.prototype.destroy.call(this) }, b.prototype.resetLevel = function() { this.rad = this.startRad }, b
    }(Obstacle),
    Spark = function(a) {
        function b(b, c, d, e) { var f = a.call(this, b, c, d) || this; return f.sparkBlock = e, f.obstacleType = "spark", f.sprite = f.layer.create(0, 0, "spark"), f.sprite.autoCull = !0, f.sprite.anchor.set(.5, .5), f.sprite.visible = !1, f.deathBoxPolygon = new SAT.Box(new SAT.Vector(0, 0), 16, 16).toPolygon(), f.deathBoxPolygon.setOffset(new SAT.Vector((-8), (-8))), f }
        return __extends(b, a), b.prototype.spawn = function(a, b) { this.sparkBlock && (a = this.sparkBlock.leftEdge, b = this.sparkBlock.topEdge, this.direction = "right"), this.xPos = a, this.yPos = b, this.alive = !0, this.sprite.visible = !0, this.updatePositions() }, b.prototype.update = function() {
            if (this.sparkBlock) switch (this.direction) {
                case "right":
                    this.xPos += 5 * this.main.gameSpeed, this.xPos > this.sparkBlock.rightEdge && (this.xPos = this.sparkBlock.rightEdge, this.direction = "down");
                    break;
                case "down":
                    this.yPos += 5 * this.main.gameSpeed, this.yPos > this.sparkBlock.bottomEdge && (this.yPos = this.sparkBlock.bottomEdge, this.direction = "left");
                    break;
                case "left":
                    this.xPos -= 5 * this.main.gameSpeed, this.xPos < this.sparkBlock.leftEdge && (this.xPos = this.sparkBlock.leftEdge, this.direction = "up");
                    break;
                case "up":
                    this.yPos -= 5 * this.main.gameSpeed, this.yPos < this.sparkBlock.topEdge && (this.yPos = this.sparkBlock.topEdge, this.direction = "right")
            }
            Math.random() < .2 && this.main.createColorParticle(this.xPos, this.yPos, 10 * Math.random() - 5, 5 * Math.random(), 16763904, 4, !1, !1, 10, !0), this.updatePositions();
            for (var a = 0, b = this.main.pools; a < b.length; a++) {
                var c = b[a];
                SAT.testPolygonPolygon(this.deathBoxPolygon, c.totalPolygon) && (c.electric = !0)
            }
        }, b.prototype.updatePositions = function() { this.sprite.position.set(this.xPos, this.yPos), this.deathBoxPolygon.pos.x = this.xPos, this.deathBoxPolygon.pos.y = this.yPos }, b.prototype.resetLevel = function() {
            if (this.sparkBlock) {
                var a = this.sparkBlock.leftEdge,
                    b = this.sparkBlock.topEdge;
                this.direction = "right", this.xPos = a, this.yPos = b
            }
            this.updatePositions()
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.deathBoxPolygon = null }, b
    }(Obstacle),
    ShurikanDispenser = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b, c, d) || this;
            e.sprite = d.create(0, 0, "shurikanDispenser"), e.sprite.autoCull = !0, e.sprite.anchor.set(.5, .5), e.sprite.animations.add("spawn"), e.sprite.visible = !1, e.obstacleType = "shurikan", e.alive = !1, e.hitBoxPoly = new SAT.Box(new Vector(0, 0), 20, 20).toPolygon(), e.hitBoxPoly.setOffset(new SAT.Vector((-10), (-10))), e.spikes = [];
            for (var f = 0; f < 4; f++) {
                var g = new FallingSpike(b, c, e.layer, (!0));
                e.spikes[f] = g, e.main.obstacles.push(g)
            }
            return e
        }
        return __extends(b, a), b.prototype.spawn = function(a, c) {
            this.xPos = a, this.yPos = c, this.sprite.position.set(a, c), this.sprite.scale.set(1, 1), this.sprite.visible = !0, this.alive = !0, this.charge = b.CHARGE_TIME;
            for (var d = 0; d < 4; d++) {
                var e = this.spikes[d];
                e.spawn(a, c, 90 * d)
            }
        }, b.prototype.levelStart = function() { this.storeNearbyPlatforms() }, b.prototype.storeNearbyPlatforms = function() {
            this.platforms = [];
            for (var a = new SAT.Circle(new SAT.Vector(this.xPos, this.yPos), 250), b = 0, c = this.main.blocks; b < c.length; b++) {
                var d = c[b];
                SAT.testCirclePolygon(a, d.totalBoundPolygon) && this.platforms.push(d)
            }
        }, b.prototype.fireSpikes = function() {
            for (var a = 0; a < 4; a++) {
                var b = this.spikes[a];
                b.dispenserFire()
            }
            this.sprite.animations.stop("spawn", !0), this.sprite.animations.play("spawn", null, !1)
        }, b.prototype.update = function() {
            var a = this.main.player,
                c = !0;
            if (a && a.alive) { var d = new SAT.Polygon(new Vector(0, 0), [new SAT.Vector(this.xPos, this.yPos), new SAT.Vector(a.xPos, a.yPos - 15)]); if (Math.pow(this.xPos - a.xPos - 15, 2) + Math.pow(this.yPos - a.yPos, 2) <= 62500) { for (var e = 0, f = this.platforms; e < f.length; e++) { var g = f[e]; if (SAT.testPolygonPolygon(d, g.totalBoundPolygon)) { c = !1; break } } c && this.charge >= b.CHARGE_TIME && (this.fireSpikes(), this.charge = 0, this.rad = 0) } } this.charge < b.CHARGE_TIME && (this.charge += this.main.gameSpeed, this.rad += Math.PI / b.CHARGE_TIME), this.sprite.rotation = this.rad
        }, b.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null }, b.prototype.resetLevel = function() { this.charge = 0 }, b.CHARGE_TIME = 35, b
    }(Obstacle),
    TextFade = function() {
        function a(a, b, c, d) {
            this.appearDistSq = 22500, this.disappearDistSq = 28900, this.reappearTime = 30,
                this.main = a, this.game = b, this.sprite = c.create(0, 0, d), this.sprite.autoCull = !0, this.sprite.anchor.set(.5, .5)
        }
        return a.prototype.spawn = function(a, b, c) { "textFade29" == this.sprite.key ? b -= 8 : "textFade13" === this.sprite.key && (this.game.device.desktop || this.sprite.loadTexture("textFade13Mobile")), this.xPos = a, this.yPos = b, this.sprite.position.set(a, b), this.sprite.rotation = c * Math.PI / 180, this.sprite.scale.x = .5, this.sprite.scale.y = .5, this.sprite.alpha = 0, this.reappear = 0 }, a.prototype.update = function() {
            var a = Math.pow(this.main.player.xPos - this.xPos, 2) + Math.pow(this.main.player.yPos - this.yPos, 2);
            a < this.appearDistSq ? (this.sprite.alpha -= .25 * (this.sprite.alpha - 1), this.sprite.scale.x -= .25 * (this.sprite.scale.x - 1), this.sprite.scale.y = this.sprite.scale.x, this.reappear = 0) : a > this.disappearDistSq && (this.reappear >= this.reappearTime ? (this.sprite.alpha -= .25 * this.sprite.alpha, this.sprite.scale.x -= .25 * this.sprite.scale.x, this.sprite.scale.y = this.sprite.scale.x) : this.reappear++)
        }, a.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.main = null }, a
    }(),
    DeathText = function() {
        function a(a, b) { this.text = a.add.bitmapText(0, 0, "grobred32", "", 18), this.text.visible = !1, this.text.anchor.set(.5, .5), b.add(this.text), this.alive = !1 }
        return a.prototype.show = function(a, b, c) { this.xPos = a, this.yPos = b, this.text.position.set(a, b), this.text.setText(c), this.text.visible = !0, this.text.scale.set(.75, .75), this.tarY = b + 30, this.alive = !0 }, a.prototype.update = function() { this.alive && (this.text.scale.x < 1.3 ? (this.text.scale.x -= .05 * (this.text.scale.x - 1.3), this.text.scale.y = this.text.scale.x, 1.3 - this.text.scale.x < .01 && this.text.scale.set(1.3, 1.3)) : (this.text.alpha -= .15 * this.text.alpha, this.text.alpha && (this.alive = !1, this.text.visible = !1)), this.yPos--, this.text.position.y = this.yPos) }, a
    }(),
    Particle = function(a) {
        function b(b, c, d, e, f, g, h) { var i = a.call(this, b) || this; return i.fadeAfter = 150, i.size = e, i.hitBox = new SAT.Box(new SAT.Vector(0, 0), e, e), i.collide = f, i.alive = !1, i.fadeAfter = h, i.liquid = g, i }
        return __extends(b, a), b.prototype.spawnBase = function(a, b, c, d) { this.xPos = a, this.yPos = b, this.xVelocity = c, this.yVelocity = d, this.hitBox.pos.x = a - .5 * this.size, this.hitBox.pos.y = b - .5 * this.size, this.hitBoxPolygon = this.hitBox.toPolygon(), this.fadeTime = 0, this.alive = !0, this.water = !1, this.onIce = !1 }, b.prototype.destroy = function() { this.hitBoxPolygon = null, this.hitBox = null, this.main.particleNum--, this.alive = !1 }, b.prototype.multAlpha = function(a) {}, b.prototype.update = function() { this.alive && (this.getWater(), this.water ? (this.xPos += .1 * this.xVelocity * this.main.gameSpeed, this.yPos += .5 * this.yVelocity * this.main.gameSpeed, this.liquid && (this.yPos += .5 * this.yVelocity * this.main.gameSpeed, this.yVelocity > -1 && (this.yVelocity -= .05 * this.main.gameSpeed))) : (this.xPos += this.xVelocity * this.main.gameSpeed, this.yPos += this.yVelocity * this.main.gameSpeed), this.collide && this.yVelocity < 12 && (this.water ? this.liquid || (this.yVelocity += .25 * this.main.gravity * this.main.gameSpeed) : this.yVelocity += this.main.gravity * this.main.gameSpeed), this.main.gameSpeed >= 1 && (this.water || this.onIce ? this.xVelocity *= .99 : this.xVelocity *= .95), Math.abs(this.xVelocity) < .1 && (this.xVelocity = 0), this.collide && this.runCollisions()) }, b.prototype.runCollisions = function() {
            for (var a = 0; a < this.main.blocks.length; a++) {
                var b = this.main.blocks[a];
                if (b.alive)
                    if (SAT.testPolygonPolygon(this.hitBoxPolygon, b.topBoundPolygon)) {
                        if (this.yVelocity >= 4 ? this.yVelocity *= -.25 : this.yVelocity >= 1 && (this.yVelocity = 0), this.yPos = b.topEdge - .5 * this.size, this.xPos += b.xVelocity, "speed" === b.blockType) {
                            var c = b;
                            this.xVelocity += c.speedInc
                        }
                        "ice" === b.blockType && (this.onIce = !0)
                    }
                else if (SAT.testPolygonPolygon(this.hitBoxPolygon, b.bottomBoundPolygon) && this.yVelocity < 0) this.yVelocity *= -.5, this.yPos = b.bottomEdge, this.xVelocity > 0 ? this.xVelocity -= .1 : this.xVelocity < 0 && (this.xVelocity += .1), this.yPos += this.yVelocity;
                else if (SAT.testPolygonPolygon(this.hitBoxPolygon, b.leftBoundPolygon)) this.xVelocity *= -.5, this.xPos = b.leftEdge - .5 * this.size, this.xPos += this.xVelocity;
                else if (SAT.testPolygonPolygon(this.hitBoxPolygon, b.rightBoundPolygon)) this.xVelocity *= -.5, this.xPos = b.rightEdge + .5 * this.size, this.xPos += this.xVelocity;
                else {
                    for (var d = 0, e = this.main.pools; d < e.length; d++) {
                        var f = e[d];
                        if (SAT.testPolygonPolygon(this.hitBoxPolygon, f.totalPolygon)) {
                            if (this.liquid && !this.water) return void this.destroy();
                            this.water || (this.yVelocity = 0), this.water = !0
                        }
                    }
                    if (this.liquid && !this.water) return void this.destroy()
                }
            }
        }, b.prototype.getWater = function() { this.water = !1; for (var a = 0, b = this.main.pools; a < b.length; a++) { var c = b[a]; if (SAT.testPolygonPolygon(this.hitBoxPolygon, c.totalPolygon)) { this.water = !0; break } } }, b
    }(Entity),
    ColorParticle = function(a) {
        function b(b, c, d, e, f, g, h, i, j) { var k = a.call(this, b, c, d, f, g, h, i) || this; return k.scaleOut = j, k.size = f, k.graphics = c.add.graphics(0, 0, d), k.graphics.beginFill(e), k.graphics.drawRect(-f / 2, -f / 2, f, f), k.graphics.endFill(), k.fadeAfter = i, k }
        return __extends(b, a), b.prototype.spawn = function(b, c, d, e) { a.prototype.spawnBase.call(this, b, c, d, e), this.graphics.position.set(b, c), this.fadeTime = 0 }, b.prototype.destroy = function() { this.alive && (this.graphics.destroy(), this.graphics = null, this.alive = !1, a.prototype.destroy.call(this)) }, b.prototype.multAlpha = function(a) { this.graphics.alpha *= a }, b.prototype.update = function() {
            if (this.alive) {
                if (this.fadeTime >= this.fadeAfter) { if (this.graphics.alpha -= .1 * this.main.gameSpeed, this.scaleOut && (this.graphics.scale.x *= .8, this.graphics.scale.y = this.graphics.scale.x), this.graphics.alpha <= 0) return void this.destroy() }
                else this.fadeTime++;
                var b = this.xPos,
                    c = this.yPos;
                a.prototype.update.call(this), this.alive && (b == this.xPos && c == this.yPos || (this.graphics.position.set(this.xPos, this.yPos), this.hitBoxPolygon.pos.x = this.xPos - .5 * this.size, this.hitBoxPolygon.pos.y = this.yPos - .5 * this.size))
            }
        }, b
    }(Particle),
    PlayerGib = function(a) {
        function b(b, c, d, e, f, g) { var h = a.call(this, b, c, d, f, g, !1, 150) || this; return h.sprite = d.create(0, 0, e), h.sprite.autoCull = !0, h.sprite.anchor.set(.5, .5), h }
        return __extends(b, a), b.prototype.spawn = function(b, c, d, e, f, g) { a.prototype.spawnBase.call(this, b, c, d, e), this.rotation = f, this.rotSpeed = g, this.sprite.position.set(b, c), this.sprite.rotation = f }, b.prototype.update = function() {
            if (this.alive) {
                if (this.fadeTime >= this.fadeAfter) { if (this.sprite.alpha -= .1 * this.main.gameSpeed, this.sprite.alpha <= 0) return void this.destroy() }
                else this.fadeTime++;
                var b = this.xPos,
                    c = this.yPos;
                a.prototype.update.call(this), this.alive && (this.rotation += this.rotSpeed, this.rotSpeed > 0 ? this.rotSpeed -= .5 : this.rotSpeed < 0 && (this.rotSpeed += .5), Math.abs(this.rotSpeed) < .6 && (this.rotSpeed = 0), b == this.xPos && c == this.yPos || (this.sprite.position.set(this.xPos, this.yPos), this.sprite.rotation = this.rotation, this.hitBox.pos.x = this.xPos - .5 * this.size, this.hitBox.pos.y = this.yPos - .5 * this.size, this.hitBoxPolygon = this.hitBox.toPolygon()))
            }
        }, b.prototype.destroy = function() { this.alive && (this.sprite && (this.sprite.destroy(), this.sprite = null), a.prototype.destroy.call(this)) }, b
    }(Particle),
    hubArrows = [];
hubArrows[0] = [{ type: "textFade", textNum: "13", x: 585.375, y: 1997.175, rotation: 0 }, { type: "textFade", textNum: "1", x: 584.8, y: 1869.4, rotation: 0 }, { type: "textFade", textNum: "4", x: 733.6500000000001, y: 1897.125, rotation: 0 }, { type: "textFade", textNum: "5", x: 924.55, y: 1753.525, rotation: -90 }, { type: "textFade", textNum: "5", x: 779.625, y: 1549.2, rotation: 164.99945068359375 }, { type: "textFade", textNum: "6", x: 740.075, y: 1639.475, rotation: 0 }, { type: "textFade", textNum: "7", x: 907.7750000000001, y: 1887.825, rotation: 0 }, { type: "textFade", textNum: "5", x: 1326.525, y: 1574.6, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1904.1, y: 1796.625, rotation: 90.00175476074219 }, { type: "textFade", textNum: "29", x: 2048.15, y: 1972, rotation: 0 }, { type: "textFade", textNum: "5", x: 1743.725, y: 1532.975, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 2155.075, y: 1304.55, rotation: 180 }, { type: "textFade", textNum: "5", x: 1391.1750000000002, y: 1161.85, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.9, y: 1132.9250000000002, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.8, y: 1270.025, rotation: 0 }, { type: "textFade", textNum: "33", x: 670.325, y: 918.85, rotation: 0 }, { type: "textFade", textNum: "4", x: 2219.2, y: 1120.6750000000002, rotation: 0 }, { type: "textFade", textNum: "5", x: 642.1, y: 582.775, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.875, y: 647.825, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.65, y: 616.725, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1904.1, y: 735.325, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2381.525, y: 804.2, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.675, y: 827, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.95, y: 1018.4250000000001, rotation: 89.99824523925781 }], hubArrows[1] = [{ type: "textFade", textNum: "43", x: 584.25, y: 1871.175, rotation: 0 }, { type: "textFade", textNum: "5", x: 924.1, y: 1754.5749999999998, rotation: -90 }, { type: "textFade", textNum: "5", x: 1117.1, y: 1513.6750000000002, rotation: 90 }, { type: "textFade", textNum: "44", x: 739.3499999999999, y: 1641.275, rotation: 0 }, { type: "textFade", textNum: "19", x: 1102.625, y: 1646.975, rotation: 0 }, { type: "textFade", textNum: "5", x: 1903.65, y: 1797.6750000000002, rotation: 90.00175476074219 }, { type: "textFade", textNum: "29", x: 2047.7, y: 1973.05, rotation: 0 }, { type: "textFade", textNum: "5", x: 1743.275, y: 1534.025, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 2154.625, y: 1305.6, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.725, y: 1162.9, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.45, y: 1133.975, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.35, y: 1271.0749999999998, rotation: 0 }, { type: "textFade", textNum: "33", x: 669.875, y: 919.9, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.75, y: 1121.725, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.65, y: 583.825, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.425, y: 648.875, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.2, y: 617.775, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1903.65, y: 736.375, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2381.075, y: 805.25, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.225, y: 828.05, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.5, y: 1019.475, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 717.475, y: 1895.875, rotation: -44.99955749511719 }, { type: "textFade", textNum: "5", x: 704.775, y: 1525.7, rotation: 0 }], hubArrows[2] = [{ type: "textFade", textNum: "43", x: 584.25, y: 1871.475, rotation: 0 }, { type: "textFade", textNum: "5", x: 1104.1, y: 2015.525, rotation: -90 }, { type: "textFade", textNum: "5", x: 1326.075, y: 1575.95, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1903.65, y: 1797.975, rotation: 90.00175476074219 }, { type: "textFade", textNum: "29", x: 2047.7, y: 1973.35, rotation: 0 }, { type: "textFade", textNum: "5", x: 2154.625, y: 1305.9, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.725, y: 1163.2, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.45, y: 1134.275, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.35, y: 1271.375, rotation: 0 }, { type: "textFade", textNum: "33", x: 669.875, y: 920.2, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.75, y: 1122.025, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.65, y: 584.125, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.425, y: 649.175, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.2, y: 618.075, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1903.65, y: 736.675, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2381.075, y: 805.55, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.225, y: 828.35, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.5, y: 1019.775, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 730.775, y: 1885.1750000000002, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.75, y: 1767.1750000000002, rotation: -90 }, { type: "textFade", textNum: "5", x: 738.175, y: 1563, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.875, y: 1908.2, rotation: 180 }], hubArrows[3] = [{ type: "textFade", textNum: "43", x: 584.1500000000001, y: 1870.475, rotation: 0 }, { type: "textFade", textNum: "5", x: 1104, y: 2014.525, rotation: -90 }, { type: "textFade", textNum: "5", x: 1325.975, y: 1574.95, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1903.575, y: 1857.9250000000002, rotation: -60.0001220703125 }, { type: "textFade", textNum: "29", x: 2047.6000000000001, y: 1972.35, rotation: 0 }, { type: "textFade", textNum: "5", x: 2154.525, y: 1304.9, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.625, y: 1162.2, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.35, y: 1133.275, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.25, y: 1270.375, rotation: 0 }, { type: "textFade", textNum: "33", x: 669.775, y: 919.2, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.6499999999996, y: 1121.025, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.55, y: 583.125, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.325, y: 648.175, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.1, y: 617.075, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1903.55, y: 735.675, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2380.975, y: 804.55, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.125, y: 827.35, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.4, y: 1018.775, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 730.675, y: 1884.1750000000002, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.65, y: 1766.1750000000002, rotation: -90 }, { type: "textFade", textNum: "5", x: 738.075, y: 1562, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.8249999999998, y: 1907.2, rotation: 0 }, { type: "textFade", textNum: "5", x: 2201.5, y: 1841.9250000000002, rotation: 90.00175476074219 }], hubArrows[4] = [{ type: "textFade", textNum: "43", x: 584.25, y: 1872.425, rotation: 0 }, { type: "textFade", textNum: "5", x: 1104.1, y: 2016.475, rotation: -90 }, { type: "textFade", textNum: "5", x: 1326.075, y: 1576.9, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1859.625, y: 1767.8249999999998, rotation: -134.99737548828125 }, { type: "textFade", textNum: "5", x: 1743.275, y: 1535.275, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 2154.625, y: 1306.85, rotation: 180 }, { type: "textFade", textNum: "5", x: 735.45, y: 1135.225, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.35, y: 1272.3249999999998, rotation: 0 }, { type: "textFade", textNum: "33", x: 669.875, y: 921.15, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.75, y: 1122.975, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.65, y: 585.075, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.425, y: 650.125, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.2, y: 619.025, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1903.65, y: 737.625, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2381.075, y: 806.5, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.225, y: 829.3, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.5, y: 1020.725, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 730.775, y: 1886.125, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.75, y: 1768.125, rotation: -90 }, { type: "textFade", textNum: "5", x: 738.175, y: 1563.95, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.9250000000002, y: 1909.15, rotation: 0 }, { type: "textFade", textNum: "5", x: 2201.6, y: 1859.8249999999998, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2072.125, y: 2307.25, rotation: .0008697509765625 }], hubArrows[5] = [{ type: "textFade", textNum: "43", x: 584.2, y: 1873.525, rotation: 0 }, { type: "textFade", textNum: "5", x: 1104.05, y: 2017.575, rotation: -90 }, { type: "textFade", textNum: "5", x: 1326.025, y: 1578, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1854.5749999999998, y: 1763.275, rotation: -134.9982452392578 }, { type: "textFade", textNum: "5", x: 1743.225, y: 1536.375, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 2154.575, y: 1307.95, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.6750000000002, y: 1165.25, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.4, y: 1136.3249999999998, rotation: -89.9947509765625 }, { type: "textFade", textNum: "30", x: 1043.3, y: 1273.4250000000002, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.7, y: 1124.0749999999998, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.6, y: 586.175, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 862.375, y: 651.2249999999999, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1701.15, y: 620.125, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1903.6, y: 738.725, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2381.025, y: 807.6, rotation: 0 }, { type: "textFade", textNum: "5", x: 2180.175, y: 830.4, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3375.45, y: 1021.825, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 730.725, y: 1887.225, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.7, y: 1769.225, rotation: -90 }, { type: "textFade", textNum: "5", x: 738.125, y: 1565.05, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.875, y: 1910.25, rotation: 0 }, { type: "textFade", textNum: "5", x: 2201.55, y: 1844.9250000000002, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2064.075, y: 2307.3, rotation: 0 }], hubArrows[6] = [{ type: "textFade", textNum: "5", x: 2155.575, y: 1308.9, rotation: 180 }, { type: "textFade", textNum: "5", x: 1391.6750000000002, y: 1166.2, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 736.4, y: 1137.3249999999998, rotation: 90.0052490234375 }, { type: "textFade", textNum: "30", x: 1044.3, y: 1274.375, rotation: 0 }, { type: "textFade", textNum: "33", x: 670.825, y: 923.2, rotation: 0 }, { type: "textFade", textNum: "4", x: 2219.7, y: 1125.025, rotation: 0 }, { type: "textFade", textNum: "5", x: 642.6, y: 587.125, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 1702.15, y: 621.075, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 1904.6, y: 739.675, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2382.025, y: 808.55, rotation: 0 }, { type: "textFade", textNum: "5", x: 2181.175, y: 831.35, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3376.45, y: 1022.775, rotation: 89.99824523925781 }, { type: "textFade", textNum: "43", x: 585.2, y: 1874.475, rotation: 0 }, { type: "textFade", textNum: "5", x: 1105.05, y: 2018.525, rotation: -90 }, { type: "textFade", textNum: "5", x: 1327.025, y: 1578.95, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1855.5749999999998, y: 1764.225, rotation: -134.9982452392578 }, { type: "textFade", textNum: "5", x: 1744.225, y: 1537.325, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 731.725, y: 1888.1750000000002, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 924.7, y: 1770.1750000000002, rotation: -90 }, { type: "textFade", textNum: "5", x: 739.125, y: 1566, rotation: 0 }, { type: "textFade", textNum: "5", x: 1554.875, y: 1911.2, rotation: 0 }, { type: "textFade", textNum: "5", x: 2202.55, y: 1845.875, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2065.075, y: 2308.25, rotation: 0 }, { type: "textFade", textNum: "5", x: 895.75, y: 1079.975, rotation: -89.9947509765625 }], hubArrows[7] = [{ type: "textFade", textNum: "33", x: 670.975, y: 918.15, rotation: 0 }, { type: "textFade", textNum: "5", x: 642.75, y: 582.125, rotation: 90.0052490234375 }, { type: "textFade", textNum: "5", x: 863.525, y: 647.125, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1702.3, y: 616.025, rotation: 90.00436401367188 }, { type: "textFade", textNum: "38", x: 2382.175, y: 803.5, rotation: 0 }, { type: "textFade", textNum: "5", x: 2181.325, y: 826.3, rotation: -.0008697509765625 }, { type: "textFade", textNum: "5", x: 3376.6, y: 1017.725, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 2155.725, y: 1303.85, rotation: 180 }, { type: "textFade", textNum: "5", x: 1391.8249999999998, y: 1161.15, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 736.55, y: 1132.275, rotation: 90.0052490234375 }, { type: "textFade", textNum: "30", x: 1044.45, y: 1269.3249999999998, rotation: 0 }, { type: "textFade", textNum: "4", x: 2219.8500000000004, y: 1119.975, rotation: 0 }, { type: "textFade", textNum: "43", x: 585.3499999999999, y: 1869.425, rotation: 0 }, { type: "textFade", textNum: "5", x: 1105.2, y: 2013.475, rotation: -90 }, { type: "textFade", textNum: "5", x: 1327.175, y: 1573.9, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1855.725, y: 1759.1750000000002, rotation: -134.9982452392578 }, { type: "textFade", textNum: "5", x: 1744.375, y: 1532.275, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 731.875, y: 1883.125, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 924.85, y: 1765.125, rotation: -90 }, { type: "textFade", textNum: "5", x: 739.275, y: 1560.95, rotation: 0 }, { type: "textFade", textNum: "5", x: 1555.025, y: 1906.15, rotation: 0 }, { type: "textFade", textNum: "5", x: 2202.7, y: 1840.8249999999998, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2065.225, y: 2303.2, rotation: 0 }, { type: "textFade", textNum: "5", x: 895.9, y: 1074.9250000000002, rotation: -89.9947509765625 }], hubArrows[8] = [{ type: "textFade", textNum: "33", x: 669.675, y: 919, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.45, y: 582.975, rotation: 90.0052490234375 }, { type: "textFade", textNum: "5", x: 862.225, y: 647.9749999999999, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1370.525, y: 839, rotation: .004364013671875 }, { type: "textFade", textNum: "5", x: 3375.3, y: 1018.575, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 2154.425, y: 1304.7, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.525, y: 1162, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.25, y: 1133.125, rotation: 90.0052490234375 }, { type: "textFade", textNum: "30", x: 1043.15, y: 1270.1750000000002, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.55, y: 1120.8249999999998, rotation: 0 }, { type: "textFade", textNum: "43", x: 584.05, y: 1870.275, rotation: 0 }, { type: "textFade", textNum: "5", x: 1103.9, y: 2014.325, rotation: -90 }, { type: "textFade", textNum: "5", x: 1325.875, y: 1574.75, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1854.4250000000002, y: 1760.025, rotation: -134.9982452392578 }, { type: "textFade", textNum: "5", x: 1743.0749999999998, y: 1533.125, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 730.575, y: 1883.975, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.55, y: 1765.975, rotation: -90 }, { type: "textFade", textNum: "5", x: 737.975, y: 1561.8, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.725, y: 1907, rotation: 0 }, { type: "textFade", textNum: "5", x: 2201.4, y: 1841.6750000000002, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2063.925, y: 2304.05, rotation: 0 }, { type: "textFade", textNum: "5", x: 894.6, y: 1075.775, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 1698.075, y: 664.025, rotation: -59.99620056152344 }], hubArrows[9] = [{ type: "textFade", textNum: "33", x: 669.675, y: 919, rotation: 0 }, { type: "textFade", textNum: "5", x: 641.45, y: 582.975, rotation: 90.0052490234375 }, { type: "textFade", textNum: "5", x: 862.225, y: 647.9749999999999, rotation: -29.995941162109375 }, { type: "textFade", textNum: "5", x: 1370.525, y: 839, rotation: .004364013671875 }, { type: "textFade", textNum: "5", x: 3375.3, y: 1018.575, rotation: 89.99824523925781 }, { type: "textFade", textNum: "5", x: 2154.425, y: 1304.7, rotation: 180 }, { type: "textFade", textNum: "5", x: 1390.525, y: 1162, rotation: 166.93624877929688 }, { type: "textFade", textNum: "5", x: 735.25, y: 1133.125, rotation: 90.0052490234375 }, { type: "textFade", textNum: "30", x: 1043.15, y: 1270.1750000000002, rotation: 0 }, { type: "textFade", textNum: "4", x: 2218.55, y: 1120.8249999999998, rotation: 0 }, { type: "textFade", textNum: "43", x: 584.05, y: 1870.275, rotation: 0 }, { type: "textFade", textNum: "5", x: 1103.9, y: 2014.325, rotation: -90 }, { type: "textFade", textNum: "5", x: 1325.875, y: 1574.75, rotation: 14.998931884765625 }, { type: "textFade", textNum: "5", x: 1854.4250000000002, y: 1760.025, rotation: -134.9982452392578 }, { type: "textFade", textNum: "5", x: 1743.0749999999998, y: 1533.125, rotation: -29.999221801757812 }, { type: "textFade", textNum: "5", x: 730.575, y: 1883.975, rotation: -45.00044250488281 }, { type: "textFade", textNum: "5", x: 923.55, y: 1765.975, rotation: -90 }, { type: "textFade", textNum: "5", x: 737.975, y: 1561.8, rotation: 0 }, { type: "textFade", textNum: "5", x: 1553.725, y: 1907, rotation: 0 }, { type: "textFade", textNum: "5", x: 2201.4, y: 1841.6750000000002, rotation: -89.99824523925781 }, { type: "textFade", textNum: "5", x: 2063.925, y: 2304.05, rotation: 0 }, { type: "textFade", textNum: "5", x: 894.6, y: 1075.775, rotation: -89.9947509765625 }, { type: "textFade", textNum: "5", x: 1698.075, y: 664.025, rotation: -59.99620056152344 }, { type: "textFade", textNum: "5", x: 1902.1, y: 700.075, rotation: 90.00436401367188 }, { type: "textFade", textNum: "5", x: 2034.325, y: 838.2, rotation: .004364013671875 }, { type: "textFade", textNum: "38", x: 2254.475, y: 802.75, rotation: 0 }], hubArrows[10] = hubArrows[9];
var Options = function() {
        function a(a) {
            this.autoReset = !1, this.particleLimit = 30, this.controllerSelect = !1, this.blend = !0, this.waves = !0, this.parallax = !0, this.musicVolume = 1, this.effectVolume = .5, this.muted = !1, this.game = a;
            var b = SaveGame.getInstance(this.game).getAllValues();
            this.loadOptions(b.options)
        }
        return a.prototype.loadOptions = function(a) { this.musicVolume = a.mv, this.effectVolume = a.efxv, this.autoReset = a.ar, this.particleLimit = a.pl, this.controllerSelect = a.nc, this.blend = a.bl, this.waves = a.wv, this.parallax = a.plx, this.muted = a.mt }, a.prototype.saveOptions = function() {
            var a = { mv: this.musicVolume, efxv: this.effectVolume, ar: this.autoReset, pl: this.particleLimit, nc: this.controllerSelect, bl: this.blend, wv: this.waves, plx: this.parallax, mt: this.muted };
            SaveGame.getInstance().saveOptions(a)
        }, a.prototype.clearSavedData = function() {
            SaveGame.getInstance().resetOptions();
            var a = SaveGame.getInstance().getOptions();
            this.loadOptions(JSON.parse(a))
        }, a
    }(),
    Achievement = function() {
        function a(a, b, c, d) { this.spriteKey = a, this.type = b, this.name = c, this.description = d, this.completed = !1 }
        return a
    }(),
    Achievements = function() {
        function a(a, b) { this.game = b, this.main = a, this.achievements = {}, this.standardActs = [], this.hardcore = [], this.awesome = [], this.completion = [], this.standardGot = 0, this.hardcoreGot = 0, this.awesomeGot = 0, this.completionGot = 0, this.totalGot = 0, this.allMax = 0, this.addAchievement("act1", "act1Achievement", 0, "Act 1", "Complete Act 1 to any ranking"), this.addAchievement("act2", "act2Achievement", 0, "Act 2", "Complete Act 2 to any ranking"), this.addAchievement("act3", "act3Achievement", 0, "Act 3", "Complete Act 3 to any ranking"), this.addAchievement("act4", "act4Achievement", 0, "Act 4", "Complete Act 4 to any ranking"), this.addAchievement("act5", "act5Achievement", 0, "Act 5", "Complete Act 5 to any ranking"), this.addAchievement("act6", "act6Achievement", 0, "Act 6", "Complete Act 6 to any ranking"), this.addAchievement("act7", "act7Achievement", 0, "Act 7", "Complete Act 7 to any ranking"), this.addAchievement("act8", "act8Achievement", 0, "Act 8", "Complete Act 8 to any ranking"), this.addAchievement("act9", "act9Achievement", 0, "Act 9", "Complete Act 9 to any ranking"), this.addAchievement("act10", "act10Achievement", 0, "Vexation", "Complete the Vexation to any ranking"), this.addAchievement("star1", "star1Achievement", 1, "Mine !", "Grab the hidden star on Act 1"), this.addAchievement("star2", "star2Achievement", 1, "Thanks Box !", "Grab the hidden star on Act 2"), this.addAchievement("star3", "star3Achievement", 1, "It's the Climb !", "Grab the hidden star on Act 3"), this.addAchievement("star4", "star4Achievement", 1, "Between a Saw", "Grab the hidden star on Act 4"), this.addAchievement("star5", "star5Achievement", 1, "Leap of Faith", "Grab the hidden star on Act 5"), this.addAchievement("star6", "star6Achievement", 1, "Keychain", "Grab the hidden star on Act 6"), this.addAchievement("star7", "star7Achievement", 1, "Take the Plunge", "Grab the hidden star on Act 7"), this.addAchievement("star8", "star8Achievement", 1, "Lights Out !", "Grab the hidden star on Act 8"), this.addAchievement("star9", "star9Achievement", 1, "Outside the Box", "Grab the hidden star on Act 9"), this.addAchievement("star10", "star10Achievement", 1, "Inside the Box", "Grab the hidden star on the Vexation"), this.addAchievement("challenge1", "challenge1Achievement", 1, "One Step At A Time", "Complete Challenge Mode for Act 1"), this.addAchievement("challenge2", "challenge2Achievement", 1, "Double Down", "Complete Challenge Mode for Act 2"), this.addAchievement("challenge3", "challenge3Achievement", 1, "Third's the Charm", "Complete Challenge Mode for Act 3"), this.addAchievement("challenge4", "challenge4Achievement", 1, "Fantastic Four", "Complete Challenge Mode for Act 4"), this.addAchievement("challenge5", "challenge5Achievement", 1, "High Five", "Complete Challenge Mode for Act 5"), this.addAchievement("challenge6", "challenge6Achievement", 1, "Demon", "Complete Challenge Mode for Act 6"), this.addAchievement("challenge7", "challenge7Achievement", 1, "You're Lucky", "Complete Challenge Mode for Act 7"), this.addAchievement("challenge8", "challenge8Achievement", 1, "Eight Times the Champ", "Complete Challenge Mode for Act 8"), this.addAchievement("challenge9", "challenge9Achievement", 1, "Nine Lives", "Complete Challenge Mode for Act 9"), this.addAchievement("perfect", "awesome1Achievement", 2, "Perfect !", "Complete any Act with Perfect ranking"), this.addAchievement("caretaker", "awesome2Achievement", 2, "Caretaker", "Hold 4 keys at one time"), this.addAchievement("gasping", "awesome3Achievement", 2, "Gasping", "Surface from swimming with one bubble left"), this.addAchievement("timeflies", "awesome4Achievement", 2, "Time Flies V2.0", "Play the game for over one hour"), this.addAchievement("headsup", "awesome5Achievement", 2, "Heads Up", "Get crushed by a pushable block"), this.addAchievement("deathtycoon", "awesome6Achievement", 2, "Death Tycoon", "Get over 100 total deaths"), this.addAchievement("olympian", "complete1Achievement", 3, "Olympian", "Achieve Gold or better on every Act"), this.addAchievement("perfectionist", "complete2Achievement", 3, "Perfectionist", "Achieve Perfect or better on every Act"), this.addAchievement("astronomer", "complete3Achievement", 3, "Astronomer", "Collect every star in the game"), this.addAchievement("winner", "complete4Achievement", 3, "Winner", "Complete every Act in Challenge Mode"), this.tryLoadAchievements() }
        return a.prototype.addAchievement = function(a, b, c, d, e) {
            var f = new Achievement(b, c, d, e);
            switch (this.achievements[a] = f, c) {
                case 0:
                    this.standardActs.push(f);
                    break;
                case 1:
                    this.hardcore.push(f);
                    break;
                case 2:
                    this.awesome.push(f);
                    break;
                case 3:
                    this.completion.push(f)
            }
            this.allMax++
        }, a.prototype.gotAchievement = function(a) {
            var b = this.achievements[a];
            if (b && !b.completed) {
                switch (b.completed = !0, this.main.achievementUnlocked.show(b), Fabrique.Utils.isOnDevice(this.game) && SocialServicesHandler.submitAchievement(this.game, a), this.saveAchievements(), b.icon && (b.icon.sprite.filters = null), b.type) {
                    case 0:
                        this.standardGot++;
                        break;
                    case 1:
                        this.hardcoreGot++;
                        break;
                    case 2:
                        this.awesomeGot++;
                        break;
                    case 3:
                        this.completionGot++
                }
                this.totalGot++, this.main.timerGui.updateProgress(this.getTotalProgress()), this.main.achievementsWindow.updateProgress()
            }
        }, a.prototype.saveAchievements = function() {
            var a = {};
            for (var b in this.achievements) {
                var c = this.achievements[b];
                a[b] = c.completed
            }
            SaveGame.getInstance().saveAchievements(a)
        }, a.prototype.clearSavedData = function() {
            for (var a in this.achievements) {
                var b = this.achievements[a];
                b.completed = !1, b.icon.sprite.filters = [AchievementsWindow.GRAY_FILTER]
            }
            SaveGame.getInstance().resetAchievements(), this.totalGot = 0, this.standardGot = 0, this.awesomeGot = 0, this.hardcoreGot = 0, this.completionGot = 0
        }, a.prototype.tryLoadAchievements = function() {
            var a = SaveGame.getInstance().getAchievements();
            if (a) try {
                var b = a;
                for (var c in b) {
                    var d = b[c],
                        e = this.achievements[c];
                    if (void 0 === d || !e) return;
                    if (e.completed = d, d) switch (this.totalGot++, e.type) {
                        case 0:
                            this.standardGot++;
                            break;
                        case 1:
                            this.hardcoreGot++;
                            break;
                        case 2:
                            this.awesomeGot++;
                            break;
                        case 3:
                            this.completionGot++
                    }
                }
            }
            catch (f) { return }
        }, a.prototype.getStandardActsProgress = function() { return this.standardGot / this.standardActs.length }, a.prototype.getHardcoreProgress = function() { return this.hardcoreGot / this.hardcore.length }, a.prototype.getAwesomeProgress = function() { return this.awesomeGot / this.awesome.length }, a.prototype.getCompletionProgress = function() { return this.main.levels ? (this.hardcoreGot + this.main.levels.getGoldNumber() + this.main.levels.getPerfectNumber()) / (this.hardcore.length + 20) : 0 }, a.prototype.getTotalProgress = function() { return this.totalGot / this.allMax }, a
    }(),
    TimerGui = function() {
        function a(a, b, c) {
            this.main = a, this.game = b, this.layer = c, this.timerContainer = b.add.group(c), this.timerBG = this.timerContainer.create(-15, -10, "timerBG"), this.timerLabelText = b.add.bitmapText(20, 5, "grob24", "Time Played:", 12), this.timerContainer.addChild(this.timerLabelText), this.timerText = b.add.bitmapText(15, 18, "grob24", "00:00:00", 24), this.timerContainer.addChild(this.timerText),
                this.rankLabelText = b.add.bitmapText(5, 60, "grob24", "Progress:", 12), this.timerContainer.addChild(this.rankLabelText), this.rankText = b.add.sprite(-5, 70, "perfectText"), this.rankText.scale.set(.6, .6), this.rankText.visible = !1, this.timerContainer.addChild(this.rankText), this.progressText = b.add.bitmapText(35, 70, "grob24", "0%", 20), this.timerContainer.addChild(this.progressText), this.levelNameContainer = b.add.group(c), this.levelNameContainer.position.x = b.width, this.levelNameBG = this.levelNameContainer.create(-140, -10, "levelNameBG"), this.deathText = b.add.bitmapText(-20, 35, "grobred32", "0 total deaths", 12), this.deathText.anchor.set(1, 0), this.levelNameContainer.addChild(this.deathText), this.levelName = b.add.bitmapText(-10, 5, "grob24", "Level Hub", 24), this.levelName.anchor.set(1, 0), this.levelNameContainer.addChild(this.levelName), this.inGame = !1
        }
        return a.prototype.enterLevel = function(a) { this.rankLabelText.setText("Current Rank"), this.rankType = 0, this.rankText.loadTexture("perfectText"), this.rankText.visible = !0, this.timerText.setText("00:00:00"), this.levelName.setText(a.name), this.deathText.setText("0 deaths"), this.progressText.visible = !1, this.inGame = !0, this.currentLevel = a, this.main.options.blend ? (this.timerBG.filters = [this.main.currentLevel.colorFilter], this.levelNameBG.filters = [this.main.currentLevel.colorFilter]) : (this.timerBG.filters = null, this.levelNameBG.filters = null) }, a.prototype.exitLevel = function() { this.levelName.setText("Level Hub"), this.rankLabelText.setText("Progress:"), this.rankText.visible = !1, this.inGame = !1, this.timerBG.filters = null, this.levelNameBG.filters = null, this.progressText.visible = !0 }, a.prototype.resetLevel = function() { this.rankType = 0, this.rankText.loadTexture("perfectText") }, a.prototype.hide = function() { this.timerContainer.visible = !1, this.levelNameContainer.visible = !1 }, a.prototype.show = function() { this.timerContainer.visible = !0, this.levelNameContainer.visible = !0 }, a.prototype.updateLevelTime = function(a) {
            if (this.inGame) {
                this.timerText.setText(timeDecorator(Date.now() - Constants.actStartTime));
                var b = Date.now() - Constants.actStartTime;
                switch (this.rankType) {
                    case 0:
                    case 1:
                        b > this.currentLevel.goldTime && (this.main.sounds.playSound("downgrade"), this.rankType = 2, this.rankText.loadTexture("silverText"));
                        break;
                    case 2:
                        b > this.currentLevel.silverTime && (this.main.sounds.playSound("downgrade"), this.rankType = 3, this.rankText.loadTexture("bronzeText"));
                        break;
                    case 3:
                        b > this.currentLevel.bronzeTime && (this.main.sounds.playSound("downgrade"), this.rankType = 4, this.rankText.loadTexture("noneText"))
                }
            }
            else this.timerText.setText(timeDecoratorHub(Date.now() - Constants.levelMapStartTime))
        }, a.prototype.updateDeaths = function(a) { this.inGame ? (this.deathText.setText(a + " deaths"), a > 0 && (this.main.sounds.playSound("downgrade"), 0 === this.rankType && (this.rankType = 1, this.rankText.loadTexture("goldText")))) : this.deathText.setText(a + " total deaths") }, a.prototype.updateProgress = function(a) { this.progressText.setText(Math.floor(100 * a) + "%") }, a.prototype.resizeStage = function(a, b) { this.levelNameContainer.position.x = a }, a
    }(),
    GameKey = function() {
        function a(a) { this.keys = a, this.buttonDown = !1, this.calls = [] }
        return a.prototype.isDown = function() {
            for (var a = 0, b = this.calls; a < b.length; a++) {
                var c = b[a],
                    d = c;
                if (d()) return !0
            }
            for (var e = 0, f = this.keys; e < f.length; e++) { var g = f[e]; if (g.isDown) return !0 }
            return !1
        }, a.prototype.pressed = function() { return this.isDown() && !this.prev }, a.prototype.update = function() { this.isDown() ? this.prev = !0 : this.prev = !1 }, a
    }(),
    BREAK_X_1 = 560,
    BREAK_X_2 = 360,
    VexGameState = function() {
        function a(a) {}
        return a.prototype.init = function() { document.body.style.backgroundColor = "#ffffff" }, a.prototype.create = function() {
            var a = this,
                b = this.game.input.keyboard.addKey(Phaser.Keyboard.UP),
                c = this.game.input.keyboard.addKey(Phaser.Keyboard.W),
                d = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN),
                e = this.game.input.keyboard.addKey(Phaser.Keyboard.S),
                f = this.game.input.keyboard.addKey(Phaser.Keyboard.LEFT),
                g = this.game.input.keyboard.addKey(Phaser.Keyboard.A),
                h = this.game.input.keyboard.addKey(Phaser.Keyboard.RIGHT),
                i = this.game.input.keyboard.addKey(Phaser.Keyboard.D),
                j = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR),
                k = this.game.input.keyboard.addKey(Phaser.Keyboard.R),
                l = new GameKey([b, c]),
                m = new GameKey([d, e]),
                n = new GameKey([f, g]),
                o = new GameKey([h, i]),
                p = new GameKey([j]),
                q = new GameKey([k]);
            this.circleMovement = new ControllerStick(this.game, 150, 400, "circleLrButton", (!0)), n.calls.push(this.circleMovement.leftIsDown.bind(this.circleMovement)), o.calls.push(this.circleMovement.rightIsDown.bind(this.circleMovement)), this.buttonJump = new ControllerButton(this.game, 400, 500, "jumpButton", (!1)), l.calls.push(this.buttonJump.buttonPressed.bind(this.buttonJump)), this.buttonCrouch = new ControllerButton(this.game, 400, 400, "crouchButton", (!1)), m.calls.push(this.buttonCrouch.buttonPressed.bind(this.buttonCrouch));
            var r = this.circleMovement,
                s = this.buttonJump,
                t = this.buttonCrouch;
            this.circle1 = new ControllerStick(this.game, 150, 400, "circleButton", (!1)), this.circle2 = new ControllerStick(this.game, this.game.width - 150, 400, "circleButton", (!1));
            var u = this.circle1,
                v = this.circle2;
            l.calls.push(this.circle1.upIsDown.bind(this.circle1)), l.calls.push(this.circle2.upIsDown.bind(this.circle2)), m.calls.push(this.circle1.downIsDown.bind(this.circle1)), m.calls.push(this.circle2.downIsDown.bind(this.circle2)), n.calls.push(this.circle1.leftIsDown.bind(this.circle1)), n.calls.push(this.circle2.leftIsDown.bind(this.circle2)), o.calls.push(this.circle1.rightIsDown.bind(this.circle1)), o.calls.push(this.circle2.rightIsDown.bind(this.circle2));
            var w, x = this.game;
            this.keys = { up: l, down: m, left: n, right: o, reset: q, space: p, show: function() { x.device.desktop || (Constants.oldControls ? (u.show(), v.show()) : (r.show(), s.show(), t.show())) }, hide: function() { r.hide(), s.hide(), t.hide(), u.hide(), v.hide() }, isScreenButtonDown: function() { return !!r.isDown || (!!s.isDown || (!!t.isDown || (!!u.isDown || !!v.isDown))) }, setAlpha: function(a) { r.sprite.alpha = a, s.sprite.alpha = a, t.sprite.alpha = a, u.sprite.alpha = a, v.sprite.alpha = a } }, this.keys.hide(), this.game.stage.backgroundColor = "#FFFFFF", this.game.world.setBounds(-3e3, -3e3, 9e3, 6e3), this.game.device.desktop ? (this.stage.disableVisibilityChange = !0, this.game.onBlur.add(function(b) { a.game.sound.mute = !0 }), this.game.onFocus.add(function(b) { a.game.sound.mute = !1 })) : (this.stage.disableVisibilityChange = !1, this.game.onPause.add(function(b) { a.game.sound.mute = !0 }), this.game.onResume.add(function(b) { a.game.sound.mute = !1 })), this.main = new Main(this.game, this.keys), w = this.main, this.game.scale.onSizeChange.add(function(b, c, d) { a.game.device.desktop || (c *= 1.35, d *= 1.35), a.resizeStage(b, c, d), a }), this.resizeStage(null, this.game.width, this.game.height);
            var y = this.game.add.group();
            y.add(this.circleMovement.sprite), y.add(this.buttonJump.sprite), y.add(this.buttonCrouch.sprite), y.add(this.circle1.sprite), y.add(this.circle2.sprite);
            var z = function() { a.main.mobilePressedDown(), a.main.mobilePressedDown() };
            this.circle1.pressedDown.add(z), this.circle2.pressedDown.add(z), this.circleMovement.pressedDown.add(z), this.buttonJump.pressedDown.add(z), this.buttonCrouch.pressedDown.add(z)
        }, a.prototype.resizeStage = function(a, b, c) { this.main.resizeStage(b, c), this.circleMovement.sprite.cameraOffset.x = 130, this.circleMovement.sprite.scale.set(1.25), this.buttonJump.sprite.cameraOffset.x = b - 130, this.buttonCrouch.sprite.cameraOffset.x = b - 270, this.buttonJump.sprite.scale.set(.75), this.buttonCrouch.sprite.scale.set(.75), this.circle1.sprite.cameraOffset.x = 130, this.circle2.sprite.cameraOffset.x = b - 130, this.circle1.sprite.scale.set(1.25), this.circle2.sprite.scale.set(1.25), b < BREAK_X_2 ? (this.circle1.sprite.cameraOffset.y = c - 240, this.circle2.sprite.cameraOffset.y = c - 240, this.circle1.sprite.scale.set(.8, .8), this.circle2.sprite.scale.set(.8, .8), this.circle1.sprite.cameraOffset.x = 70, this.circle2.sprite.cameraOffset.x = b - 70) : b < BREAK_X_1 ? (this.circleMovement.sprite.scale.set(1.15), this.circleMovement.sprite.cameraOffset.y = c - 240, this.buttonJump.sprite.scale.set(.6), this.buttonCrouch.sprite.scale.set(.6), this.buttonJump.sprite.cameraOffset.x = b - 70, this.buttonCrouch.sprite.cameraOffset.x = b - 170, this.buttonJump.sprite.cameraOffset.y = c - 280, this.buttonCrouch.sprite.cameraOffset.y = c - 190, this.circle1.sprite.scale.set(1.15), this.circle2.sprite.scale.set(1.15), this.circle1.sprite.cameraOffset.y = c - 240, this.circle2.sprite.cameraOffset.y = c - 240) : (this.circleMovement.sprite.cameraOffset.x = 160, this.circleMovement.sprite.cameraOffset.y = c - 180, this.buttonJump.sprite.cameraOffset.y = c - 220, this.buttonCrouch.sprite.cameraOffset.y = c - 150, this.circle1.sprite.cameraOffset.x = 160, this.circle2.sprite.cameraOffset.x = b - 160, this.circle1.sprite.cameraOffset.y = c - 180, this.circle2.sprite.cameraOffset.y = c - 180) }, a.prototype.update = function() {
            this.main.update();
            for (var a in this.keys) "function" != typeof this.keys[a] && this.keys[a].update();
            Constants.oldControls ? (this.circle1.update(), this.circle2.update()) : this.circleMovement.update()
        }, a.prototype.quitGame = function() {}, a
    }(),
    RankTime = function() {
        function a(a, b, c) { this.main = a, this.game = b, this.layer = c, this.container = b.add.group(c), this.container.position.set(b.width - 375, b.height), this.bg = this.container.create(0, 0, "rankTimeBG"), this.staticText = b.add.sprite(38, -17, "rankTimeStaticText"), this.container.addChild(this.staticText), this.levelNameText = b.add.bitmapText(15, 48, "grob24", "Level Hub", 24), this.container.addChild(this.levelNameText), this.timeText = b.add.bitmapText(80, 18, "grob24", "00:00", 12), this.container.addChild(this.timeText), this.goldTimeText = b.add.bitmapText(132, 60, "grob24", "00:00", 12), this.container.addChild(this.goldTimeText), this.silverTimeText = b.add.bitmapText(217, 60, "grob24", "00:00", 12), this.container.addChild(this.silverTimeText), this.bronzeTimeText = b.add.bitmapText(302, 60, "grob24", "00:00", 12), this.container.addChild(this.bronzeTimeText), this.goldIcon = b.add.sprite(185, 29, "completedIcon"), this.goldIcon.scale.set(.6, .6), this.goldIcon.anchor.set(.5, .5), this.container.addChild(this.goldIcon), this.starIcon = b.add.sprite(250, 29, "starIcon"), this.starIcon.scale.set(.6, .6), this.starIcon.anchor.set(.5, .5), this.container.addChild(this.starIcon), this.challengeIcon = b.add.sprite(320, 29, "challengeIcon"), this.challengeIcon.scale.set(.6, .6), this.challengeIcon.anchor.set(.5, .5), this.container.addChild(this.challengeIcon), this.container.visible = !1 }
        return a.prototype.show = function(a) { this.showingLevel = a, this.levelNameText.setText(a.name), a.topTime > -1 ? this.timeText.setText(timeDecoratorActBlock(a.topTime)) : this.timeText.setText(timeDecoratorActBlock(0)), this.goldTimeText.setText(timeDecoratorActBlock(a.goldTime)), this.silverTimeText.setText(timeDecoratorActBlock(a.silverTime)), this.bronzeTimeText.setText(timeDecoratorActBlock(a.bronzeTime)), a.gotGold() ? (this.goldIcon.frame = 1, a.challengeData && (this.main.allowSpace = !0), this.main.keys.show()) : this.goldIcon.frame = 0, a.challengeCompleted ? this.challengeIcon.frame = 1 : this.challengeIcon.frame = 0, a.gotStar ? this.starIcon.frame = 1 : this.starIcon.frame = 0, this.main.options.blend ? this.bg.filters = [a.colorFilter] : this.bg.filters = null, this.container.visible = !0 }, a.prototype.hide = function() { this.main.allowSpace = !1, this.main.keys.show(), this.showingLevel = null }, a.prototype.invis = function() { this.container.visible = !1 }, a.prototype.vis = function() { this.container.visible = !0 }, a.prototype.leaveHub = function() { this.container.y = this.game.height, this.main.buttonSet.bottomButtons.position.y = this.game.height - 50, this.container.visible = !1 }, a.prototype.update = function() {
            if (this.showingLevel) {
                var a = this.game.height - 80;
                if (this.container.y > this.game.height - a) {
                    var b = this.container.y - a;
                    Math.abs(b) < 2 ? this.container.y = a : this.container.y -= b / 4, this.game.width < BREAK_X_1 ? this.main.buttonSet.bottomButtons.y = this.container.y - 50 : this.main.buttonSet.brandLogo && (this.main.buttonSet.brandLogo.y = this.container.y + 10 - this.game.height)
                }
            }
            else {
                var b = this.container.y - this.game.height;
                Math.abs(b) < 2 ? (this.container.y = this.game.height, this.container.visible = !0) : this.container.y -= b / 4, this.game.width < BREAK_X_1 ? this.main.buttonSet.bottomButtons.y = this.container.y - 50 : this.main.buttonSet.brandLogo && (this.main.buttonSet.brandLogo.y = this.container.y + 10 - this.game.height)
            }
        }, a.prototype.resizeStage = function(a, b) { this.container.x = a - 375 }, a
    }(),
    BottomButton = function() {
        function a(a, b, c, d, e, f, g) {
            var h = this;
            this.game = a, this.container = a.add.group(f), this.container.position.set(b, c), this.bg = this.container.create(0, 0, "stageButtonBG"), this.bg.inputEnabled = !0, this.logo = this.container.create(25, 25, d), this.logo.anchor.set(.5, .5), this.light = a.add.graphics(0, 0), this.light.visible = !1, this.light.beginFill(16777215, .2), this.light.drawRect(0, 0, 50, 50), this.light.endFill(), this.container.addChild(this.light), this.label = this.container.create(25, -20, "stageLabelBG"), this.label.anchor.set(.5, .5), this.container.addChild(this.label), this.labelText = a.add.bitmapText(0, 0, "grob24", e, 14), this.labelText.anchor.set(.5, .5), this.label.addChild(this.labelText), this.label.visible = !1, a.device.desktop && (this.bg.events.onInputOver.add(function() { h.light.visible = !0, h.label.visible = !0 }, this), this.bg.events.onInputOut.add(function() { h.light.visible = !1, h.label.visible = !1 }, this)), this.bg.events.onInputUp.add(g, this)
        }
        return a
    }(),
    ButtonSet = function() {
        function a(a, b, c) {
            var d = this;
            this.main = a, this.game = b, this.layer = c, this.bottomButtons = b.add.group(c, "bottomButtons"), this.bottomButtons.visible = !1, this.bottomButtons.position.set(0, b.height - 50), this.logoGroup = b.add.group(c, "logoGroup"), this.logoGroup.position.set(0, b.height - 50), Fabrique.Branding.isAirfi() || (this.brandLogo = Fabrique.Branding.getLogoWithLink(this.game, "vex-3"), c.add(this.brandLogo), this.brandLogo.inputEnabled = Fabrique.Branding.outGoingLinksAllowed(), this.brandLogo.input.useHandCursor = !0, this.brandLogo.events.onInputUp.add(function() { Fabrique.Branding.openCampaignLink(d.game, "vex-3", Fabrique.UtmTargets.logo) }), this.brandLogo.scale.set(.6, .6)), this.firstButton = new BottomButton(b, 0, 0, "quitLogo", "Main Menu", this.bottomButtons, function() { d.triggerFirst() }), this.firstButton.label.x += 15, this.secondButton = new BottomButton(b, 51, 0, "trophyLogo", this.getlabelText(), this.bottomButtons, function() { d.triggerSecond() }), this.thirdButton = new BottomButton(b, 102, 0, "optionsLogo", "Options", this.bottomButtons, function() { d.triggerThird() }), this.fourthButton = new BottomButton(b, 153, 0, "actSelectLogo", "Act Select", this.bottomButtons, function() { d.triggerFourth() }), this.muteButton = new ExplandButton(b, b.width - 20, 30, "muteButton", this.layer, function() {}, function() {}, function() { Constants.muted ? (Constants.muted = !1, d.main.correctSoundValues(), d.muteButton.sprite.frame = 0) : (Constants.muted = !0, d.main.correctSoundValues(), d.muteButton.sprite.frame = 1) }), this.pauseButton = new ExplandButton(b, 570, 30, "pauseButton", this.layer, function() {}, function() {}, function() { a.pauseWindow.show() }), this.pauseButton.hide()
        }
        return a.prototype.muteTheButton = function(a) {}, a.prototype.getlabelText = function() { return Fabrique.Utils.isOnDevice(this.game) ? "Achievements" : "Trophies" }, a.prototype.update = function() { this.pauseButton.update(), this.muteButton.update() }, a.prototype.changeLevel = function() { "hub" === this.main.currentLevelID ? (this.firstButton.logo.loadTexture("quitLogo"), this.firstButton.labelText.setText("Main Menu"), this.secondButton.logo.loadTexture("trophyLogo"), this.secondButton.labelText.setText(this.getlabelText()), this.thirdButton.logo.loadTexture("optionsLogo"), this.thirdButton.labelText.setText("Options"), this.fourthButton.logo.loadTexture("actSelectLogo"), this.fourthButton.labelText.setText("Act Select"), this.bottomButtons.filters = null, this.muteButton.sprite.filters = null, this.pauseButton.sprite.filters = null, this.brandLogo && (this.brandLogo.visible = !0)) : (this.firstButton.logo.loadTexture("resetLogo"), this.firstButton.labelText.setText("Reset Act"), this.secondButton.logo.loadTexture("quitLogo"), this.secondButton.labelText.setText("Quit Act"), this.thirdButton.logo.loadTexture("trophyLogo"), this.thirdButton.labelText.setText(this.getlabelText()), this.fourthButton.logo.loadTexture("optionsLogo"), this.fourthButton.labelText.setText("Options"), Constants.blend && (this.bottomButtons.filters = [this.main.currentLevel.colorFilter], this.muteButton.sprite.filters = [this.main.currentLevel.colorFilter], this.pauseButton.sprite.filters = [this.main.currentLevel.colorFilter], (Fabrique.Utils.getBrandingDomain() === Fabrique.BrandingDomain.Bild || Fabrique.Branding.isContracted(this.game)) && this.brandLogo && (this.brandLogo.visible = !1))), Fabrique.Utils.isOnDevice(this.game) ? (this.muteButton.sprite.position.set(this.game.width - 160, 20), this.pauseButton.sprite.position.set(this.game.width - 200, 20)) : (this.muteButton.sprite.position.set(this.game.width - 30, 80), this.pauseButton.sprite.position.set(this.game.width - 70, 80)), this.pauseButton.show(), this.bottomButtons.visible = !0 }, a.prototype.enterMainMenu = function() { this.muteButton.sprite.position.set(this.game.width - 20, 30), this.pauseButton.hide(), this.bottomButtons.visible = !1 }, a.prototype.triggerFirst = function() { this.main.state !== GameStates.Window && ("hub" === this.main.currentLevelID ? this.main.exitLevel() : (Constants.actStartTime = Date.now(), this.main.resetLevel())) }, a.prototype.showAchievements = function() { Fabrique.Utils.isOnDevice(this.game) ? SocialServicesHandler.showAchievements(this.game) : this.main.achievementsWindow.show() }, a.prototype.triggerSecond = function() { this.main.state !== GameStates.Window && ("hub" === this.main.currentLevelID ? this.showAchievements() : this.main.exitLevel()) }, a.prototype.triggerThird = function() { this.main.state !== GameStates.Window && ("hub" === this.main.currentLevelID ? this.main.optionsWindow.show() : this.showAchievements()) }, a.prototype.triggerFourth = function() { this.main.state !== GameStates.Window && ("hub" === this.main.currentLevelID ? this.main.actSelectWindow.show() : this.main.optionsWindow.show()) }, a.prototype.resizeStage = function(a, b) { this.bottomButtons.position.y = b - 50, this.logoGroup.position.y = b - 50, this.main.state === GameStates.MainMenu ? this.muteButton.sprite.position.set(a - 20, 30) : Fabrique.Utils.isOnDevice(this.game) ? (this.muteButton.sprite.position.set(this.game.width - 160, 20), this.pauseButton.sprite.position.set(this.game.width - 200, 20)) : (this.muteButton.sprite.position.set(this.game.width - 30, 80), this.pauseButton.sprite.position.set(this.game.width - 70, 80)), this.brandLogo && this.brandLogo.position.set(a - 10, b - 10) }, a
    }(),
    SimpleTransition = function() {
        function a(a, b, c) { this.main = a, this.game = b, this.scaleX = b.width / 640, this.scaleY = b.height / 560, this.topHalf = c.create(0, 0, "simpleTransition"), this.topHalf.scale.set(this.scaleX, this.scaleY), this.bottomHalf = c.create(0, 0, "simpleTransition"), this.bottomHalf.anchor.set(1, 1), this.bottomHalf.scale.set(-this.scaleX, -this.scaleY), this.topHalf.fixedToCamera = !0, this.bottomHalf.fixedToCamera = !0, this.topHalf.visible = !1, this.bottomHalf.visible = !1, this.state = 0 }
        return a.prototype.beginTransition = function(a, b, c) { this.state = 1, this.isHub = c, this.topHalf.cameraOffset.set(0, 0), this.topHalf.anchor.set(0, 0), this.bottomHalf.cameraOffset.set(0, 0), this.bottomHalf.anchor.set(1, 1), this.topHalf.rotation = -90, this.bottomHalf.rotation = 90, this.callback = a, b && this.main.options.blend ? (this.topHalf.filters = [b], this.bottomHalf.filters = [b]) : (this.topHalf.filters = null, this.bottomHalf.filters = null), this.topHalf.visible = !0, this.bottomHalf.visible = !0 }, a.prototype.update = function() {
            var a = this;
            if (1 === this.state) {
                var b = this.topHalf.angle - 0;
                this.topHalf.angle -= b / 10, Math.abs(b) < .5 && (this.topHalf.rotation = 0, this.bottomHalf.rotation = 0, this.topHalf.cameraOffset.set(this.game.width, this.game.height), this.bottomHalf.cameraOffset.set(this.game.width, this.game.height), this.topHalf.anchor.set(1, 1), this.bottomHalf.anchor.set(0, 0), this.isHub || !this.game.device.desktop && !Fabrique.Utils.isOnDevice(this.game) ? (this.state = 2, this.callback()) : (this.state = 0, Fabrique.LoaderHelper.show(), Fabrique.AdHandler.getInstance(this.game).showAd(function() { Fabrique.LoaderHelper.hide(), a.state = 2, a.callback() }, function() { Fabrique.LoaderHelper.hide() }, "level"))), this.bottomHalf.rotation = -this.topHalf.rotation
            }
            else if (2 === this.state) {
                var b = this.topHalf.angle - 60;
                this.topHalf.angle -= b / 10, Math.abs(b) < .5 && (this.topHalf.rotation = 90, this.bottomHalf.rotation = -this.topHalf.rotation, this.state = 0, this.topHalf.visible = !1, this.bottomHalf.visible = !1), this.bottomHalf.rotation = -this.topHalf.rotation
            }
        }, a.prototype.resizeStage = function(a, b) { this.scaleX = a / 640, this.scaleY = b / 560, this.topHalf.scale.set(this.scaleX, this.scaleY), this.bottomHalf.anchor.set(1, 1), this.bottomHalf.scale.set(-this.scaleX, -this.scaleY) }, a
    }(),
    VexWindow = function() {
        function a(a, b, c) { this.main = a, this.game = b, this.layer = c, this.container = b.add.group(c) }
        return a.prototype.init = function() {
            var a = this;
            this.closeButton = this.game.add.sprite(100, -100, "closeButton"), this.closeButton.inputEnabled = !0, this.closeButton.anchor.set(.5, .5), this.closeButton.events.onInputUp.add(function() { a.main.sounds.playSound("buttonClick"), a.hide() }, this), this.container.position.set(this.game.width / 2, -400), this.frame.anchor.set(.5, .5), this.container.addChild(this.frame), this.container.addChild(this.closeButton), this.container.visible = !1, this.showing = !1
        }, a.prototype.show = function() { this.main.state !== GameStates.Playing && this.main.state !== GameStates.MainMenu || (this.container.position.y = -800, this.container.visible = !0, this.showing = !0, this.main.openWindow()) }, a.prototype.hide = function() { this.showing = !1, this.main.closeWindow() }, a.prototype.update = function() {
            if (this.showing) {
                var a = this.game.height / 2,
                    b = this.container.position.y - a;
                b > -2 ? this.container.position.y = a : this.container.position.y -= b / 4
            }
            else {
                var a = this.game.height + 800,
                    b = this.container.y - a;
                this.container.position.y > this.game.height + 500 ? (this.container.position.y = 900, this.container.visible = !1) : this.container.position.y -= b / 4
            }
        }, a.prototype.resizeStage = function(a, b) { this.container.x = a / 2 }, a
    }(),
    ActSelectButton = function() {
        function a() {}
        return a
    }(),
    ActSelectWindow = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b, c, d) || this;
            e.frame = d.create(0, 0, "actSelectSmall"), e.frame.scale.x = (c.width - 80) / 330, e.frame.scale.y = (c.height - 120) / 330, e.buttons = [];
            var f = Math.floor((c.width - 120) / 90);
            e.init();
            for (var g = function(a) {
                    var d = b.levels.levels[a + 1],
                        g = new ActSelectButton,
                        i = c.add.sprite(120 - c.width / 2 + a % f * 90, -c.height / 2 + 140 + 100 * Math.floor(a / f), "act" + (a + 1) + "-button");
                    h.container.addChild(i), i.inputEnabled = !0, i.anchor.set(.5, 0), i.scale.set(.8, .8), i.events.onInputUp.add(function() { e.main.portToActBlock(a + 1), e.hide() }, h), g.sprite = i;
                    var j = c.add.sprite(-4, 32, d.getRankSpriteKey());
                    j.anchor.set(.5, 0), j.scale.set(.35, .35), g.rank = j, i.addChild(j);
                    var k = c.add.sprite(-18, 60, "completedIcon");
                    k.anchor.set(.5, .5), k.scale.set(.5, .5), g.trophy = k, d.gotGold() && (k.frame = 1), i.addChild(k);
                    var l = c.add.sprite(-2, 60, "starIcon");
                    l.anchor.set(.5, .5), l.scale.set(.5, .5), g.star = l, i.addChild(l), d.gotStar && (l.frame = 1);
                    var m = c.add.sprite(12, 60, "challengeIcon");
                    m.anchor.set(.5, .5), m.scale.set(.5, .5), g.saw = m, d.challengeCompleted && (m.frame = 1), i.addChild(m), "10" === d.id && (m.visible = !1, l.x = 12), h.buttons.push(g), d.topTime === -1 && (i.visible = !1)
                }, h = this, i = 0; i < 10; i++) g(i);
            return e.resizeStage(c.width, c.height), e
        }
        return __extends(b, a), b.prototype.resetWindow = function() {
            for (var a = 0; a < 10; a++) {
                var b = this.main.levels.levels[a + 1],
                    c = this.buttons[a];
                b.topTime !== -1 && (c.sprite.visible = !0, c.rank.loadTexture(b.getRankSpriteKey()), b.challengeCompleted && (c.saw.frame = 1), b.gotStar && (c.star.frame = 1), b.gotGold() && (c.trophy.frame = 1))
            }
        }, b.prototype.resizeStage = function(a, b) {
            if (this.container.position.x = a / 2, this.frame.scale.x = (a - 60) / 330, this.frame.scale.y = (b - 100) / 330, a + b < 1100)
                for (var c = Math.floor((a - 120) / 70), d = 0; d < 10; d++) {
                    var e = this.buttons[d];
                    e.sprite.scale.set(.8, .8), e.sprite.position.x = 100 - a / 2 + d % c * 70, e.sprite.position.y = -b / 2 + 60 + 70 * Math.floor(d / c)
                }
            else
                for (var c = Math.floor((a - 120) / 100), d = 0; d < 10; d++) {
                    var e = this.buttons[d];
                    e.sprite.scale.set(1, 1), e.sprite.position.x = 100 - a / 2 + d % c * 100, e.sprite.position.y = -b / 2 + 120 + 100 * Math.floor(d / c)
                }
            this.closeButton.position.set(150 * this.frame.scale.x, -160 * this.frame.scale.y)
        }, b
    }(VexWindow),
    AchievementUnlocked = function() {
        function a(a, b, c) { this.main = a, this.game = b, this.layer = c, this.container = b.add.group(c), this.container.position.set(650, 80), this.frame = this.container.create(0, 0, "achievementUnlocked"), this.screenX = b.width, this.container.visible = !1, this.icon = b.add.sprite(56, 50, "act1Achievement"), this.icon.anchor.set(.5, .5), this.container.addChild(this.icon), this.nameText = b.add.bitmapText(86, 40, "grob24", "", 12), this.container.addChild(this.nameText), this.showing = !1 }
        return a.prototype.show = function(a) { this.container.position.x = this.game.width, this.container.visible = !0, this.showing = !0, this.showTime = 120, this.icon.loadTexture(a.spriteKey), this.nameText.setText(a.name), this.nameText.maxWidth = .3 * this.container.width, this.main.sounds.playSound("achievementUnlocked") }, a.prototype.hide = function() { this.showing = !1 }, a.prototype.update = function() {
            if (this.showing) {
                if (this.showTime--, this.showTime <= 0) return void this.hide();
                var a = this.container.position.x - this.game.width + 150;
                a < 5 ? this.container.position.x = this.game.width - 150 : this.container.position.x -= a / 4
            }
            else {
                var a = this.container.position.x - this.game.width;
                this.container.position.x > this.game.width ? (this.container.position.x = this.game.width, this.container.visible = !1) : this.container.position.x -= a / 4
            }
        }, a.prototype.resetWindow = function() {}, a
    }(),
    StuckPopup = function() {
        function a(a, b, c) { this.main = a, this.game = b, this.layer = c, this.container = b.add.group(c), this.container.position.set(b.width / 2, -60), this.frame = this.container.create(0, 0, "stuckWindow"), this.frame.anchor.set(.5, .5), this.screenX = b.width, this.container.visible = !1, this.showing = !1, this.frame.inputEnabled = !0, this.frame.events.onInputUp.add(function() { window.open(Constants.tutorialURL, "_blank") }) }
        return a.prototype.show = function(a) { this.level = a, this.container.position.x = this.game.width / 2, this.container.position.y = -60, this.container.visible = !0, this.showing = !0 }, a.prototype.hide = function() { this.showing = !1 }, a.prototype.update = function() {
            if (this.showing) {
                var a = this.container.position.y - 35;
                a > -5 ? this.container.position.y = 35 : this.container.position.y -= a / 4
            }
            else {
                var a = this.container.position.y + 60;
                this.container.position.y < -55 ? (this.container.position.y = -60, this.container.visible = !1) : this.container.position.y -= a / 4
            }
        }, a.prototype.resizeWindow = function(a, b) { this.container.position.x = a / 2 }, a
    }(),
    ExplandButton = function() {
        function a(a, b, c, d, e, f, g, h) {
            var i = this;
            this.game = a, this.sprite = a.add.sprite(b, c, d), this.sprite.anchor.set(.5, .5), this.sprite.inputEnabled = !0, e.addChild(this.sprite), this.sprite.events.onInputOver.add(function() { f(), i.over = !0 }), this.sprite.events.onInputOut.add(function() { g(), i.over = !1 }), this.sprite.events.onInputUp.add(function() { h() }), this.scale = 1, this.scaleOff = 1, this.over = !1
        }
        return a.prototype.update = function() {
            if (this.sprite.visible && (this.sprite.scale.set(this.scale * this.scaleOff, this.scale * this.scaleOff), this.game.device.desktop)) {
                if (this.over) {
                    if (this.scale < 1.1) {
                        var a = this.scale - 1.1;
                        a > -.01 ? this.scale = 1.1 : this.scale -= a / 6, this.sprite.scale.set(this.scale * this.scaleOff, this.scale * this.scaleOff)
                    }
                }
                else if (this.scale > 1) {
                    var a = this.scale - 1;
                    a < .01 ? this.scale = 1 : this.scale -= a / 6, this.sprite.scale.set(this.scale * this.scaleOff, this.scale * this.scaleOff)
                }
                this.sprite.scale.set(this.scale * this.scaleOff, this.scale * this.scaleOff)
            }
        }, a.prototype.hide = function() { this.sprite.visible = !1 }, a.prototype.show = function() { this.sprite.visible = !0 }, a
    }(),
    AchievementsWindow = function(a) {
        function b(c, d, e) {
            var f = a.call(this, c, d, e) || this;
            f.offscreenX = 700, f.frame = e.create(0, 0, "actSelectSmall"), f.frame.scale.x = (d.width - 80) / 330, f.frame.scale.y = (d.height - 120) / 330, f.init(), f.closeButton.position.set(520, -50), f.buttons = [], b.GRAY_FILTER || (b.GRAY_FILTER = d.add.filter("Gray"));
            var g = Math.floor(100 * c.achievements.getTotalProgress()) + "% Total";
            f.totalProgressText = d.add.bitmapText(280, 10, "grob24", g, 24), f.container.addChild(f.totalProgressText), f.buttonScreen = d.add.group(), f.container.addChild(f.buttonScreen), f.standardActsButton = new ExplandButton(d, 160, 120, "standardActsButton", f.buttonScreen, function() { f.bottomText.setText("Standard Acts - Completing the standard acts, 1 to the Vexation") }, function() { f.bottomText.setText("") }, function() { f.main.sounds.playSound("buttonClick"), f.showScreen(f.standardActsScreen) }), f.standardActsProgressBar = d.add.sprite(-48, 75, "achievementProgressBar"), f.standardActsButton.sprite.addChild(f.standardActsProgressBar), f.standardActsProgressBar.scale.x = Math.max(.01, c.achievements.getStandardActsProgress()), f.standardActsProgressBar.anchor.set(0, .5), g = Math.floor(100 * c.achievements.getStandardActsProgress()) + "%", f.standardActsProgressText = d.add.bitmapText(0, 75, "grob24", g, 14), f.standardActsProgressText.anchor.set(.5, .5), f.standardActsButton.sprite.addChild(f.standardActsProgressText), f.buttons.push(f.standardActsButton), f.challengeActsButton = new ExplandButton(d, 400, 135, "challengeActsButton", f.buttonScreen, function() { f.bottomText.setText("Hardcore - Completing the challenge acts and finding hidden stars") }, function() { f.bottomText.setText("") }, function() { f.main.sounds.playSound("buttonClick"), f.showScreen(f.hardcoreScreen) }), f.hardcoreProgressBar = d.add.sprite(-48, 65, "achievementProgressBar"), f.challengeActsButton.sprite.addChild(f.hardcoreProgressBar), f.hardcoreProgressBar.scale.x = Math.max(.01, c.achievements.getHardcoreProgress()), f.hardcoreProgressBar.anchor.set(0, .5), g = Math.floor(100 * c.achievements.getHardcoreProgress()) + "%", f.hardcoreProgressText = d.add.bitmapText(0, 65, "grob24", g, 14), f.hardcoreProgressText.anchor.set(.5, .5), f.challengeActsButton.sprite.addChild(f.hardcoreProgressText), f.buttons.push(f.challengeActsButton), f.awesomeStuffButton = new ExplandButton(d, 160, 290, "awesomeStuffButton", f.buttonScreen, function() { f.bottomText.setText("Awesome Stuff - Performing hard and tricky feats") }, function() { f.bottomText.setText("") }, function() { f.main.sounds.playSound("buttonClick"), f.showScreen(f.awesomeScreen) }), f.buttons.push(f.awesomeStuffButton), f.awesomeProgressBar = d.add.sprite(-48, 65, "achievementProgressBar"), f.awesomeStuffButton.sprite.addChild(f.awesomeProgressBar), f.awesomeProgressBar.scale.x = Math.max(.01, c.achievements.getAwesomeProgress()), f.awesomeProgressBar.anchor.set(0, .5), g = Math.floor(100 * c.achievements.getAwesomeProgress()) + "%", f.awesomeProgressText = d.add.bitmapText(0, 65, "grob24", g, 14), f.awesomeProgressText.anchor.set(.5, .5), f.awesomeStuffButton.sprite.addChild(f.awesomeProgressText), f.completionButton = new ExplandButton(d, 400, 290, "completionButton", f.buttonScreen, function() { f.bottomText.setText("Completion - A round-up of the other categories") }, function() { f.bottomText.setText("") }, function() { f.main.sounds.playSound("buttonClick"), f.showScreen(f.completionScreen) }), f.completionProgressBar = d.add.sprite(-48, 55, "achievementProgressBar"), f.completionButton.sprite.addChild(f.completionProgressBar), f.completionProgressBar.scale.x = Math.max(.01, c.achievements.getCompletionProgress()), f.completionProgressBar.anchor.set(0, .5), g = Math.floor(100 * c.achievements.getCompletionProgress()) + "%", f.completionProgressText = d.add.bitmapText(0, 55, "grob24", g, 14), f.completionProgressText.anchor.set(.5, .5), f.completionButton.sprite.addChild(f.completionProgressText), f.buttons.push(f.completionButton), f.standardActsScreen = d.add.group(), f.standardButtons = [], f.container.addChild(f.standardActsScreen);
            for (var h = function(a) {
                    var c = i.main.achievements.standardActs[a],
                        e = new ExplandButton(d, 80 + a % 8 * 60, 120 + 60 * Math.floor(a / 8), c.spriteKey, i.standardActsScreen, function() { f.bottomText.setText(c.name + " - " + c.description) }, function() { f.bottomText.setText("") }, function() {});
                    c.completed || (e.sprite.filters = [b.GRAY_FILTER]), c.icon = e, i.standardButtons.push(e), i.buttons.push(e)
                }, i = this, j = 0; j < f.main.achievements.standardActs.length; j++) h(j);
            f.backButton = d.add.sprite(60, 300, "backButton"), f.backButton.visible = !1, f.backButton.inputEnabled = !0, f.backButton.events.onInputUp.add(function() { f.showMainScreen() }), f.container.addChild(f.backButton), f.standardActsScreen.visible = !1, f.hardcoreScreen = d.add.group(), f.container.addChild(f.hardcoreScreen), f.hardcoreButtons = [];
            for (var k = function(a) {
                    var c = l.main.achievements.hardcore[a],
                        e = new ExplandButton(d, 80 + a % 8 * 60, 120 + 60 * Math.floor(a / 8), c.spriteKey, l.hardcoreScreen, function() {
                            f.bottomText.setText(c.name + " - " + c.description)
                        }, function() { f.bottomText.setText("") }, function() {});
                    e.sprite.scale.set(.7, .7), c.completed || (e.sprite.filters = [b.GRAY_FILTER]), c.icon = e, l.buttons.push(e), l.hardcoreButtons.push(e)
                }, l = this, j = 0; j < f.main.achievements.hardcore.length; j++) k(j);
            f.hardcoreScreen.visible = !1, f.awesomeScreen = d.add.group(), f.container.addChild(f.awesomeScreen), f.awesomeButtons = [];
            for (var m = function(a) {
                    var c = n.main.achievements.awesome[a],
                        e = new ExplandButton(d, 80 + a % 8 * 60, 120 + 60 * Math.floor(a / 8), c.spriteKey, n.awesomeScreen, function() { f.bottomText.setText(c.name + " - " + c.description) }, function() { f.bottomText.setText("") }, function() {});
                    c.completed || (e.sprite.filters = [b.GRAY_FILTER]), c.icon = e, n.buttons.push(e), n.awesomeButtons.push(e)
                }, n = this, j = 0; j < f.main.achievements.awesome.length; j++) m(j);
            f.awesomeScreen.visible = !1, f.completionScreen = d.add.group(), f.container.addChild(f.completionScreen), f.completionButtons = [];
            for (var o = function(a) {
                    var c = p.main.achievements.completion[a],
                        e = new ExplandButton(d, 80 + a % 8 * 60, 120 + 60 * Math.floor(a / 8), c.spriteKey, p.completionScreen, function() { f.bottomText.setText(c.name + " - " + c.description) }, function() { f.bottomText.setText("") }, function() {});
                    c.completed || (e.sprite.filters = [b.GRAY_FILTER]), c.icon = e, p.buttons.push(e), p.completionButtons.push(e)
                }, p = this, j = 0; j < f.main.achievements.completion.length; j++) o(j);
            return f.completionScreen.visible = !1, f.bottomText = d.add.bitmapText(-100, 170, "grob24", "", 14), f.container.addChild(f.bottomText), f.showingScreen = !1, f.currentScreen = f.buttonScreen, f.resizeStage(d.width, d.height), f
        }
        return __extends(b, a), b.prototype.updateProgress = function() {
            var a = Math.floor(100 * this.main.achievements.getTotalProgress()) + "% Total Completion";
            this.totalProgressText.setText(a), a = Math.floor(100 * this.main.achievements.getCompletionProgress()) + "%", this.completionProgressText.setText(a), this.completionProgressBar.scale.x = Math.max(.01, this.main.achievements.getCompletionProgress()), a = Math.floor(100 * this.main.achievements.getAwesomeProgress()) + "%", this.awesomeProgressText.setText(a), this.awesomeProgressBar.scale.x = Math.max(.01, this.main.achievements.getAwesomeProgress()), a = Math.floor(100 * this.main.achievements.getHardcoreProgress()) + "%", this.hardcoreProgressText.setText(a), this.hardcoreProgressBar.scale.x = Math.max(.01, this.main.achievements.getHardcoreProgress()), a = Math.floor(100 * this.main.achievements.getStandardActsProgress()) + "%", this.standardActsProgressText.setText(a), this.standardActsProgressBar.scale.x = Math.max(.01, this.main.achievements.getStandardActsProgress())
        }, b.prototype.showScreen = function(a) { this.game.analytics.google.sendScreenView("trophies"), this.currentScreen.visible = !1, a.visible = !0, this.currentScreen = a, this.backButton.visible = !0, this.totalProgressText.visible = !1 }, b.prototype.showMainScreen = function() { this.showScreen(this.buttonScreen), this.backButton.visible = !1, this.totalProgressText.visible = !0 }, b.prototype.update = function() {
            a.prototype.update.call(this);
            for (var b = 0, c = this.buttons; b < c.length; b++) {
                var d = c[b];
                d.update()
            }
        }, b.prototype.resizeStage = function(a, b) {
            if (this.container.position.x = a / 2, this.frame.scale.x = (a - 60) / 330, this.frame.scale.y = (b - 60) / 330, a + b < 1100 ? (this.standardActsButton.scaleOff = .7, this.challengeActsButton.scaleOff = .7, this.awesomeStuffButton.scaleOff = .7, this.completionButton.scaleOff = .7, this.standardActsButton.sprite.scale.set(this.standardActsButton.scale * this.standardActsButton.scaleOff), this.challengeActsButton.sprite.scale.set(this.challengeActsButton.scale * this.challengeActsButton.scaleOff), this.awesomeStuffButton.sprite.scale.set(this.awesomeStuffButton.scale * this.awesomeStuffButton.scaleOff), this.completionButton.sprite.scale.set(this.completionButton.scale * this.completionButton.scaleOff), a < b ? (this.standardActsButton.sprite.position.set(0, -180), this.challengeActsButton.sprite.position.set(0, -60), this.awesomeStuffButton.sprite.position.set(0, 70), this.completionButton.sprite.position.set(0, 180), this.bottomText.visible = !1, this.backButton.position.set(60 * this.frame.scale.x, 105 * this.frame.scale.y)) : (this.standardActsButton.sprite.position.set(-100, -55), this.challengeActsButton.sprite.position.set(100, -55), this.awesomeStuffButton.sprite.position.set(-100, 55), this.completionButton.sprite.position.set(100, 55), this.bottomText.visible = !0, this.backButton.position.set(80 * this.frame.scale.x, 105 * this.frame.scale.y))) : a < b ? (this.standardActsButton.sprite.position.set(0, -180), this.challengeActsButton.sprite.position.set(0, -60), this.awesomeStuffButton.sprite.position.set(0, 70), this.completionButton.sprite.position.set(0, 180), this.bottomText.visible = !1, this.backButton.position.set(60 * this.frame.scale.x, 105 * this.frame.scale.y)) : (this.standardActsButton.sprite.position.set(-a / 4 + 40, -b / 4 + 40), this.challengeActsButton.sprite.position.set(a / 4 - 40, -b / 4 + 40), this.awesomeStuffButton.sprite.position.set(-a / 4 + 40, b / 4 - 40), this.completionButton.sprite.position.set(a / 4 - 40, b / 4 - 40), this.bottomText.visible = !0, this.backButton.position.set(80 * this.frame.scale.x, 105 * this.frame.scale.y)), a + b < 1100) {
                for (var c = Math.floor((a - 120) / 70), d = 0; d < this.standardButtons.length; d++) {
                    var e = this.standardButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 70, e.sprite.position.y = -b / 2 + 80 + 70 * Math.floor(d / c), e.scaleOff = .8
                }
                for (var f = Math.floor((a - 120) / 60), d = 0; d < this.hardcoreButtons.length; d++) {
                    var e = this.hardcoreButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % f * 60, e.sprite.position.y = -b / 2 + 80 + 60 * Math.floor(d / f), e.scaleOff = .8
                }
                for (var d = 0; d < this.awesomeButtons.length; d++) {
                    var e = this.awesomeButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 70, e.sprite.position.y = -b / 2 + 80 + 70 * Math.floor(d / c), e.scaleOff = .8
                }
                for (var d = 0; d < this.completionButtons.length; d++) {
                    var e = this.completionButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 70, e.sprite.position.y = -b / 2 + 80 + 70 * Math.floor(d / c), e.scaleOff = .8
                }
            }
            else {
                for (var c = Math.floor((a - 120) / 100), d = 0; d < this.standardButtons.length; d++) {
                    var e = this.standardButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 100, e.sprite.position.y = -b / 2 + 80 + 100 * Math.floor(d / c), e.scaleOff = 1
                }
                for (var f = Math.floor((a - 120) / 80), d = 0; d < this.hardcoreButtons.length; d++) {
                    var e = this.hardcoreButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % f * 80, e.sprite.position.y = -b / 2 + 80 + 80 * Math.floor(d / f), e.scaleOff = 1
                }
                for (var d = 0; d < this.awesomeButtons.length; d++) {
                    var e = this.awesomeButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 100, e.sprite.position.y = -b / 2 + 80 + 100 * Math.floor(d / c), e.scaleOff = 1
                }
                for (var d = 0; d < this.completionButtons.length; d++) {
                    var e = this.completionButtons[d];
                    e.sprite.position.x = 100 - a / 2 + d % c * 70, e.sprite.position.y = -b / 2 + 80 + 100 * Math.floor(d / c), e.scaleOff = 1
                }
            }
            this.closeButton.position.set(150 * this.frame.scale.x, -160 * this.frame.scale.y), this.bottomText.position.set(-140 * this.frame.scale.x, 145 * this.frame.scale.y), this.totalProgressText.position.set(-145 * this.frame.scale.x, -160 * this.frame.scale.y)
        }, b
    }(VexWindow),
    OptionSlider = function() {
        function a(a, b, c, d, e, f, g) { this.game = a, this.container = a.add.group(), this.container.position.set(c, d), b.addChild(this.container), this.slider = a.add.sprite(-75, 0, "slider"), this.slider.anchor.set(0, .5), this.slideDrag = a.add.sprite(150 * e, 0, "slideDrag"), this.slideDrag.anchor.set(.5, .5), this.slider.addChild(this.slideDrag), this.container.addChild(this.slider), this.slider.inputEnabled = !0, this.slider.events.onInputDown.add(this.setDrag, this), this.stopCall = g, this.labelText = a.add.bitmapText(0, -40, "grob24", f, 16), this.labelText.anchor.set(.5, 0), this.container.addChild(this.labelText), this.xPos = c }
        return a.prototype.setPos = function(a, b) { this.xPos = a, this.container.position.set(a, b) }, a.prototype.setDrag = function(a, b) { this.sliding = !0 }, a.prototype.setValue = function(a) { this.slideDrag.position.x = 150 * a, this.stopCall(a) }, a.prototype.stopDrag = function() {
            if (this.sliding) {
                this.sliding = !1;
                var a = Math.max(Math.min(150, this.game.input.activePointer.position.x - this.xPos + 75 - this.game.width / 2), 0);
                this.stopCall(a / 150)
            }
        }, a.prototype.update = function() { this.sliding && (this.slideDrag.position.x = this.game.input.activePointer.position.x - this.xPos + 75 - this.game.width / 2, this.slideDrag.position.x = Math.max(Math.min(150, this.slideDrag.position.x), 0)) }, a
    }(),
    OptionTick = function() {
        function a(a, b, c, d, e, f, g, h) { this.container = a.add.group(), b.addChild(this.container), this.sprite = a.add.sprite(0, 0, "tickButton"), this.sprite.anchor.set(.5, .5), this.container.addChild(this.sprite), this.sprite.inputEnabled = !0, this.sprite.events.onInputUp.add(this.toggle, this), this.labelText = a.add.bitmapText(10, 0, "grob24", f, 16), this.labelText.anchor.set(1, .5), this.labelText.align = "center", this.container.addChild(this.labelText), this.enabled = e, this.enabled || (this.sprite.frame = 1), this.onCall = g, this.offCall = h }
        return a.prototype.toggle = function() { this.enabled ? (this.enabled = !1, this.sprite.frame = 1, this.offCall()) : (this.enabled = !0, this.sprite.frame = 0, this.onCall()) }, a.prototype.setValue = function(a) { this.enabled = a, a ? this.sprite.frame = 0 : this.sprite.frame = 1 }, a
    }(),
    OptionsWindow = function(a) {
        function b(b, c, d) {
            var e = a.call(this, b, c, d) || this;
            e.frame = d.create(0, 0, "actSelectSmall"), e.frame.scale.x = (c.width - 80) / 330, e.frame.scale.y = (c.height - 120) / 330;
            Math.floor((c.width - 120) / 90);
            return e.items = [], e.init(), e.closeButton.position.set(150, -15), e.titleText = c.add.bitmapText(0, 0, "grob24", "Options", 24), e.container.addChild(e.titleText), e.sliders = [], e.bgmVolumeSlider = new OptionSlider(c, e.container, 20, 150, Constants.musicVolume, "Music Volume - " + Math.round(100 * Constants.musicVolume), function(a) { Constants.musicVolume = a, Constants.musicVolume = a, Constants.muted === !1 && (b.buttonSet.muteButton.sprite.frame = 0, b.options.musicVolume = Constants.musicVolume, b.options.effectVolume = Constants.effectVolume, b.sounds.currentMusic && (b.sounds.currentMusic.volume = Constants.musicVolume)), SaveGame.getInstance().saveOptions(), e.bgmVolumeSlider.labelText.setText("Music Volume - " + Math.round(100 * Constants.musicVolume)) }), e.sliders.push(e.bgmVolumeSlider), e.effectVolumeSlider = new OptionSlider(c, e.container, 20, 210, Constants.effectVolume, "Effect Volume - " + Math.round(100 * Constants.effectVolume), function(a) { Constants.effectVolume = a, Constants.effectVolume = a, Constants.muted === !1 && (b.buttonSet.muteButton.sprite.frame = 0, b.options.musicVolume = Constants.musicVolume, b.options.effectVolume = Constants.effectVolume, b.sounds.currentMusic && (b.sounds.currentMusic.volume = Constants.musicVolume)), SaveGame.getInstance().saveOptions(), e.effectVolumeSlider.labelText.setText("Effect Volume - " + Math.round(100 * Constants.effectVolume)) }), e.sliders.push(e.effectVolumeSlider), e.particleLimitSlider = new OptionSlider(c, e.container, 410, 155, Constants.particleLimit / 100, "Particle Limit - " + Math.round(b.options.particleLimit), function(a) { Constants.particleLimit = 100 * a, SaveGame.getInstance().saveOptions(), e.particleLimitSlider.labelText.setText("Particle Limit - " + Math.round(Constants.particleLimit)) }), e.sliders.push(e.particleLimitSlider), c.input.onUp.add(function() {
                for (var a = 0, b = e.sliders; a < b.length; a++) {
                    var c = b[a];
                    c.stopDrag()
                }
            }), e.game.device.desktop || (e.controllerSelect = new OptionTick(c, e.container, 240, 410, Constants.blend, "Old Controls", function() { Constants.oldControls = !0, SaveGame.getInstance().saveOptions() }, function() { Constants.oldControls = !1, SaveGame.getInstance().saveOptions() })), e.autoResetTick = new OptionTick(c, e.container, 120, 420, Constants.autoReset, "Auto Reset When\nBest Time Passed", function() { Constants.autoReset = !0, SaveGame.getInstance().saveOptions() }, function() { Constants.autoReset = !1, SaveGame.getInstance().saveOptions() }), e.blendTick = new OptionTick(c, e.container, 450, 240, Constants.blend, "Blend Mode", function() { Constants.blend = !0, SaveGame.getInstance().saveOptions() }, function() { Constants.blend = !1, SaveGame.getInstance().saveOptions() }), e.parallaxTick = new OptionTick(c, e.container, 490, 320, Constants.parallax, "Background Parallax", function() { Constants.parallax = !0, SaveGame.getInstance().saveOptions() }, function() { Constants.parallax = !1, SaveGame.getInstance().saveOptions() }), e.noClear = c.add.sprite(445, 470, "optionsNoClear"), e.noClear.anchor.set(.5, .5), e.container.addChild(e.noClear), e.noClear.visible = !1, e.clearAllButton = new ExplandButton(c, 0, 0, "clearAllButton", e.container, function() {}, function() {}, function() { e.main.clearAllSavedData(), e.hide() }), e.clearAllButton.hide(), e.resizeStage(c.width, c.height), e
        }
        return __extends(b, a), b.prototype.updateValues = function() { this.bgmVolumeSlider.setValue(Constants.musicVolume), this.effectVolumeSlider.setValue(Constants.effectVolume), Constants.particleLimit = Constants.particleLimit / 100, this.particleLimitSlider.setValue(Constants.particleLimit), this.autoResetTick.setValue(Constants.autoReset), this.parallaxTick.setValue(Constants.parallax), this.controllerSelect && this.controllerSelect.setValue(Constants.oldControls), this.blendTick.setValue(Constants.blend) }, b.prototype.show = function() { this.game.analytics.google.sendScreenView("options"), "mainmenu" === this.main.currentLevelID ? this.clearAllButton.show() : this.noClear.visible = !0, a.prototype.show.call(this) }, b.prototype.hide = function() { this.clearAllButton.hide(), this.noClear.visible = !1, a.prototype.hide.call(this) }, b.prototype.update = function() {
            a.prototype.update.call(this);
            for (var b = 0, c = this.sliders; b < c.length; b++) {
                var d = c[b];
                d.update()
            }
            this.clearAllButton.update()
        }, b.prototype.resizeStage = function(a, b) { this.container.position.x = a / 2, this.frame.scale.x = (a - 60) / 330, this.frame.scale.y = (b - 60) / 330, a < b ? (this.bgmVolumeSlider.setPos(0, -150), this.effectVolumeSlider.setPos(0, -90), this.particleLimitSlider.setPos(0, -30), this.controllerSelect && this.controllerSelect.container.position.set(40, 40), this.blendTick.container.position.set(40, 80), this.autoResetTick.container.position.set(40, 120), this.parallaxTick.container.position.set(40, 160), this.clearAllButton.sprite.position.set(0, 240), this.noClear.position.set(0, 230)) : b < 350 ? (this.bgmVolumeSlider.setPos(-100, -20), this.effectVolumeSlider.setPos(100, -60), this.particleLimitSlider.setPos(-100, 35), this.controllerSelect && this.controllerSelect.container.position.set(-100, 40), this.blendTick.container.position.set(-100, 70), this.autoResetTick.container.position.set(140, -10), this.parallaxTick.container.position.set(140, 20), this.clearAllButton.sprite.position.set(110, 70), this.noClear.position.set(110, 130)) : (this.bgmVolumeSlider.setPos(-a / 4 + 40, 10), this.effectVolumeSlider.setPos(-a / 4 + 40, -60), this.particleLimitSlider.setPos(-a / 4 + 40, 80), this.controllerSelect && this.controllerSelect.container.position.set(a / 4, -60), this.blendTick.container.position.set(a / 4, -20), this.autoResetTick.container.position.set(a / 4, 20), this.parallaxTick.container.position.set(a / 4, 60), this.clearAllButton.sprite.position.set(a / 4, 120), this.noClear.position.set(a / 4, 120)), this.titleText.position.set(-140 * this.frame.scale.x, -150 * this.frame.scale.y), this.closeButton.position.set(150 * this.frame.scale.x, -160 * this.frame.scale.y) }, b
    }(VexWindow),
    PauseWindow = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.frame = c.add.sprite(0, 0, "pauseWindow"), e.game = c, e.showY = 170, e.init(), Fabrique.Branding.isAirfi() || (e.brandLogo = Fabrique.Branding.getLogoWithLink(e.game, "vex-3"), e.container.addChild(e.brandLogo), e.brandLogo.inputEnabled = Fabrique.Branding.outGoingLinksAllowed(), e.brandLogo.input.useHandCursor = !0, e.brandLogo.anchor.set(.5, .5), e.brandLogo.scale.set(.8, .8), e.brandLogo.position.set(150 * e.frame.scale.x - 150, -160 * e.frame.scale.y + 200), e.brandLogo.events.onInputUp.add(function() { Fabrique.Branding.openCampaignLink(e.game, "vex-3", Fabrique.UtmTargets.logo) })), e.closeButton.position.set(120, -80), e }
        return __extends(b, a), b.prototype.show = function() { a.prototype.show.call(this), Constants.pausedMapTime = Date.now(), null !== Constants.actStartTime && (Constants.pausedActTime = Date.now()) }, b.prototype.hide = function() {
            a.prototype.hide.call(this);
            var b = Date.now(),
                c = b - Constants.pausedMapTime;
            if (Constants.levelMapStartTime += c, null !== Constants.actStartTime) {
                var d = Date.now(),
                    e = d - Constants.pausedActTime;
                Constants.actStartTime += e
            }
        }, b
    }(VexWindow),
    MainMenu = function() {
        function a(a, b, c) {
            var d = this;
            b.analytics.google.sendScreenView("menu"), this.game = b, this.buttonLayer = b.add.group(c), Fabrique.Branding.isAirfi() || (this.moreGames = new Fabrique.MoreGames.Menu(this.game, "vex-3"), this.moreGames.x = this.game.width / 2, this.moreGames.y = this.game.height / 2), this.optionsButton = new ExplandButton(b, 550, 320, "menuOptions", this.buttonLayer, function() {}, function() {}, function() { a.state === GameStates.MainMenu && a.optionsWindow.show() }), this.achievementsButton = new ExplandButton(b, 270, 460, this.getTrophyBtnImageName(), this.buttonLayer, function() {}, function() {}, function() { d.showAchievements(a) }), Fabrique.Branding.isAirfi() || (this.moreGamesButton = new ExplandButton(b, 420, 460, this.getMoreGamesBtnImageName(), this.buttonLayer, function() {}, function() {}, function() { d.showMoreGames() })), (Fabrique.Utils.getBrandingDomain() === Fabrique.BrandingDomain.Bild || Fabrique.Branding.isContracted(this.game)) && this.moreGamesButton && (this.moreGamesButton.sprite.visible = !1), Fabrique.Utils.isOnDevice(this.game) && SocialServicesHandler.login(this.game), this.playButton = new ExplandButton(b, 120, 320, "menuPlayGame", this.buttonLayer, function() {}, function() {}, function() { a.state === GameStates.MainMenu && a.changeLevel("hub", -1) }), this.playButton.scaleOff = .8, this.vex4Button = new ExplandButton(b, 680, 540, "vex4Logo", this.buttonLayer, function() {}, function() {}, function() { d.vex4Link() }), this.windowOpen = !1, this.buttonLayer.y = b.height + 400, this.vexLogo = c.create(320, -200, "vexLogo"), this.vexLogo.anchor.set(.5, .5), this.logoAni = 0, this.buttonTarY = 0, Fabrique.Branding.isAirfi() || (this.brandLogo = Fabrique.Branding.getLogoWithLink(this.game, "vex-3"), c.add(this.brandLogo), this.brandLogo.inputEnabled = Fabrique.Branding.outGoingLinksAllowed(), this.brandLogo.input.useHandCursor = !0, this.brandLogo.events.onInputUp.add(function() { Fabrique.Branding.openCampaignLink(d.game, "vex-3", Fabrique.UtmTargets.logo) }), this.brandLogo.scale.set(.6, .6)), this.resizeStage(b.width, b.height), this.logoScale = 1, this.vexLogo.scale.set(this.logoScale * this.extraScale), this.vexLogoTarY = 60, Fabrique.Utils.isOnDevice(this.game) || Fabrique.Branding.isAirfi() || this.game.add.existing(this.moreGames)
        }
        return a.prototype.getTrophyBtnImageName = function() { return Fabrique.Utils.isOnDevice(this.game) ? "menuAchievements" : "menuTrophy" }, a.prototype.getMoreGamesBtnImageName = function() { return Fabrique.Utils.isOnDevice(this.game) ? "menuLeaderBoard" : "menuMoreGames" }, a.prototype.showMoreGames = function() { Fabrique.Utils.isOnDevice(this.game) ? SocialServicesHandler.showLeaderboards(this.game) : this.moreGames && this.moreGames.show() }, a.prototype.showAchievements = function(a) { Fabrique.Utils.isOnDevice(this.game) ? SocialServicesHandler.showAchievements(this.game) : a.state === GameStates.MainMenu && a.achievementsWindow.show() }, a.prototype.vex4Link = function() { window.open("https://kizi.com/games/vex-4?utm_source=" + window.location.host + "&utm_medium=html5&utm_term=vex-4&utm_content=vex3&utm_campaign=Gamedistribution", "_blank") }, a.prototype.enterMenu = function() { this.logoAni = 0, this.vexLogo.position.y = -200, this.buttonLayer.y = 600, this.logoScale = 1 }, a.prototype.update = function() {
            if (this.playButton.update(), this.optionsButton.update(), this.achievementsButton.update(), this.vex4Button.update(), this.moreGamesButton && this.moreGamesButton.update(), 0 === this.logoAni) {
                if (this.vexLogo.y < 260) {
                    var a = this.vexLogo.y - 260;
                    a > -5 ? (this.vexLogo.y = 260, this.logoAni = 1) : this.vexLogo.y -= a / 8
                }
            }
            else if (1 === this.logoAni) {
                if (this.vexLogo.y != this.vexLogoTarY) {
                    var a = this.vexLogo.y - this.vexLogoTarY;
                    Math.abs(a) < 2 ? this.vexLogo.y = this.vexLogoTarY : (this.vexLogo.y -= a / 8, this.logoScale -= .012, this.vexLogo.scale.x = this.logoScale * this.extraScale, this.vexLogo.scale.y = this.vexLogo.scale.x)
                }
                else this.buttonLayer.y === this.buttonTarY && (this.logoAni = 2);
                if (this.buttonLayer.y > this.buttonTarY) {
                    var a = this.buttonLayer.y - this.buttonTarY;
                    a < 2 ? this.buttonLayer.y = this.buttonTarY : this.buttonLayer.y -= a / 8
                }
            }
            else {
                if (this.windowOpen) {
                    if (this.buttonLayer.y != this.game.height + 400) {
                        var a = this.buttonLayer.y - this.game.height + 400;
                        Math.abs(a) < 2 ? this.buttonLayer.y = this.game.height + 400 : this.buttonLayer.y -= a / 4
                    }
                }
                else if (this.buttonLayer.y != this.buttonTarY) {
                    var a = this.buttonLayer.y - this.buttonTarY;
                    Math.abs(a) < 2 ? this.buttonLayer.y = this.buttonTarY : this.buttonLayer.y -= a / 4
                }
                if (this.vexLogo.y != this.vexLogoTarY) {
                    var a = this.vexLogo.y - this.vexLogoTarY;
                    Math.abs(a) < 2 ? this.vexLogo.y = this.vexLogoTarY : this.vexLogo.y -= a / 8
                }
            }
        }, a.prototype.resizeStage = function(a, b) {
            if (this.buttonLayer.position.x = a / 2, this.vexLogoTarY = 60, a < b)
                if (a > 500 && b > 800) {
                    if (b > 1e3) {
                        this.buttonLayer.scale.set(1.7, 1.7), this.buttonTarY = -b, this.vex4Button.scale = .8;
                        var c = b > 600 ? b - 30 : b;
                        this.playButton.sprite.position.set(0, c - 280), this.achievementsButton.sprite.position.set(-85, c - 150), this.vex4Button.sprite.position.set(80, c + 30), this.moreGamesButton && this.moreGamesButton.sprite.position.set(-85, c - 40), this.optionsButton.sprite.position.set(75, c - 125)
                    }
                    else {
                        this.buttonLayer.scale.set(1.7, 1.7), this.buttonTarY = -b + 320;
                        var c = b > 600 ? b - 30 : b;
                        this.playButton.sprite.position.set(0, c - 380), this.achievementsButton.sprite.position.set(-85, c - 270), this.vex4Button.sprite.position.set(80, c - 90), this.moreGamesButton && this.moreGamesButton.sprite.position.set(-85, c - 160), this.optionsButton.sprite.position.set(75, c - 245)
                    }
                    this.extraScale = 2
                }
            else if (a > 350 && b > 600) {
                this.buttonLayer.scale.set(1, 1), this.extraScale = 1.5, this.buttonTarY = 0;
                var c = b > 600 ? b - 30 : b;
                this.playButton.sprite.position.set(0, c - 380), this.achievementsButton.sprite.position.set(-85, c - 270), this.vex4Button.sprite.position.set(80, c - 90), this.moreGamesButton && this.moreGamesButton.sprite.position.set(-85, c - 160), this.optionsButton.sprite.position.set(75, c - 245)
            }
            else {
                this.buttonLayer.scale.set(.8, .8), this.vexLogo.scale.set(1, 1), this.extraScale = .8, this.buttonTarY = 70, this.vexLogoTarY = 30;
                var c = b > 600 ? b - 30 : b;
                this.playButton.sprite.position.set(0, c - 380), this.achievementsButton.sprite.position.set(-85, c - 270), this.vex4Button.sprite.position.set(80, c - 90), this.moreGamesButton && this.moreGamesButton.sprite.position.set(-85, c - 160), this.optionsButton.sprite.position.set(75, c - 245)
            }
            else if (a > b && a < 900)
                if (this.vexLogoTarY = 60, a > 900 && b > 550) {
                    this.buttonLayer.scale.set(1.4, 1.4), this.extraScale = 2, this.vexLogoTarY = 90, this.vex4Button.scale = 1, this.buttonTarY = b / 2 - 500;
                    var c = Math.min(b, 460);
                    this.playButton.sprite.position.set(-150, c - 240), this.achievementsButton.sprite.position.set(-80, c - 115), this.vex4Button.sprite.position.set(175, c), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 110), this.optionsButton.sprite.position.set(150, c - 240)
                }
            else if (a > 600 && b > 350) {
                this.buttonLayer.scale.set(1.05, 1.05), this.extraScale = 1.2, this.buttonTarY = -40, this.vex4Button.scale = .8;
                var c = Math.min(b, 460);
                this.playButton.sprite.position.set(-150, c - 240), this.achievementsButton.sprite.position.set(-80, c - 115), this.vex4Button.sprite.position.set(240, c - 100), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 110), this.optionsButton.sprite.position.set(150, c - 240)
            }
            else {
                this.buttonLayer.scale.set(.8, .8), this.vexLogo.scale.set(1, 1), this.extraScale = .8, this.buttonTarY = 0, this.vex4Button.scale = .7;
                var c = Math.min(b, 460);
                this.playButton.sprite.position.set(-150, c - 200), this.achievementsButton.sprite.position.set(-80, c - 75), this.vex4Button.sprite.position.set(210, c - 45), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 70), this.optionsButton.sprite.position.set(150, c - 200)
            }
            else if (this.vexLogoTarY = 60, a > 900 && b > 550) {
                this.buttonLayer.scale.set(1.4, 1.4), this.extraScale = 2, this.vexLogoTarY = 90, this.vex4Button.scale = 1, this.buttonTarY = b / 2 - 500;
                var c = Math.min(b, 460);
                this.playButton.sprite.position.set(-150, c - 155), this.achievementsButton.sprite.position.set(-80, c - 30), this.vex4Button.sprite.position.set(240, c), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 25), this.optionsButton.sprite.position.set(150, c - 155)
            }
            else if (a > 600 && b > 350) {
                this.buttonLayer.scale.set(1.2, 1.2), this.extraScale = 1.5, this.buttonTarY = -40, this.vex4Button.scale = 1;
                var c = Math.min(b, 460);
                this.playButton.sprite.position.set(-150, c - 250), this.achievementsButton.sprite.position.set(-80, c - 125), this.vex4Button.sprite.position.set(240, c - 95), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 120), this.optionsButton.sprite.position.set(150, c - 250)
            }
            else {
                this.buttonLayer.scale.set(1, 1), this.vexLogo.scale.set(1, 1), this.extraScale = .8, this.buttonTarY = 0, this.vex4Button.scale = 1;
                var c = Math.min(b, 460);
                this.playButton.sprite.position.set(-150, c - 155), this.achievementsButton.sprite.position.set(-80, c - 30), this.vex4Button.sprite.position.set(240, c), this.moreGamesButton && this.moreGamesButton.sprite.position.set(80, c - 25), this.optionsButton.sprite.position.set(150, c - 155)
            }
            this.brandLogo && this.brandLogo.position.set(10, b - 70), this.vexLogo.scale.x = this.logoScale * this.extraScale, this.vexLogo.scale.y = this.vexLogo.scale.x, this.vexLogo.position.x = a / 2, this.moreGames && (this.moreGames.x = this.game.width / 2, this.moreGames.y = this.game.height / 2)
        }, a
    }(),
    GameStates;
! function(a) { a[a.Loading = 0] = "Loading", a[a.Playing = 1] = "Playing", a[a.Window = 2] = "Window", a[a.MainMenu = 3] = "MainMenu" }(GameStates || (GameStates = {}));
var Main = function() {
        function a(a, b) {
            var c = this;
            this.gameSpeed = 1, this.gravity = .5, this.tint = 16720418, this.skipMenu = !1, this.enableHellButton = !1, this.finished = !1, this.time = 0, this.timeCheck = Date.now(), this.game = a, this.keys = b, this.allowSpace = !1, this.yKey = a.input.keyboard.addKey(Phaser.Keyboard.Y), this.hKey = a.input.keyboard.addKey(Phaser.Keyboard.H), a.time.desiredFps = 30, this.sounds = new Sounds(this, a), this.background = a.add.group(), this.background.create(-200, -400, "parallaxBackground"), this.background.alpha = .5, this.background.fixedToCamera = !1, this.underPoolLayer = a.add.group(), this.playerUnderLayer = a.add.group(), this.poolLayer = a.add.group(), this.obstacleLayer = a.add.group(), this.levelLayer = a.add.group(), this.topObstacleLayer = a.add.group(), this.particleLayer = a.add.group(), this.topPoolLayer = a.add.group(), this.textLayer = a.add.group(), this.playerLayer = a.add.group(), this.overlayLayer = a.add.group(), this.guiLayer = a.add.group(), this.guiLayer.fixedToCamera = !0, this.mainMenuLayer = a.add.group(), this.windowLayer = a.add.group(), this.windowLayer.fixedToCamera = !0, this.transitionLayer = a.add.group(), this.mainMenu = new MainMenu(this, a, this.mainMenuLayer), this.timerGui = new TimerGui(this, a, this.guiLayer), this.rankTime = new RankTime(this, a, this.guiLayer), this.darkOverlay = this.overlayLayer.create(0, 0, "darkOverlay"), this.darkOverlay.anchor.set(.5, .5), this.darkOverlay.animations.add("dark"), this.darkOverlay.visible = !1, this.darkGraphics = this.game.add.graphics(0, 0, this.overlayLayer), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a.width, -a.height - 259, 2 * a.width, a.height), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(259, -259 - a.height, a.width, 2 * a.height), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a.width - 259, 259, 2 * a.width, a.height), this.darkGraphics.endFill(), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a.width - 259, -259 - a.height, a.width, 2 * a.height), this.darkGraphics.endFill(), this.darkGraphics.visible = !1, this.windowOverlay = this.game.add.graphics(0, 0, this.overlayLayer), this.windowOverlay.beginFill(0, .35), this.windowOverlay.drawRect(-10, -10, a.width + 20, a.height + 20), this.windowOverlay.endFill(), this.windowOverlay.fixedToCamera = !0, this.windowOverlay.visible = !1, this.flashOverlay = a.add.graphics(0, 0, this.overlayLayer), this.flashOverlay.fixedToCamera = !0, this.flashOverlay.beginFill(16777215), this.flashOverlay.drawRect(-10, 10, a.width + 10, a.height + 10), this.flashOverlay.endFill(), this.flashOverlay.visible = !1, this.exploding = !1, this.deathText = new DeathText(a, this.overlayLayer), this.state = GameStates.Loading, this.player = new Player(this, a, this.playerLayer), this.checkpointText = new CheckPointText(this, a, this.particleLayer), this.destroying = !1, this.options = new Options(a), this.achievements = new Achievements(this, this.game), this.achievementsWindow = new AchievementsWindow(this, a, this.windowLayer), this.achievementUnlocked = new AchievementUnlocked(this, a, this.windowLayer), this.stuckPopup = new StuckPopup(this, a, this.windowLayer), this.tipsWindow = new TipsWindow(this.game, this.windowLayer), this.optionsWindow = new OptionsWindow(this, a, this.windowLayer), this.pauseWindow = new PauseWindow(this, a, this.windowLayer), this.buttonSet = new ButtonSet(this, a, this.guiLayer), this.currentLevelID = "mainmenu", this.firstSpawn = !1, this.transition = new SimpleTransition(this, a, this.transitionLayer), this.levels = new Levels(function() {}), this.achievementsWindow.updateProgress(), this.game.onBlur.add(function() { c.state === GameStates.Playing && c.pauseWindow.show() }), this.game.onPause.add(function() { c.state === GameStates.Playing && c.pauseWindow.show() }, this), this.game.onFocus.add(function() {}), this.actSelectWindow = new ActSelectWindow(this, a, this.windowLayer), Constants.muted && (this.buttonSet.muteButton.sprite.frame = 1), this.optionsWindow.updateValues(), this.keys.hide(), this.timerGui.hide(), this.state = GameStates.MainMenu, this.sounds.playMenuSong(), this.skipMenu && this.changeLevel("hub", -1), this.correctSoundValues()
        }
        return a.prototype.mobilePressedDown = function() {
            var a = this;
            Fabrique.Utils.isOnDevice(this.game) ? (this.correctSoundValues(), this.player.enterActBlock()) : Fabrique.AdHandler.getInstance(this.game).showAd(function() { a.game.paused = !1, a.keys.show(), a.player.resume(), a.correctSoundValues(), a.player.enterActBlock() }, function() { a.game.paused = !0, a.keys.hide(), a.player.pause() }, "level")
        }, a.prototype.gotoMainMenu = function() {
            var a = this;
            this.transition.beginTransition(function() { a.prevLevel = a.currentLevelID, a.destroying = !0, a.state = GameStates.Loading, a.currentLevel = a.levels.levels[a.currentLevelID], a.destroyLevel(), a.timerLive = !1, a.buttonSet.enterMainMenu(), a.state = GameStates.MainMenu, a.mainMenuLayer.visible = !0, a.keys.hide(), a.timerGui.hide(), a.rankTime.invis(), a.currentLevelID = "mainmenu", a.game.camera.x = 0, a.game.camera.y = 0, a.background.position.set(0, 0), a.mainMenu.enterMenu() }, null, !1), this.state = GameStates.Loading
        }, a.prototype.changeLevel = function(a, b, c) {
            var d = this;
            void 0 === c && (c = !1), Constants.levelMapStartTime || (Constants.levelMapStartTime = Date.now()), SaveGame.getInstance(this.game).saveStats(), this.state === GameStates.MainMenu ? this.prevLevel = "mainmenu" : this.prevLevel = this.currentLevelID, this.transition.beginTransition(function() {
                if ("mainmenu" !== d.prevLevel ? d.prevLevel = d.currentLevelID : (d.mainMenuLayer.visible = !1, d.timerGui.show(), d.rankTime.vis()), d.sounds.playRandomMusic(), d.destroying = !0, d.currentLevelID = "" + a, d.currentLevel = d.levels.levels[d.currentLevelID], d.flashOverlay.visible = !1, "hub" === d.currentLevelID) {
                    if (b !== -1) {
                        if (d.currentChallenge) {
                            Fabrique.Utils.isOnDevice(d.game) && SocialServicesHandler.submitScore(d.game, Constants.actFinishTime, "challenge", d.prevLevel), d.achievements.gotAchievement("challenge" + d.prevLevel);
                            var e = d.levels.levels[d.prevLevel];
                            e.challengeCompleted = !0, d.levels.checkWinner() && d.achievements.gotAchievement("winner"), e.saveLevel()
                        }
                        else d.achievements.gotAchievement("act" + d.prevLevel), d.elapsedTime = Date.now() - Constants.actStartTime, Fabrique.Utils.isOnDevice(d.game) && SocialServicesHandler.submitScore(d.game, Constants.actFinishTime, "act", d.prevLevel);
                        d.levels.levels[d.prevLevel].setBestTime(Constants.actFinishTime, d.currentDeaths), 0 === d.levels.levels[d.prevLevel].bestRank && (d.achievements.gotAchievement("perfect"), d.levels.checkPerfection() && d.achievements.gotAchievement("perfectionist")), d.levels.levels[d.prevLevel].bestRank <= 1 && d.levels.checkOlympian() && d.achievements.gotAchievement("olympian");
                        var f = parseInt(d.prevLevel);
                        f > d.levels.latestCompleted && (d.levels.latestCompleted = f, Constants.latestCompleted = f)
                    }
                    d.actSelectWindow.resetWindow()
                }
                "mainmenu" !== d.prevLevel && d.destroyLevel(), c ? d.createLevel(d.currentLevel.challengeData, d.game) : d.createLevel(d.currentLevel.data, d.game), d.firstSpawn = !0, d.timerLive = !1, d.currentTime = null, d.currentDeaths = 0, d.stuckPopup.hide(), d.buttonSet.changeLevel(), "hub" !== d.currentLevelID ? (d.game.analytics.google.sendScreenView("gameplay"), d.allowSpace = !1, d.rankTime.leaveHub(), d.timerGui.enterLevel(d.currentLevel), d.correctSoundValues(), d.game.analytics.game.addEvent(new GA.Events.Progression("Start:Level:" + d.currentLevelID)), Constants.actStartTime = Date.now(),
                    Constants.blend ? (d.background.filters = [d.currentLevel.colorFilter], d.optionsWindow.frame.filters = [d.currentLevel.colorFilter], d.achievementsWindow.frame.filters = [d.currentLevel.colorFilter], d.pauseWindow.frame.filters = [d.currentLevel.colorFilter], d.achievementUnlocked.frame.filters = [d.currentLevel.colorFilter], d.stuckPopup.frame.filters = [d.currentLevel.colorFilter]) : (d.background.filters = null, d.optionsWindow.frame.filters = null, d.achievementsWindow.frame.filters = null, d.pauseWindow.frame.filters = null, d.achievementUnlocked.frame.filters = null, d.stuckPopup.frame.filters = null)) : (d.game.analytics.google.sendScreenView("level_select"), d.timerGui.exitLevel(), d.background.filters = null, d.optionsWindow.frame.filters = null, d.achievementsWindow.frame.filters = null, d.pauseWindow.frame.filters = null, d.achievementUnlocked.frame.filters = null, d.stuckPopup.frame.filters = null, d.timerGui.updateDeaths(Constants.totalDeaths), d.timerGui.updateProgress(d.achievements.getTotalProgress())), "10" == d.currentLevelID ? (d.followingWire = !0, d.wireTrail.startFollow()) : d.followingWire = !1, d.currentChallenge = c, d.state = GameStates.Playing, d.keys.show(), 0 == d.levels.latestCompleted ? d.keys.setAlpha(.5) : 1 == d.levels.latestCompleted ? d.keys.setAlpha(.2) : d.keys.setAlpha(.15)
            }, this.levels.levels[a].colorFilter, "hub" === this.currentLevelID || "mainmenu" === this.currentLevelID), this.state = GameStates.Loading
        }, a.prototype.finishLevel = function() { this.finished || (this.finished = !0, this.enableHellButton = !1, (Constants.actFinishTime < this.levels.levels.hub.topTime || this.levels.levels.hub.topTime === -1) && (this.levels.levels.hub.topTime = Constants.actFinishTime), this.game.analytics.game.addEvent(new GA.Events.Progression("Complete:Level:" + this.currentLevelID, this.currentDeaths, Math.round((Date.now() - Constants.actStartTime) / 1e3))), Constants.actStartTime = null, this.resumeOnFinish()) }, a.prototype.resumeOnFinish = function() {
            var a = this.currentTime;
            this.game.paused = !1, this.changeLevel("hub", a), this.keys.show(), this.player.resume(), this.finished = !1, this.correctSoundValues()
        }, a.prototype.destroyLevel = function() {
            for (var a = 0, b = this.blocks; a < b.length; a++) {
                var c = b[a];
                c.destroy()
            }
            this.blocks = null;
            for (var d = 0, e = this.obstacles; d < e.length; d++) {
                var f = e[d];
                f.destroy()
            }
            for (var g = 0, h = this.ziplines; g < h.length; g++) {
                var i = h[g];
                i.destroy()
            }
            this.ziplines = null;
            for (var j = 0, k = this.checkpoints; j < k.length; j++) {
                var l = k[j];
                l.destroy()
            }
            this.checkpoints = null;
            for (var m = 0, n = this.textFades; m < n.length; m++) {
                var o = n[m];
                o.destroy()
            }
            this.textFades = null;
            for (var p = 0, q = this.pools; p < q.length; p++) {
                var r = q[p];
                r.destroy()
            }
            this.pools = null;
            for (var s = 0, t = this.poles; s < t.length; s++) {
                var u = t[s];
                u.destroy()
            }
            this.poles = null;
            for (var v = 0, w = this.stars; v < w.length; v++) {
                var x = w[v];
                x.destroy()
            }
            this.stars = null;
            for (var y = 0, z = this.fans; y < z.length; y++) {
                var A = z[y];
                A.destroy()
            }
            this.fans = null;
            for (var B = 0, C = this.keyObjs; B < C.length; B++) {
                var D = C[B];
                D.destroy()
            }
            this.keyObjs = null;
            for (var E = 0, F = this.cannons; E < F.length; E++) {
                var G = F[E];
                G.destroy()
            }
            this.cannons = null;
            for (var H = 0, I = this.slopes; H < I.length; H++) {
                var J = I[H];
                J.destroy()
            }
            this.slopes = null;
            for (var K = 0, L = this.breatheBlasters; K < L.length; K++) {
                var M = L[K];
                M.destroy()
            }
            this.breatheBlasters = null;
            for (var N = 0, O = this.wires; N < O.length; N++) {
                var P = O[N];
                P.destroy()
            }
            this.wires = null;
            for (var Q = 0, R = this.lightSwitches; Q < R.length; Q++) {
                var S = R[Q];
                S.destroy()
            }
            this.lightSwitches = null;
            for (var T = 0, U = this.misc; T < U.length; T++) {
                var V = U[T];
                V.destroy()
            }
            this.misc = null;
            for (var W = 0, X = this.particles; W < X.length; W++) {
                var Y = X[W];
                Y.destroy()
            }
            this.wireTrail && this.wireTrail.destroy(), this.finishPortal = null, this.player.hide()
        }, a.prototype.createLevel = function(a, b) {
            var c = 0,
                d = 0;
            this.dark = !1, this.darkOverlay.visible = !1, this.darkGraphics.visible = !1, this.blocks = [], this.solarBlocks = [], this.slopes = [], this.obstacles = [], this.ziplines = [], this.checkpoints = [], this.poles = [], this.particles = [], this.textFades = [], this.pools = [], this.stars = [], this.fans = [], this.keyObjs = [], this.wires = [], this.misc = [], this.cannons = [], this.lightSwitches = [], this.breatheBlasters = [], this.actBlocks = {}, this.explosiveBlock = null, this.wireTrail = null, this.particleNum = 0;
            for (var e = null, f = null, g = 0; g < a.length; g++) {
                var h = a[g];
                switch (h.type) {
                    case "spawnPoint":
                        c = h.x, d = h.y;
                        break;
                    case "basicBlock":
                        var i = new BasicBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "verticalUpBlock":
                        var i = new VerticalUpBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "verticalDownBlock":
                        var i = new VerticalDownBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "horizontalBlock":
                        var i = new HorizontalBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "horizontalBlockFast":
                        var i = new HorizontalBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height, -5), this.blocks.push(i);
                        break;
                    case "fallingBlock":
                        var i = new FallingBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "bounceBlock":
                        var i = new BounceBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "pushBlock":
                        var i = new PushBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "iceBlock":
                        var i = new IceBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "glassBlock":
                        var i = new GlassBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "speedBlock":
                        var i = new SpeedBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height, 2.5), this.blocks.push(i);
                        break;
                    case "speedBlockLeft":
                        var i = new SpeedBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height, -2.5), this.blocks.push(i);
                        break;
                    case "lockBlock":
                        var i = new LB(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "sparkBlock":
                        var i = new SparkBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "solarBlock":
                        var i = new SolarBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i), this.solarBlocks.push(i);
                        break;
                    case "invisBlock":
                        var i = new InvisBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "invisBlockUp":
                        var i = new InvisBlockUp(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "invisBlockDown":
                        var i = new InvisBlockDown(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i);
                        break;
                    case "explosiveBlock":
                        var i = new ExplosiveBlock(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height), this.blocks.push(i), this.explosiveBlock = i;
                        break;
                    case "blockedWall":
                        var i = new BlockedWall(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height, h.rotation, this.levels.levels[h.actnum]), this.blocks.push(i);
                        break;
                    case "actBlock":
                        var i = new ActBlock(this, b, this.levelLayer, h.actNum, this.levels.levels[h.actNum]);
                        i.spawn(h.x, h.y), this.blocks.push(i), this.actBlocks[h.actNum] = i;
                        break;
                    case "swimmingPool":
                        var i = void 0;
                        i = "7" == this.currentLevelID ? new SwimmingPool(this, b, this.topPoolLayer) : new SwimmingPool(this, b, this.poolLayer), i.spawn(h.x, h.y, h.width, h.height), this.pools.push(i);
                        break;
                    case "leftSlope":
                        var i = new LeftSlope(this, b, this.levelLayer);
                        i.spawn(h.x, h.y, h.width, h.height, h.rotation), this.slopes.push(i);
                        break;
                    case "rightSlope":
                        var i = new LeftSlope(this, b, this.levelLayer, (!0));
                        i.spawn(h.x, h.y, h.width, h.height, h.rotation), this.slopes.push(i);
                        break;
                    case "ziplinePole":
                        var j = new ZiplinePole(this, b, this.obstacleLayer);
                        j.spawn(h.x, h.y), e ? (this.ziplines.push(e.attach(j)), e = null) : e = j, this.misc.push(j);
                        break;
                    case "pole":
                        var k = new Pole(this, b, this.topObstacleLayer);
                        k.spawn(h.x, h.y), this.poles.push(k);
                        break;
                    case "checkpoint":
                        var l = new Checkpoint(this, b, this.obstacleLayer, (!1));
                        l.spawn(h.x, h.y), this.checkpoints.push(l);
                        break;
                    case "checkpointSwimming":
                        var l = new Checkpoint(this, b, this.obstacleLayer, (!0));
                        l.spawn(h.x, h.y), this.checkpoints.push(l);
                        break;
                    case "star":
                        var m = new Star(this, b, this.topObstacleLayer);
                        m.spawn(h.x, h.y), this.stars.push(m);
                        break;
                    case "windBlaster":
                        var n = new WindBlaster(this, b, this.obstacleLayer);
                        n.spawn(h.x, h.y, h.rotation), this.fans.push(n);
                        break;
                    case "finishPortal":
                        var o = new FinishPortal(this, b, this.obstacleLayer);
                        o.spawn(h.x, h.y), this.misc.push(o), this.finishPortal = o;
                        break;
                    case "key":
                        var p = new Key(this, b, this.obstacleLayer);
                        p.spawn(h.x, h.y), this.keyObjs.push(p);
                        break;
                    case "timedKey":
                        var p = new TimedKey(this, b, this.obstacleLayer);
                        p.spawn(h.x, h.y), this.keyObjs.push(p);
                        break;
                    case "circularCannon":
                        var q = new CircularCannon(this, b, this.topObstacleLayer);
                        q.spawn(h.x, h.y), this.cannons.push(q);
                        break;
                    case "lightSwitch":
                        var r = new LightSwitch(this, b, this.topObstacleLayer);
                        r.spawn(h.x, h.y), this.lightSwitches.push(r);
                        break;
                    case "wire":
                        var s = new Wire(this, b, this.obstacleLayer);
                        s.spawn(h.x, h.y, h.rotation), this.wires.push(s);
                        break;
                    case "buzzsaw":
                        var t = new Buzzsaw(this, b, this.obstacleLayer);
                        h.width ? t.spawn(h.x, h.y, Math.round(h.width) / 101) : t.spawn(h.x, h.y), this.obstacles.push(t);
                        break;
                    case "buzzsawVerticalUp":
                        var t = new BuzzsawVerticalUp(this, b, this.obstacleLayer);
                        t.spawn(h.x, h.y), this.obstacles.push(t);
                        break;
                    case "buzzsawVerticalDown":
                        var t = new BuzzsawVerticalUp(this, b, this.obstacleLayer);
                        t.spawn(h.x, h.y, 2), this.obstacles.push(t);
                        break;
                    case "buzzsawHorizontal":
                        var t = new BuzzsawHorizontal(this, b, this.obstacleLayer);
                        h.width ? t.spawn(h.x, h.y, 2, Math.round(h.width) / 101) : t.spawn(h.x, h.y, 2), this.obstacles.push(t);
                        break;
                    case "buzzsawHorizontalFast":
                        var t = new BuzzsawHorizontal(this, b, this.obstacleLayer);
                        t.spawn(h.x, h.y, 5), this.obstacles.push(t);
                        break;
                    case "bouncingBuzzsaw":
                        var t = new BouncingBuzzsaw(this, b, this.obstacleLayer);
                        h.width ? t.spawn(h.x, h.y, Math.round(h.width) / 101) : t.spawn(h.x, h.y), this.obstacles.push(t);
                        break;
                    case "enlargingBuzzsaw":
                        var t = new EnlargingBuzzsaw(this, b, this.obstacleLayer);
                        h.width ? t.spawn(h.x, h.y, Math.round(h.width) / 101) : t.spawn(h.x, h.y), this.obstacles.push(t);
                        break;
                    case "buzzsawOnStick":
                        var t = void 0;
                        t = "hub" === this.currentLevelID ? new BuzzsawOnStick(this, b, this.obstacleLayer) : new BuzzsawOnStick(this, b, this.topObstacleLayer), t.spawn(h.x, h.y, h.rotation), this.obstacles.push(t);
                        break;
                    case "spike":
                        var u = new Spike(this, b, this.obstacleLayer);
                        u.spawn(h.x, h.y, h.rotation), this.obstacles.push(u);
                        break;
                    case "spike10x":
                        var u = new Spike10x(this, b, this.obstacleLayer);
                        u.spawn(h.x, h.y, h.rotation), this.obstacles.push(u);
                        break;
                    case "spike30x":
                        var u = new Spike30x(this, b, this.obstacleLayer);
                        u.spawn(h.x, h.y, h.rotation), this.obstacles.push(u);
                        break;
                    case "fallingSpike":
                        var u = new FallingSpike(this, b, this.obstacleLayer);
                        u.spawn(h.x, h.y, h.rotation - 90), this.obstacles.push(u);
                        break;
                    case "shurikanSpawner":
                        var u = new ShurikanSpawner(this, b, this.obstacleLayer);
                        u.spawn(h.x, h.y, h.rotation), this.obstacles.push(u);
                        break;
                    case "classicLaser":
                        var v = new ClassicLaser(this, b, this.topObstacleLayer);
                        v.spawn(h.x, h.y), this.obstacles.push(v);
                        break;
                    case "quadrantRight":
                        var w = new Quadrant(this, b, this.obstacleLayer);
                        h.width ? w.spawn(h.x, h.y, h.rotation, 2 * Math.PI / 180, h.width / 180) : w.spawn(h.x, h.y, h.rotation, 2 * Math.PI / 180), this.obstacles.push(w);
                        break;
                    case "quadrantLeft":
                        var w = new Quadrant(this, b, this.obstacleLayer);
                        h.width ? w.spawn(h.x, h.y, h.rotation, -2 * Math.PI / 180, h.width / 180) : w.spawn(h.x, h.y, h.rotation, -2 * Math.PI / 180), this.obstacles.push(w);
                        break;
                    case "laserPoint":
                        if (f) {
                            var x = new LaserPoint(this, b, this.obstacleLayer);
                            x.spawn(f.x, f.y, h.x, h.y), this.obstacles.push(x), f = null
                        }
                        else f = new Phaser.Point(h.x, h.y);
                        break;
                    case "reaper":
                        var y = new Reaper(this, b, this.obstacleLayer);
                        h.width ? y.spawn(h.x, h.y, h.rotation, Math.round(h.width) / 133) : y.spawn(h.x, h.y, h.rotation), this.obstacles.push(y);
                        break;
                    case "shurikanDispenser":
                        var z = new ShurikanDispenser(this, b, this.obstacleLayer);
                        z.spawn(h.x, h.y), this.obstacles.push(z);
                        break;
                    case "hazardStrips":
                        var A = new HazardStrips(this, b, this.topObstacleLayer);
                        A.spawn(h.x, h.y), this.misc.push(A);
                        break;
                    case "breatheBlaster":
                        var B = new BreatheBlaster(this, b, this.obstacleLayer);
                        B.spawn(h.x, h.y, h.rotation), this.breatheBlasters.push(B);
                        break;
                    case "textFade":
                        var C = new TextFade(this, b, this.textLayer, "textFade" + h.textNum);
                        C.spawn(h.x, h.y, h.rotation), this.textFades.push(C)
                }
            }
            for (var p in this.blocks) {
                var i = this.blocks[p];
                i.levelStart()
            }
            for (var D = 0, E = this.obstacles; D < E.length; D++) {
                var F = E[D];
                F.levelStart()
            }
            if ("10" === this.currentLevelID && (this.wireTrail = new WireTrail(this, this.wires)), "hub" == this.currentLevelID) {
                for (var G = hubArrows[this.levels.latestCompleted], H = 0, I = G; H < I.length; H++) {
                    var h = I[H];
                    if ("textFade" === h.type) {
                        var C = new TextFade(this, b, this.textLayer, "textFade" + h.textNum);
                        C.spawn(h.x, h.y, h.rotation), this.textFades.push(C)
                    }
                }
                this.prevLevel && "mainmenu" != this.prevLevel ? this.player.spawn(this.actBlocks[this.prevLevel].xPos, this.actBlocks[this.prevLevel].topEdge) : this.levels.latestCompleted > 0 ? this.player.spawn(this.actBlocks[this.levels.latestCompleted].xPos, this.actBlocks[this.levels.latestCompleted].topEdge) : this.player.spawn(c, d)
            }
            else this.player.spawn(c, d);
            this.spawnX = c, this.spawnY = d, this.state = GameStates.Playing
        }, a.prototype.correctSoundValues = function() { Constants.muted === !1 ? (this.optionsWindow.bgmVolumeSlider.setValue(Constants.musicVolume), this.optionsWindow.effectVolumeSlider.setValue(Constants.effectVolume)) : (this.buttonSet.muteButton.sprite.frame = 1, this.options.musicVolume = 0, this.options.effectVolume = 0, this.sounds.currentMusic && (this.sounds.currentMusic.volume = 0)), SaveGame.getInstance().saveOptions() }, a.prototype.createColorParticle = function(a, b, c, d, e, f, g, h, i, j) {
            if (void 0 === e && (e = 0), void 0 === f && (f = 4), void 0 === g && (g = !0), void 0 === h && (h = !1), void 0 === i && (i = 140), void 0 === j && (j = !1), 0 !== Constants.particleLimit) {
                var k = new ColorParticle(this, this.game, this.particleLayer, e, f, g, h, i, j);
                if (k.spawn(a, b, c, d), this.particleNum++, this.particles.push(k), this.particleNum >= Constants.particleLimit)
                    for (var l = 0, m = this.particles; l < m.length; l++) { var n = m[l]; if (n.alive) { n.destroy(); break } }
            }
        }, a.prototype.createPlayerGib = function(a, b, c, d, e, f, g, h, i, j, k) {
            void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 4), void 0 === i && (i = !0), void 0 === j && (j = !1), void 0 === k && (k = 0);
            var l = new PlayerGib(this, this.game, this.particleLayer, e, h, i);
            if (l.spawn(a, b, c, d, f, g), this.particleNum++, this.particles.push(l), this.particleNum >= Constants.particleLimit)
                for (var m = 0, n = this.particles; m < n.length; m++) { var o = n[m]; if (o.alive) { o.destroy(); break } }
        }, a.prototype.goDark = function() {
            var a = this;
            if (!this.dark) {
                this.dark = !0, this.darkOverlay.visible = !0, setTimeout(function() { return a.darkOverlay.animations.play("dark", 30, !1, !1) }, 100), this.darkGraphics.visible = !0, this.flashOverlay.visible = !1;
                for (var b = 0, c = this.solarBlocks; b < c.length; b++) {
                    var d = c[b];
                    d.goDark()
                }
            }
        }, a.prototype.goLight = function() {
            this.dark && (this.flashOverlay.visible = !0, this.flashOverlay.alpha = 1), this.dark = !1, this.darkOverlay.visible = !1, this.darkOverlay.animations.stop("dark", !0), this.darkGraphics.visible = !1;
            for (var a = 0, b = this.solarBlocks; a < b.length; a++) {
                var c = b[a];
                c.goLight()
            }
        }, a.prototype.explode = function() { this.exploding = !0, this.flashOverlay.visible = !0, this.flashOverlay.alpha = 0 }, a.prototype.checkpointTriggered = function(a) {
            for (var b = 0, c = this.checkpoints; b < c.length; b++) {
                var d = c[b];
                d !== a && 1 === d.state && ("hub" == this.currentLevelID || "6" == this.currentLevelID ? d.resetLevel() : d.gray())
            }
        }, a.prototype.portToActBlock = function(a) { this.player.currentPole = null, this.player.xPos = this.actBlocks[a].xPos, this.player.yPos = this.actBlocks[a].topEdge, this.player.yVelocity = 0, this.player.xVelocity = 0, this.player.forcedXVelocity = 0, this.player.setIdle(), this.player.updateHitBoxesPos(), this.player.updatePositions(), this.game.camera.x = this.player.xPos - 320, this.game.camera.y = this.player.yPos - 280 }, a.prototype.playerDeath = function() { this.currentDeaths++, Constants.totalDeaths++, "hub" !== this.currentLevelID && this.game.analytics.game.addEvent(new GA.Events.Progression("Fail:Level:" + this.currentLevelID, this.currentDeaths, Math.round((Date.now() - Constants.actStartTime) / 1e3))), this.currentDeaths % 11 !== 10 || this.game.device.desktop || this.tipsWindow.animateWindow(), 3 !== this.currentDeaths || Fabrique.Utils.isOnDevice(this.game) || this.stuckPopup.show(parseInt(this.currentLevelID) - 1), Constants.totalDeaths > 100 && this.achievements.gotAchievement("deathtycoon"), "hub" === this.currentLevelID ? this.timerGui.updateDeaths(Constants.totalDeaths) : this.timerGui.updateDeaths(this.currentDeaths), SaveGame.getInstance(this.game).saveStats() }, a.prototype.exitLevel = function() { "hub" === this.currentLevelID ? this.gotoMainMenu() : (this.changeLevel("hub", -1), this.enableHellButton = !1) }, a.prototype.openWindow = function() { this.state = GameStates.Window, "mainmenu" === this.currentLevelID ? this.mainMenu.windowOpen = !0 : this.windowOverlay.visible = !0, this.keys.hide(), this.player.pause() }, a.prototype.closeWindow = function() { "mainmenu" === this.currentLevelID ? (this.mainMenu.windowOpen = !1, this.state = GameStates.MainMenu, this.game.analytics.google.sendScreenView("menu")) : (this.state = GameStates.Playing, this.keys.show(), this.player.resume()), this.windowOverlay.visible = !1, this.sounds.currentMusic.resume() }, a.prototype.update = function() {
            var a = Date.now();
            switch (a - this.timeCheck < 34 && (this.time += a - this.timeCheck, this.timeCheck = Date.now()), this.transition.update(), this.state) {
                case GameStates.Playing:
                    for (var b = 0, c = this.cannons; b < c.length; b++) {
                        var d = c[b];
                        d.update()
                    }
                    if (this.player.update(), this.state !== GameStates.Playing) return;
                    for (var e in this.blocks) {
                        var f = this.blocks[e];
                        f.update()
                    }
                    this.wireTrail && (this.followingWire && this.wireTrail.followTick() && (this.followingWire = !1, this.wireTrail.burning = !0, this.timerLive = !0), this.wireTrail.update());
                    for (var e in this.obstacles) {
                        var g = this.obstacles[e];
                        g.update()
                    }
                    for (var h = 0, i = this.pools; h < i.length; h++) {
                        var j = i[h];
                        j.update()
                    }
                    for (var k = 0; k < this.particles.length; k++) {
                        var l = this.particles[k];
                        l.alive ? l.update() : (this.particles.splice(k, 1), k--)
                    }
                    for (var e in this.poles) {
                        var m = this.poles[e];
                        m.update()
                    }
                    for (var e in this.checkpoints) {
                        var g = this.checkpoints[e];
                        g.update()
                    }
                    for (var e in this.textFades) {
                        var n = this.textFades[e];
                        n.update()
                    }
                    for (var o = 0, p = this.fans; o < p.length; o++) {
                        var q = p[o];
                        q.update()
                    }
                    for (var r = 0, s = this.keyObjs; r < s.length; r++) {
                        var e = s[r];
                        e.update()
                    }
                    for (var t = 0, u = this.breatheBlasters; t < u.length; t++) {
                        var v = u[t];
                        v.update()
                    }
                    this.finishPortal && this.finishPortal.update(), this.deathText && this.deathText.update(), this.checkpointText && this.checkpointText.update(), this.exploding ? (this.flashOverlay.alpha += .05, this.flashOverlay.alpha >= 1 && (this.exploding = !1, this.changeLevel("hub", -1))) : this.dark ? (this.darkGraphics.position.set(this.player.xPos, this.player.yPos), this.darkOverlay.position.set(this.player.xPos, this.player.yPos)) : this.flashOverlay.visible && (this.flashOverlay.alpha -= .03, this.flashOverlay.alpha <= 0 && (this.flashOverlay.visible = !1)), Constants.timePlayed++, Constants.isAnHour(Constants.levelMapStartTime) && this.achievements.gotAchievement("timeflies"), "hub" == this.currentLevelID ? (this.rankTime.update(), this.timerGui.updateLevelTime(Constants.levelMapStartTime)) : (this.timerLive && (this.currentTime = Constants.actStartTime, this.timerGui.updateLevelTime(Constants.actStartTime)), this.keys.reset.pressed() && (this.resetLevel(), Constants.actStartTime = Date.now()), Constants.autoReset && this.currentLevel.topTime !== -1 && this.currentTime > this.currentLevel.topTime && this.resetLevel()), Constants.parallax ? (this.background.x = this.game.camera.x + this.game.camera.x / 10 % 140, this.background.y = this.game.camera.y + this.game.camera.y / 10 % 140) : (this.background.x = this.game.camera.x, this.background.y = this.game.camera.y);
                    break;
                case GameStates.Window:
                    "mainmenu" == this.currentLevelID && this.mainMenu.update();
                    break;
                case GameStates.MainMenu:
                    this.mainMenu.update(), Constants.parallax && (this.background.x += 1, this.background.y += 1, this.background.x = this.background.x % 140, this.background.y = this.background.y % 140)
            }
            this.actSelectWindow && this.actSelectWindow.update(), this.achievementsWindow && this.achievementsWindow.update(), this.achievementUnlocked && this.achievementUnlocked.update(), this.stuckPopup && this.stuckPopup.update(), this.optionsWindow && this.optionsWindow.update(), this.pauseWindow && this.pauseWindow.update()
        }, a.prototype.resetDeath = function() { this.resumeOnReset() }, a.prototype.pauseOnLevelEnd = function() { this.game.paused = !0, this.keys.hide(), this.player.pause() }, a.prototype.resumeOnReset = function() {
            var a = Date.now();
            this.currentTime = a, this.game.paused = !1;
            for (var b = 0, c = this.blocks; b < c.length; b++) {
                var d = c[b];
                d.reset()
            }
            for (var e = 0, f = this.obstacles; e < f.length; e++) {
                var g = f[e];
                g.reset()
            }
            for (var h = 0, i = this.keyObjs; h < i.length; h++) {
                var j = i[h];
                j.reset()
            }
            this.goLight(), this.keys.show(), this.player.resume()
        }, a.prototype.resetLevel = function() {
            this.dark && this.goLight();
            for (var a = 0, b = this.obstacles; a < b.length; a++) {
                var c = b[a];
                c.resetLevel()
            }
            for (var d = 0, e = this.checkpoints; d < e.length; d++) {
                var f = e[d];
                f.resetLevel()
            }
            for (var g = 0, h = this.wires; g < h.length; g++) {
                var i = h[g];
                i.resetLevel()
            }
            this.wireTrail && this.wireTrail.resetLevel();
            for (var j = 0, k = this.blocks; j < k.length; j++) {
                var l = k[j];
                l.resetLevel()
            }
            for (var m = 0, n = this.keyObjs; m < n.length; m++) {
                var o = n[m];
                o.resetLevel()
            }
            this.player.spawn(this.spawnX, this.spawnY), this.timerGui.resetLevel(), this.currentTime = null, this.currentDeaths = 0, this.timerGui.updateDeaths(this.currentDeaths)
        }, a.prototype.resizeStage = function(a, b) { this.timerGui.resizeStage(a, b), this.buttonSet.resizeStage(a, b), this.rankTime.resizeStage(a, b), this.transition.resizeStage(a, b), this.tipsWindow.resize(), this.stuckPopup.resizeWindow(a, b), this.pauseWindow.resizeStage(a, b), this.actSelectWindow && this.actSelectWindow.resizeStage(a, b), this.optionsWindow.resizeStage(a, b), this.achievementsWindow.resizeStage(a, b), this.mainMenu.resizeStage(a, b), this.darkGraphics.clear(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a, -b - 259, 2 * a, b), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(259, -259 - b, a, 3 * b), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a - 259, 259, 2 * a, b), this.darkGraphics.endFill(), this.darkGraphics.endFill(), this.darkGraphics.beginFill(0), this.darkGraphics.drawRect(-a - 259, -259 - b, a, 3 * b), this.darkGraphics.endFill(), this.windowOverlay.clear(), this.windowOverlay.beginFill(0, .35), this.windowOverlay.drawRect(-10, -10, a + 20, b + 20), this.windowOverlay.endFill(), this.flashOverlay.clear(), this.flashOverlay.beginFill(16777215), this.flashOverlay.drawRect(-10, 10, this.game.width + 10, this.game.height + 10), this.flashOverlay.endFill() }, a.prototype.clearAllSavedData = function() { this.levels.clearAllLevelData(), SaveGame.getInstance().clearAll(), this.optionsWindow.updateValues(), this.achievements.clearSavedData(), this.achievementsWindow.updateProgress(), this.keys.show(), this.buttonSet.muteButton.sprite.frame = 0, this.sounds.playMenuSong(), this.levels = new Levels(function() {}), this.achievementUnlocked = new AchievementUnlocked(this, this.game, this.windowLayer), this.achievementsWindow = new AchievementsWindow(this, this.game, this.windowLayer), this.actSelectWindow = new ActSelectWindow(this, this.game, this.windowLayer), this.rankTime = new RankTime(this, this.game, this.guiLayer), this.correctSoundValues() }, a
    }(),
    Vex3;
! function(a) {
    var b = function(a) {
        function b() { var b = a.call(this, { enableDebug: !1, width: 960, height: 840, renderer: Phaser.AUTO, parent: "content", transparent: !0, antialias: !0, preserveDrawingBuffer: !1, physicsConfig: null, seed: "", state: null, forceSetTimeOut: !1 }) || this; return b.clearBeforeRender = !1, Phaser.Device.whenReady(function() { b.stage.disableVisibilityChange = !0, document.getElementById("content").addEventListener("touchstart", function(a) { b.gameResumed(a) }) }), b.state.add("preGame", { create: b.stateCreator.bind(b), preload: b.statePreloader.bind(b) }, !0), b }
        return __extends(b, a), b.prototype.statePreloader = function() {
            var a = this;
            libs.forEach(function(b) { a.load.script(b, b) })
        }, b.prototype.stateCreator = function() { this.plugins.add(Fabrique.Plugins.GameEvents), this.plugins.add(Fabrique.Plugins.GoogleAnalytics), this.plugins.add(Fabrique.Plugins.GameAnalytics), this.plugins.add(PhaserSpine.SpinePlugin), this.plugins.add(PhaserAds.AdManager), this.plugins.add(PhaserCachebuster.CacheBuster), this.plugins.add(PhaserSuperStorage.StoragePlugin), this.storage.forcePromises = !0, Fabrique.Utils.isOnDevice(this) && void 0 !== window.NativeStorage && this.storage.setAdapter(new PhaserSuperStorage.StorageAdapters.CordovaStorage), this.state.add(Fabrique.SplashScreen.Preloader.Name, Fabrique.SplashScreen.Preloader, !1), this.state.add("Boot", VexBoot), this.state.add("Game", VexGameState), this.state.start("Boot"), this.state.remove("preGame") }, b
    }(Phaser.Game);
    a.Game = b
}(Vex3 || (Vex3 = {}));
var Constants = function() {
        function a() {}
        return a.getInterstialAd = function(b, c) {
            var d;
            switch (b) {
                case "start":
                    d = c ? a.iOS_AD_ID_StartInterstitial : a.Google_AD_ID_StartInterstitial;
                    break;
                case "level":
                    d = c ? a.iOS_AD_ID_LevelInterstitial : a.Google_AD_ID_LevelInterstitial;
                    break;
                case "pause":
                    d = c ? a.iOS_AD_ID_PauseBanner : a.Google_AD_ID_PauseBanner
            }
            return d
        }, a.calcCurrentTime = function(a) {
            var b = new Date(Date.now()),
                c = new Date(a);
            c.setTime(c.getTime());
            var d = b - c;
            return d
        }, a.isAnHour = function(a) { var b = Math.floor(a / 1e3 / 60 / 60); return 1 == b }, a.overrideSplash = function(a) { return Fabrique.Utils.getBrandingDomain() != Fabrique.BrandingDomain.Bild || !!Fabrique.Branding.isContracted(a) }, a.GOOGLE_ID = "UA-85519155-1", a.GOOGLE_APP_NAME = "Vex 3", a.GAME_KEY = "20cbc90eaf20dbd14fc4265232077ef3", a.SECRET_KEY = "6843de2fc526e0131ff1424076aae62a79630806", a.GAME_TITLE = "vex-3", a.AdID = 201, a.iOS_AD_ID = "ca-app-pub-1394495769473752~2756650820", a.iOS_AD_ID_StartInterstitial = "ca-app-pub-1394495769473752/7186850421", a.iOS_AD_ID_PauseBanner = "ca-app-pub-1394495769473752/8663583623", a.iOS_AD_ID_LevelInterstitial = "ca-app-pub-1394495769473752/4233384021", a.Google_AD_ID = "ca-app-pub-1394495769473752~1140316825", a.Google_AD_ID_StartInterstitial = "ca-app-pub-1394495769473752/7047249623", a.Google_AD_ID_PauseBanner = "ca-app-pub-1394495769473752/8523982820", a.Google_AD_ID_LevelInterstitial = "ca-app-pub-1394495769473752/5570516420", a.tutorialURL = "http://kizi.com/videos/u/vex-3", a.totalDeaths = 0, a.timePlayed = 0, a.autoReset = !1, a.particleLimit = 30, a.oldControls = !1, a.blend = !0, a.waves = !0, a.parallax = !0, a.musicVolume = 1, a.effectVolume = .5, a.muted = !1, a.gotStar = !1, a.challengeCompleted = !1, a.latestCompleted = 0, a.currentLevel = 1, a.actFinishTime = -1, a.pausedActTime = null, a.pausedMapTime = null, a.isPaused = !1, a.achievements = { act1: !1, act2: !1, act3: !1, act4: !1, act5: !1, act6: !1, act7: !1, act8: !1, act9: !1, star1: !1, star2: !1, star3: !1, star4: !1, star5: !1, star6: !1, star7: !1, star8: !1, star9: !1, star10: !1, challenge1: !1, challenge2: !1, challenge3: !1, challenge4: !1, challenge5: !1, challenge6: !1, challenge7: !1, challenge8: !1, challenge9: !1, perfect: !1, caretaker: !1, gasping: !1, timeflies: !1, headsup: !1, deathtycoon: !1, olympian: !1, perfectionist: !1, astronomer: !1, winner: !1, vexation: !1 }, a
    }(),
    SocialServicesData = function() {
        function a() {}
        return a.convertTime = function(a, b) { return a.device.android ? b : 100 * Math.floor(b / 1e3) }, a.getActName = function(a, b) {
            var c;
            switch (a) {
                case "act":
                    c = "10" === b ? "vexation" : a + b;
                    break;
                case "challenge":
                    c = "hardcore" + b
            }
            return c
        }, a.getSocialServiceID = function(a, b, c) { var d = b[c]; return a.device.android ? d.android : a.device.iOS ? d.ios : void 0 }, a.ACT_1 = "CggI4vyI-WkQAhAU", a.ACT_2 = "CggI4vyI-WkQAhAV", a.ACT_3 = "CggI4vyI-WkQAhAW", a.ACT_4 = "CggI4vyI-WkQAhAX", a.ACT_5 = "CggI4vyI-WkQAhAY", a.ACT_6 = "CggI4vyI-WkQAhAZ", a.ACT_7 = "CggI4vyI-WkQAhAa", a.ACT_8 = "CggI4vyI-WkQAhAb", a.ACT_9 = "CggI4vyI-WkQAhAc", a.VEXATION = "CggI4vyI-WkQAhAd", a.MINE_ = "CggI4vyI-WkQAhAe", a.THANKS_BOX_ = "CggI4vyI-WkQAhAf", a.ITS_THE_CLIMB_ = "CggI4vyI-WkQAhAg", a.BETWEEN_A_SAW = "CggI4vyI-WkQAhAh", a.LEAP_OF_FAITH = "CggI4vyI-WkQAhAi", a.KEYCHAIN = "CggI4vyI-WkQAhAj", a.TAKE_THE_PLUNGE = "CggI4vyI-WkQAhAk", a.LIGHTS_OUT_ = "CggI4vyI-WkQAhAl", a.OUTSIDE_THE_BOX = "CggI4vyI-WkQAhAm", a.INSIDE_THE_BOX = "CggI4vyI-WkQAhAn", a.ONE_STEP_AT_A_TIME = "CggI4vyI-WkQAhAo", a.DOUBLE_DOWN = "CggI4vyI-WkQAhAp", a.THIRDS_THE_CHARM = "CggI4vyI-WkQAhAq", a.FANTASTIC_FOUR = "CggI4vyI-WkQAhAr", a.HIGH_FIVE = "CggI4vyI-WkQAhAs", a.DEMON = "CggI4vyI-WkQAhAt", a.YOURE_LUCKY = "CggI4vyI-WkQAhAu", a.EIGHT_TIMES_THE_CHAMP = "CggI4vyI-WkQAhAv", a.NINE_LIVES = "CggI4vyI-WkQAhAw", a.PERFECT_ = "CggI4vyI-WkQAhAx", a.CARETAKER = "CggI4vyI-WkQAhAy", a.GASPING = "CggI4vyI-WkQAhAz", a.TIME_FLIES_V20 = "CggI4vyI-WkQAhA0", a.HEADS_UP = "CggI4vyI-WkQAhA1", a.DEATH_TYCOON = "CggI4vyI-WkQAhA2", a.OLYMPIAN = "CggI4vyI-WkQAhA3", a.PERFECTIONIST = "CggI4vyI-WkQAhA4", a.ASTRONOMER = "CggI4vyI-WkQAhA5", a.WINNER = "CggI4vyI-WkQAhA6", a.LEAD_ACT_1 = "CggI4vyI-WkQAhAB", a.LEAD_ACT_2 = "CggI4vyI-WkQAhAD", a.LEAD_ACT_3 = "CggI4vyI-WkQAhAF", a.LEAD_ACT_4 = "CggI4vyI-WkQAhAH", a.LEAD_ACT_5 = "CggI4vyI-WkQAhAJ", a.LEAD_ACT_6 = "CggI4vyI-WkQAhAL", a.LEAD_ACT_7 = "CggI4vyI-WkQAhAN", a.LEAD_ACT_8 = "CggI4vyI-WkQAhAP", a.LEAD_ACT_9 = "CggI4vyI-WkQAhAR", a.LEAD_ACT_1__HARDCORE = "CggI4vyI-WkQAhAC", a.LEAD_ACT_2__HARDCORE = "CggI4vyI-WkQAhAE", a.LEAD_ACT_3__HARDCORE = "CggI4vyI-WkQAhAG", a.LEAD_ACT_4__HARDCORE = "CggI4vyI-WkQAhAI", a.LEAD_ACT_5__HARDCORE = "CggI4vyI-WkQAhAK", a.LEAD_ACT_6__HARDCORE = "CggI4vyI-WkQAhAM", a.LEAD_ACT_7__HARDCORE = "CggI4vyI-WkQAhAO", a.LEAD_ACT_8__HARDCORE = "CggI4vyI-WkQAhAQ", a.LEAD_ACT_9__HARDCORE = "CggI4vyI-WkQAhAS", a.LEAD_VEXATION = "CggI4vyI-WkQAhAT", a.AchToSocialID = { act1: { android: a.ACT_1, ios: "act1" }, act2: { android: a.ACT_2, ios: "act2" }, act3: { android: a.ACT_3, ios: "act3" }, act4: { android: a.ACT_4, ios: "act4" }, act5: { android: a.ACT_5, ios: "act5" }, act6: { android: a.ACT_6, ios: "act6" }, act7: { android: a.ACT_7, ios: "act7" }, act8: { android: a.ACT_8, ios: "act8" }, act9: { android: a.ACT_9, ios: "act9" }, act10: { android: a.VEXATION, ios: "vexation" }, star1: { android: a.MINE_, ios: "mine" }, star2: { android: a.THANKS_BOX_, ios: "thanks_box" }, star3: { android: a.ITS_THE_CLIMB_, ios: "its_the_climb" }, star4: { android: a.BETWEEN_A_SAW, ios: "between_a_saw" }, star5: { android: a.LEAP_OF_FAITH, ios: "leap_of_faith" }, star6: { android: a.KEYCHAIN, ios: "keychain" }, star7: { android: a.TAKE_THE_PLUNGE, ios: "take_the_plunge" }, star8: { android: a.LIGHTS_OUT_, ios: "lights_out" }, star9: { android: a.OUTSIDE_THE_BOX, ios: "outside_the_box" }, star10: { android: a.INSIDE_THE_BOX, ios: "inside_the_box" }, challenge1: { android: a.ONE_STEP_AT_A_TIME, ios: "one_step_at_a_time" }, challenge2: { android: a.DOUBLE_DOWN, ios: "double_down" }, challenge3: { android: a.THIRDS_THE_CHARM, ios: "thirds_the_charm" }, challenge4: { android: a.FANTASTIC_FOUR, ios: "fantastic_four" }, challenge5: { android: a.HIGH_FIVE, ios: "high_five" }, challenge6: { android: a.DEMON, ios: "demon" }, challenge7: { android: a.YOURE_LUCKY, ios: "youre_lucky" }, challenge8: { android: a.EIGHT_TIMES_THE_CHAMP, ios: "eight_times_the_champ" }, challenge9: { android: a.NINE_LIVES, ios: "nine_lives" }, perfect: { android: a.PERFECT_, ios: "perfect" }, caretaker: { android: a.CARETAKER, ios: "caretaker" }, gasping: { android: a.GASPING, ios: "gasping" }, timeflies: { android: a.TIME_FLIES_V20, ios: "time_flies" }, headsup: { android: a.HEADS_UP, ios: "heads_up" }, deathtycoon: { android: a.DEATH_TYCOON, ios: "death_tycoon" }, olympian: { android: a.OLYMPIAN, ios: "olympian" }, perfectionist: { android: a.PERFECT_, ios: "perfectionist" }, astronomer: { android: a.ASTRONOMER, ios: "astronomer" }, winner: { android: a.WINNER, ios: "winner" } }, a.LeaderBoardToSocialID = { act1: { android: a.LEAD_ACT_1, ios: "act1" }, act2: { android: a.LEAD_ACT_2, ios: "act2" }, act3: { android: a.LEAD_ACT_3, ios: "act3" }, act4: { android: a.LEAD_ACT_4, ios: "act4" }, act5: { android: a.LEAD_ACT_5, ios: "act5" }, act6: { android: a.LEAD_ACT_6, ios: "act6" }, act7: { android: a.LEAD_ACT_7, ios: "act7" }, act8: { android: a.LEAD_ACT_8, ios: "act8" }, act9: { android: a.LEAD_ACT_9, ios: "act9" }, hardcore1: { android: a.LEAD_ACT_1__HARDCORE, ios: "act1_hardcore" }, hardcore2: { android: a.LEAD_ACT_2__HARDCORE, ios: "act2_hardcore" }, hardcore3: { android: a.LEAD_ACT_3__HARDCORE, ios: "act3_hardcore" }, hardcore4: { android: a.LEAD_ACT_4__HARDCORE, ios: "act4_hardcore" }, hardcore5: { android: a.LEAD_ACT_5__HARDCORE, ios: "act5_hardcore" }, hardcore6: { android: a.LEAD_ACT_6__HARDCORE, ios: "act6_hardcore" }, hardcore7: { android: a.LEAD_ACT_7__HARDCORE, ios: "act7_hardcore" }, hardcore8: { android: a.LEAD_ACT_8__HARDCORE, ios: "act8_hardcore" }, hardcore9: { android: a.LEAD_ACT_9__HARDCORE, ios: "act9_hardcore" }, vexation: { android: a.LEAD_VEXATION, ios: "vexation" } }, a
    }(),
    Fabrique;
! function(a) {
    var b = function() {
        function b(a) { this.game = a }
        return b.prototype.initAdProvider = function() {
            if (a.Utils.isOnDevice(this.game)) {
                var b = Constants.getInterstialAd("start", this.game.device.iOS);
                this.game.ads.setAdProvider(new PhaserAds.AdProvider.CocoonAds(this.game, PhaserAds.AdProvider.CocoonProvider.AdMob, {})), this.game.ads.preloadAd(PhaserAds.AdType.interstitial, b);
            }
            else this.game.ads.setAdProvider(new PhaserAds.AdProvider.GameDistributionAds(this.game, "762c932b4db74c6da0c1d101b2da8be6", "ABD36C6C-E74B-4BA7-BE87-0AB01F98D30D-s1"))
        }, b.prototype.showAd = function(b, c, d) {
            var e = this;
            this.game.ads.onContentPaused.addOnce(function() { e.game.analytics.google.sendScreenView("advertisement"), c && c.call(e) }), this.game.ads.onContentResumed.addOnce(function() {
                if (a.Utils.isOnDevice(e.game) && d) {
                    var c = Constants.getInterstialAd(d, e.game.device.iOS);
                    e.game.ads.preloadAd(PhaserAds.AdType.interstitial, c)
                }
                b && b.call(e), e.game.ads.onContentPaused.removeAll(), e.game.ads.onContentResumed.removeAll()
            }), a.Utils.isOnDevice(this.game) ? this.game.ads.showAd(PhaserAds.AdType.interstitial) : this.game.ads.showAd()
        }, b.getInstance = function(a) { return null === b.instance && (b.instance = new b(a)), b.instance }, b.instance = null, b
    }();
    a.AdHandler = b
}(Fabrique || (Fabrique = {}));
var Fabrique;
! function(a) {
    var b = function() {
        function b(a) { this.game = a }
        return b.prototype.initAnalytics = function() {
            var b = this;
            this.game.analytics.game.setup(Constants.GAME_KEY, Constants.SECRET_KEY, version, this.game.analytics.game.createUser());
            var c = Date.now();
            window.addEventListener("beforeunload", function() { b.game.analytics.game.addEvent(new GA.Events.SessionEnd((Date.now() - c) / 1e3)), b.game.analytics.game.sendEvents() }), a.Utils.isOnDevice(this.game) ? this.game.analytics.google.setup(Constants.GOOGLE_ID, Constants.GOOGLE_APP_NAME, version, { storage: "none" }) : this.game.analytics.google.setup(Constants.GOOGLE_ID, Constants.GOOGLE_APP_NAME, version), this.game.analytics.game.setup(Constants.GAME_KEY, Constants.SECRET_KEY, version, new GA.User)
        }, b.getInstance = function(a) { return null === b.instance && (b.instance = new b(a)), b.instance }, b.instance = null, b
    }();
    a.AnalyticsHandler = b
}(Fabrique || (Fabrique = {}));
var SaveGame = function() {
        function a(a) { this.levels = [], this.achievements = Constants.achievements, this.game = a }
        return a.getInstance = function(b) { return a.instance || (a.instance = new a(b)), a.instance }, a.prototype.init = function() {
            var a = this;
            this.game.storage.setNamespace("v3"), this.game.storage.getItem("sg").then(function(b) { null === b || void 0 === b ? (a.clearAll(), a.save()) : a.restore() })
        }, a.prototype.getAllValues = function() { return { options: this.getOptions(), stats: this.getStats(), latestCompleted: Constants.latestCompleted, levels: this.getAllLevels(), achievements: this.getAchievements() } }, a.prototype.setAllValues = function(a) { this.setOptions(a.options), this.setStats(a.stats), this.setLastLevel(a.latestCompleted), this.setAllLevels(a.levels), this.setAchievements(a.achievements) }, a.prototype.getOptions = function() { return { mv: Constants.musicVolume, efxv: Constants.effectVolume, ar: Constants.autoReset, pl: Constants.particleLimit, nc: Constants.oldControls, bl: Constants.blend, wv: Constants.waves, plx: Constants.parallax, mt: Constants.muted } }, a.prototype.setOptions = function(a) { Constants.musicVolume = a.mv, Constants.effectVolume = a.efxv, Constants.autoReset = a.ar, Constants.particleLimit = a.pl, Constants.oldControls = a.nc, Constants.blend = a.bl, Constants.waves = a.wv, Constants.parallax = a.plx, Constants.muted = a.mt }, a.prototype.getStats = function() { return { td: Constants.totalDeaths, tp: Constants.timePlayed } }, a.prototype.setStats = function(a) { Constants.totalDeaths = a.td, Constants.timePlayed = a.tp }, a.prototype.setLastLevel = function(a) { Constants.latestCompleted = a }, a.prototype.getAllLevels = function() { return this.levels }, a.prototype.setLevel = function(a, b) {
            var c = a - 1,
                d = this.levels[c];
            d = b, d.id = a, this.levels[c] = d
        }, a.prototype.setAllLevels = function(a) { this.levels = [], this.levels = a }, a.prototype.getLevel = function(a) { return this.levels[a] }, a.prototype.getAchievements = function() { return this.achievements }, a.prototype.setAchievements = function(a) { this.achievements = a }, a.prototype.clearOptions = function() { Constants.musicVolume = 1, Constants.effectVolume = .5, Constants.autoReset = !1, Constants.particleLimit = 30, Constants.oldControls = !1, Constants.blend = !0, Constants.waves = !0, Constants.parallax = !0, Constants.muted = !1, this.game.device.desktop || (Constants.particleLimit = 0, Constants.blend = !1, Constants.waves = !1, Constants.parallax = !1) }, a.prototype.clearStats = function() { Constants.totalDeaths = 0, Constants.timePlayed = 0 }, a.prototype.clearLevel = function() { return { tt: -1, br: 4, gs: !1, cc: !1, fn: !1 } }, a.prototype.clearAllLevels = function() {
            this.levels = [];
            for (var a = 0; a <= 10; a++) {
                var b = this.clearLevel();
                b.id = a + 1, this.levels.push(b)
            }
        }, a.prototype.clearAchievements = function() { this.achievements = Constants.achievements }, a.prototype.saveOptions = function(a) { this.save() }, a.prototype.resetOptions = function() { this.clearOptions(), this.save() }, a.prototype.saveStats = function(a) { this.save() }, a.prototype.resetStats = function() { this.clearStats(), this.save() }, a.prototype.saveLevels = function(a, b) { this.setLevel(a, b), this.setLastLevel(a), this.save() }, a.prototype.resetLevels = function() { this.clearAllLevels(), this.setLastLevel(0), this.save() }, a.prototype.saveAchievements = function(a) { this.setAchievements(a), this.save() }, a.prototype.resetAchievements = function() { this.clearAchievements(), this.save() }, a.prototype.clearAll = function() { this.clearOptions(), this.clearStats(), this.clearAllLevels(), this.save() }, a.prototype.save = function() {
            var a = JSON.stringify(this.getAllValues()),
                b = this.hash([a.options, a.stats, a.latestCompleted, a.levels, a.achievements].join("-"));
            this.game.storage.setItem("sg", a), this.game.storage.setItem("h", b)
        }, a.prototype.restore = function() {
            var a = this;
            this.game.storage.getItem("sg").then(function(b) { a.setAllValues(JSON.parse(b)) })
        }, a.prototype.load = function() { return this.game.storage.getItem("sg") }, a.prototype.hash = function(a) { var b, c, d, e = 0; if (0 === a.length) return e.toString(); for (b = 0, d = a.length; b < d; b++) c = a.charCodeAt(b), e = (e << 5) - e + c, e |= 0; return e.toString() }, a.prototype.checkStoredHash = function() {
            var a = this,
                b = this.getAllValues();
            this.game.storage.getItem("h").then(function(c) { a.hash([b.options, b.stats, b.latestCompleted, b.levels, b.achievements].join("-")) })
        }, a
    }(),
    SocialServicesHandler = function() {
        function a() {}
        return a.init = function(a) { socialService = this.getSocialInterface(a) }, a.getSocialInterface = function(a) { return a.device.android ? (Cocoon.Social.GooglePlayGames.init({}), Cocoon.Social.GooglePlayGames.getSocialInterface()) : a.device.iOS ? (Cocoon.Social.GameCenter.init({}), Cocoon.Social.GameCenter.getSocialInterface()) : void 0 }, a.login = function(a) { socialService.login(function(a, b) {}) }, a.submitAchievement = function(a, b) {
            var c = SocialServicesData.getSocialServiceID(a, SocialServicesData.AchToSocialID, b);
            socialService.submitAchievement(c, function(a) {})
        }, a.submitScore = function(a, b, c, d) {
            var e = SocialServicesData.convertTime(a, b),
                f = SocialServicesData.getActName(c, d),
                g = SocialServicesData.getSocialServiceID(a, SocialServicesData.LeaderBoardToSocialID, f);
            socialService.submitScore(e, function(a) {}, { leaderboardID: g })
        }, a.showAchievements = function(a) { socialService.showAchievements(function(a) {}) }, a.showLeaderboards = function(a) { socialService.showLeaderboard(function(a) {}) }, a
    }(),
    PressDown = function() {
        function a(a) { this.parentGroup = a, this.blinkingImg = this.parentGroup.create(0, -50, "pressDown"), this.blinkingImg.anchor.set(.5, .5), this.blinkingImg.visible = !1, this.pressDownTimer = 60, this.showPressDown = !1 }
        return a.prototype.blink = function() { this.showPressDown ? (this.pressDownTimer <= 0 ? (this.blinkingImg.visible = !this.blinkingImg.visible, this.pressDownTimer = 15) : this.pressDownTimer--, this.parentGroup.scale.x < 0 ? this.blinkingImg.scale.x = -1 : this.blinkingImg.scale.x = 1) : (this.blinkingImg.visible = !1, this.pressDownTimer = 60) }, a
    }(),
    VexBoot = function() {
        function a(a) {}
        return a.prototype.init = function() {
            var a = this;
            this.input.maxPointers = 2, Fabrique.AnalyticsHandler.getInstance(this.game).initAnalytics(), Fabrique.AdHandler.getInstance(this.game).initAdProvider(), SaveGame.getInstance(this.game).init(), Fabrique.Utils.isOnDevice(this.game) && SocialServicesHandler.init(this.game), this.game.canvas.oncontextmenu = function(a) { a.preventDefault() }, this.game.analytics.google.sendScreenView("boot"), this.game.load.cacheBuster = "undefined" == typeof version ? null : version, this.game.device.desktop ? (this.scale.scaleMode = Phaser.ScaleManager.RESIZE, this.scale.supportsFullScreen = !0, this.scale.setMinMax(640, 300, 2e3, 1120), this.scale.pageAlignHorizontally = !0, this.scale.pageAlignVertically = !0) : (this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.game.scale.pageAlignHorizontally = !0, this.game.scale.pageAlignVertically = !0, this.game.scale.windowConstraints.right = "layout", this.game.scale.windowConstraints.bottom = "visual", window.addEventListener("resize", function(b) { return a.resizeCallback(a.game.scale) }), this.resizeCallback(this.game.scale))
        }, a.prototype.resizeCallback = function(a) {
            var b = 1.35;
            this.game.device.pixelRatio > 1 && (b = 1.35), a.width === window.innerWidth * b && a.height === window.innerHeight * b || (a.setGameSize(window.innerWidth * b, window.innerHeight * b), a.setUserScale(1 / b, 1 / b))
        }, a.prototype.create = function() {
            var a = this;
            Fabrique.LoaderHelper.hide(), this.game.state.start(Fabrique.SplashScreen.Preloader.Name, !0, !1, {
                nextState: "Game",
                splashOverride: Fabrique.BrandingDomain.Kizi,
                mobilePlayClickhandler: function() { Fabrique.LoaderHelper.show(), Fabrique.AdHandler.getInstance(a.game).showAd(function() { Fabrique.LoaderHelper.hide(), a.game.state.start("Game") }, function() { Fabrique.LoaderHelper.hide() }, "start") },
                preloadHandler: function() {
                    a.game.analytics.google.sendScreenView("splash"), Fabrique.Branding.preloadImages(a.game), Fabrique.Branding.isAirfi() || Fabrique.MoreGames.Menu.preloadImages(a.game), a.game.stage.disableVisibilityChange = !1, a.game.device.iOS ? (a.game.load.audio("connectHang", ["assets/sounds/connect-hang.m4a"], !1), a.game.load.audio("fall", ["assets/sounds/fall.m4a"], !1), a.game.load.audio("downgrade", ["assets/sounds/downgrade.m4a"], !1), a.game.load.audio("poleSwing", ["assets/sounds/pole-swing.m4a"], !1), a.game.load.audio("splash1", ["assets/sounds/splash1.m4a"], !1), a.game.load.audio("ziplineFull", ["assets/sounds/zipline-full.m4a"], !1), a.game.load.audio("cannonEnter", ["assets/sounds/cannon-enter.m4a"], !1), a.game.load.audio("wallSlide", ["assets/sounds/wall-slide.m4a"], !1), a.game.load.audio("connect", ["assets/sounds/connect.m4a"], !1), a.game.load.audio("land", ["assets/sounds/land.m4a"], !1), a.game.load.audio("slide", ["assets/sounds/slide.m4a"], !1), a.game.load.audio("death1", ["assets/sounds/slide.m4a"], !1), a.game.load.audio("death2", ["assets/sounds/death2.m4a"], !1), a.game.load.audio("electricity", ["assets/sounds/electricity.m4a"], !1), a.game.load.audio("poleWoosh", ["assets/sounds/pole-woosh.m4a"], !1), a.game.load.audio("bounce1", ["assets/sounds/bounce1.m4a"], !1), a.game.load.audio("cannonFire", ["assets/sounds/cannon-fire.m4a"], !1), a.game.load.audio("glassSmash", ["assets/sounds/glass-smash.m4a"], !1), a.game.load.audio("fallingBlock", ["assets/sounds/falling-block.m4a"], !1), a.game.load.audio("blockDestroy", ["assets/sounds/block-destroy.m4a"], !1), a.game.load.audio("menuSong", ["assets/sounds/menu-song.m4a"], !1), a.game.load.audio("vexSong1", ["assets/sounds/vex-song-1.m4a"], !1), a.game.load.audio("vexSong2", ["assets/sounds/vex-song-2.m4a"], !1), a.game.load.audio("vexSong3", ["assets/sounds/vex-song-3.m4a"], !1), a.game.load.audio("vexSong4", ["assets/sounds/vex-song-4.m4a"], !1), a.game.load.audio("buttonClick", ["assets/sounds/button-click.m4a"], !1), a.game.load.audio("achievementUnlocked", ["assets/sounds/achievement-unlocked.m4a"], !1), a.game.load.audio("footstep", ["assets/sounds/footstep.m4a"], !1), a.game.load.audio("laserFire", ["assets/sounds/laser-fire.m4a"], !1), a.game.load.audio("ding", ["assets/sounds/ding.m4a"], !1), a.game.load.audio("kickBlock", ["assets/sounds/kick-block.m4a"], !1), a.game.load.audio("starPickup", ["assets/sounds/star-pickup.m4a"], !1)) : (a.game.load.audio("connectHang", ["assets/sounds/connect-hang.ogg"], ["assets/sounds/connect-hang.mp3"], !1), a.game.load.audio("fall", ["assets/sounds/fall.ogg"], ["assets/sounds/fall.wav"], !1), a.game.load.audio("downgrade", ["assets/sounds/downgrade.ogg"], ["assets/sounds/downgrade.mp3"], !1), a.game.load.audio("poleSwing", ["assets/sounds/pole-swing.ogg"], ["assets/sounds/pole-swing.mp3"], !1), a.game.load.audio("splash1", ["assets/sounds/splash1.ogg"], ["assets/sounds/splash1.mp3"], !1), a.game.load.audio("ziplineFull", ["assets/sounds/zipline-full.ogg"], ["assets/sounds/zipline-full.mp3"], !1), a.game.load.audio("cannonEnter", ["assets/sounds/cannon-enter.ogg"], ["assets/sounds/cannon-enter.mp3"], !1), a.game.load.audio("wallSlide", ["assets/sounds/wall-slide.ogg"], ["assets/sounds/wall-slide.mp3"], !1), a.game.load.audio("connect", ["assets/sounds/connect.ogg"], ["assets/sounds/connect.mp3"], !1), a.game.load.audio("land", ["assets/sounds/land.ogg"], ["assets/sounds/land.mp3"], !1), a.game.load.audio("slide", ["assets/sounds/slide.ogg"], ["assets/sounds/slide.mp3"], !1), a.game.load.audio("death1", ["assets/sounds/slide.ogg"], ["assets/sounds/slide.mp3"], !1), a.game.load.audio("death2", ["assets/sounds/death2.ogg"], ["assets/sounds/death2.mp3"], !1), a.game.load.audio("electricity", ["assets/sounds/electricity.ogg"], ["assets/sounds/electricity.mp3"], !1), a.game.load.audio("poleWoosh", ["assets/sounds/pole-woosh.ogg"], ["assets/sounds/pole-woosh.mp3"], !1), a.game.load.audio("bounce1", ["assets/sounds/bounce1.ogg"], ["assets/sounds/bounce1.mp3"], !1), a.game.load.audio("cannonFire", ["assets/sounds/cannon-fire.ogg"], ["assets/sounds/cannon-fire.mp3"], !1), a.game.load.audio("glassSmash", ["assets/sounds/glass-smash.ogg"], ["assets/sounds/glass-smash.mp3"], !1), a.game.load.audio("fallingBlock", ["assets/sounds/falling-block.ogg"], ["assets/sounds/falling-block.mp3"], !1), a.game.load.audio("blockDestroy", ["assets/sounds/block-destroy.ogg"], ["assets/sounds/block-destroy.mp3"], !1), a.game.load.audio("menuSong", ["assets/sounds/menu-song.ogg"], ["assets/sounds/menu-song.mp3"], !1), a.game.load.audio("vexSong1", ["assets/sounds/vex-song-1.ogg"], ["assets/sounds/vex-song-1.mp3"], !1), a.game.load.audio("vexSong2", ["assets/sounds/vex-song-2.ogg"], ["assets/sounds/vex-song-2.mp3"], !1), a.game.load.audio("vexSong3", ["assets/sounds/vex-song-3.ogg"], ["assets/sounds/vex-song-3.mp3"], !1), a.game.load.audio("vexSong4", ["assets/sounds/vex-song-4.ogg"], ["assets/sounds/vex-song-4.mp3"], !1), a.game.load.audio("buttonClick", ["assets/sounds/button-click.ogg"], ["assets/sounds/button-click.mp3"], !1), a.game.load.audio("achievementUnlocked", ["assets/sounds/achievement-unlocked.ogg"], ["assets/sounds/achievement-unlocked.mp3"], !1), a.game.load.audio("footstep", ["assets/sounds/footstep.ogg"], ["assets/sounds/footstep.mp3"], !1), a.game.load.audio("laserFire", ["assets/sounds/laser-fire.ogg"], ["assets/sounds/laser-fire.mp3"], !1), a.game.load.audio("ding", ["assets/sounds/ding.ogg"], ["assets/sounds/ding.mp3"], !1), a.game.load.audio("kickBlock", ["assets/sounds/kick-block.ogg"], ["assets/sounds/kick-block.mp3"], !1), a.game.load.audio("starPickup", ["assets/sounds/star-pickup.ogg"], ["assets/sounds/star-pickup.mp3"], !1)), a.game.load.script("colorMatrixFilter", "assets/filters/ColorMatrixFilter.js"), a.game.load.script("blurX", "assets/filters/BlurX.js"), a.game.load.script("blurY", "assets/filters/BlurY.js"), a.game.load.script("gray", "assets/filters/Gray.js"), a.game.load.bitmapFont("grob24", "assets/images/fonts/grob24.png", "assets/images/fonts/grob24.fnt"), a.game.load.bitmapFont("grobred32", "assets/images/fonts/grobred32.png", "assets/images/fonts/grobred32.fnt"), a.game.load.image("menuPlayGame", "assets/images/buttons/mainmenu/menu-play-game.png"), a.game.load.image("menuOptions", "assets/images/buttons/mainmenu/menu-options.png"), a.game.load.image("menuTrophy", "assets/images/buttons/mainmenu/menu-trophy.png"), a.game.load.image("vex4Logo", "assets/images/buttons/mainmenu/vex4.png"), Fabrique.Branding.isAirfi() || a.game.load.image("menuMoreGames", "assets/images/buttons/mainmenu/menu-more-games.png"), a.game.load.image("menuLeaderBoard", "assets/images/buttons/mainmenu/menu-leaderboard.png"), a.game.load.image("menuAchievements", "assets/images/buttons/mainmenu/menu-achievement.png"), a.game.load.image("circleButton", "assets/images/circle-button.png"), a.game.load.image("circleLrButton", "assets/images/L_R-circle-button.png"), a.game.load.image("jumpButton", "assets/images/jump-button.png"), a.game.load.image("crouchButton", "assets/images/crouch-button.png"), a.game.load.image("spaceButton", "assets/images/space-button.png"), a.game.load.image("normalBtn", "assets/images/press-down-normal.png"), a.game.load.image("hardcoreBtn", "assets/images/press-down-hard.png"), a.game.load.image("hellNormal", "assets/images/text/hell_white_normal.png"), a.game.load.spritesheet("tickboxWhite", "assets/images/buttons/tick_white_box.png", 132, 25, 2, 0, 1), a.game.load.image("hellXL", "assets/images/hell_xl.png"), a.game.load.image("clickHellTxt", "assets/images/text/act-block/click_hell_text.png"), a.game.load.image("gameTopBG", "assets/images/gui/game-top-bg.png"), a.game.load.image("rankTimeBG", "assets/images/gui/rank-time-bg.png"), a.game.load.image("timerBG", "assets/images/gui/timer-bg.png"), a.game.load.image("levelNameBG", "assets/images/gui/level-name-bg.png"), a.game.load.image("rankTimeStaticText", "assets/images/gui/rank-time-static-text.png"), a.game.load.image("bronzeText", "assets/images/text/ranks/bronze-text.png"), a.game.load.image("silverText", "assets/images/text/ranks/silver-text.png"), a.game.load.image("goldText", "assets/images/text/ranks/gold-text.png"), a.game.load.image("perfectText", "assets/images/text/ranks/perfect-text.png"), a.game.load.image("clearText", "assets/images/text/ranks/clear-text.png"), a.game.load.image("noneText", "assets/images/text/ranks/none-text.png"), a.game.load.image("stageButtonBG", "assets/images/buttons/stage-button-bg.png"), a.game.load.image("stageLabelBG", "assets/images/buttons/bottom-label-bg.png"), a.game.load.image("quitLogo", "assets/images/buttons/quit-logo.png"), a.game.load.image("trophyLogo", "assets/images/buttons/trophy-logo.png"), a.game.load.image("optionsLogo", "assets/images/buttons/options-logo.png"), a.game.load.image("resetLogo", "assets/images/buttons/reset-logo.png"), a.game.load.image("actSelectLogo", "assets/images/buttons/act-select-logo.png"), a.game.load.spritesheet("muteButton", "assets/images/buttons/mute-button.png", 30, 29, 2, 0, 1), a.game.load.image("pauseButton", "assets/images/buttons/pause-button.png"), a.game.load.image("actSelectWindow", "assets/images/windows/act-select-window.png"), a.game.load.image("actSelectWindowLong", "assets/images/windows/pause-window-small.png"), a.game.load.image("actSelectSmall", "assets/images/windows/act-select-small.png"), a.game.load.image("closeButton", "assets/images/buttons/close-button.png"), a.game.load.image("act1-button", "assets/images/buttons/act1-button.png"), a.game.load.image("act2-button", "assets/images/buttons/act2-button.png"), a.game.load.image("act3-button", "assets/images/buttons/act3-button.png"), a.game.load.image("act4-button", "assets/images/buttons/act4-button.png"), a.game.load.image("act5-button", "assets/images/buttons/act5-button.png"), a.game.load.image("act6-button", "assets/images/buttons/act6-button.png"), a.game.load.image("act7-button", "assets/images/buttons/act7-button.png"), a.game.load.image("act8-button", "assets/images/buttons/act8-button.png"), a.game.load.image("act9-button", "assets/images/buttons/act9-button.png"), a.game.load.image("act10-button", "assets/images/buttons/act10-button.png"), a.game.load.image("achievementsWindow", "assets/images/windows/achievements-window.png"), a.game.load.image("standardActsButton", "assets/images/buttons/standard-acts-button.png"), a.game.load.image("challengeActsButton", "assets/images/buttons/challenge-acts-button.png"), a.game.load.image("awesomeStuffButton", "assets/images/buttons/awesome-stuff-button.png"), a.game.load.image("completionButton", "assets/images/buttons/completion-button.png"), a.game.load.image("achievementProgressBar", "assets/images/buttons/achievements/achievement-progress-bar.png"), a.game.load.image("optionsWindow", "assets/images/windows/options-window.png"), a.game.load.image("slider", "assets/images/buttons/slider.png"), a.game.load.image("slideDrag", "assets/images/buttons/slide-drag.png"), a.game.load.spritesheet("tickButton", "assets/images/buttons/tick-button.png", 132, 25, 2, 0, 1), a.game.load.spritesheet("qualityButton", "assets/images/buttons/quality-button.png", 55, 20, 3, 0, 1), a.game.load.spritesheet("qualityButton", "assets/images/buttons/quality-button.png", 55, 20, 3, 0, 1), a.game.load.image("optionsNoClear", "assets/images/buttons/options-noclear.png"), a.game.load.image("clearAllButton", "assets/images/buttons/clear-all-button.png"), a.game.load.image("pauseWindow", "assets/images/windows/pause-window-small.png"), a.game.load.image("parallaxBackground", "assets/images/parallaxBackground.png"), a.game.load.image("simpleTransition", "assets/images/gui/simple-transition.png"), a.game.load.image("basicBlock", "assets/images/blocks/block-basic.png"), a.game.load.spritesheet("basicBlockColors", "assets/images/blocks/basic-block-colors.png", 99, 99, 12, 0, 2), a.game.load.image("leftSlope", "assets/images/blocks/left-slope.png"), a.game.load.spritesheet("leftSlopeColors", "assets/images/blocks/slope-colors.png", 99, 99, 8, 0, 2), a.game.load.image("verticalUpBlock", "assets/images/blocks/vertical-up-block.png"), a.game.load.image("verticalDownBlock", "assets/images/blocks/vertical-down-block.png"), a.game.load.image("horizontalBlock", "assets/images/blocks/horizontal-block.png"), a.game.load.image("fallingBlock", "assets/images/blocks/falling-block.png"), a.game.load.image("bounceBlock", "assets/images/blocks/bounce-block.png"), a.game.load.image("pushBlock", "assets/images/blocks/push-block.png"), a.game.load.image("iceBlock", "assets/images/blocks/ice-block.png"), a.game.load.image("glassBlock", "assets/images/blocks/glass-block.png"), a.game.load.image("speedBlock", "assets/images/blocks/speed-block.png"), a.game.load.image("lockBlock", "assets/images/blocks/lock-block.png"), a.game.load.image("sparkBlock", "assets/images/blocks/spark-block.png"), a.game.load.image("solarBlock", "assets/images/blocks/solar-block.png"), a.game.load.image("invisBlock", "assets/images/blocks/invis-block.png"), a.game.load.image("invisBlockUp", "assets/images/blocks/invis-block-up.png"), a.game.load.image("invisBlockDown", "assets/images/blocks/invis-block-down.png"), a.game.load.image("explosiveBlock", "assets/images/blocks/explosive-block.png"), a.game.load.spritesheet("blockedWall", "assets/images/blocks/blocked-wall.png", 65, 444, 120, 0, 1), a.game.load.image("actBlock1", "assets/images/blocks/act-block-1.png"), a.game.load.image("actBlock2", "assets/images/blocks/act-block-2.png"), a.game.load.image("actBlock3", "assets/images/blocks/act-block-3.png"), a.game.load.image("actBlock4", "assets/images/blocks/act-block-4.png"), a.game.load.image("actBlock5", "assets/images/blocks/act-block-5.png"), a.game.load.image("actBlock6", "assets/images/blocks/act-block-6.png"), a.game.load.image("actBlock7", "assets/images/blocks/act-block-7.png"), a.game.load.image("actBlock8", "assets/images/blocks/act-block-8.png"), a.game.load.image("actBlock9", "assets/images/blocks/act-block-9.png"), a.game.load.image("actBlock10", "assets/images/blocks/act-block-10.png"), a.game.load.image("swimmingPool", "assets/images/blocks/swimming-pool.png"), a.game.load.image("leftSlope", "assets/images/blocks/left-slope.png"), a.game.load.spritesheet("slope-colors", "assets/images/blocks/slope-colors.png", 100, 100, 8), a.game.load.spritesheet("arrowAnimation", "assets/images/blocks/arrow-animation.png", 100, 292, 30), a.game.load.image("arrowStatic", "assets/images/blocks/arrow-static.png"), a.game.load.spritesheet("checkpoint", "assets/images/items/checkpoint.png", 24, 55, 3), a.game.load.spritesheet("checkpointSwimming", "assets/images/items/checkpoint-swimming.png", 51, 62, 3, 1), a.game.load.image("checkpointText", "assets/images/items/checkpoint-text.png"), a.game.load.spritesheet("finishPortal", "assets/images/items/finish-portal.png", 52, 60, 60), a.game.load.image("ziplinePole", "assets/images/items/zipline-pole.png"), a.game.load.image("pole", "assets/images/items/pole.png"), a.game.load.image("poleRedSection", "assets/images/items/pole-red-section.png"), a.game.load.image("star", "assets/images/items/star.png"), a.game.load.image("hazardStrips", "assets/images/items/hazard-strips.png"), a.game.load.image("breatheBlaster", "assets/images/items/breathe-blaster.png"), a.game.load.image("windBlaster", "assets/images/items/wind-blaster.png"), a.game.load.spritesheet("windFan", "assets/images/items/wind-fan.png", 13, 53, 6), a.game.load.image("key", "assets/images/items/key.png"), a.game.load.image("timedKey", "assets/images/items/timed-key.png"), a.game.load.image("cannonBase", "assets/images/items/cannon-base.png"), a.game.load.image("cannonTube", "assets/images/items/cannon-tube.png"), a.game.load.image("lightSwitch", "assets/images/items/light-switch.png"), a.game.load.image("wire", "assets/images/items/wire.png"), a.game.load.image("buzzsaw", "assets/images/obstacles/buzzsaw.png"), a.game.load.image("buzzsawOnStick", "assets/images/obstacles/buzzsaw-on-stick.png"), a.game.load.image("spike", "assets/images/obstacles/spike.png"), a.game.load.image("spike10x", "assets/images/obstacles/spike10x.png"), a.game.load.image("spike30x", "assets/images/obstacles/spike30x.png"), a.game.load.image("fallingSpike", "assets/images/obstacles/falling-spike.png"), a.game.load.image("shurikanSpawner", "assets/images/obstacles/shurikan-spawner.png"), a.game.load.spritesheet("shurikanHorizontal", "assets/images/obstacles/shurikan-horizontal.png", 22, 22, 3), a.game.load.spritesheet("shurikanHorizontal", "assets/images/obstacles/shurikan-horizontal.png", 22, 22, 3), a.game.load.spritesheet("shurikanDispenser", "assets/images/obstacles/shurikan-dispenser.png", 46, 46, 25), a.game.load.image("classicLaser", "assets/images/obstacles/classic-laser.png"), a.game.load.image("bullet", "assets/images/obstacles/laser-bullet.png"), a.game.load.image("quadrant", "assets/images/obstacles/quadrant.png"), a.game.load.image("reaper", "assets/images/obstacles/reaper.png"), a.game.load.image("spark", "assets/images/obstacles/spark.png"), a.game.load.image("pressDown", "assets/images/press-down.png"), a.game.load.image("actCheck", "assets/images/act-check.png"), a.game.load.image("playerStand", "assets/images/player/player-stand.png"), a.game.load.spritesheet("playerSlide", "assets/images/player/player-slide.png", 37, 36, 16), a.game.load.spritesheet("playerCrouch", "assets/images/player/player-crouch.png", 28, 33, 15, 1), a.game.load.spritesheet("playerRun", "assets/images/player/player-run.png", 30, 32, 20), a.game.load.spritesheet("playerJump", "assets/images/player/player-jump.png", 22, 39, 7), a.game.load.spritesheet("playerJumpDown", "assets/images/player/player-jump-down.png", 25, 40, 17), a.game.load.spritesheet("playerJumpFrontFlip", "assets/images/player/player-jump-front-flip.png", 35, 43, 19), a.game.load.spritesheet("playerJumpBackFlip", "assets/images/player/player-jump-back-flip.png", 36, 41, 22), a.game.load.spritesheet("playerFall", "assets/images/player/player-fall.png", 23, 37, 23), a.game.load.spritesheet("playerScale", "assets/images/player/player-scale.png", 20, 39, 4), a.game.load.spritesheet("playerHang", "assets/images/player/player-hang.png", 19, 38, 20), a.game.load.spritesheet("playerPulley", "assets/images/player/player-pulley.png", 43, 39, 35), a.game.load.spritesheet("playerSwing", "assets/images/player/player-swing.png", 61, 72, 35), a.game.load.spritesheet("playerPush", "assets/images/player/player-push.png", 28, 33, 31), a.game.load.spritesheet("playerKick", "assets/images/player/player-kick.png", 36, 41, 28), a.game.load.spritesheet("playerSwimTop", "assets/images/player/player-swim-top.png", 20, 23, 8), a.game.load.spritesheet("playerSwimBottom", "assets/images/player/player-swim-bottom.png", 16, 20, 28), a.game.load.spritesheet("playerSpawn", "assets/images/player/player-spawn.png", 16, 40, 60), a.game.load.image("playerHead", "assets/images/player/parts/player-head.png"), a.game.load.image("playerBody", "assets/images/player/parts/player-body.png"), a.game.load.image("playerArm", "assets/images/player/parts/player-arm.png"), a.game.load.image("playerLeg", "assets/images/player/parts/player-leg.png"), a.game.load.image("breatheBlock", "assets/images/breathe-block.png"), a.game.load.image("enterLevelText", "assets/images/text/act-block/enter-level-text.png"), a.game.load.image("actDownArrow", "assets/images/text/act-block/act-down-arrow.png"), a.game.load.image("completedText", "assets/images/text/act-block/completed-text.png"), a.game.load.image("hellText", "assets/images/text/act-block/hell-text.png"), a.game.load.image("fastestTimeText", "assets/images/text/act-block/fastest-time-text.png"), a.game.load.spritesheet("completedIcon", "assets/images/text/act-block/completed-icon.png", 50, 44, 2), a.game.load.spritesheet("challengeIcon", "assets/images/text/act-block/challenge-icon.png", 68, 67, 2), a.game.load.spritesheet("starIcon", "assets/images/text/act-block/star-icon.png", 48, 46, 2), a.game.load.image("vexLogo", "assets/images/vex-logo.png"), a.game.load.image("textFade1", "assets/images/text/text-fade-1.png"), a.game.load.image("textFade2", "assets/images/text/text-fade-2.png"), a.game.load.image("textFade4", "assets/images/text/text-fade-4.png"), a.game.load.image("textFade5", "assets/images/text/text-fade-5.png"), a.game.load.image("textFade6", "assets/images/text/text-fade-6.png"), a.game.load.image("textFade7", "assets/images/text/text-fade-7.png"), a.game.load.image("textFade8", "assets/images/text/text-fade-8.png"), a.game.load.image("textFade10", "assets/images/text/text-fade-10.png"), a.game.load.image("textFade11", "assets/images/text/text-fade-11.png"), a.game.load.image("textFade12", "assets/images/text/text-fade-12.png"), a.game.load.image("textFade13", "assets/images/text/text-fade-13.png"), a.game.load.image("textFade13Mobile", "assets/images/text/text-fade-13-mobile.png"), a.game.load.image("textFade14", "assets/images/text/text-fade-14.png"), a.game.load.image("textFade15", "assets/images/text/text-fade-15.png"), a.game.load.image("textFade16", "assets/images/text/text-fade-16.png"), a.game.load.image("textFade17", "assets/images/text/text-fade-17.png"), a.game.load.image("textFade18", "assets/images/text/text-fade-18.png"), a.game.load.image("textFade19", "assets/images/text/text-fade-19.png"), a.game.load.image("textFade20", "assets/images/text/text-fade-20.png"), a.game.load.image("textFade21", "assets/images/text/text-fade-21.png"), a.game.load.image("textFade22", "assets/images/text/text-fade-22.png"), a.game.load.image("textFade23", "assets/images/text/text-fade-23.png"), a.game.load.image("textFade24", "assets/images/text/text-fade-24.png"), a.game.load.image("textFade25", "assets/images/text/text-fade-25.png"), a.game.load.image("textFade26", "assets/images/text/text-fade-26.png"), a.game.load.image("textFade27", "assets/images/text/text-fade-27.png"), a.game.load.image("textFade28", "assets/images/text/text-fade-28.png"), a.game.load.image("textFade29", "assets/images/text/text-fade-29.png"), a.game.load.image("textFade30", "assets/images/text/text-fade-30.png"), a.game.load.image("textFade31", "assets/images/text/text-fade-31.png"), a.game.load.image("textFade32", "assets/images/text/text-fade-32.png"), a.game.load.image("textFade33", "assets/images/text/text-fade-33.png"), a.game.load.image("textFade34", "assets/images/text/text-fade-34.png"), a.game.load.image("textFade35", "assets/images/text/text-fade-35.png"), a.game.load.image("textFade36", "assets/images/text/text-fade-36.png"), a.game.load.image("textFade37", "assets/images/text/text-fade-37.png"), a.game.load.image("textFade38", "assets/images/text/text-fade-38.png"), a.game.load.image("textFade39", "assets/images/text/text-fade-39.png"), a.game.load.image("textFade40", "assets/images/text/text-fade-40.png"), a.game.load.image("textFade41", "assets/images/text/text-fade-41.png"), a.game.load.image("textFade42", "assets/images/text/text-fade-42.png"), a.game.load.image("textFade43", "assets/images/text/text-fade-43.png"), a.game.load.image("textFade44", "assets/images/text/text-fade-44.png"), a.game.load.spritesheet("darkOverlay", "assets/images/dark-overlay.png", 520, 520, 30), a.game.load.image("achievementUnlocked", "assets/images/windows/achievement-unlocked.png"), a.game.load.image("stuckWindow", "assets/images/windows/stuck-window.png"), a.game.load.image("backButton", "assets/images/buttons/back-button.png");
                    for (var b = 1; b <= 10; b++) a.game.load.image("act" + b + "Achievement", "assets/images/buttons/achievements/act" + b + "-achievement.png");
                    for (var b = 1; b <= 10; b++) a.game.load.image("star" + b + "Achievement", "assets/images/buttons/achievements/star" + b + "-achievement.png");
                    for (var b = 1; b <= 9; b++) a.game.load.image("challenge" + b + "Achievement", "assets/images/buttons/achievements/challenge" + b + "-achievement.png");
                    for (var b = 1; b <= 7; b++) a.game.load.image("awesome" + b + "Achievement", "assets/images/buttons/achievements/awesome" + b + "-achievement.png");
                    for (var b = 1; b <= 4; b++) a.game.load.image("complete" + b + "Achievement", "assets/images/buttons/achievements/complete" + b + "-achievement.png")
                }
            })
        }, a
    }(),
    OrientationWindow = function(a) {
        function b(b, c, d) { var e = a.call(this, b, c, d) || this; return e.frame = d.create(0, 0, "orientationWindow"), e.showY = 170, e.init(), e.closeButton.position.set(450, -30), e }
        return __extends(b, a), b
    }(VexWindow),
    TipsWindow = function() {
        function a(a, b) { this.canDisplay = !0, this.game = a, this.windowGroup = this.game.add.group(b), this.makeTip() }
        return a.prototype.makeTip = function() { this.background = this.game.add.sprite(.5 * this.game.width, .1 * this.game.height, "actSelectSmall"), this.tipText = this.game.add.bitmapText(.5 * this.game.width, .1 * this.game.height, "grob24", "Tip: Don't like the controls? You can switch them in the option menu!", 20), this.background.width = 1.02 * this.game.width, this.background.height = .065 * this.game.height, this.background.anchor.set(.5), this.tipText.anchor.set(.5), this.windowGroup.add(this.background), this.windowGroup.add(this.tipText), this.windowGroup.alpha = 0, this.resize() }, a.prototype.animateWindow = function() {
            if (this.canDisplay) {
                this.canDisplay = !1, this.game.add.tween(this.windowGroup).to({ alpha: 1 }, 600, Phaser.Easing.Linear.None, !0);
                var a = this.game.add.tween(this.windowGroup).to({ y: 100 }, 1e3, Phaser.Easing.Exponential.Out, !0);
                a.onComplete.add(this.resetWindow, this)
            }
        }, a.prototype.resetWindow = function() {
            var a = this,
                b = this.game.add.tween(this.windowGroup).to({ alpha: 0 }, 300, Phaser.Easing.Linear.None, !0, 7500);
            b.onComplete.add(function() { a.windowGroup.y -= 100, a.windowGroup.alpha = 0, a.canDisplay = !0 }, this)
        }, a.prototype.resize = function() { this.game.width > this.game.height ? (this.background.width = 1.02 * this.game.width, this.background.height = .065 * this.game.height, this.background.x = .5 * this.game.width, this.background.y = .1 * this.game.height, this.tipText.x = .5 * this.game.width, this.tipText.y = .1 * this.game.height, this.tipText.fontSize = 20) : (this.background.width = 1.02 * this.game.width, this.background.height = .045 * this.game.height, this.background.x = .5 * this.game.width, this.background.y = .1 * this.game.height, this.tipText.x = .5 * this.game.width, this.tipText.y = .1 * this.game.height, this.tipText.fontSize = 15) }, a
    }();
