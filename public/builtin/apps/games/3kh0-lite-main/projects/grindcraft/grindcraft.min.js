!(function (a) {
  if ("object" == typeof exports) module.exports = a();
  else if (("function" == typeof define, 1)) {
    var b;
    "undefined" != typeof window ? (b = window) : "undefined" != typeof global ? (b = global) : "undefined" != typeof self && (b = self), (b.p2 = a());
  } else define(a);
})(function () {
  return (function a(b, c, d) {
    function e(g, h) {
      if (!c[g]) {
        if (!b[g]) {
          var i = "function" == typeof require && require;
          if (!h && i) return i(g, !0);
          if (f) return f(g, !0);
          throw new Error("Cannot find module '" + g + "'");
        }
        var j = (c[g] = { exports: {} });
        b[g][0].call(
          j.exports,
          function (a) {
            var c = b[g][1][a];
            return e(c ? c : a);
          },
          j,
          j.exports,
          a,
          b,
          c,
          d
        );
      }
      return c[g].exports;
    }
    for (var f = "function" == typeof require && require, g = 0; g < d.length; g++) e(d[g]);
    return e;
  })(
    {
      1: [
        function (a, b, c) {
          function d() {}
          var e = a("./Scalar");
          (b.exports = d),
            (d.lineInt = function (a, b, c) {
              c = c || 0;
              var d,
                f,
                g,
                h,
                i,
                j,
                k,
                l = [0, 0];
              return (
                (d = a[1][1] - a[0][1]),
                (f = a[0][0] - a[1][0]),
                (g = d * a[0][0] + f * a[0][1]),
                (h = b[1][1] - b[0][1]),
                (i = b[0][0] - b[1][0]),
                (j = h * b[0][0] + i * b[0][1]),
                (k = d * i - h * f),
                e.eq(k, 0, c) || ((l[0] = (i * g - f * j) / k), (l[1] = (d * j - h * g) / k)),
                l
              );
            }),
            (d.segmentsIntersect = function (a, b, c, d) {
              var e = b[0] - a[0],
                f = b[1] - a[1],
                g = d[0] - c[0],
                h = d[1] - c[1];
              if (g * f - h * e == 0) return !1;
              var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e),
                j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
              return i >= 0 && i <= 1 && j >= 0 && j <= 1;
            });
        },
        { "./Scalar": 4 },
      ],
      2: [
        function (a, b, c) {
          function d() {}
          (b.exports = d),
            (d.area = function (a, b, c) {
              return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
            }),
            (d.left = function (a, b, c) {
              return d.area(a, b, c) > 0;
            }),
            (d.leftOn = function (a, b, c) {
              return d.area(a, b, c) >= 0;
            }),
            (d.right = function (a, b, c) {
              return d.area(a, b, c) < 0;
            }),
            (d.rightOn = function (a, b, c) {
              return d.area(a, b, c) <= 0;
            });
          var e = [],
            f = [];
          (d.collinear = function (a, b, c, g) {
            if (g) {
              var h = e,
                i = f;
              (h[0] = b[0] - a[0]), (h[1] = b[1] - a[1]), (i[0] = c[0] - b[0]), (i[1] = c[1] - b[1]);
              var j = h[0] * i[0] + h[1] * i[1],
                k = Math.sqrt(h[0] * h[0] + h[1] * h[1]),
                l = Math.sqrt(i[0] * i[0] + i[1] * i[1]),
                m = Math.acos(j / (k * l));
              return m < g;
            }
            return 0 == d.area(a, b, c);
          }),
            (d.sqdist = function (a, b) {
              var c = b[0] - a[0],
                d = b[1] - a[1];
              return c * c + d * d;
            });
        },
        {},
      ],
      3: [
        function (a, b, c) {
          function d() {
            this.vertices = [];
          }
          function e(a, b, c, d, e) {
            e = e || 0;
            var f = b[1] - a[1],
              g = a[0] - b[0],
              i = f * a[0] + g * a[1],
              j = d[1] - c[1],
              k = c[0] - d[0],
              l = j * c[0] + k * c[1],
              m = f * k - j * g;
            return h.eq(m, 0, e) ? [0, 0] : [(k * i - g * l) / m, (f * l - j * i) / m];
          }
          var f = a("./Line"),
            g = a("./Point"),
            h = a("./Scalar");
          (b.exports = d),
            (d.prototype.at = function (a) {
              var b = this.vertices,
                c = b.length;
              return b[a < 0 ? (a % c) + c : a % c];
            }),
            (d.prototype.first = function () {
              return this.vertices[0];
            }),
            (d.prototype.last = function () {
              return this.vertices[this.vertices.length - 1];
            }),
            (d.prototype.clear = function () {
              this.vertices.length = 0;
            }),
            (d.prototype.append = function (a, b, c) {
              if ("undefined" == typeof b) throw new Error("From is not given!");
              if ("undefined" == typeof c) throw new Error("To is not given!");
              if (c - 1 < b) throw new Error("lol1");
              if (c > a.vertices.length) throw new Error("lol2");
              if (b < 0) throw new Error("lol3");
              for (var d = b; d < c; d++) this.vertices.push(a.vertices[d]);
            }),
            (d.prototype.makeCCW = function () {
              for (var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c) (b[c][1] < b[a][1] || (b[c][1] == b[a][1] && b[c][0] > b[a][0])) && (a = c);
              g.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse();
            }),
            (d.prototype.reverse = function () {
              for (var a = [], b = 0, c = this.vertices.length; b !== c; b++) a.push(this.vertices.pop());
              this.vertices = a;
            }),
            (d.prototype.isReflex = function (a) {
              return g.right(this.at(a - 1), this.at(a), this.at(a + 1));
            });
          var i = [],
            j = [];
          (d.prototype.canSee = function (a, b) {
            var c,
              d,
              e = i,
              h = j;
            if (g.leftOn(this.at(a + 1), this.at(a), this.at(b)) && g.rightOn(this.at(a - 1), this.at(a), this.at(b))) return !1;
            d = g.sqdist(this.at(a), this.at(b));
            for (var k = 0; k !== this.vertices.length; ++k)
              if (
                (k + 1) % this.vertices.length !== a &&
                k !== a &&
                g.leftOn(this.at(a), this.at(b), this.at(k + 1)) &&
                g.rightOn(this.at(a), this.at(b), this.at(k)) &&
                ((e[0] = this.at(a)), (e[1] = this.at(b)), (h[0] = this.at(k)), (h[1] = this.at(k + 1)), (c = f.lineInt(e, h)), g.sqdist(this.at(a), c) < d)
              )
                return !1;
            return !0;
          }),
            (d.prototype.copy = function (a, b, c) {
              var e = c || new d();
              if ((e.clear(), a < b)) for (var f = a; f <= b; f++) e.vertices.push(this.vertices[f]);
              else {
                for (var f = 0; f <= b; f++) e.vertices.push(this.vertices[f]);
                for (var f = a; f < this.vertices.length; f++) e.vertices.push(this.vertices[f]);
              }
              return e;
            }),
            (d.prototype.getCutEdges = function () {
              for (var a = [], b = [], c = [], e = new d(), f = Number.MAX_VALUE, g = 0; g < this.vertices.length; ++g)
                if (this.isReflex(g))
                  for (var h = 0; h < this.vertices.length; ++h)
                    if (this.canSee(g, h)) {
                      (b = this.copy(g, h, e).getCutEdges()), (c = this.copy(h, g, e).getCutEdges());
                      for (var i = 0; i < c.length; i++) b.push(c[i]);
                      b.length < f && ((a = b), (f = b.length), a.push([this.at(g), this.at(h)]));
                    }
              return a;
            }),
            (d.prototype.decomp = function () {
              var a = this.getCutEdges();
              return a.length > 0 ? this.slice(a) : [this];
            }),
            (d.prototype.slice = function (a) {
              if (0 == a.length) return [this];
              if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
                for (var b = [this], c = 0; c < a.length; c++)
                  for (var d = a[c], e = 0; e < b.length; e++) {
                    var f = b[e],
                      g = f.slice(d);
                    if (g) {
                      b.splice(e, 1), b.push(g[0], g[1]);
                      break;
                    }
                  }
                return b;
              }
              var d = a,
                c = this.vertices.indexOf(d[0]),
                e = this.vertices.indexOf(d[1]);
              return c != -1 && e != -1 && [this.copy(c, e), this.copy(e, c)];
            }),
            (d.prototype.isSimple = function () {
              for (var a = this.vertices, b = 0; b < a.length - 1; b++) for (var c = 0; c < b - 1; c++) if (f.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) return !1;
              for (var b = 1; b < a.length - 2; b++) if (f.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) return !1;
              return !0;
            }),
            (d.prototype.quickDecomp = function (a, b, c, f, h, i) {
              (h = h || 100), (i = i || 0), (f = f || 25), (a = "undefined" != typeof a ? a : []), (b = b || []), (c = c || []);
              var j = [0, 0],
                k = [0, 0],
                l = [0, 0],
                m = 0,
                n = 0,
                o = 0,
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = new d(),
                u = new d(),
                v = this,
                w = this.vertices;
              if (w.length < 3) return a;
              if ((i++, i > h)) return a;
              for (var x = 0; x < this.vertices.length; ++x)
                if (v.isReflex(x)) {
                  b.push(v.vertices[x]), (m = n = Number.MAX_VALUE);
                  for (var y = 0; y < this.vertices.length; ++y)
                    g.left(v.at(x - 1), v.at(x), v.at(y)) &&
                      g.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) &&
                      ((l = e(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1))), g.right(v.at(x + 1), v.at(x), l) && ((o = g.sqdist(v.vertices[x], l)), o < n && ((n = o), (k = l), (r = y)))),
                      g.left(v.at(x + 1), v.at(x), v.at(y + 1)) &&
                        g.rightOn(v.at(x + 1), v.at(x), v.at(y)) &&
                        ((l = e(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1))), g.left(v.at(x - 1), v.at(x), l) && ((o = g.sqdist(v.vertices[x], l)), o < m && ((m = o), (j = l), (q = y))));
                  if (r == (q + 1) % this.vertices.length)
                    (l[0] = (k[0] + j[0]) / 2),
                      (l[1] = (k[1] + j[1]) / 2),
                      c.push(l),
                      x < q
                        ? (t.append(v, x, q + 1), t.vertices.push(l), u.vertices.push(l), 0 != r && u.append(v, r, v.vertices.length), u.append(v, 0, x + 1))
                        : (0 != x && t.append(v, x, v.vertices.length), t.append(v, 0, q + 1), t.vertices.push(l), u.vertices.push(l), u.append(v, r, x + 1));
                  else {
                    if ((r > q && (q += this.vertices.length), (p = Number.MAX_VALUE), q < r)) return a;
                    for (var y = r; y <= q; ++y) g.leftOn(v.at(x - 1), v.at(x), v.at(y)) && g.rightOn(v.at(x + 1), v.at(x), v.at(y)) && ((o = g.sqdist(v.at(x), v.at(y))), o < p && ((p = o), (s = y % this.vertices.length)));
                    x < s ? (t.append(v, x, s + 1), 0 != s && u.append(v, s, w.length), u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length), t.append(v, 0, s + 1), u.append(v, s, x + 1));
                  }
                  return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, c, f, h, i), u.quickDecomp(a, b, c, f, h, i)) : (u.quickDecomp(a, b, c, f, h, i), t.quickDecomp(a, b, c, f, h, i)), a;
                }
              return a.push(this), a;
            }),
            (d.prototype.removeCollinearPoints = function (a) {
              for (var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c) g.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1), c--, b++);
              return b;
            });
        },
        { "./Line": 1, "./Point": 2, "./Scalar": 4 },
      ],
      4: [
        function (a, b, c) {
          function d() {}
          (b.exports = d),
            (d.eq = function (a, b, c) {
              return (c = c || 0), Math.abs(a - b) < c;
            });
        },
        {},
      ],
      5: [
        function (a, b, c) {
          b.exports = { Polygon: a("./Polygon"), Point: a("./Point") };
        },
        { "./Point": 2, "./Polygon": 3 },
      ],
      6: [
        function (a, b, c) {
          b.exports = {
            name: "p2",
            version: "0.7.0",
            description: "A JavaScript 2D physics engine.",
            author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
            keywords: ["p2.js", "p2", "physics", "engine", "2d"],
            main: "./src/p2.js",
            engines: { node: "*" },
            repository: { type: "git", url: "https://github.com/schteppe/p2.js.git" },
            bugs: { url: "https://github.com/schteppe/p2.js/issues" },
            licenses: [{ type: "MIT" }],
            devDependencies: {
              grunt: "^0.4.5",
              "grunt-contrib-jshint": "^0.11.2",
              "grunt-contrib-nodeunit": "^0.4.1",
              "grunt-contrib-uglify": "~0.4.0",
              "grunt-contrib-watch": "~0.5.0",
              "grunt-browserify": "~2.0.1",
              "grunt-contrib-concat": "^0.4.0",
            },
            dependencies: { "poly-decomp": "0.1.0" },
          };
        },
        {},
      ],
      7: [
        function (a, b, c) {
          function d(a) {
            (this.lowerBound = e.create()), a && a.lowerBound && e.copy(this.lowerBound, a.lowerBound), (this.upperBound = e.create()), a && a.upperBound && e.copy(this.upperBound, a.upperBound);
          }
          var e = a("../math/vec2");
          a("../utils/Utils"), (b.exports = d);
          var f = e.create();
          (d.prototype.setFromPoints = function (a, b, c, d) {
            var g = this.lowerBound,
              h = this.upperBound;
            "number" != typeof c && (c = 0), 0 !== c ? e.rotate(g, a[0], c) : e.copy(g, a[0]), e.copy(h, g);
            for (var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++) {
              var l = a[k];
              if (0 !== c) {
                var m = l[0],
                  n = l[1];
                (f[0] = i * m - j * n), (f[1] = j * m + i * n), (l = f);
              }
              for (var o = 0; o < 2; o++) l[o] > h[o] && (h[o] = l[o]), l[o] < g[o] && (g[o] = l[o]);
            }
            b && (e.add(this.lowerBound, this.lowerBound, b), e.add(this.upperBound, this.upperBound, b)), d && ((this.lowerBound[0] -= d), (this.lowerBound[1] -= d), (this.upperBound[0] += d), (this.upperBound[1] += d));
          }),
            (d.prototype.copy = function (a) {
              e.copy(this.lowerBound, a.lowerBound), e.copy(this.upperBound, a.upperBound);
            }),
            (d.prototype.extend = function (a) {
              for (var b = 2; b--; ) {
                var c = a.lowerBound[b];
                this.lowerBound[b] > c && (this.lowerBound[b] = c);
                var d = a.upperBound[b];
                this.upperBound[b] < d && (this.upperBound[b] = d);
              }
            }),
            (d.prototype.overlaps = function (a) {
              var b = this.lowerBound,
                c = this.upperBound,
                d = a.lowerBound,
                e = a.upperBound;
              return ((d[0] <= c[0] && c[0] <= e[0]) || (b[0] <= e[0] && e[0] <= c[0])) && ((d[1] <= c[1] && c[1] <= e[1]) || (b[1] <= e[1] && e[1] <= c[1]));
            }),
            (d.prototype.containsPoint = function (a) {
              var b = this.lowerBound,
                c = this.upperBound;
              return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1];
            }),
            (d.prototype.overlapsRay = function (a) {
              var b = 1 / a.direction[0],
                c = 1 / a.direction[1],
                d = (this.lowerBound[0] - a.from[0]) * b,
                e = (this.upperBound[0] - a.from[0]) * b,
                f = (this.lowerBound[1] - a.from[1]) * c,
                g = (this.upperBound[1] - a.from[1]) * c,
                h = Math.max(Math.max(Math.min(d, e), Math.min(f, g))),
                i = Math.min(Math.min(Math.max(d, e), Math.max(f, g)));
              return i < 0 ? -1 : h > i ? -1 : h;
            });
        },
        { "../math/vec2": 30, "../utils/Utils": 57 },
      ],
      8: [
        function (a, b, c) {
          function d(a) {
            (this.type = a), (this.result = []), (this.world = null), (this.boundingVolumeType = d.AABB);
          }
          var e = a("../math/vec2"),
            f = a("../objects/Body");
          (b.exports = d),
            (d.AABB = 1),
            (d.BOUNDING_CIRCLE = 2),
            (d.prototype.setWorld = function (a) {
              this.world = a;
            }),
            (d.prototype.getCollisionPairs = function (a) {});
          var g = e.create();
          (d.boundingRadiusCheck = function (a, b) {
            e.sub(g, a.position, b.position);
            var c = e.squaredLength(g),
              d = a.boundingRadius + b.boundingRadius;
            return c <= d * d;
          }),
            (d.aabbCheck = function (a, b) {
              return a.getAABB().overlaps(b.getAABB());
            }),
            (d.prototype.boundingVolumeCheck = function (a, b) {
              var c;
              switch (this.boundingVolumeType) {
                case d.BOUNDING_CIRCLE:
                  c = d.boundingRadiusCheck(a, b);
                  break;
                case d.AABB:
                  c = d.aabbCheck(a, b);
                  break;
                default:
                  throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
              }
              return c;
            }),
            (d.canCollide = function (a, b) {
              var c = f.KINEMATIC,
                d = f.STATIC;
              return !(
                (a.type === d && b.type === d) ||
                (a.type === c && b.type === d) ||
                (a.type === d && b.type === c) ||
                (a.type === c && b.type === c) ||
                (a.sleepState === f.SLEEPING && b.sleepState === f.SLEEPING) ||
                (a.sleepState === f.SLEEPING && b.type === d) ||
                (b.sleepState === f.SLEEPING && a.type === d)
              );
            }),
            (d.NAIVE = 1),
            (d.SAP = 2);
        },
        { "../math/vec2": 30, "../objects/Body": 31 },
      ],
      9: [
        function (a, b, c) {
          function d() {
            e.call(this, e.NAIVE);
          }
          var e = (a("../shapes/Circle"), a("../shapes/Plane"), a("../shapes/Shape"), a("../shapes/Particle"), a("../collision/Broadphase"));
          a("../math/vec2"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.getCollisionPairs = function (a) {
              var b = a.bodies,
                c = this.result;
              c.length = 0;
              for (var d = 0, f = b.length; d !== f; d++)
                for (var g = b[d], h = 0; h < d; h++) {
                  var i = b[h];
                  e.canCollide(g, i) && this.boundingVolumeCheck(g, i) && c.push(g, i);
                }
              return c;
            }),
            (d.prototype.aabbQuery = function (a, b, c) {
              c = c || [];
              for (var d = a.bodies, e = 0; e < d.length; e++) {
                var f = d[e];
                f.aabbNeedsUpdate && f.updateAABB(), f.aabb.overlaps(b) && c.push(f);
              }
              return c;
            });
        },
        { "../collision/Broadphase": 8, "../math/vec2": 30, "../shapes/Circle": 39, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45 },
      ],
      10: [
        function (a, b, c) {
          function d() {
            (this.contactEquations = []),
              (this.frictionEquations = []),
              (this.enableFriction = !0),
              (this.enabledEquations = !0),
              (this.slipForce = 10),
              (this.frictionCoefficient = 0.3),
              (this.surfaceVelocity = 0),
              (this.contactEquationPool = new k({ size: 32 })),
              (this.frictionEquationPool = new l({ size: 64 })),
              (this.restitution = 0),
              (this.stiffness = n.DEFAULT_STIFFNESS),
              (this.relaxation = n.DEFAULT_RELAXATION),
              (this.frictionStiffness = n.DEFAULT_STIFFNESS),
              (this.frictionRelaxation = n.DEFAULT_RELAXATION),
              (this.enableFrictionReduction = !0),
              (this.collidingBodiesLastStep = new m()),
              (this.contactSkinSize = 0.01);
          }
          function e(a, b) {
            g.set(a.vertices[0], 0.5 * -b.length, -b.radius), g.set(a.vertices[1], 0.5 * b.length, -b.radius), g.set(a.vertices[2], 0.5 * b.length, b.radius), g.set(a.vertices[3], 0.5 * -b.length, b.radius);
          }
          function f(a, b, c, d) {
            for (var e = T, f = U, j = V, k = W, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++) {
              var p = m[o % m.length],
                q = m[(o + 1) % m.length];
              g.rotate(e, p, d), g.rotate(f, q, d), i(e, e, c), i(f, f, c), h(j, e, l), h(k, f, l);
              var r = g.crossLength(j, k);
              if ((null === n && (n = r), r * n <= 0)) return !1;
              n = r;
            }
            return !0;
          }
          var g = a("../math/vec2"),
            h = g.sub,
            i = g.add,
            j = g.dot,
            k = (a("../utils/Utils"), a("../utils/ContactEquationPool")),
            l = a("../utils/FrictionEquationPool"),
            m = a("../utils/TupleDictionary"),
            n = a("../equations/Equation"),
            o = (a("../equations/ContactEquation"), a("../equations/FrictionEquation"), a("../shapes/Circle")),
            p = a("../shapes/Convex"),
            q = a("../shapes/Shape"),
            r = (a("../objects/Body"), a("../shapes/Box"));
          b.exports = d;
          var s = g.fromValues(0, 1),
            t = g.fromValues(0, 0),
            u = g.fromValues(0, 0),
            v = g.fromValues(0, 0),
            w = g.fromValues(0, 0),
            x = g.fromValues(0, 0),
            y = g.fromValues(0, 0),
            z = g.fromValues(0, 0),
            A = g.fromValues(0, 0),
            B = g.fromValues(0, 0),
            C = g.fromValues(0, 0),
            D = g.fromValues(0, 0),
            E = g.fromValues(0, 0),
            F = g.fromValues(0, 0),
            G = g.fromValues(0, 0),
            H = g.fromValues(0, 0),
            I = g.fromValues(0, 0),
            J = g.fromValues(0, 0),
            K = g.fromValues(0, 0),
            L = [],
            M = g.create(),
            N = g.create();
          (d.prototype.bodiesOverlap = function (a, b) {
            for (var c = M, d = N, e = 0, f = a.shapes.length; e !== f; e++) {
              var g = a.shapes[e];
              a.toWorldFrame(c, g.position);
              for (var h = 0, i = b.shapes.length; h !== i; h++) {
                var j = b.shapes[h];
                if ((b.toWorldFrame(d, j.position), this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0))) return !0;
              }
            }
            return !1;
          }),
            (d.prototype.collidedLastStep = function (a, b) {
              var c = 0 | a.id,
                d = 0 | b.id;
              return !!this.collidingBodiesLastStep.get(c, d);
            }),
            (d.prototype.reset = function () {
              this.collidingBodiesLastStep.reset();
              for (var a = this.contactEquations, b = a.length; b--; ) {
                var c = a[b],
                  d = c.bodyA.id,
                  e = c.bodyB.id;
                this.collidingBodiesLastStep.set(d, e, !0);
              }
              for (var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++) this.contactEquationPool.release(f[h]);
              for (var h = 0; h < g.length; h++) this.frictionEquationPool.release(g[h]);
              this.contactEquations.length = this.frictionEquations.length = 0;
            }),
            (d.prototype.createContactEquation = function (a, b, c, d) {
              var e = this.contactEquationPool.get();
              return (
                (e.bodyA = a),
                (e.bodyB = b),
                (e.shapeA = c),
                (e.shapeB = d),
                (e.restitution = this.restitution),
                (e.firstImpact = !this.collidedLastStep(a, b)),
                (e.stiffness = this.stiffness),
                (e.relaxation = this.relaxation),
                (e.needsUpdate = !0),
                (e.enabled = this.enabledEquations),
                (e.offset = this.contactSkinSize),
                e
              );
            }),
            (d.prototype.createFrictionEquation = function (a, b, c, d) {
              var e = this.frictionEquationPool.get();
              return (
                (e.bodyA = a),
                (e.bodyB = b),
                (e.shapeA = c),
                (e.shapeB = d),
                e.setSlipForce(this.slipForce),
                (e.frictionCoefficient = this.frictionCoefficient),
                (e.relativeVelocity = this.surfaceVelocity),
                (e.enabled = this.enabledEquations),
                (e.needsUpdate = !0),
                (e.stiffness = this.frictionStiffness),
                (e.relaxation = this.frictionRelaxation),
                (e.contactEquations.length = 0),
                e
              );
            }),
            (d.prototype.createFrictionFromContact = function (a) {
              var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
              return g.copy(b.contactPointA, a.contactPointA), g.copy(b.contactPointB, a.contactPointB), g.rotate90cw(b.t, a.normalA), b.contactEquations.push(a), b;
            }),
            (d.prototype.createFrictionFromAverage = function (a) {
              var b = this.contactEquations[this.contactEquations.length - 1],
                c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB),
                d = b.bodyA;
              b.bodyB, g.set(c.contactPointA, 0, 0), g.set(c.contactPointB, 0, 0), g.set(c.t, 0, 0);
              for (var e = 0; e !== a; e++)
                (b = this.contactEquations[this.contactEquations.length - 1 - e]),
                  b.bodyA === d
                    ? (g.add(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointA), g.add(c.contactPointB, c.contactPointB, b.contactPointB))
                    : (g.sub(c.t, c.t, b.normalA), g.add(c.contactPointA, c.contactPointA, b.contactPointB), g.add(c.contactPointB, c.contactPointB, b.contactPointA)),
                  c.contactEquations.push(b);
              var f = 1 / a;
              return g.scale(c.contactPointA, c.contactPointA, f), g.scale(c.contactPointB, c.contactPointB, f), g.normalize(c.t, c.t), g.rotate90cw(c.t, c.t), c;
            }),
            (d.prototype[q.LINE | q.CONVEX] = d.prototype.convexLine = function (a, b, c, d, e, f, g, h, i) {
              return !i && 0;
            }),
            (d.prototype[q.LINE | q.BOX] = d.prototype.lineBox = function (a, b, c, d, e, f, g, h, i) {
              return !i && 0;
            });
          var O = new r({ width: 1, height: 1 }),
            P = g.create();
          (d.prototype[q.CAPSULE | q.CONVEX] = d.prototype[q.CAPSULE | q.BOX] = d.prototype.convexCapsule = function (a, b, c, d, f, h, i, j, k) {
            var l = P;
            g.set(l, h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
            var m = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
            g.set(l, -h.length / 2, 0), g.rotate(l, l, j), g.add(l, l, i);
            var n = this.circleConvex(f, h, l, j, a, b, c, d, k, h.radius);
            if (k && (m || n)) return !0;
            var o = O;
            e(o, h);
            var p = this.convexConvex(a, b, c, d, f, o, i, j, k);
            return p + m + n;
          }),
            (d.prototype[q.CAPSULE | q.LINE] = d.prototype.lineCapsule = function (a, b, c, d, e, f, g, h, i) {
              return !i && 0;
            });
          var Q = g.create(),
            R = g.create(),
            S = new r({ width: 1, height: 1 });
          (d.prototype[q.CAPSULE | q.CAPSULE] = d.prototype.capsuleCapsule = function (a, b, c, d, f, h, i, j, k) {
            for (var l, m = Q, n = R, o = 0, p = 0; p < 2; p++) {
              g.set(m, ((0 === p ? -1 : 1) * b.length) / 2, 0), g.rotate(m, m, d), g.add(m, m, c);
              for (var q = 0; q < 2; q++) {
                g.set(n, ((0 === q ? -1 : 1) * h.length) / 2, 0), g.rotate(n, n, j), g.add(n, n, i), this.enableFrictionReduction && ((l = this.enableFriction), (this.enableFriction = !1));
                var r = this.circleCircle(a, b, m, d, f, h, n, j, k, b.radius, h.radius);
                if ((this.enableFrictionReduction && (this.enableFriction = l), k && r)) return !0;
                o += r;
              }
            }
            this.enableFrictionReduction && ((l = this.enableFriction), (this.enableFriction = !1));
            var s = S;
            e(s, b);
            var t = this.convexCapsule(a, s, c, d, f, h, i, j, k);
            if ((this.enableFrictionReduction && (this.enableFriction = l), k && t)) return !0;
            if (((o += t), this.enableFrictionReduction)) {
              var l = this.enableFriction;
              this.enableFriction = !1;
            }
            e(s, h);
            var u = this.convexCapsule(f, s, i, j, a, b, c, d, k);
            return this.enableFrictionReduction && (this.enableFriction = l), !(!k || !u) || ((o += u), this.enableFrictionReduction && o && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(o)), o);
          }),
            (d.prototype[q.LINE | q.LINE] = d.prototype.lineLine = function (a, b, c, d, e, f, g, h, i) {
              return !i && 0;
            }),
            (d.prototype[q.PLANE | q.LINE] = d.prototype.planeLine = function (a, b, c, d, e, f, k, l, m) {
              var n = t,
                o = u,
                p = v,
                q = w,
                r = x,
                C = y,
                D = z,
                E = A,
                F = B,
                G = L,
                H = 0;
              g.set(n, -f.length / 2, 0),
                g.set(o, f.length / 2, 0),
                g.rotate(p, n, l),
                g.rotate(q, o, l),
                i(p, p, k),
                i(q, q, k),
                g.copy(n, p),
                g.copy(o, q),
                h(r, o, n),
                g.normalize(C, r),
                g.rotate90cw(F, C),
                g.rotate(E, s, d),
                (G[0] = n),
                (G[1] = o);
              for (var I = 0; I < G.length; I++) {
                var J = G[I];
                h(D, J, c);
                var K = j(D, E);
                if (K < 0) {
                  if (m) return !0;
                  var M = this.createContactEquation(a, e, b, f);
                  H++,
                    g.copy(M.normalA, E),
                    g.normalize(M.normalA, M.normalA),
                    g.scale(D, E, K),
                    h(M.contactPointA, J, D),
                    h(M.contactPointA, M.contactPointA, a.position),
                    h(M.contactPointB, J, k),
                    i(M.contactPointB, M.contactPointB, k),
                    h(M.contactPointB, M.contactPointB, e.position),
                    this.contactEquations.push(M),
                    this.enableFrictionReduction || (this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M)));
                }
              }
              return !m && (this.enableFrictionReduction || (H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H))), H);
            }),
            (d.prototype[q.PARTICLE | q.CAPSULE] = d.prototype.particleCapsule = function (a, b, c, d, e, f, g, h, i) {
              return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0);
            }),
            (d.prototype[q.CIRCLE | q.LINE] = d.prototype.circleLine = function (a, b, c, d, e, f, k, l, m, n, o) {
              var n = n || 0,
                o = "undefined" != typeof o ? o : b.radius,
                p = t,
                q = u,
                r = v,
                s = w,
                H = x,
                I = y,
                J = z,
                K = A,
                M = B,
                N = C,
                O = D,
                P = E,
                Q = F,
                R = G,
                S = L;
              g.set(K, -f.length / 2, 0), g.set(M, f.length / 2, 0), g.rotate(N, K, l), g.rotate(O, M, l), i(N, N, k), i(O, O, k), g.copy(K, N), g.copy(M, O), h(I, M, K), g.normalize(J, I), g.rotate90cw(H, J), h(P, c, K);
              var T = j(P, H);
              h(s, K, k), h(Q, c, k);
              var U = o + n;
              if (Math.abs(T) < U) {
                g.scale(p, H, T), h(r, c, p), g.scale(q, H, j(H, Q)), g.normalize(q, q), g.scale(q, q, n), i(r, r, q);
                var V = j(J, r),
                  W = j(J, K),
                  X = j(J, M);
                if (V > W && V < X) {
                  if (m) return !0;
                  var Y = this.createContactEquation(a, e, b, f);
                  return (
                    g.scale(Y.normalA, p, -1),
                    g.normalize(Y.normalA, Y.normalA),
                    g.scale(Y.contactPointA, Y.normalA, o),
                    i(Y.contactPointA, Y.contactPointA, c),
                    h(Y.contactPointA, Y.contactPointA, a.position),
                    h(Y.contactPointB, r, k),
                    i(Y.contactPointB, Y.contactPointB, k),
                    h(Y.contactPointB, Y.contactPointB, e.position),
                    this.contactEquations.push(Y),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)),
                    1
                  );
                }
              }
              (S[0] = K), (S[1] = M);
              for (var Z = 0; Z < S.length; Z++) {
                var $ = S[Z];
                if ((h(P, $, c), g.squaredLength(P) < Math.pow(U, 2))) {
                  if (m) return !0;
                  var Y = this.createContactEquation(a, e, b, f);
                  return (
                    g.copy(Y.normalA, P),
                    g.normalize(Y.normalA, Y.normalA),
                    g.scale(Y.contactPointA, Y.normalA, o),
                    i(Y.contactPointA, Y.contactPointA, c),
                    h(Y.contactPointA, Y.contactPointA, a.position),
                    h(Y.contactPointB, $, k),
                    g.scale(R, Y.normalA, -n),
                    i(Y.contactPointB, Y.contactPointB, R),
                    i(Y.contactPointB, Y.contactPointB, k),
                    h(Y.contactPointB, Y.contactPointB, e.position),
                    this.contactEquations.push(Y),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)),
                    1
                  );
                }
              }
              return 0;
            }),
            (d.prototype[q.CIRCLE | q.CAPSULE] = d.prototype.circleCapsule = function (a, b, c, d, e, f, g, h, i) {
              return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius);
            }),
            (d.prototype[q.CIRCLE | q.CONVEX] = d.prototype[q.CIRCLE | q.BOX] = d.prototype.circleConvex = function (a, b, c, d, e, j, k, l, m, n) {
              for (var n = "number" == typeof n ? n : b.radius, o = t, p = u, q = v, r = w, s = x, y = C, z = D, A = F, B = G, E = H, J = I, K = !1, L = Number.MAX_VALUE, M = j.vertices, N = 0; N !== M.length + 1; N++) {
                var O = M[N % M.length],
                  P = M[(N + 1) % M.length];
                if ((g.rotate(o, O, l), g.rotate(p, P, l), i(o, o, k), i(p, p, k), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), g.scale(B, s, -b.radius), i(B, B, c), f(B, j, k, l))) {
                  g.sub(E, o, B);
                  var Q = Math.abs(g.dot(E, s));
                  Q < L && (g.copy(J, B), (L = Q), g.scale(A, s, Q), g.add(A, A, B), (K = !0));
                }
              }
              if (K) {
                if (m) return !0;
                var R = this.createContactEquation(a, e, b, j);
                return (
                  g.sub(R.normalA, J, c),
                  g.normalize(R.normalA, R.normalA),
                  g.scale(R.contactPointA, R.normalA, n),
                  i(R.contactPointA, R.contactPointA, c),
                  h(R.contactPointA, R.contactPointA, a.position),
                  h(R.contactPointB, A, k),
                  i(R.contactPointB, R.contactPointB, k),
                  h(R.contactPointB, R.contactPointB, e.position),
                  this.contactEquations.push(R),
                  this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)),
                  1
                );
              }
              if (n > 0)
                for (var N = 0; N < M.length; N++) {
                  var S = M[N];
                  if ((g.rotate(z, S, l), i(z, z, k), h(y, z, c), g.squaredLength(y) < Math.pow(n, 2))) {
                    if (m) return !0;
                    var R = this.createContactEquation(a, e, b, j);
                    return (
                      g.copy(R.normalA, y),
                      g.normalize(R.normalA, R.normalA),
                      g.scale(R.contactPointA, R.normalA, n),
                      i(R.contactPointA, R.contactPointA, c),
                      h(R.contactPointA, R.contactPointA, a.position),
                      h(R.contactPointB, z, k),
                      i(R.contactPointB, R.contactPointB, k),
                      h(R.contactPointB, R.contactPointB, e.position),
                      this.contactEquations.push(R),
                      this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)),
                      1
                    );
                  }
                }
              return 0;
            });
          var T = g.create(),
            U = g.create(),
            V = g.create(),
            W = g.create();
          (d.prototype[q.PARTICLE | q.CONVEX] = d.prototype[q.PARTICLE | q.BOX] = d.prototype.particleConvex = function (a, b, c, d, e, k, l, m, n) {
            var o = t,
              p = u,
              q = v,
              r = w,
              s = x,
              A = y,
              B = z,
              D = C,
              E = F,
              G = J,
              H = K,
              I = Number.MAX_VALUE,
              L = !1,
              M = k.vertices;
            if (!f(c, k, l, m)) return 0;
            if (n) return !0;
            for (var N = 0; N !== M.length + 1; N++) {
              var O = M[N % M.length],
                P = M[(N + 1) % M.length];
              g.rotate(o, O, m), g.rotate(p, P, m), i(o, o, l), i(p, p, l), h(q, p, o), g.normalize(r, q), g.rotate90cw(s, r), h(D, c, o), j(D, s), h(A, o, l), h(B, c, l), g.sub(G, o, c);
              var Q = Math.abs(g.dot(G, s));
              Q < I && ((I = Q), g.scale(E, s, Q), g.add(E, E, c), g.copy(H, s), (L = !0));
            }
            if (L) {
              var R = this.createContactEquation(a, e, b, k);
              return (
                g.scale(R.normalA, H, -1),
                g.normalize(R.normalA, R.normalA),
                g.set(R.contactPointA, 0, 0),
                i(R.contactPointA, R.contactPointA, c),
                h(R.contactPointA, R.contactPointA, a.position),
                h(R.contactPointB, E, l),
                i(R.contactPointB, R.contactPointB, l),
                h(R.contactPointB, R.contactPointB, e.position),
                this.contactEquations.push(R),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(R)),
                1
              );
            }
            return 0;
          }),
            (d.prototype[q.CIRCLE] = d.prototype.circleCircle = function (a, b, c, d, e, f, j, k, l, m, n) {
              var o = t,
                m = m || b.radius,
                n = n || f.radius;
              h(o, c, j);
              var p = m + n;
              if (g.squaredLength(o) > Math.pow(p, 2)) return 0;
              if (l) return !0;
              var q = this.createContactEquation(a, e, b, f);
              return (
                h(q.normalA, j, c),
                g.normalize(q.normalA, q.normalA),
                g.scale(q.contactPointA, q.normalA, m),
                g.scale(q.contactPointB, q.normalA, -n),
                i(q.contactPointA, q.contactPointA, c),
                h(q.contactPointA, q.contactPointA, a.position),
                i(q.contactPointB, q.contactPointB, j),
                h(q.contactPointB, q.contactPointB, e.position),
                this.contactEquations.push(q),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)),
                1
              );
            }),
            (d.prototype[q.PLANE | q.CONVEX] = d.prototype[q.PLANE | q.BOX] = d.prototype.planeConvex = function (a, b, c, d, e, f, k, l, m) {
              var n = t,
                o = u,
                p = v,
                q = 0;
              g.rotate(o, s, d);
              for (var r = 0; r !== f.vertices.length; r++) {
                var w = f.vertices[r];
                if ((g.rotate(n, w, l), i(n, n, k), h(p, n, c), j(p, o) <= 0)) {
                  if (m) return !0;
                  q++;
                  var x = this.createContactEquation(a, e, b, f);
                  h(p, n, c), g.copy(x.normalA, o);
                  var y = j(p, x.normalA);
                  g.scale(p, x.normalA, y),
                    h(x.contactPointB, n, e.position),
                    h(x.contactPointA, n, p),
                    h(x.contactPointA, x.contactPointA, a.position),
                    this.contactEquations.push(x),
                    this.enableFrictionReduction || (this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x)));
                }
              }
              return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)), q;
            }),
            (d.prototype[q.PARTICLE | q.PLANE] = d.prototype.particlePlane = function (a, b, c, d, e, f, i, k, l) {
              var m = t,
                n = u;
              (k = k || 0), h(m, c, i), g.rotate(n, s, k);
              var o = j(m, n);
              if (o > 0) return 0;
              if (l) return !0;
              var p = this.createContactEquation(e, a, f, b);
              return (
                g.copy(p.normalA, n),
                g.scale(m, p.normalA, o),
                h(p.contactPointA, c, m),
                h(p.contactPointA, p.contactPointA, e.position),
                h(p.contactPointB, c, a.position),
                this.contactEquations.push(p),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)),
                1
              );
            }),
            (d.prototype[q.CIRCLE | q.PARTICLE] = d.prototype.circleParticle = function (a, b, c, d, e, f, j, k, l) {
              var m = t;
              if ((h(m, j, c), g.squaredLength(m) > Math.pow(b.radius, 2))) return 0;
              if (l) return !0;
              var n = this.createContactEquation(a, e, b, f);
              return (
                g.copy(n.normalA, m),
                g.normalize(n.normalA, n.normalA),
                g.scale(n.contactPointA, n.normalA, b.radius),
                i(n.contactPointA, n.contactPointA, c),
                h(n.contactPointA, n.contactPointA, a.position),
                h(n.contactPointB, j, e.position),
                this.contactEquations.push(n),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)),
                1
              );
            });
          var X = new o({ radius: 1 }),
            Y = g.create(),
            Z = g.create();
          g.create(),
            (d.prototype[q.PLANE | q.CAPSULE] = d.prototype.planeCapsule = function (a, b, c, d, e, f, h, j, k) {
              var l = Y,
                m = Z,
                n = X;
              g.set(l, -f.length / 2, 0), g.rotate(l, l, j), i(l, l, h), g.set(m, f.length / 2, 0), g.rotate(m, m, j), i(m, m, h), (n.radius = f.radius);
              var o;
              this.enableFrictionReduction && ((o = this.enableFriction), (this.enableFriction = !1));
              var p = this.circlePlane(e, n, l, 0, a, b, c, d, k),
                q = this.circlePlane(e, n, m, 0, a, b, c, d, k);
              if ((this.enableFrictionReduction && (this.enableFriction = o), k)) return p || q;
              var r = p + q;
              return this.enableFrictionReduction && r && this.frictionEquations.push(this.createFrictionFromAverage(r)), r;
            }),
            (d.prototype[q.CIRCLE | q.PLANE] = d.prototype.circlePlane = function (a, b, c, d, e, f, k, l, m) {
              var n = a,
                o = b,
                p = c,
                q = e,
                r = k,
                w = l;
              w = w || 0;
              var x = t,
                y = u,
                z = v;
              h(x, p, r), g.rotate(y, s, w);
              var A = j(y, x);
              if (A > o.radius) return 0;
              if (m) return !0;
              var B = this.createContactEquation(q, n, f, b);
              return (
                g.copy(B.normalA, y),
                g.scale(B.contactPointB, B.normalA, -o.radius),
                i(B.contactPointB, B.contactPointB, p),
                h(B.contactPointB, B.contactPointB, n.position),
                g.scale(z, B.normalA, A),
                h(B.contactPointA, x, z),
                i(B.contactPointA, B.contactPointA, r),
                h(B.contactPointA, B.contactPointA, q.position),
                this.contactEquations.push(B),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(B)),
                1
              );
            }),
            (d.prototype[q.CONVEX] = d.prototype[q.CONVEX | q.BOX] = d.prototype[q.BOX] = d.prototype.convexConvex = function (a, b, c, e, f, k, l, m, n, o) {
              var p = t,
                q = u,
                r = v,
                s = w,
                y = x,
                C = z,
                D = A,
                E = B,
                F = 0,
                o = "number" == typeof o ? o : 0,
                G = d.findSeparatingAxis(b, c, e, k, l, m, p);
              if (!G) return 0;
              h(D, l, c), j(p, D) > 0 && g.scale(p, p, -1);
              var H = d.getClosestEdge(b, e, p, !0),
                I = d.getClosestEdge(k, m, p);
              if (H === -1 || I === -1) return 0;
              for (var J = 0; J < 2; J++) {
                var K = H,
                  L = I,
                  M = b,
                  N = k,
                  O = c,
                  P = l,
                  Q = e,
                  R = m,
                  S = a,
                  T = f;
                if (0 === J) {
                  var U;
                  (U = K), (K = L), (L = U), (U = M), (M = N), (N = U), (U = O), (O = P), (P = U), (U = Q), (Q = R), (R = U), (U = S), (S = T), (T = U);
                }
                for (var V = L; V < L + 2; V++) {
                  var W = N.vertices[(V + N.vertices.length) % N.vertices.length];
                  g.rotate(q, W, R), i(q, q, P);
                  for (var X = 0, Y = K - 1; Y < K + 2; Y++) {
                    var Z = M.vertices[(Y + M.vertices.length) % M.vertices.length],
                      $ = M.vertices[(Y + 1 + M.vertices.length) % M.vertices.length];
                    g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(E, y), g.normalize(E, E), h(D, q, r);
                    var _ = j(E, D);
                    ((Y === K && _ <= o) || (Y !== K && _ <= 0)) && X++;
                  }
                  if (X >= 3) {
                    if (n) return !0;
                    var aa = this.createContactEquation(S, T, M, N);
                    F++;
                    var Z = M.vertices[K % M.vertices.length],
                      $ = M.vertices[(K + 1) % M.vertices.length];
                    g.rotate(r, Z, Q), g.rotate(s, $, Q), i(r, r, O), i(s, s, O), h(y, s, r), g.rotate90cw(aa.normalA, y), g.normalize(aa.normalA, aa.normalA), h(D, q, r);
                    var _ = j(aa.normalA, D);
                    g.scale(C, aa.normalA, _),
                      h(aa.contactPointA, q, O),
                      h(aa.contactPointA, aa.contactPointA, C),
                      i(aa.contactPointA, aa.contactPointA, O),
                      h(aa.contactPointA, aa.contactPointA, S.position),
                      h(aa.contactPointB, q, P),
                      i(aa.contactPointB, aa.contactPointB, P),
                      h(aa.contactPointB, aa.contactPointB, T.position),
                      this.contactEquations.push(aa),
                      this.enableFrictionReduction || (this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(aa)));
                  }
                }
              }
              return this.enableFrictionReduction && this.enableFriction && F && this.frictionEquations.push(this.createFrictionFromAverage(F)), F;
            });
          var $ = g.fromValues(0, 0);
          d.projectConvexOntoAxis = function (a, b, c, d, e) {
            var f,
              h,
              i = null,
              k = null,
              l = $;
            g.rotate(l, d, -c);
            for (var m = 0; m < a.vertices.length; m++) (f = a.vertices[m]), (h = j(f, l)), (null === i || h > i) && (i = h), (null === k || h < k) && (k = h);
            if (k > i) {
              var n = k;
              (k = i), (i = n);
            }
            var o = j(b, d);
            g.set(e, k + o, i + o);
          };
          var _ = g.fromValues(0, 0),
            aa = g.fromValues(0, 0),
            ba = g.fromValues(0, 0),
            ca = g.fromValues(0, 0),
            da = g.fromValues(0, 0),
            ea = g.fromValues(0, 0);
          d.findSeparatingAxis = function (a, b, c, e, f, i, j) {
            var k = null,
              l = !1,
              m = !1,
              n = _,
              o = aa,
              p = ba,
              q = ca,
              s = da,
              t = ea;
            if (a instanceof r && e instanceof r)
              for (var u = 0; 2 !== u; u++) {
                var v = a,
                  w = c;
                1 === u && ((v = e), (w = i));
                for (var x = 0; 2 !== x; x++) {
                  0 === x ? g.set(q, 0, 1) : 1 === x && g.set(q, 1, 0), 0 !== w && g.rotate(q, q, w), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                  var y = s,
                    z = t,
                    A = !1;
                  s[0] > t[0] && ((z = s), (y = t), (A = !0));
                  var B = z[0] - y[1];
                  (l = B <= 0), (null === k || B > k) && (g.copy(j, q), (k = B), (m = l));
                }
              }
            else
              for (var u = 0; 2 !== u; u++) {
                var v = a,
                  w = c;
                1 === u && ((v = e), (w = i));
                for (var x = 0; x !== v.vertices.length; x++) {
                  g.rotate(o, v.vertices[x], w), g.rotate(p, v.vertices[(x + 1) % v.vertices.length], w), h(n, p, o), g.rotate90cw(q, n), g.normalize(q, q), d.projectConvexOntoAxis(a, b, c, q, s), d.projectConvexOntoAxis(e, f, i, q, t);
                  var y = s,
                    z = t,
                    A = !1;
                  s[0] > t[0] && ((z = s), (y = t), (A = !0));
                  var B = z[0] - y[1];
                  (l = B <= 0), (null === k || B > k) && (g.copy(j, q), (k = B), (m = l));
                }
              }
            return m;
          };
          var fa = g.fromValues(0, 0),
            ga = g.fromValues(0, 0),
            ha = g.fromValues(0, 0);
          d.getClosestEdge = function (a, b, c, d) {
            var e = fa,
              f = ga,
              i = ha;
            g.rotate(e, c, -b), d && g.scale(e, e, -1);
            for (var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++) {
              h(f, a.vertices[(n + 1) % l], a.vertices[n % l]), g.rotate90cw(i, f), g.normalize(i, i);
              var o = j(i, e);
              (k === -1 || o > m) && ((k = n % l), (m = o));
            }
            return k;
          };
          var ia = g.create(),
            ja = g.create(),
            ka = g.create(),
            la = g.create(),
            ma = g.create(),
            na = g.create(),
            oa = g.create();
          d.prototype[q.CIRCLE | q.HEIGHTFIELD] = d.prototype.circleHeightfield = function (a, b, c, d, e, f, j, k, l, m) {
            var n = f.heights,
              m = m || b.radius,
              o = f.elementWidth,
              p = ja,
              q = ia,
              r = ma,
              s = oa,
              t = na,
              u = ka,
              v = la,
              w = Math.floor((c[0] - m - j[0]) / o),
              x = Math.ceil((c[0] + m - j[0]) / o);
            w < 0 && (w = 0), x >= n.length && (x = n.length - 1);
            for (var y = n[w], z = n[x], A = w; A < x; A++) n[A] < z && (z = n[A]), n[A] > y && (y = n[A]);
            if (c[1] - m > y) return !l && 0;
            for (var B = !1, A = w; A < x; A++) {
              g.set(u, A * o, n[A]), g.set(v, (A + 1) * o, n[A + 1]), g.add(u, u, j), g.add(v, v, j), g.sub(t, v, u), g.rotate(t, t, Math.PI / 2), g.normalize(t, t), g.scale(q, t, -m), g.add(q, q, c), g.sub(p, q, u);
              var C = g.dot(p, t);
              if (q[0] >= u[0] && q[0] < v[0] && C <= 0) {
                if (l) return !0;
                (B = !0), g.scale(p, t, -C), g.add(r, q, p), g.copy(s, t);
                var D = this.createContactEquation(e, a, f, b);
                g.copy(D.normalA, s),
                  g.scale(D.contactPointB, D.normalA, -m),
                  i(D.contactPointB, D.contactPointB, c),
                  h(D.contactPointB, D.contactPointB, a.position),
                  g.copy(D.contactPointA, r),
                  g.sub(D.contactPointA, D.contactPointA, e.position),
                  this.contactEquations.push(D),
                  this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
              }
            }
            if (((B = !1), m > 0))
              for (var A = w; A <= x; A++)
                if ((g.set(u, A * o, n[A]), g.add(u, u, j), g.sub(p, c, u), g.squaredLength(p) < Math.pow(m, 2))) {
                  if (l) return !0;
                  B = !0;
                  var D = this.createContactEquation(e, a, f, b);
                  g.copy(D.normalA, p),
                    g.normalize(D.normalA, D.normalA),
                    g.scale(D.contactPointB, D.normalA, -m),
                    i(D.contactPointB, D.contactPointB, c),
                    h(D.contactPointB, D.contactPointB, a.position),
                    h(D.contactPointA, u, j),
                    i(D.contactPointA, D.contactPointA, j),
                    h(D.contactPointA, D.contactPointA, e.position),
                    this.contactEquations.push(D),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D));
                }
            return B ? 1 : 0;
          };
          var pa = g.create(),
            qa = g.create(),
            ra = g.create(),
            sa = new p({ vertices: [g.create(), g.create(), g.create(), g.create()] });
          d.prototype[q.BOX | q.HEIGHTFIELD] = d.prototype[q.CONVEX | q.HEIGHTFIELD] = d.prototype.convexHeightfield = function (a, b, c, d, e, f, h, i, j) {
            var k = f.heights,
              l = f.elementWidth,
              m = pa,
              n = qa,
              o = ra,
              p = sa,
              q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l),
              r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
            q < 0 && (q = 0), r >= k.length && (r = k.length - 1);
            for (var s = k[q], t = k[r], u = q; u < r; u++) k[u] < t && (t = k[u]), k[u] > s && (s = k[u]);
            if (a.aabb.lowerBound[1] > s) return !j && 0;
            for (var v = 0, u = q; u < r; u++) {
              g.set(m, u * l, k[u]), g.set(n, (u + 1) * l, k[u + 1]), g.add(m, m, h), g.add(n, n, h);
              var w = 100;
              g.set(o, 0.5 * (n[0] + m[0]), 0.5 * (n[1] + m[1] - w)),
                g.sub(p.vertices[0], n, o),
                g.sub(p.vertices[1], m, o),
                g.copy(p.vertices[2], p.vertices[1]),
                g.copy(p.vertices[3], p.vertices[0]),
                (p.vertices[2][1] -= w),
                (p.vertices[3][1] -= w),
                (v += this.convexConvex(a, b, c, d, e, p, o, 0, j));
            }
            return v;
          };
        },
        {
          "../equations/ContactEquation": 21,
          "../equations/Equation": 22,
          "../equations/FrictionEquation": 23,
          "../math/vec2": 30,
          "../objects/Body": 31,
          "../shapes/Box": 37,
          "../shapes/Circle": 39,
          "../shapes/Convex": 40,
          "../shapes/Shape": 45,
          "../utils/ContactEquationPool": 48,
          "../utils/FrictionEquationPool": 49,
          "../utils/TupleDictionary": 56,
          "../utils/Utils": 57,
        },
      ],
      11: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}),
              (this.from = a.from ? f.fromValues(a.from[0], a.from[1]) : f.create()),
              (this.to = a.to ? f.fromValues(a.to[0], a.to[1]) : f.create()),
              (this.checkCollisionResponse = void 0 === a.checkCollisionResponse || a.checkCollisionResponse),
              (this.skipBackfaces = !!a.skipBackfaces),
              (this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1),
              (this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1),
              (this.mode = void 0 !== a.mode ? a.mode : d.ANY),
              (this.callback = a.callback || function (a) {}),
              (this.direction = f.create()),
              (this.length = 1),
              this.update();
          }
          function e(a, b, c) {
            f.sub(h, c, a);
            var d = f.dot(h, b);
            return f.scale(i, b, d), f.add(i, i, a), f.squaredDistance(c, i);
          }
          b.exports = d;
          var f = a("../math/vec2");
          a("../collision/RaycastResult"),
            a("../shapes/Shape"),
            a("../collision/AABB"),
            (d.prototype.constructor = d),
            (d.CLOSEST = 1),
            (d.ANY = 2),
            (d.ALL = 4),
            (d.prototype.update = function () {
              var a = this.direction;
              f.sub(a, this.to, this.from), (this.length = f.length(a)), f.normalize(a, a);
            }),
            (d.prototype.intersectBodies = function (a, b) {
              for (var c = 0, d = b.length; !a.shouldStop(this) && c < d; c++) {
                var e = b[c],
                  f = e.getAABB();
                (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e);
              }
            });
          var g = f.create();
          (d.prototype.intersectBody = function (a, b) {
            var c = this.checkCollisionResponse;
            if (!c || b.collisionResponse)
              for (var d = g, e = 0, h = b.shapes.length; e < h; e++) {
                var i = b.shapes[e];
                if ((!c || i.collisionResponse) && 0 !== (this.collisionGroup & i.collisionMask) && 0 !== (i.collisionGroup & this.collisionMask)) {
                  f.rotate(d, i.position, b.angle), f.add(d, d, b.position);
                  var j = i.angle + b.angle;
                  if ((this.intersectShape(a, i, j, d, b), a.shouldStop(this))) break;
                }
              }
          }),
            (d.prototype.intersectShape = function (a, b, c, d, f) {
              var g = this.from,
                h = e(g, this.direction, d);
              h > b.boundingRadius * b.boundingRadius || ((this._currentBody = f), (this._currentShape = b), b.raycast(a, this, d, c), (this._currentBody = this._currentShape = null));
            }),
            (d.prototype.getAABB = function (a) {
              var b = this.to,
                c = this.from;
              f.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])), f.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]));
            }),
            f.create(),
            (d.prototype.reportIntersection = function (a, b, c, e) {
              var g = (this.from, this.to, this._currentShape),
                h = this._currentBody;
              if (!(this.skipBackfaces && f.dot(c, this.direction) > 0))
                switch (this.mode) {
                  case d.ALL:
                    a.set(c, g, h, b, e), this.callback(a);
                    break;
                  case d.CLOSEST:
                    (b < a.fraction || !a.hasHit()) && a.set(c, g, h, b, e);
                    break;
                  case d.ANY:
                    a.set(c, g, h, b, e);
                }
            });
          var h = f.create(),
            i = f.create();
        },
        { "../collision/AABB": 7, "../collision/RaycastResult": 12, "../math/vec2": 30, "../shapes/Shape": 45 },
      ],
      12: [
        function (a, b, c) {
          function d() {
            (this.normal = e.create()), (this.shape = null), (this.body = null), (this.faceIndex = -1), (this.fraction = -1), (this.isStopped = !1);
          }
          var e = a("../math/vec2"),
            f = a("../collision/Ray");
          (b.exports = d),
            (d.prototype.reset = function () {
              e.set(this.normal, 0, 0), (this.shape = null), (this.body = null), (this.faceIndex = -1), (this.fraction = -1), (this.isStopped = !1);
            }),
            (d.prototype.getHitDistance = function (a) {
              return e.distance(a.from, a.to) * this.fraction;
            }),
            (d.prototype.hasHit = function () {
              return this.fraction !== -1;
            }),
            (d.prototype.getHitPoint = function (a, b) {
              e.lerp(a, b.from, b.to, this.fraction);
            }),
            (d.prototype.stop = function () {
              this.isStopped = !0;
            }),
            (d.prototype.shouldStop = function (a) {
              return this.isStopped || (this.fraction !== -1 && a.mode === f.ANY);
            }),
            (d.prototype.set = function (a, b, c, d, f) {
              e.copy(this.normal, a), (this.shape = b), (this.body = c), (this.fraction = d), (this.faceIndex = f);
            });
        },
        { "../collision/Ray": 11, "../math/vec2": 30 },
      ],
      13: [
        function (a, b, c) {
          function d() {
            f.call(this, f.SAP), (this.axisList = []), (this.axisIndex = 0);
            var a = this;
            (this._addBodyHandler = function (b) {
              a.axisList.push(b.body);
            }),
              (this._removeBodyHandler = function (b) {
                var c = a.axisList.indexOf(b.body);
                c !== -1 && a.axisList.splice(c, 1);
              });
          }
          var e = a("../utils/Utils"),
            f = a("../collision/Broadphase");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.setWorld = function (a) {
              (this.axisList.length = 0),
                e.appendArray(this.axisList, a.bodies),
                a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler),
                a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler),
                (this.world = a);
            }),
            (d.sortAxisList = function (a, b) {
              b = 0 | b;
              for (var c = 1, d = a.length; c < d; c++) {
                for (var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--) a[f + 1] = a[f];
                a[f + 1] = e;
              }
              return a;
            }),
            (d.prototype.sortList = function () {
              var a = this.axisList,
                b = this.axisIndex;
              d.sortAxisList(a, b);
            }),
            (d.prototype.getCollisionPairs = function (a) {
              var b = this.axisList,
                c = this.result,
                d = this.axisIndex;
              c.length = 0;
              for (var e = b.length; e--; ) {
                var g = b[e];
                g.aabbNeedsUpdate && g.updateAABB();
              }
              this.sortList();
              for (var h = 0, i = 0 | b.length; h !== i; h++)
                for (var j = b[h], k = h + 1; k < i; k++) {
                  var l = b[k],
                    m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
                  if (!m) break;
                  f.canCollide(j, l) && this.boundingVolumeCheck(j, l) && c.push(j, l);
                }
              return c;
            }),
            (d.prototype.aabbQuery = function (a, b, c) {
              (c = c || []), this.sortList();
              var d = this.axisIndex,
                e = "x";
              1 === d && (e = "y"), 2 === d && (e = "z");
              for (var f = this.axisList, g = (b.lowerBound[e], b.upperBound[e], 0); g < f.length; g++) {
                var h = f[g];
                h.aabbNeedsUpdate && h.updateAABB(), h.aabb.overlaps(b) && c.push(h);
              }
              return c;
            });
        },
        { "../collision/Broadphase": 8, "../utils/Utils": 57 },
      ],
      14: [
        function (a, b, c) {
          function d(a, b, c, d) {
            (this.type = c),
              (d = e.defaults(d, { collideConnected: !0, wakeUpBodies: !0 })),
              (this.equations = []),
              (this.bodyA = a),
              (this.bodyB = b),
              (this.collideConnected = d.collideConnected),
              d.wakeUpBodies && (a && a.wakeUp(), b && b.wakeUp());
          }
          b.exports = d;
          var e = a("../utils/Utils");
          (d.prototype.update = function () {
            throw new Error("method update() not implmemented in this Constraint subclass!");
          }),
            (d.DISTANCE = 1),
            (d.GEAR = 2),
            (d.LOCK = 3),
            (d.PRISMATIC = 4),
            (d.REVOLUTE = 5),
            (d.prototype.setStiffness = function (a) {
              for (var b = this.equations, c = 0; c !== b.length; c++) {
                var d = b[c];
                (d.stiffness = a), (d.needsUpdate = !0);
              }
            }),
            (d.prototype.setRelaxation = function (a) {
              for (var b = this.equations, c = 0; c !== b.length; c++) {
                var d = b[c];
                (d.relaxation = a), (d.needsUpdate = !0);
              }
            });
        },
        { "../utils/Utils": 57 },
      ],
      15: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = h.defaults(c, { localAnchorA: [0, 0], localAnchorB: [0, 0] })),
              e.call(this, a, b, e.DISTANCE, c),
              (this.localAnchorA = g.fromValues(c.localAnchorA[0], c.localAnchorA[1])),
              (this.localAnchorB = g.fromValues(c.localAnchorB[0], c.localAnchorB[1]));
            var d = this.localAnchorA,
              i = this.localAnchorB;
            if (((this.distance = 0), "number" == typeof c.distance)) this.distance = c.distance;
            else {
              var j = g.create(),
                k = g.create(),
                l = g.create();
              g.rotate(j, d, a.angle), g.rotate(k, i, b.angle), g.add(l, b.position, k), g.sub(l, l, j), g.sub(l, l, a.position), (this.distance = g.length(l));
            }
            var m;
            m = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce;
            var n = new f(a, b, -m, m);
            (this.equations = [n]), (this.maxForce = m);
            var l = g.create(),
              o = g.create(),
              p = g.create(),
              q = this;
            (n.computeGq = function () {
              var a = this.bodyA,
                b = this.bodyB,
                c = a.position,
                e = b.position;
              return g.rotate(o, d, a.angle), g.rotate(p, i, b.angle), g.add(l, e, p), g.sub(l, l, o), g.sub(l, l, c), g.length(l) - q.distance;
            }),
              this.setMaxForce(m),
              (this.upperLimitEnabled = !1),
              (this.upperLimit = 1),
              (this.lowerLimitEnabled = !1),
              (this.lowerLimit = 0),
              (this.position = 0);
          }
          var e = a("./Constraint"),
            f = a("../equations/Equation"),
            g = a("../math/vec2"),
            h = a("../utils/Utils");
          (b.exports = d), (d.prototype = new e()), (d.prototype.constructor = d);
          var i = g.create(),
            j = g.create(),
            k = g.create();
          (d.prototype.update = function () {
            var a = this.equations[0],
              b = this.bodyA,
              c = this.bodyB,
              d = (this.distance, b.position),
              e = c.position,
              f = this.equations[0],
              h = a.G;
            g.rotate(j, this.localAnchorA, b.angle), g.rotate(k, this.localAnchorB, c.angle), g.add(i, e, k), g.sub(i, i, j), g.sub(i, i, d), (this.position = g.length(i));
            var l = !1;
            if (
              (this.upperLimitEnabled && this.position > this.upperLimit && ((f.maxForce = 0), (f.minForce = -this.maxForce), (this.distance = this.upperLimit), (l = !0)),
              this.lowerLimitEnabled && this.position < this.lowerLimit && ((f.maxForce = this.maxForce), (f.minForce = 0), (this.distance = this.lowerLimit), (l = !0)),
              (this.lowerLimitEnabled || this.upperLimitEnabled) && !l)
            )
              return void (f.enabled = !1);
            (f.enabled = !0), g.normalize(i, i);
            var m = g.crossLength(j, i),
              n = g.crossLength(k, i);
            (h[0] = -i[0]), (h[1] = -i[1]), (h[2] = -m), (h[3] = i[0]), (h[4] = i[1]), (h[5] = n);
          }),
            (d.prototype.setMaxForce = function (a) {
              var b = this.equations[0];
              (b.minForce = -a), (b.maxForce = a);
            }),
            (d.prototype.getMaxForce = function () {
              var a = this.equations[0];
              return a.maxForce;
            });
        },
        { "../equations/Equation": 22, "../math/vec2": 30, "../utils/Utils": 57, "./Constraint": 14 },
      ],
      16: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}),
              e.call(this, a, b, e.GEAR, c),
              (this.ratio = void 0 !== c.ratio ? c.ratio : 1),
              (this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle),
              (c.angle = this.angle),
              (c.ratio = this.ratio),
              (this.equations = [new f(a, b, c)]),
              void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque);
          }
          var e = a("./Constraint"),
            f = (a("../equations/Equation"), a("../equations/AngleLockEquation"));
          a("../math/vec2"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.update = function () {
              var a = this.equations[0];
              a.ratio !== this.ratio && a.setRatio(this.ratio), (a.angle = this.angle);
            }),
            (d.prototype.setMaxTorque = function (a) {
              this.equations[0].setMaxTorque(a);
            }),
            (d.prototype.getMaxTorque = function (a) {
              return this.equations[0].maxForce;
            });
        },
        { "../equations/AngleLockEquation": 20, "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 },
      ],
      17: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, e.LOCK, c);
            var d = "undefined" == typeof c.maxForce ? Number.MAX_VALUE : c.maxForce,
              h = (c.localAngleB || 0, new g(a, b, -d, d)),
              i = new g(a, b, -d, d),
              j = new g(a, b, -d, d),
              k = f.create(),
              l = f.create(),
              m = this;
            (h.computeGq = function () {
              return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[0];
            }),
              (i.computeGq = function () {
                return f.rotate(k, m.localOffsetB, a.angle), f.sub(l, b.position, a.position), f.sub(l, l, k), l[1];
              });
            var n = f.create(),
              o = f.create();
            (j.computeGq = function () {
              return f.rotate(n, m.localOffsetB, b.angle - m.localAngleB), f.scale(n, n, -1), f.sub(l, a.position, b.position), f.add(l, l, n), f.rotate(o, n, -Math.PI / 2), f.normalize(o, o), f.dot(l, o);
            }),
              (this.localOffsetB = f.create()),
              c.localOffsetB ? f.copy(this.localOffsetB, c.localOffsetB) : (f.sub(this.localOffsetB, b.position, a.position), f.rotate(this.localOffsetB, this.localOffsetB, -a.angle)),
              (this.localAngleB = 0),
              "number" == typeof c.localAngleB ? (this.localAngleB = c.localAngleB) : (this.localAngleB = b.angle - a.angle),
              this.equations.push(h, i, j),
              this.setMaxForce(d);
          }
          var e = a("./Constraint"),
            f = a("../math/vec2"),
            g = a("../equations/Equation");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.setMaxForce = function (a) {
              for (var b = this.equations, c = 0; c < this.equations.length; c++) (b[c].maxForce = a), (b[c].minForce = -a);
            }),
            (d.prototype.getMaxForce = function () {
              return this.equations[0].maxForce;
            });
          var h = f.create(),
            i = f.create(),
            j = f.create(),
            k = f.fromValues(1, 0),
            l = f.fromValues(0, 1);
          d.prototype.update = function () {
            var a = this.equations[0],
              b = this.equations[1],
              c = this.equations[2],
              d = this.bodyA,
              e = this.bodyB;
            f.rotate(h, this.localOffsetB, d.angle),
              f.rotate(i, this.localOffsetB, e.angle - this.localAngleB),
              f.scale(i, i, -1),
              f.rotate(j, i, Math.PI / 2),
              f.normalize(j, j),
              (a.G[0] = -1),
              (a.G[1] = 0),
              (a.G[2] = -f.crossLength(h, k)),
              (a.G[3] = 1),
              (b.G[0] = 0),
              (b.G[1] = -1),
              (b.G[2] = -f.crossLength(h, l)),
              (b.G[4] = 1),
              (c.G[0] = -j[0]),
              (c.G[1] = -j[1]),
              (c.G[3] = j[0]),
              (c.G[4] = j[1]),
              (c.G[5] = f.crossLength(i, j));
          };
        },
        { "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 },
      ],
      18: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, e.PRISMATIC, c);
            var d = h.fromValues(0, 0),
              j = h.fromValues(1, 0),
              k = h.fromValues(0, 0);
            c.localAnchorA && h.copy(d, c.localAnchorA), c.localAxisA && h.copy(j, c.localAxisA), c.localAnchorB && h.copy(k, c.localAnchorB), (this.localAnchorA = d), (this.localAnchorB = k), (this.localAxisA = j);
            var l = (this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE),
              m = new g(a, b, -l, l),
              n = new h.create(),
              o = new h.create(),
              p = new h.create(),
              q = new h.create();
            if (
              ((m.computeGq = function () {
                return h.dot(p, q);
              }),
              (m.updateJacobian = function () {
                var c = this.G,
                  e = a.position,
                  f = b.position;
                h.rotate(n, d, a.angle),
                  h.rotate(o, k, b.angle),
                  h.add(p, f, o),
                  h.sub(p, p, e),
                  h.sub(p, p, n),
                  h.rotate(q, j, a.angle + Math.PI / 2),
                  (c[0] = -q[0]),
                  (c[1] = -q[1]),
                  (c[2] = -h.crossLength(n, q) + h.crossLength(q, p)),
                  (c[3] = q[0]),
                  (c[4] = q[1]),
                  (c[5] = h.crossLength(o, q));
              }),
              this.equations.push(m),
              !c.disableRotationalLock)
            ) {
              var r = new i(a, b, -l, l);
              this.equations.push(r);
            }
            (this.position = 0),
              (this.velocity = 0),
              (this.lowerLimitEnabled = "undefined" != typeof c.lowerLimit),
              (this.upperLimitEnabled = "undefined" != typeof c.upperLimit),
              (this.lowerLimit = "undefined" != typeof c.lowerLimit ? c.lowerLimit : 0),
              (this.upperLimit = "undefined" != typeof c.upperLimit ? c.upperLimit : 1),
              (this.upperLimitEquation = new f(a, b)),
              (this.lowerLimitEquation = new f(a, b)),
              (this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0),
              (this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l),
              (this.motorEquation = new g(a, b)),
              (this.motorEnabled = !1),
              (this.motorSpeed = 0);
            var s = this,
              t = this.motorEquation;
            t.computeGW,
              (t.computeGq = function () {
                return 0;
              }),
              (t.computeGW = function () {
                var a = this.G,
                  b = this.bodyA,
                  c = this.bodyB,
                  d = b.velocity,
                  e = c.velocity,
                  f = b.angularVelocity,
                  g = c.angularVelocity;
                return this.gmult(a, d, f, e, g) + s.motorSpeed;
              });
          }
          var e = a("./Constraint"),
            f = a("../equations/ContactEquation"),
            g = a("../equations/Equation"),
            h = a("../math/vec2"),
            i = a("../equations/RotationalLockEquation");
          (b.exports = d), (d.prototype = new e()), (d.prototype.constructor = d);
          var j = h.create(),
            k = h.create(),
            l = h.create(),
            m = h.create(),
            n = h.create(),
            o = h.create();
          (d.prototype.update = function () {
            var a = this.equations,
              b = a[0],
              c = this.upperLimit,
              d = this.lowerLimit,
              e = this.upperLimitEquation,
              f = this.lowerLimitEquation,
              g = this.bodyA,
              i = this.bodyB,
              p = this.localAxisA,
              q = this.localAnchorA,
              r = this.localAnchorB;
            b.updateJacobian(), h.rotate(j, p, g.angle), h.rotate(m, q, g.angle), h.add(k, m, g.position), h.rotate(n, r, i.angle), h.add(l, n, i.position);
            var s = (this.position = h.dot(l, j) - h.dot(k, j));
            if (this.motorEnabled) {
              var t = this.motorEquation.G;
              (t[0] = j[0]), (t[1] = j[1]), (t[2] = h.crossLength(j, n)), (t[3] = -j[0]), (t[4] = -j[1]), (t[5] = -h.crossLength(j, m));
            }
            if (this.upperLimitEnabled && s > c)
              h.scale(e.normalA, j, -1), h.sub(e.contactPointA, k, g.position), h.sub(e.contactPointB, l, i.position), h.scale(o, j, c), h.add(e.contactPointA, e.contactPointA, o), a.indexOf(e) === -1 && a.push(e);
            else {
              var u = a.indexOf(e);
              u !== -1 && a.splice(u, 1);
            }
            if (this.lowerLimitEnabled && s < d)
              h.scale(f.normalA, j, 1), h.sub(f.contactPointA, k, g.position), h.sub(f.contactPointB, l, i.position), h.scale(o, j, d), h.sub(f.contactPointB, f.contactPointB, o), a.indexOf(f) === -1 && a.push(f);
            else {
              var u = a.indexOf(f);
              u !== -1 && a.splice(u, 1);
            }
          }),
            (d.prototype.enableMotor = function () {
              this.motorEnabled || (this.equations.push(this.motorEquation), (this.motorEnabled = !0));
            }),
            (d.prototype.disableMotor = function () {
              if (this.motorEnabled) {
                var a = this.equations.indexOf(this.motorEquation);
                this.equations.splice(a, 1), (this.motorEnabled = !1);
              }
            }),
            (d.prototype.setLimits = function (a, b) {
              "number" == typeof a ? ((this.lowerLimit = a), (this.lowerLimitEnabled = !0)) : ((this.lowerLimit = a), (this.lowerLimitEnabled = !1)),
                "number" == typeof b ? ((this.upperLimit = b), (this.upperLimitEnabled = !0)) : ((this.upperLimit = b), (this.upperLimitEnabled = !1));
            });
        },
        { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../math/vec2": 30, "./Constraint": 14 },
      ],
      19: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, e.REVOLUTE, c);
            var d = (this.maxForce = "undefined" != typeof c.maxForce ? c.maxForce : Number.MAX_VALUE);
            (this.pivotA = i.create()),
              (this.pivotB = i.create()),
              c.worldPivot
                ? (i.sub(this.pivotA, c.worldPivot, a.position), i.sub(this.pivotB, c.worldPivot, b.position), i.rotate(this.pivotA, this.pivotA, -a.angle), i.rotate(this.pivotB, this.pivotB, -b.angle))
                : (i.copy(this.pivotA, c.localPivotA), i.copy(this.pivotB, c.localPivotB));
            var o = (this.equations = [new f(a, b, -d, d), new f(a, b, -d, d)]),
              p = o[0],
              q = o[1],
              r = this;
            (p.computeGq = function () {
              return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, l);
            }),
              (q.computeGq = function () {
                return i.rotate(j, r.pivotA, a.angle), i.rotate(k, r.pivotB, b.angle), i.add(n, b.position, k), i.sub(n, n, a.position), i.sub(n, n, j), i.dot(n, m);
              }),
              (q.minForce = p.minForce = -d),
              (q.maxForce = p.maxForce = d),
              (this.motorEquation = new g(a, b)),
              (this.motorEnabled = !1),
              (this.angle = 0),
              (this.lowerLimitEnabled = !1),
              (this.upperLimitEnabled = !1),
              (this.lowerLimit = 0),
              (this.upperLimit = 0),
              (this.upperLimitEquation = new h(a, b)),
              (this.lowerLimitEquation = new h(a, b)),
              (this.upperLimitEquation.minForce = 0),
              (this.lowerLimitEquation.maxForce = 0);
          }
          var e = a("./Constraint"),
            f = a("../equations/Equation"),
            g = a("../equations/RotationalVelocityEquation"),
            h = a("../equations/RotationalLockEquation"),
            i = a("../math/vec2");
          b.exports = d;
          var j = i.create(),
            k = i.create(),
            l = i.fromValues(1, 0),
            m = i.fromValues(0, 1),
            n = i.create();
          (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.setLimits = function (a, b) {
              "number" == typeof a ? ((this.lowerLimit = a), (this.lowerLimitEnabled = !0)) : ((this.lowerLimit = a), (this.lowerLimitEnabled = !1)),
                "number" == typeof b ? ((this.upperLimit = b), (this.upperLimitEnabled = !0)) : ((this.upperLimit = b), (this.upperLimitEnabled = !1));
            }),
            (d.prototype.update = function () {
              var a = this.bodyA,
                b = this.bodyB,
                c = this.pivotA,
                d = this.pivotB,
                e = this.equations,
                f = (e[0], e[1], e[0]),
                g = e[1],
                h = this.upperLimit,
                n = this.lowerLimit,
                o = this.upperLimitEquation,
                p = this.lowerLimitEquation,
                q = (this.angle = b.angle - a.angle);
              if (this.upperLimitEnabled && q > h) (o.angle = h), e.indexOf(o) === -1 && e.push(o);
              else {
                var r = e.indexOf(o);
                r !== -1 && e.splice(r, 1);
              }
              if (this.lowerLimitEnabled && q < n) (p.angle = n), e.indexOf(p) === -1 && e.push(p);
              else {
                var r = e.indexOf(p);
                r !== -1 && e.splice(r, 1);
              }
              i.rotate(j, c, a.angle),
                i.rotate(k, d, b.angle),
                (f.G[0] = -1),
                (f.G[1] = 0),
                (f.G[2] = -i.crossLength(j, l)),
                (f.G[3] = 1),
                (f.G[4] = 0),
                (f.G[5] = i.crossLength(k, l)),
                (g.G[0] = 0),
                (g.G[1] = -1),
                (g.G[2] = -i.crossLength(j, m)),
                (g.G[3] = 0),
                (g.G[4] = 1),
                (g.G[5] = i.crossLength(k, m));
            }),
            (d.prototype.enableMotor = function () {
              this.motorEnabled || (this.equations.push(this.motorEquation), (this.motorEnabled = !0));
            }),
            (d.prototype.disableMotor = function () {
              if (this.motorEnabled) {
                var a = this.equations.indexOf(this.motorEquation);
                this.equations.splice(a, 1), (this.motorEnabled = !1);
              }
            }),
            (d.prototype.motorIsEnabled = function () {
              return !!this.motorEnabled;
            }),
            (d.prototype.setMotorSpeed = function (a) {
              if (this.motorEnabled) {
                var b = this.equations.indexOf(this.motorEquation);
                this.equations[b].relativeVelocity = a;
              }
            }),
            (d.prototype.getMotorSpeed = function () {
              return !!this.motorEnabled && this.motorEquation.relativeVelocity;
            });
        },
        { "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../equations/RotationalVelocityEquation": 25, "../math/vec2": 30, "./Constraint": 14 },
      ],
      20: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), (this.angle = c.angle || 0), (this.ratio = "number" == typeof c.ratio ? c.ratio : 1), this.setRatio(this.ratio);
          }
          var e = a("./Equation");
          a("../math/vec2"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeGq = function () {
              return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
            }),
            (d.prototype.setRatio = function (a) {
              var b = this.G;
              (b[2] = a), (b[5] = -1), (this.ratio = a);
            }),
            (d.prototype.setMaxTorque = function (a) {
              (this.maxForce = a), (this.minForce = -a);
            });
        },
        { "../math/vec2": 30, "./Equation": 22 },
      ],
      21: [
        function (a, b, c) {
          function d(a, b) {
            e.call(this, a, b, 0, Number.MAX_VALUE),
              (this.contactPointA = f.create()),
              (this.penetrationVec = f.create()),
              (this.contactPointB = f.create()),
              (this.normalA = f.create()),
              (this.restitution = 0),
              (this.firstImpact = !1),
              (this.shapeA = null),
              (this.shapeB = null);
          }
          var e = a("./Equation"),
            f = a("../math/vec2");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeB = function (a, b, c) {
              var d = this.bodyA,
                e = this.bodyB,
                g = this.contactPointA,
                h = this.contactPointB,
                i = d.position,
                j = e.position,
                k = this.penetrationVec,
                l = this.normalA,
                m = this.G,
                n = f.crossLength(g, l),
                o = f.crossLength(h, l);
              (m[0] = -l[0]), (m[1] = -l[1]), (m[2] = -n), (m[3] = l[0]), (m[4] = l[1]), (m[5] = o), f.add(k, j, h), f.sub(k, k, i), f.sub(k, k, g);
              var p, q;
              this.firstImpact && 0 !== this.restitution ? ((q = 0), (p = (1 / b) * (1 + this.restitution) * this.computeGW())) : ((q = f.dot(l, k) + this.offset), (p = this.computeGW()));
              var r = this.computeGiMf(),
                s = -q * a - p * b - c * r;
              return s;
            });
        },
        { "../math/vec2": 30, "./Equation": 22 },
      ],
      22: [
        function (a, b, c) {
          function d(a, b, c, e) {
            (this.minForce = "undefined" == typeof c ? -Number.MAX_VALUE : c),
              (this.maxForce = "undefined" == typeof e ? Number.MAX_VALUE : e),
              (this.bodyA = a),
              (this.bodyB = b),
              (this.stiffness = d.DEFAULT_STIFFNESS),
              (this.relaxation = d.DEFAULT_RELAXATION),
              (this.G = new f.ARRAY_TYPE(6));
            for (var g = 0; g < 6; g++) this.G[g] = 0;
            (this.offset = 0), (this.a = 0), (this.b = 0), (this.epsilon = 0), (this.timeStep = 1 / 60), (this.needsUpdate = !0), (this.multiplier = 0), (this.relativeVelocity = 0), (this.enabled = !0);
          }
          b.exports = d;
          var e = a("../math/vec2"),
            f = a("../utils/Utils");
          a("../objects/Body"),
            (d.prototype.constructor = d),
            (d.DEFAULT_STIFFNESS = 1e6),
            (d.DEFAULT_RELAXATION = 4),
            (d.prototype.update = function () {
              var a = this.stiffness,
                b = this.relaxation,
                c = this.timeStep;
              (this.a = 4 / (c * (1 + 4 * b))), (this.b = (4 * b) / (1 + 4 * b)), (this.epsilon = 4 / (c * c * a * (1 + 4 * b))), (this.needsUpdate = !1);
            }),
            (d.prototype.gmult = function (a, b, c, d, e) {
              return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e;
            }),
            (d.prototype.computeB = function (a, b, c) {
              var d = this.computeGW(),
                e = this.computeGq(),
                f = this.computeGiMf();
              return -e * a - d * b - f * c;
            });
          var g = e.create(),
            h = e.create();
          (d.prototype.computeGq = function () {
            var a = this.G,
              b = this.bodyA,
              c = this.bodyB,
              d = (b.position, c.position, b.angle),
              e = c.angle;
            return this.gmult(a, g, d, h, e) + this.offset;
          }),
            (d.prototype.computeGW = function () {
              var a = this.G,
                b = this.bodyA,
                c = this.bodyB,
                d = b.velocity,
                e = c.velocity,
                f = b.angularVelocity,
                g = c.angularVelocity;
              return this.gmult(a, d, f, e, g) + this.relativeVelocity;
            }),
            (d.prototype.computeGWlambda = function () {
              var a = this.G,
                b = this.bodyA,
                c = this.bodyB,
                d = b.vlambda,
                e = c.vlambda,
                f = b.wlambda,
                g = c.wlambda;
              return this.gmult(a, d, f, e, g);
            });
          var i = e.create(),
            j = e.create();
          (d.prototype.computeGiMf = function () {
            var a = this.bodyA,
              b = this.bodyB,
              c = a.force,
              d = a.angularForce,
              f = b.force,
              g = b.angularForce,
              h = a.invMassSolve,
              k = b.invMassSolve,
              l = a.invInertiaSolve,
              m = b.invInertiaSolve,
              n = this.G;
            return e.scale(i, c, h), e.multiply(i, a.massMultiplier, i), e.scale(j, f, k), e.multiply(j, b.massMultiplier, j), this.gmult(n, i, d * l, j, g * m);
          }),
            (d.prototype.computeGiMGt = function () {
              var a = this.bodyA,
                b = this.bodyB,
                c = a.invMassSolve,
                d = b.invMassSolve,
                e = a.invInertiaSolve,
                f = b.invInertiaSolve,
                g = this.G;
              return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f;
            });
          var k = e.create(),
            l = e.create(),
            m = e.create();
          e.create(),
            e.create(),
            e.create(),
            (d.prototype.addToWlambda = function (a) {
              var b = this.bodyA,
                c = this.bodyB,
                d = k,
                f = l,
                g = m,
                h = b.invMassSolve,
                i = c.invMassSolve,
                j = b.invInertiaSolve,
                n = c.invInertiaSolve,
                o = this.G;
              (f[0] = o[0]),
                (f[1] = o[1]),
                (g[0] = o[3]),
                (g[1] = o[4]),
                e.scale(d, f, h * a),
                e.multiply(d, d, b.massMultiplier),
                e.add(b.vlambda, b.vlambda, d),
                (b.wlambda += j * o[2] * a),
                e.scale(d, g, i * a),
                e.multiply(d, d, c.massMultiplier),
                e.add(c.vlambda, c.vlambda, d),
                (c.wlambda += n * o[5] * a);
            }),
            (d.prototype.computeInvC = function (a) {
              return 1 / (this.computeGiMGt() + a);
            });
        },
        { "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 },
      ],
      23: [
        function (a, b, c) {
          function d(a, b, c) {
            f.call(this, a, b, -c, c), (this.contactPointA = e.create()), (this.contactPointB = e.create()), (this.t = e.create()), (this.contactEquations = []), (this.shapeA = null), (this.shapeB = null), (this.frictionCoefficient = 0.3);
          }
          var e = a("../math/vec2"),
            f = a("./Equation");
          a("../utils/Utils"),
            (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.setSlipForce = function (a) {
              (this.maxForce = a), (this.minForce = -a);
            }),
            (d.prototype.getSlipForce = function () {
              return this.maxForce;
            }),
            (d.prototype.computeB = function (a, b, c) {
              var d = (this.bodyA, this.bodyB, this.contactPointA),
                f = this.contactPointB,
                g = this.t,
                h = this.G;
              (h[0] = -g[0]), (h[1] = -g[1]), (h[2] = -e.crossLength(d, g)), (h[3] = g[0]), (h[4] = g[1]), (h[5] = e.crossLength(f, g));
              var i = this.computeGW(),
                j = this.computeGiMf(),
                k = -i * b - c * j;
              return k;
            });
        },
        { "../math/vec2": 30, "../utils/Utils": 57, "./Equation": 22 },
      ],
      24: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), (this.angle = c.angle || 0);
            var d = this.G;
            (d[2] = 1), (d[5] = -1);
          }
          var e = a("./Equation"),
            f = a("../math/vec2");
          (b.exports = d), (d.prototype = new e()), (d.prototype.constructor = d);
          var g = f.create(),
            h = f.create(),
            i = f.fromValues(1, 0),
            j = f.fromValues(0, 1);
          d.prototype.computeGq = function () {
            return f.rotate(g, i, this.bodyA.angle + this.angle), f.rotate(h, j, this.bodyB.angle), f.dot(g, h);
          };
        },
        { "../math/vec2": 30, "./Equation": 22 },
      ],
      25: [
        function (a, b, c) {
          function d(a, b) {
            e.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE), (this.relativeVelocity = 1), (this.ratio = 1);
          }
          var e = a("./Equation");
          a("../math/vec2"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeB = function (a, b, c) {
              var d = this.G;
              (d[2] = -1), (d[5] = this.ratio);
              var e = this.computeGiMf(),
                f = this.computeGW(),
                g = -f * b - c * e;
              return g;
            });
        },
        { "../math/vec2": 30, "./Equation": 22 },
      ],
      26: [
        function (a, b, c) {
          var d = function () {};
          (b.exports = d),
            (d.prototype = {
              constructor: d,
              on: function (a, b, c) {
                (b.context = c || this), void 0 === this._listeners && (this._listeners = {});
                var d = this._listeners;
                return void 0 === d[a] && (d[a] = []), d[a].indexOf(b) === -1 && d[a].push(b), this;
              },
              has: function (a, b) {
                if (void 0 === this._listeners) return !1;
                var c = this._listeners;
                if (b) {
                  if (void 0 !== c[a] && c[a].indexOf(b) !== -1) return !0;
                } else if (void 0 !== c[a]) return !0;
                return !1;
              },
              off: function (a, b) {
                if (void 0 === this._listeners) return this;
                var c = this._listeners,
                  d = c[a].indexOf(b);
                return d !== -1 && c[a].splice(d, 1), this;
              },
              emit: function (a) {
                if (void 0 === this._listeners) return this;
                var b = this._listeners,
                  c = b[a.type];
                if (void 0 !== c) {
                  a.target = this;
                  for (var d = 0, e = c.length; d < e; d++) {
                    var f = c[d];
                    f.call(f.context, a);
                  }
                }
                return this;
              },
            });
        },
        {},
      ],
      27: [
        function (a, b, c) {
          function d(a, b, c) {
            if (((c = c || {}), !(a instanceof e && b instanceof e))) throw new Error("First two arguments must be Material instances.");
            (this.id = d.idCounter++),
              (this.materialA = a),
              (this.materialB = b),
              (this.friction = "undefined" != typeof c.friction ? Number(c.friction) : 0.3),
              (this.restitution = "undefined" != typeof c.restitution ? Number(c.restitution) : 0),
              (this.stiffness = "undefined" != typeof c.stiffness ? Number(c.stiffness) : f.DEFAULT_STIFFNESS),
              (this.relaxation = "undefined" != typeof c.relaxation ? Number(c.relaxation) : f.DEFAULT_RELAXATION),
              (this.frictionStiffness = "undefined" != typeof c.frictionStiffness ? Number(c.frictionStiffness) : f.DEFAULT_STIFFNESS),
              (this.frictionRelaxation = "undefined" != typeof c.frictionRelaxation ? Number(c.frictionRelaxation) : f.DEFAULT_RELAXATION),
              (this.surfaceVelocity = "undefined" != typeof c.surfaceVelocity ? Number(c.surfaceVelocity) : 0),
              (this.contactSkinSize = 0.005);
          }
          var e = a("./Material"),
            f = a("../equations/Equation");
          (b.exports = d), (d.idCounter = 0);
        },
        { "../equations/Equation": 22, "./Material": 28 },
      ],
      28: [
        function (a, b, c) {
          function d(a) {
            this.id = a || d.idCounter++;
          }
          (b.exports = d), (d.idCounter = 0);
        },
        {},
      ],
      29: [
        function (a, b, c) {
          var d = {};
          (d.GetArea = function (a) {
            if (a.length < 6) return 0;
            for (var b = a.length - 2, c = 0, d = 0; d < b; d += 2) c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
            return (c += (a[0] - a[b]) * (a[b + 1] + a[1])), 0.5 * -c;
          }),
            (d.Triangulate = function (a) {
              var b = a.length >> 1;
              if (b < 3) return [];
              for (var c = [], e = [], f = 0; f < b; f++) e.push(f);
              for (var f = 0, g = b; g > 3; ) {
                var h = e[(f + 0) % g],
                  i = e[(f + 1) % g],
                  j = e[(f + 2) % g],
                  k = a[2 * h],
                  l = a[2 * h + 1],
                  m = a[2 * i],
                  n = a[2 * i + 1],
                  o = a[2 * j],
                  p = a[2 * j + 1],
                  q = !1;
                if (d._convex(k, l, m, n, o, p)) {
                  q = !0;
                  for (var r = 0; r < g; r++) {
                    var s = e[r];
                    if (s != h && s != i && s != j && d._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                      q = !1;
                      break;
                    }
                  }
                }
                if (q) c.push(h, i, j), e.splice((f + 1) % g, 1), g--, (f = 0);
                else if (f++ > 3 * g) break;
              }
              return c.push(e[0], e[1], e[2]), c;
            }),
            (d._PointInTriangle = function (a, b, c, d, e, f, g, h) {
              var i = g - c,
                j = h - d,
                k = e - c,
                l = f - d,
                m = a - c,
                n = b - d,
                o = i * i + j * j,
                p = i * k + j * l,
                q = i * m + j * n,
                r = k * k + l * l,
                s = k * m + l * n,
                t = 1 / (o * r - p * p),
                u = (r * q - p * s) * t,
                v = (o * s - p * q) * t;
              return u >= 0 && v >= 0 && u + v < 1;
            }),
            (d._convex = function (a, b, c, d, e, f) {
              return (b - d) * (e - c) + (c - a) * (f - d) >= 0;
            }),
            (b.exports = d);
        },
        {},
      ],
      30: [
        function (a, b, c) {
          var d = (b.exports = {}),
            e = a("../utils/Utils");
          (d.crossLength = function (a, b) {
            return a[0] * b[1] - a[1] * b[0];
          }),
            (d.crossVZ = function (a, b, c) {
              return d.rotate(a, b, -Math.PI / 2), d.scale(a, a, c), a;
            }),
            (d.crossZV = function (a, b, c) {
              return d.rotate(a, c, Math.PI / 2), d.scale(a, a, b), a;
            }),
            (d.rotate = function (a, b, c) {
              if (0 !== c) {
                var d = Math.cos(c),
                  e = Math.sin(c),
                  f = b[0],
                  g = b[1];
                (a[0] = d * f - e * g), (a[1] = e * f + d * g);
              } else (a[0] = b[0]), (a[1] = b[1]);
            }),
            (d.rotate90cw = function (a, b) {
              var c = b[0],
                d = b[1];
              (a[0] = d), (a[1] = -c);
            }),
            (d.toLocalFrame = function (a, b, c, e) {
              d.copy(a, b), d.sub(a, a, c), d.rotate(a, a, -e);
            }),
            (d.toGlobalFrame = function (a, b, c, e) {
              d.copy(a, b), d.rotate(a, a, e), d.add(a, a, c);
            }),
            (d.vectorToLocalFrame = function (a, b, c) {
              d.rotate(a, b, -c);
            }),
            (d.vectorToGlobalFrame = function (a, b, c) {
              d.rotate(a, b, c);
            }),
            (d.centroid = function (a, b, c, e) {
              return d.add(a, b, c), d.add(a, a, e), d.scale(a, a, 1 / 3), a;
            }),
            (d.create = function () {
              var a = new e.ARRAY_TYPE(2);
              return (a[0] = 0), (a[1] = 0), a;
            }),
            (d.clone = function (a) {
              var b = new e.ARRAY_TYPE(2);
              return (b[0] = a[0]), (b[1] = a[1]), b;
            }),
            (d.fromValues = function (a, b) {
              var c = new e.ARRAY_TYPE(2);
              return (c[0] = a), (c[1] = b), c;
            }),
            (d.copy = function (a, b) {
              return (a[0] = b[0]), (a[1] = b[1]), a;
            }),
            (d.set = function (a, b, c) {
              return (a[0] = b), (a[1] = c), a;
            }),
            (d.add = function (a, b, c) {
              return (a[0] = b[0] + c[0]), (a[1] = b[1] + c[1]), a;
            }),
            (d.subtract = function (a, b, c) {
              return (a[0] = b[0] - c[0]), (a[1] = b[1] - c[1]), a;
            }),
            (d.sub = d.subtract),
            (d.multiply = function (a, b, c) {
              return (a[0] = b[0] * c[0]), (a[1] = b[1] * c[1]), a;
            }),
            (d.mul = d.multiply),
            (d.divide = function (a, b, c) {
              return (a[0] = b[0] / c[0]), (a[1] = b[1] / c[1]), a;
            }),
            (d.div = d.divide),
            (d.scale = function (a, b, c) {
              return (a[0] = b[0] * c), (a[1] = b[1] * c), a;
            }),
            (d.distance = function (a, b) {
              var c = b[0] - a[0],
                d = b[1] - a[1];
              return Math.sqrt(c * c + d * d);
            }),
            (d.dist = d.distance),
            (d.squaredDistance = function (a, b) {
              var c = b[0] - a[0],
                d = b[1] - a[1];
              return c * c + d * d;
            }),
            (d.sqrDist = d.squaredDistance),
            (d.length = function (a) {
              var b = a[0],
                c = a[1];
              return Math.sqrt(b * b + c * c);
            }),
            (d.len = d.length),
            (d.squaredLength = function (a) {
              var b = a[0],
                c = a[1];
              return b * b + c * c;
            }),
            (d.sqrLen = d.squaredLength),
            (d.negate = function (a, b) {
              return (a[0] = -b[0]), (a[1] = -b[1]), a;
            }),
            (d.normalize = function (a, b) {
              var c = b[0],
                d = b[1],
                e = c * c + d * d;
              return e > 0 && ((e = 1 / Math.sqrt(e)), (a[0] = b[0] * e), (a[1] = b[1] * e)), a;
            }),
            (d.dot = function (a, b) {
              return a[0] * b[0] + a[1] * b[1];
            }),
            (d.str = function (a) {
              return "vec2(" + a[0] + ", " + a[1] + ")";
            }),
            (d.lerp = function (a, b, c, d) {
              var e = b[0],
                f = b[1];
              return (a[0] = e + d * (c[0] - e)), (a[1] = f + d * (c[1] - f)), a;
            }),
            (d.reflect = function (a, b, c) {
              var d = b[0] * c[0] + b[1] * c[1];
              (a[0] = b[0] - 2 * c[0] * d), (a[1] = b[1] - 2 * c[1] * d);
            }),
            (d.getLineSegmentsIntersection = function (a, b, c, e, f) {
              var g = d.getLineSegmentsIntersectionFraction(b, c, e, f);
              return !(g < 0 || ((a[0] = b[0] + g * (c[0] - b[0])), (a[1] = b[1] + g * (c[1] - b[1])), 0));
            }),
            (d.getLineSegmentsIntersectionFraction = function (a, b, c, d) {
              var e,
                f,
                g = b[0] - a[0],
                h = b[1] - a[1],
                i = d[0] - c[0],
                j = d[1] - c[1];
              return (e = (-h * (a[0] - c[0]) + g * (a[1] - c[1])) / (-i * h + g * j)), (f = (i * (a[1] - c[1]) - j * (a[0] - c[0])) / (-i * h + g * j)), e >= 0 && e <= 1 && f >= 0 && f <= 1 ? f : -1;
            });
        },
        { "../utils/Utils": 57 },
      ],
      31: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}),
              k.call(this),
              (this.id = a.id || ++d._idCounter),
              (this.world = null),
              (this.shapes = []),
              (this.mass = a.mass || 0),
              (this.invMass = 0),
              (this.inertia = 0),
              (this.invInertia = 0),
              (this.invMassSolve = 0),
              (this.invInertiaSolve = 0),
              (this.fixedRotation = !!a.fixedRotation),
              (this.fixedX = !!a.fixedX),
              (this.fixedY = !!a.fixedY),
              (this.massMultiplier = e.create()),
              (this.position = e.fromValues(0, 0)),
              a.position && e.copy(this.position, a.position),
              (this.interpolatedPosition = e.fromValues(0, 0)),
              (this.interpolatedAngle = 0),
              (this.previousPosition = e.fromValues(0, 0)),
              (this.previousAngle = 0),
              (this.velocity = e.fromValues(0, 0)),
              a.velocity && e.copy(this.velocity, a.velocity),
              (this.vlambda = e.fromValues(0, 0)),
              (this.wlambda = 0),
              (this.angle = a.angle || 0),
              (this.angularVelocity = a.angularVelocity || 0),
              (this.force = e.create()),
              a.force && e.copy(this.force, a.force),
              (this.angularForce = a.angularForce || 0),
              (this.damping = "number" == typeof a.damping ? a.damping : 0.1),
              (this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : 0.1),
              (this.type = d.STATIC),
              "undefined" != typeof a.type ? (this.type = a.type) : a.mass ? (this.type = d.DYNAMIC) : (this.type = d.STATIC),
              (this.boundingRadius = 0),
              (this.aabb = new j()),
              (this.aabbNeedsUpdate = !0),
              (this.allowSleep = void 0 === a.allowSleep || a.allowSleep),
              (this.wantsToSleep = !1),
              (this.sleepState = d.AWAKE),
              (this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : 0.2),
              (this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1),
              (this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1),
              (this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse),
              (this.idleTime = 0),
              (this.timeLastSleepy = 0),
              (this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1),
              (this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10),
              (this.concavePath = null),
              (this._wakeUpAfterNarrowphase = !1),
              this.updateMassProperties();
          }
          var e = a("../math/vec2"),
            f = a("poly-decomp"),
            g = a("../shapes/Convex"),
            h = a("../collision/RaycastResult"),
            i = a("../collision/Ray"),
            j = a("../collision/AABB"),
            k = a("../events/EventEmitter");
          (b.exports = d),
            (d.prototype = new k()),
            (d.prototype.constructor = d),
            (d._idCounter = 0),
            (d.prototype.updateSolveMassProperties = function () {
              this.sleepState === d.SLEEPING || this.type === d.KINEMATIC ? ((this.invMassSolve = 0), (this.invInertiaSolve = 0)) : ((this.invMassSolve = this.invMass), (this.invInertiaSolve = this.invInertia));
            }),
            (d.prototype.setDensity = function (a) {
              var b = this.getArea();
              (this.mass = b * a), this.updateMassProperties();
            }),
            (d.prototype.getArea = function () {
              for (var a = 0, b = 0; b < this.shapes.length; b++) a += this.shapes[b].area;
              return a;
            }),
            (d.prototype.getAABB = function () {
              return this.aabbNeedsUpdate && this.updateAABB(), this.aabb;
            });
          var l = new j(),
            m = e.create();
          (d.prototype.updateAABB = function () {
            for (var a = this.shapes, b = a.length, c = m, d = this.angle, f = 0; f !== b; f++) {
              var g = a[f],
                h = g.angle + d;
              e.rotate(c, g.position, d), e.add(c, c, this.position), g.computeAABB(l, c, h), 0 === f ? this.aabb.copy(l) : this.aabb.extend(l);
            }
            this.aabbNeedsUpdate = !1;
          }),
            (d.prototype.updateBoundingRadius = function () {
              for (var a = this.shapes, b = a.length, c = 0, d = 0; d !== b; d++) {
                var f = a[d],
                  g = e.length(f.position),
                  h = f.boundingRadius;
                g + h > c && (c = g + h);
              }
              this.boundingRadius = c;
            }),
            (d.prototype.addShape = function (a, b, c) {
              if (a.body) throw new Error("A shape can only be added to one body.");
              (a.body = this), b ? e.copy(a.position, b) : e.set(a.position, 0, 0), (a.angle = c || 0), this.shapes.push(a), this.updateMassProperties(), this.updateBoundingRadius(), (this.aabbNeedsUpdate = !0);
            }),
            (d.prototype.removeShape = function (a) {
              var b = this.shapes.indexOf(a);
              return b !== -1 && (this.shapes.splice(b, 1), (this.aabbNeedsUpdate = !0), (a.body = null), !0);
            }),
            (d.prototype.updateMassProperties = function () {
              if (this.type === d.STATIC || this.type === d.KINEMATIC) (this.mass = Number.MAX_VALUE), (this.invMass = 0), (this.inertia = Number.MAX_VALUE), (this.invInertia = 0);
              else {
                var a = this.shapes,
                  b = a.length,
                  c = this.mass / b,
                  f = 0;
                if (this.fixedRotation) (this.inertia = Number.MAX_VALUE), (this.invInertia = 0);
                else {
                  for (var g = 0; g < b; g++) {
                    var h = a[g],
                      i = e.squaredLength(h.position),
                      j = h.computeMomentOfInertia(c);
                    f += j + c * i;
                  }
                  (this.inertia = f), (this.invInertia = f > 0 ? 1 / f : 0);
                }
                (this.invMass = 1 / this.mass), e.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
              }
            }),
            e.create(),
            (d.prototype.applyForce = function (a, b) {
              if ((e.add(this.force, this.force, a), b)) {
                var c = e.crossLength(b, a);
                this.angularForce += c;
              }
            });
          var n = e.create(),
            o = e.create(),
            p = e.create();
          d.prototype.applyForceLocal = function (a, b) {
            b = b || p;
            var c = n,
              d = o;
            this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyForce(c, d);
          };
          var q = e.create();
          d.prototype.applyImpulse = function (a, b) {
            if (this.type === d.DYNAMIC) {
              var c = q;
              if ((e.scale(c, a, this.invMass), e.multiply(c, this.massMultiplier, c), e.add(this.velocity, c, this.velocity), b)) {
                var f = e.crossLength(b, a);
                (f *= this.invInertia), (this.angularVelocity += f);
              }
            }
          };
          var r = e.create(),
            s = e.create(),
            t = e.create();
          (d.prototype.applyImpulseLocal = function (a, b) {
            b = b || t;
            var c = r,
              d = s;
            this.vectorToWorldFrame(c, a), this.vectorToWorldFrame(d, b), this.applyImpulse(c, d);
          }),
            (d.prototype.toLocalFrame = function (a, b) {
              e.toLocalFrame(a, b, this.position, this.angle);
            }),
            (d.prototype.toWorldFrame = function (a, b) {
              e.toGlobalFrame(a, b, this.position, this.angle);
            }),
            (d.prototype.vectorToLocalFrame = function (a, b) {
              e.vectorToLocalFrame(a, b, this.angle);
            }),
            (d.prototype.vectorToWorldFrame = function (a, b) {
              e.vectorToGlobalFrame(a, b, this.angle);
            }),
            (d.prototype.fromPolygon = function (a, b) {
              b = b || {};
              for (var c = this.shapes.length; c >= 0; --c) this.removeShape(this.shapes[c]);
              var d = new f.Polygon();
              if (((d.vertices = a), d.makeCCW(), "number" == typeof b.removeCollinearPoints && d.removeCollinearPoints(b.removeCollinearPoints), "undefined" == typeof b.skipSimpleCheck && !d.isSimple())) return !1;
              this.concavePath = d.vertices.slice(0);
              for (var c = 0; c < this.concavePath.length; c++) {
                var h = [0, 0];
                e.copy(h, this.concavePath[c]), (this.concavePath[c] = h);
              }
              var i;
              i = b.optimalDecomp ? d.decomp() : d.quickDecomp();
              for (var j = e.create(), c = 0; c !== i.length; c++) {
                for (var k = new g({ vertices: i[c].vertices }), l = 0; l !== k.vertices.length; l++) {
                  var h = k.vertices[l];
                  e.sub(h, h, k.centerOfMass);
                }
                e.scale(j, k.centerOfMass, 1), k.updateTriangles(), k.updateCenterOfMass(), k.updateBoundingRadius(), this.addShape(k, j);
              }
              return this.adjustCenterOfMass(), (this.aabbNeedsUpdate = !0), !0;
            });
          var u = (e.fromValues(0, 0), e.fromValues(0, 0)),
            v = e.fromValues(0, 0),
            w = e.fromValues(0, 0);
          (d.prototype.adjustCenterOfMass = function () {
            var a = u,
              b = v,
              c = w,
              d = 0;
            e.set(b, 0, 0);
            for (var f = 0; f !== this.shapes.length; f++) {
              var g = this.shapes[f];
              e.scale(a, g.position, g.area), e.add(b, b, a), (d += g.area);
            }
            e.scale(c, b, 1 / d);
            for (var f = 0; f !== this.shapes.length; f++) {
              var g = this.shapes[f];
              e.sub(g.position, g.position, c);
            }
            e.add(this.position, this.position, c);
            for (var f = 0; this.concavePath && f < this.concavePath.length; f++) e.sub(this.concavePath[f], this.concavePath[f], c);
            this.updateMassProperties(), this.updateBoundingRadius();
          }),
            (d.prototype.setZeroForce = function () {
              e.set(this.force, 0, 0), (this.angularForce = 0);
            }),
            (d.prototype.resetConstraintVelocity = function () {
              var a = this,
                b = a.vlambda;
              e.set(b, 0, 0), (a.wlambda = 0);
            }),
            (d.prototype.addConstraintVelocity = function () {
              var a = this,
                b = a.velocity;
              e.add(b, b, a.vlambda), (a.angularVelocity += a.wlambda);
            }),
            (d.prototype.applyDamping = function (a) {
              if (this.type === d.DYNAMIC) {
                var b = this.velocity;
                e.scale(b, b, Math.pow(1 - this.damping, a)), (this.angularVelocity *= Math.pow(1 - this.angularDamping, a));
              }
            }),
            (d.prototype.wakeUp = function () {
              var a = this.sleepState;
              (this.sleepState = d.AWAKE), (this.idleTime = 0), a !== d.AWAKE && this.emit(d.wakeUpEvent);
            }),
            (d.prototype.sleep = function () {
              (this.sleepState = d.SLEEPING), (this.angularVelocity = 0), (this.angularForce = 0), e.set(this.velocity, 0, 0), e.set(this.force, 0, 0), this.emit(d.sleepEvent);
            }),
            (d.prototype.sleepTick = function (a, b, c) {
              if (this.allowSleep && this.type !== d.SLEEPING) {
                this.wantsToSleep = !1;
                var f = (this.sleepState, e.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2)),
                  g = Math.pow(this.sleepSpeedLimit, 2);
                f >= g ? ((this.idleTime = 0), (this.sleepState = d.AWAKE)) : ((this.idleTime += c), (this.sleepState = d.SLEEPY)), this.idleTime > this.sleepTimeLimit && (b ? (this.wantsToSleep = !0) : this.sleep());
              }
            }),
            (d.prototype.overlaps = function (a) {
              return this.world.overlapKeeper.bodiesAreOverlapping(this, a);
            });
          var x = e.create(),
            y = e.create();
          d.prototype.integrate = function (a) {
            var b = this.invMass,
              c = this.force,
              d = this.position,
              f = this.velocity;
            e.copy(this.previousPosition, this.position),
              (this.previousAngle = this.angle),
              this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a),
              e.scale(x, c, a * b),
              e.multiply(x, this.massMultiplier, x),
              e.add(f, x, f),
              this.integrateToTimeOfImpact(a) || (e.scale(y, f, a), e.add(d, d, y), this.fixedRotation || (this.angle += this.angularVelocity * a)),
              (this.aabbNeedsUpdate = !0);
          };
          var z = new h(),
            A = new i({ mode: i.ALL }),
            B = e.create(),
            C = e.create(),
            D = e.create(),
            E = e.create();
          (d.prototype.integrateToTimeOfImpact = function (a) {
            if (this.ccdSpeedThreshold < 0 || e.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
            e.normalize(B, this.velocity), e.scale(C, this.velocity, a), e.add(C, C, this.position), e.sub(D, C, this.position);
            var b,
              c = this.angularVelocity * a,
              d = e.length(D),
              f = 1,
              g = this;
            if (
              (z.reset(),
              (A.callback = function (a) {
                a.body !== g && ((b = a.body), a.getHitPoint(C, A), e.sub(D, C, g.position), (f = e.length(D) / d), a.stop());
              }),
              e.copy(A.from, this.position),
              e.copy(A.to, C),
              A.update(),
              this.world.raycast(z, A),
              !b)
            )
              return !1;
            var h = this.angle;
            e.copy(E, this.position);
            for (var i = 0, j = 0, k = 0, l = f; l >= j && i < this.ccdIterations; ) {
              i++, (k = (l - j) / 2), e.scale(y, D, f), e.add(this.position, E, y), (this.angle = h + c * f), this.updateAABB();
              var m = this.aabb.overlaps(b.aabb) && this.world.narrowphase.bodiesOverlap(this, b);
              m ? (j = k) : (l = k);
            }
            return (f = k), e.copy(this.position, E), (this.angle = h), e.scale(y, D, f), e.add(this.position, this.position, y), this.fixedRotation || (this.angle += c * f), !0;
          }),
            (d.prototype.getVelocityAtPoint = function (a, b) {
              return e.crossVZ(a, b, this.angularVelocity), e.subtract(a, this.velocity, a), a;
            }),
            (d.sleepyEvent = { type: "sleepy" }),
            (d.sleepEvent = { type: "sleep" }),
            (d.wakeUpEvent = { type: "wakeup" }),
            (d.DYNAMIC = 1),
            (d.STATIC = 2),
            (d.KINEMATIC = 4),
            (d.AWAKE = 0),
            (d.SLEEPY = 1),
            (d.SLEEPING = 2);
        },
        { "../collision/AABB": 7, "../collision/Ray": 11, "../collision/RaycastResult": 12, "../events/EventEmitter": 26, "../math/vec2": 30, "../shapes/Convex": 40, "poly-decomp": 5 },
      ],
      32: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}),
              f.call(this, a, b, c),
              (this.localAnchorA = e.fromValues(0, 0)),
              (this.localAnchorB = e.fromValues(0, 0)),
              c.localAnchorA && e.copy(this.localAnchorA, c.localAnchorA),
              c.localAnchorB && e.copy(this.localAnchorB, c.localAnchorB),
              c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA),
              c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
            var d = e.create(),
              g = e.create();
            this.getWorldAnchorA(d), this.getWorldAnchorB(g);
            var h = e.distance(d, g);
            this.restLength = "number" == typeof c.restLength ? c.restLength : h;
          }
          var e = a("../math/vec2"),
            f = a("./Spring");
          a("../utils/Utils"),
            (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.setWorldAnchorA = function (a) {
              this.bodyA.toLocalFrame(this.localAnchorA, a);
            }),
            (d.prototype.setWorldAnchorB = function (a) {
              this.bodyB.toLocalFrame(this.localAnchorB, a);
            }),
            (d.prototype.getWorldAnchorA = function (a) {
              this.bodyA.toWorldFrame(a, this.localAnchorA);
            }),
            (d.prototype.getWorldAnchorB = function (a) {
              this.bodyB.toWorldFrame(a, this.localAnchorB);
            });
          var g = e.create(),
            h = e.create(),
            i = e.create(),
            j = e.create(),
            k = e.create(),
            l = e.create(),
            m = e.create(),
            n = e.create(),
            o = e.create();
          d.prototype.applyForce = function () {
            var a = this.stiffness,
              b = this.damping,
              c = this.restLength,
              d = this.bodyA,
              f = this.bodyB,
              p = g,
              q = h,
              r = i,
              s = j,
              t = o,
              u = k,
              v = l,
              w = m,
              x = n;
            this.getWorldAnchorA(u), this.getWorldAnchorB(v), e.sub(w, u, d.position), e.sub(x, v, f.position), e.sub(p, v, u);
            var y = e.len(p);
            e.normalize(q, p),
              e.sub(r, f.velocity, d.velocity),
              e.crossZV(t, f.angularVelocity, x),
              e.add(r, r, t),
              e.crossZV(t, d.angularVelocity, w),
              e.sub(r, r, t),
              e.scale(s, q, -a * (y - c) - b * e.dot(r, q)),
              e.sub(d.force, d.force, s),
              e.add(f.force, f.force, s);
            var z = e.crossLength(w, s),
              A = e.crossLength(x, s);
            (d.angularForce -= z), (f.angularForce += A);
          };
        },
        { "../math/vec2": 30, "../utils/Utils": 57, "./Spring": 34 },
      ],
      33: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = c || {}), e.call(this, a, b, c), (this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle);
          }
          var e = (a("../math/vec2"), a("./Spring"));
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.applyForce = function () {
              var a = this.stiffness,
                b = this.damping,
                c = this.restAngle,
                d = this.bodyA,
                e = this.bodyB,
                f = e.angle - d.angle,
                g = e.angularVelocity - d.angularVelocity,
                h = -a * (f - c) - b * g * 0;
              (d.angularForce -= h), (e.angularForce += h);
            });
        },
        { "../math/vec2": 30, "./Spring": 34 },
      ],
      34: [
        function (a, b, c) {
          function d(a, b, c) {
            (c = e.defaults(c, { stiffness: 100, damping: 1 })), (this.stiffness = c.stiffness), (this.damping = c.damping), (this.bodyA = a), (this.bodyB = b);
          }
          var e = (a("../math/vec2"), a("../utils/Utils"));
          (b.exports = d), (d.prototype.applyForce = function () {});
        },
        { "../math/vec2": 30, "../utils/Utils": 57 },
      ],
      35: [
        function (a, b, c) {
          function d(a, b) {
            (b = b || {}), (this.chassisBody = a), (this.wheels = []), (this.groundBody = new i({ mass: 0 })), (this.world = null);
            var c = this;
            this.preStepCallback = function () {
              c.update();
            };
          }
          function e(a, b) {
            (b = b || {}),
              (this.vehicle = a),
              (this.forwardEquation = new h(a.chassisBody, a.groundBody)),
              (this.sideEquation = new h(a.chassisBody, a.groundBody)),
              (this.steerValue = 0),
              (this.engineForce = 0),
              this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5),
              (this.localForwardVector = f.fromValues(0, 1)),
              b.localForwardVector && f.copy(this.localForwardVector, b.localForwardVector),
              (this.localPosition = f.fromValues(0, 0)),
              b.localPosition && f.copy(this.localPosition, b.localPosition),
              g.apply(this, a.chassisBody, a.groundBody),
              this.equations.push(this.forwardEquation, this.sideEquation),
              this.setBrakeForce(0);
          }
          var f = a("../math/vec2"),
            g = (a("../utils/Utils"), a("../constraints/Constraint")),
            h = a("../equations/FrictionEquation"),
            i = a("../objects/Body");
          (b.exports = d),
            (d.prototype.addToWorld = function (a) {
              (this.world = a), a.addBody(this.groundBody), a.on("preStep", this.preStepCallback);
              for (var b = 0; b < this.wheels.length; b++) {
                var c = this.wheels[b];
                a.addConstraint(c);
              }
            }),
            (d.prototype.removeFromWorld = function () {
              var a = this.world;
              a.removeBody(this.groundBody), a.off("preStep", this.preStepCallback);
              for (var b = 0; b < this.wheels.length; b++) {
                var c = this.wheels[b];
                a.removeConstraint(c);
              }
              this.world = null;
            }),
            (d.prototype.addWheel = function (a) {
              var b = new e(this, a);
              return this.wheels.push(b), b;
            }),
            (d.prototype.update = function () {
              for (var a = 0; a < this.wheels.length; a++) this.wheels[a].update();
            }),
            (e.prototype = new g()),
            (e.prototype.setBrakeForce = function (a) {
              this.forwardEquation.setSlipForce(a);
            }),
            (e.prototype.setSideFriction = function (a) {
              this.sideEquation.setSlipForce(a);
            });
          var j = f.create(),
            k = f.create();
          e.prototype.getSpeed = function () {
            return this.vehicle.chassisBody.vectorToWorldFrame(k, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(j, k), f.dot(j, k);
          };
          var l = f.create();
          e.prototype.update = function () {
            this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector),
              f.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2),
              this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t),
              f.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue),
              f.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue),
              this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition),
              f.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB),
              this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition),
              f.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA),
              f.normalize(l, this.forwardEquation.t),
              f.scale(l, l, this.engineForce),
              this.vehicle.chassisBody.applyForce(l, this.forwardEquation.contactPointA);
          };
        },
        { "../constraints/Constraint": 14, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 },
      ],
      36: [
        function (a, b, c) {
          var d = (b.exports = {
            AABB: a("./collision/AABB"),
            AngleLockEquation: a("./equations/AngleLockEquation"),
            Body: a("./objects/Body"),
            Broadphase: a("./collision/Broadphase"),
            Capsule: a("./shapes/Capsule"),
            Circle: a("./shapes/Circle"),
            Constraint: a("./constraints/Constraint"),
            ContactEquation: a("./equations/ContactEquation"),
            ContactEquationPool: a("./utils/ContactEquationPool"),
            ContactMaterial: a("./material/ContactMaterial"),
            Convex: a("./shapes/Convex"),
            DistanceConstraint: a("./constraints/DistanceConstraint"),
            Equation: a("./equations/Equation"),
            EventEmitter: a("./events/EventEmitter"),
            FrictionEquation: a("./equations/FrictionEquation"),
            FrictionEquationPool: a("./utils/FrictionEquationPool"),
            GearConstraint: a("./constraints/GearConstraint"),
            GSSolver: a("./solver/GSSolver"),
            Heightfield: a("./shapes/Heightfield"),
            Line: a("./shapes/Line"),
            LockConstraint: a("./constraints/LockConstraint"),
            Material: a("./material/Material"),
            Narrowphase: a("./collision/Narrowphase"),
            NaiveBroadphase: a("./collision/NaiveBroadphase"),
            Particle: a("./shapes/Particle"),
            Plane: a("./shapes/Plane"),
            Pool: a("./utils/Pool"),
            RevoluteConstraint: a("./constraints/RevoluteConstraint"),
            PrismaticConstraint: a("./constraints/PrismaticConstraint"),
            Ray: a("./collision/Ray"),
            RaycastResult: a("./collision/RaycastResult"),
            Box: a("./shapes/Box"),
            RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
            SAPBroadphase: a("./collision/SAPBroadphase"),
            Shape: a("./shapes/Shape"),
            Solver: a("./solver/Solver"),
            Spring: a("./objects/Spring"),
            TopDownVehicle: a("./objects/TopDownVehicle"),
            LinearSpring: a("./objects/LinearSpring"),
            RotationalSpring: a("./objects/RotationalSpring"),
            Utils: a("./utils/Utils"),
            World: a("./world/World"),
            vec2: a("./math/vec2"),
            version: a("../package.json").version,
          });
          Object.defineProperty(d, "Rectangle", {
            get: function () {
              return this.Box;
            },
          });
        },
        {
          "../package.json": 6,
          "./collision/AABB": 7,
          "./collision/Broadphase": 8,
          "./collision/NaiveBroadphase": 9,
          "./collision/Narrowphase": 10,
          "./collision/Ray": 11,
          "./collision/RaycastResult": 12,
          "./collision/SAPBroadphase": 13,
          "./constraints/Constraint": 14,
          "./constraints/DistanceConstraint": 15,
          "./constraints/GearConstraint": 16,
          "./constraints/LockConstraint": 17,
          "./constraints/PrismaticConstraint": 18,
          "./constraints/RevoluteConstraint": 19,
          "./equations/AngleLockEquation": 20,
          "./equations/ContactEquation": 21,
          "./equations/Equation": 22,
          "./equations/FrictionEquation": 23,
          "./equations/RotationalVelocityEquation": 25,
          "./events/EventEmitter": 26,
          "./material/ContactMaterial": 27,
          "./material/Material": 28,
          "./math/vec2": 30,
          "./objects/Body": 31,
          "./objects/LinearSpring": 32,
          "./objects/RotationalSpring": 33,
          "./objects/Spring": 34,
          "./objects/TopDownVehicle": 35,
          "./shapes/Box": 37,
          "./shapes/Capsule": 38,
          "./shapes/Circle": 39,
          "./shapes/Convex": 40,
          "./shapes/Heightfield": 41,
          "./shapes/Line": 42,
          "./shapes/Particle": 43,
          "./shapes/Plane": 44,
          "./shapes/Shape": 45,
          "./solver/GSSolver": 46,
          "./solver/Solver": 47,
          "./utils/ContactEquationPool": 48,
          "./utils/FrictionEquationPool": 49,
          "./utils/Pool": 55,
          "./utils/Utils": 57,
          "./world/World": 61,
        },
      ],
      37: [
        function (a, b, c) {
          function d(a) {
            "number" == typeof arguments[0] && "number" == typeof arguments[1] && void (a = { width: arguments[0], height: arguments[1] }), (a = a || {});
            var b = (this.width = a.width || 1),
              c = (this.height = a.height || 1),
              d = [e.fromValues(-b / 2, -c / 2), e.fromValues(b / 2, -c / 2), e.fromValues(b / 2, c / 2), e.fromValues(-b / 2, c / 2)],
              h = [e.fromValues(1, 0), e.fromValues(0, 1)];
            (a.vertices = d), (a.axes = h), (a.type = f.BOX), g.call(this, a);
          }
          var e = a("../math/vec2"),
            f = a("./Shape"),
            g = a("./Convex");
          (b.exports = d),
            (d.prototype = new g()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              var b = this.width,
                c = this.height;
              return (a * (c * c + b * b)) / 12;
            }),
            (d.prototype.updateBoundingRadius = function () {
              var a = this.width,
                b = this.height;
              this.boundingRadius = Math.sqrt(a * a + b * b) / 2;
            }),
            e.create(),
            e.create(),
            e.create(),
            e.create(),
            (d.prototype.computeAABB = function (a, b, c) {
              a.setFromPoints(this.vertices, b, c, 0);
            }),
            (d.prototype.updateArea = function () {
              this.area = this.width * this.height;
            });
        },
        { "../math/vec2": 30, "./Convex": 40, "./Shape": 45 },
      ],
      38: [
        function (a, b, c) {
          function d(a) {
            "number" == typeof arguments[0] && "number" == typeof arguments[1] && void (a = { length: arguments[0], radius: arguments[1] }),
              (a = a || {}),
              (this.length = a.length || 1),
              (this.radius = a.radius || 1),
              (a.type = e.CAPSULE),
              e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              var b = this.radius,
                c = this.length + b,
                d = 2 * b;
              return (a * (d * d + c * c)) / 12;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = this.radius + this.length / 2;
            }),
            (d.prototype.updateArea = function () {
              this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length;
            });
          var g = f.create();
          d.prototype.computeAABB = function (a, b, c) {
            var d = this.radius;
            f.set(g, this.length / 2, 0),
              0 !== c && f.rotate(g, g, c),
              f.set(a.upperBound, Math.max(g[0] + d, -g[0] + d), Math.max(g[1] + d, -g[1] + d)),
              f.set(a.lowerBound, Math.min(g[0] - d, -g[0] - d), Math.min(g[1] - d, -g[1] - d)),
              f.add(a.lowerBound, a.lowerBound, b),
              f.add(a.upperBound, a.upperBound, b);
          };
          var h = f.create(),
            i = f.create(),
            j = f.create(),
            k = f.create(),
            l = f.fromValues(0, 1);
          d.prototype.raycast = function (a, b, c, d) {
            for (var e = b.from, g = b.to, m = (b.direction, h), n = i, o = j, p = k, q = this.length / 2, r = 0; r < 2; r++) {
              var s = this.radius * (2 * r - 1);
              f.set(o, -q, s), f.set(p, q, s), f.toGlobalFrame(o, o, c, d), f.toGlobalFrame(p, p, c, d);
              var t = f.getLineSegmentsIntersectionFraction(e, g, o, p);
              if (t >= 0 && (f.rotate(n, l, d), f.scale(n, n, 2 * r - 1), b.reportIntersection(a, t, n, -1), a.shouldStop(b))) return;
            }
            for (var u = Math.pow(this.radius, 2) + Math.pow(q, 2), r = 0; r < 2; r++) {
              f.set(o, q * (2 * r - 1), 0), f.toGlobalFrame(o, o, c, d);
              var v = Math.pow(g[0] - e[0], 2) + Math.pow(g[1] - e[1], 2),
                w = 2 * ((g[0] - e[0]) * (e[0] - o[0]) + (g[1] - e[1]) * (e[1] - o[1])),
                x = Math.pow(e[0] - o[0], 2) + Math.pow(e[1] - o[1], 2) - Math.pow(this.radius, 2),
                t = Math.pow(w, 2) - 4 * v * x;
              if (!(t < 0))
                if (0 === t) {
                  if ((f.lerp(m, e, g, t), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, t, n, -1), a.shouldStop(b)))) return;
                } else {
                  var y = Math.sqrt(t),
                    z = 1 / (2 * v),
                    A = (-w - y) * z,
                    B = (-w + y) * z;
                  if (A >= 0 && A <= 1 && (f.lerp(m, e, g, A), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, A, n, -1), a.shouldStop(b)))) return;
                  if (B >= 0 && B <= 1 && (f.lerp(m, e, g, B), f.squaredDistance(m, c) > u && (f.sub(n, m, o), f.normalize(n, n), b.reportIntersection(a, B, n, -1), a.shouldStop(b)))) return;
                }
            }
          };
        },
        { "../math/vec2": 30, "./Shape": 45 },
      ],
      39: [
        function (a, b, c) {
          function d(a) {
            "number" == typeof arguments[0] && void (a = { radius: arguments[0] }), (a = a || {}), (this.radius = a.radius || 1), (a.type = e.CIRCLE), e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              var b = this.radius;
              return (a * b * b) / 2;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = this.radius;
            }),
            (d.prototype.updateArea = function () {
              this.area = Math.PI * this.radius * this.radius;
            }),
            (d.prototype.computeAABB = function (a, b, c) {
              var d = this.radius;
              f.set(a.upperBound, d, d), f.set(a.lowerBound, -d, -d), b && (f.add(a.lowerBound, a.lowerBound, b), f.add(a.upperBound, a.upperBound, b));
            });
          var g = f.create(),
            h = f.create();
          d.prototype.raycast = function (a, b, c, d) {
            var e = b.from,
              i = b.to,
              j = this.radius,
              k = Math.pow(i[0] - e[0], 2) + Math.pow(i[1] - e[1], 2),
              l = 2 * ((i[0] - e[0]) * (e[0] - c[0]) + (i[1] - e[1]) * (e[1] - c[1])),
              m = Math.pow(e[0] - c[0], 2) + Math.pow(e[1] - c[1], 2) - Math.pow(j, 2),
              n = Math.pow(l, 2) - 4 * k * m,
              o = g,
              p = h;
            if (!(n < 0))
              if (0 === n) f.lerp(o, e, i, n), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, n, p, -1);
              else {
                var q = Math.sqrt(n),
                  r = 1 / (2 * k),
                  s = (-l - q) * r,
                  t = (-l + q) * r;
                if (s >= 0 && s <= 1 && (f.lerp(o, e, i, s), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, s, p, -1), a.shouldStop(b))) return;
                t >= 0 && t <= 1 && (f.lerp(o, e, i, t), f.sub(p, o, c), f.normalize(p, p), b.reportIntersection(a, t, p, -1));
              }
          };
        },
        { "../math/vec2": 30, "./Shape": 45 },
      ],
      40: [
        function (a, b, c) {
          function d(a) {
            Array.isArray(arguments[0]) && void (a = { vertices: arguments[0], axes: arguments[1] }), (a = a || {}), (this.vertices = []);
            for (var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++) {
              var d = f.create();
              f.copy(d, b[c]), this.vertices.push(d);
            }
            if (((this.axes = []), a.axes))
              for (var c = 0; c < a.axes.length; c++) {
                var g = f.create();
                f.copy(g, a.axes[c]), this.axes.push(g);
              }
            else
              for (var c = 0; c < this.vertices.length; c++) {
                var h = this.vertices[c],
                  i = this.vertices[(c + 1) % this.vertices.length],
                  j = f.create();
                f.sub(j, i, h), f.rotate90cw(j, j), f.normalize(j, j), this.axes.push(j);
              }
            if (
              ((this.centerOfMass = f.fromValues(0, 0)),
              (this.triangles = []),
              this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()),
              (this.boundingRadius = 0),
              (a.type = e.CONVEX),
              e.call(this, a),
              this.updateBoundingRadius(),
              this.updateArea(),
              this.area < 0)
            )
              throw new Error("Convex vertices must be given in conter-clockwise winding.");
          }
          var e = a("./Shape"),
            f = a("../math/vec2"),
            g = a("../math/polyk");
          a("poly-decomp"), (b.exports = d), (d.prototype = new e()), (d.prototype.constructor = d);
          var h = f.create(),
            i = f.create();
          (d.prototype.projectOntoLocalAxis = function (a, b) {
            for (var c, d, e = null, g = null, a = h, i = 0; i < this.vertices.length; i++) (c = this.vertices[i]), (d = f.dot(c, a)), (null === e || d > e) && (e = d), (null === g || d < g) && (g = d);
            if (g > e) {
              var j = g;
              (g = e), (e = j);
            }
            f.set(b, g, e);
          }),
            (d.prototype.projectOntoWorldAxis = function (a, b, c, d) {
              var e = i;
              this.projectOntoLocalAxis(a, d), 0 !== c ? f.rotate(e, a, c) : (e = a);
              var g = f.dot(b, e);
              f.set(d, d[0] + g, d[1] + g);
            }),
            (d.prototype.updateTriangles = function () {
              this.triangles.length = 0;
              for (var a = [], b = 0; b < this.vertices.length; b++) {
                var c = this.vertices[b];
                a.push(c[0], c[1]);
              }
              for (var d = g.Triangulate(a), b = 0; b < d.length; b += 3) {
                var e = d[b],
                  f = d[b + 1],
                  h = d[b + 2];
                this.triangles.push([e, f, h]);
              }
            });
          var j = f.create(),
            k = f.create(),
            l = f.create(),
            m = f.create(),
            n = f.create();
          f.create(),
            f.create(),
            f.create(),
            f.create(),
            (d.prototype.updateCenterOfMass = function () {
              var a = this.triangles,
                b = this.vertices,
                c = this.centerOfMass,
                e = j,
                g = l,
                h = m,
                i = n,
                o = k;
              f.set(c, 0, 0);
              for (var p = 0, q = 0; q !== a.length; q++) {
                var r = a[q],
                  g = b[r[0]],
                  h = b[r[1]],
                  i = b[r[2]];
                f.centroid(e, g, h, i);
                var s = d.triangleArea(g, h, i);
                (p += s), f.scale(o, e, s), f.add(c, c, o);
              }
              f.scale(c, c, 1 / p);
            }),
            (d.prototype.computeMomentOfInertia = function (a) {
              for (var b = 0, c = 0, d = this.vertices.length, e = d - 1, g = 0; g < d; e = g, g++) {
                var h = this.vertices[e],
                  i = this.vertices[g],
                  j = Math.abs(f.crossLength(h, i)),
                  k = f.dot(i, i) + f.dot(i, h) + f.dot(h, h);
                (b += j * k), (c += j);
              }
              return (a / 6) * (b / c);
            }),
            (d.prototype.updateBoundingRadius = function () {
              for (var a = this.vertices, b = 0, c = 0; c !== a.length; c++) {
                var d = f.squaredLength(a[c]);
                d > b && (b = d);
              }
              this.boundingRadius = Math.sqrt(b);
            }),
            (d.triangleArea = function (a, b, c) {
              return 0.5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]));
            }),
            (d.prototype.updateArea = function () {
              this.updateTriangles(), (this.area = 0);
              for (var a = this.triangles, b = this.vertices, c = 0; c !== a.length; c++) {
                var e = a[c],
                  f = b[e[0]],
                  g = b[e[1]],
                  h = b[e[2]],
                  i = d.triangleArea(f, g, h);
                this.area += i;
              }
            }),
            (d.prototype.computeAABB = function (a, b, c) {
              a.setFromPoints(this.vertices, b, c, 0);
            });
          var o = f.create(),
            p = f.create(),
            q = f.create();
          d.prototype.raycast = function (a, b, c, d) {
            var e = o,
              g = p,
              h = q,
              i = this.vertices;
            f.toLocalFrame(e, b.from, c, d), f.toLocalFrame(g, b.to, c, d);
            for (var j = i.length, k = 0; k < j && !a.shouldStop(b); k++) {
              var l = i[k],
                m = i[(k + 1) % j],
                n = f.getLineSegmentsIntersectionFraction(e, g, l, m);
              n >= 0 && (f.sub(h, m, l), f.rotate(h, h, -Math.PI / 2 + d), f.normalize(h, h), b.reportIntersection(a, n, h, k));
            }
          };
        },
        { "../math/polyk": 29, "../math/vec2": 30, "./Shape": 45, "poly-decomp": 5 },
      ],
      41: [
        function (a, b, c) {
          function d(a) {
            if (Array.isArray(arguments[0]) && ((a = { heights: arguments[0] }), "object" == typeof arguments[1])) for (var b in arguments[1]) a[b] = arguments[1][b];
            (a = a || {}),
              (this.heights = a.heights ? a.heights.slice(0) : []),
              (this.maxValue = a.maxValue || null),
              (this.minValue = a.minValue || null),
              (this.elementWidth = a.elementWidth || 0.1),
              (void 0 !== a.maxValue && void 0 !== a.minValue) || this.updateMaxMinValues(),
              (a.type = e.HEIGHTFIELD),
              e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          a("../utils/Utils"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.updateMaxMinValues = function () {
              for (var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++) {
                var e = a[d];
                e > b && (b = e), e < c && (c = e);
              }
              (this.maxValue = b), (this.minValue = c);
            }),
            (d.prototype.computeMomentOfInertia = function (a) {
              return Number.MAX_VALUE;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = Number.MAX_VALUE;
            }),
            (d.prototype.updateArea = function () {
              for (var a = this.heights, b = 0, c = 0; c < a.length - 1; c++) b += ((a[c] + a[c + 1]) / 2) * this.elementWidth;
              this.area = b;
            });
          var g = [f.create(), f.create(), f.create(), f.create()];
          (d.prototype.computeAABB = function (a, b, c) {
            f.set(g[0], 0, this.maxValue), f.set(g[1], this.elementWidth * this.heights.length, this.maxValue), f.set(g[2], this.elementWidth * this.heights.length, this.minValue), f.set(g[3], 0, this.minValue), a.setFromPoints(g, b, c);
          }),
            (d.prototype.getLineSegment = function (a, b, c) {
              var d = this.heights,
                e = this.elementWidth;
              f.set(a, c * e, d[c]), f.set(b, (c + 1) * e, d[c + 1]);
            }),
            (d.prototype.getSegmentIndex = function (a) {
              return Math.floor(a[0] / this.elementWidth);
            }),
            (d.prototype.getClampedSegmentIndex = function (a) {
              var b = this.getSegmentIndex(a);
              return (b = Math.min(this.heights.length, Math.max(b, 0)));
            });
          var h = (f.create(), f.create()),
            i = f.create(),
            j = f.create(),
            k = f.create(),
            l = f.create();
          f.fromValues(0, 1),
            (d.prototype.raycast = function (a, b, c, d) {
              var e = b.from,
                g = b.to,
                m = (b.direction, h),
                n = i,
                o = j,
                p = k,
                q = l;
              f.toLocalFrame(p, e, c, d), f.toLocalFrame(q, g, c, d);
              var r = this.getClampedSegmentIndex(p),
                s = this.getClampedSegmentIndex(q);
              if (r > s) {
                var t = r;
                (r = s), (s = t);
              }
              for (var u = 0; u < this.heights.length - 1; u++) {
                this.getLineSegment(n, o, u);
                var v = f.getLineSegmentsIntersectionFraction(p, q, n, o);
                if (v >= 0 && (f.sub(m, o, n), f.rotate(m, m, d + Math.PI / 2), f.normalize(m, m), b.reportIntersection(a, v, m, -1), a.shouldStop(b))) return;
              }
            });
        },
        { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 },
      ],
      42: [
        function (a, b, c) {
          function d(a) {
            "number" == typeof arguments[0] && void (a = { length: arguments[0] }), (a = a || {}), (this.length = a.length || 1), (a.type = e.LINE), e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              return (a * Math.pow(this.length, 2)) / 12;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = this.length / 2;
            });
          var g = [f.create(), f.create()];
          d.prototype.computeAABB = function (a, b, c) {
            var d = this.length / 2;
            f.set(g[0], -d, 0), f.set(g[1], d, 0), a.setFromPoints(g, b, c, 0);
          };
          var h = (f.create(), f.create()),
            i = f.create(),
            j = f.create(),
            k = f.fromValues(0, 1);
          d.prototype.raycast = function (a, b, c, d) {
            var e = b.from,
              g = b.to,
              l = i,
              m = j,
              n = this.length / 2;
            f.set(l, -n, 0), f.set(m, n, 0), f.toGlobalFrame(l, l, c, d), f.toGlobalFrame(m, m, c, d);
            var o = f.getLineSegmentsIntersectionFraction(l, m, e, g);
            if (o >= 0) {
              var p = h;
              f.rotate(p, k, d), b.reportIntersection(a, o, p, -1);
            }
          };
        },
        { "../math/vec2": 30, "./Shape": 45 },
      ],
      43: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}), (a.type = e.PARTICLE), e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              return 0;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = 0;
            }),
            (d.prototype.computeAABB = function (a, b, c) {
              f.copy(a.lowerBound, b), f.copy(a.upperBound, b);
            });
        },
        { "../math/vec2": 30, "./Shape": 45 },
      ],
      44: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}), (a.type = e.PLANE), e.call(this, a);
          }
          var e = a("./Shape"),
            f = a("../math/vec2");
          a("../utils/Utils"),
            (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.computeMomentOfInertia = function (a) {
              return 0;
            }),
            (d.prototype.updateBoundingRadius = function () {
              this.boundingRadius = Number.MAX_VALUE;
            }),
            (d.prototype.computeAABB = function (a, b, c) {
              var d = c % (2 * Math.PI),
                e = f.set,
                g = Number.MAX_VALUE,
                h = a.lowerBound,
                i = a.upperBound;
              0 === d ? (e(h, -g, -g), e(i, g, 0)) : d === Math.PI / 2 ? (e(h, 0, -g), e(i, g, g)) : d === Math.PI ? (e(h, -g, 0), e(i, g, g)) : d === (3 * Math.PI) / 2 ? (e(h, -g, -g), e(i, 0, g)) : (e(h, -g, -g), e(i, g, g)),
                f.add(h, h, b),
                f.add(i, i, b);
            }),
            (d.prototype.updateArea = function () {
              this.area = Number.MAX_VALUE;
            });
          var g = f.create(),
            h = (f.create(), f.create(), f.create()),
            i = f.create();
          d.prototype.raycast = function (a, b, c, d) {
            var e = b.from,
              j = b.to,
              k = b.direction,
              l = g,
              m = h,
              n = i;
            f.set(m, 0, 1), f.rotate(m, m, d), f.sub(n, e, c);
            var o = f.dot(n, m);
            f.sub(n, j, c);
            var p = f.dot(n, m);
            if (!(o * p > 0 || f.squaredDistance(e, j) < o * o)) {
              var q = f.dot(m, k);
              f.sub(l, e, c);
              var r = -f.dot(m, l) / q / b.length;
              b.reportIntersection(a, r, m, -1);
            }
          };
        },
        { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 },
      ],
      45: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}),
              (this.body = null),
              (this.position = e.fromValues(0, 0)),
              a.position && e.copy(this.position, a.position),
              (this.angle = a.angle || 0),
              (this.type = a.type || 0),
              (this.id = d.idCounter++),
              (this.boundingRadius = 0),
              (this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1),
              (this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse),
              (this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1),
              (this.material = a.material || null),
              (this.area = 0),
              (this.sensor = void 0 !== a.sensor && a.sensor),
              this.type && this.updateBoundingRadius(),
              this.updateArea();
          }
          b.exports = d;
          var e = a("../math/vec2");
          (d.idCounter = 0),
            (d.CIRCLE = 1),
            (d.PARTICLE = 2),
            (d.PLANE = 4),
            (d.CONVEX = 8),
            (d.LINE = 16),
            (d.BOX = 32),
            Object.defineProperty(d, "RECTANGLE", {
              get: function () {
                return d.BOX;
              },
            }),
            (d.CAPSULE = 64),
            (d.HEIGHTFIELD = 128),
            (d.prototype.computeMomentOfInertia = function (a) {}),
            (d.prototype.updateBoundingRadius = function () {}),
            (d.prototype.updateArea = function () {}),
            (d.prototype.computeAABB = function (a, b, c) {}),
            (d.prototype.raycast = function (a, b, c, d) {});
        },
        { "../math/vec2": 30 },
      ],
      46: [
        function (a, b, c) {
          function d(a) {
            g.call(this, a, g.GS),
              (a = a || {}),
              (this.iterations = a.iterations || 10),
              (this.tolerance = a.tolerance || 1e-7),
              (this.arrayStep = 30),
              (this.lambda = new h.ARRAY_TYPE(this.arrayStep)),
              (this.Bs = new h.ARRAY_TYPE(this.arrayStep)),
              (this.invCs = new h.ARRAY_TYPE(this.arrayStep)),
              (this.useZeroRHS = !1),
              (this.frictionIterations = 0),
              (this.usedIterations = 0);
          }
          function e(a) {
            for (var b = a.length; b--; ) a[b] = 0;
          }
          var f = a("../math/vec2"),
            g = a("./Solver"),
            h = a("../utils/Utils"),
            i = a("../equations/FrictionEquation");
          (b.exports = d),
            (d.prototype = new g()),
            (d.prototype.constructor = d),
            (d.prototype.solve = function (a, b) {
              this.sortEquations();
              var c = 0,
                g = this.iterations,
                j = this.frictionIterations,
                k = this.equations,
                l = k.length,
                m = Math.pow(this.tolerance * l, 2),
                n = b.bodies,
                o = b.bodies.length,
                p = (f.add, f.set, this.useZeroRHS),
                q = this.lambda;
              if (((this.usedIterations = 0), l))
                for (var r = 0; r !== o; r++) {
                  var s = n[r];
                  s.updateSolveMassProperties();
                }
              q.length < l && ((q = this.lambda = new h.ARRAY_TYPE(l + this.arrayStep)), (this.Bs = new h.ARRAY_TYPE(l + this.arrayStep)), (this.invCs = new h.ARRAY_TYPE(l + this.arrayStep))), e(q);
              for (var t = this.invCs, u = this.Bs, q = this.lambda, r = 0; r !== k.length; r++) {
                var v = k[r];
                (v.timeStep !== a || v.needsUpdate) && ((v.timeStep = a), v.update()), (u[r] = v.computeB(v.a, v.b, a)), (t[r] = v.computeInvC(v.epsilon));
              }
              var v, w, r, x;
              if (0 !== l) {
                for (r = 0; r !== o; r++) {
                  var s = n[r];
                  s.resetConstraintVelocity();
                }
                if (j) {
                  for (c = 0; c !== j; c++) {
                    for (w = 0, x = 0; x !== l; x++) {
                      v = k[x];
                      var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                      w += Math.abs(y);
                    }
                    if ((this.usedIterations++, w * w <= m)) break;
                  }
                  for (d.updateMultipliers(k, q, 1 / a), x = 0; x !== l; x++) {
                    var z = k[x];
                    if (z instanceof i) {
                      for (var A = 0, B = 0; B !== z.contactEquations.length; B++) A += z.contactEquations[B].multiplier;
                      (A *= z.frictionCoefficient / z.contactEquations.length), (z.maxForce = A), (z.minForce = -A);
                    }
                  }
                }
                for (c = 0; c !== g; c++) {
                  for (w = 0, x = 0; x !== l; x++) {
                    v = k[x];
                    var y = d.iterateEquation(x, v, v.epsilon, u, t, q, p, a, c);
                    w += Math.abs(y);
                  }
                  if ((this.usedIterations++, w * w <= m)) break;
                }
                for (r = 0; r !== o; r++) n[r].addConstraintVelocity();
                d.updateMultipliers(k, q, 1 / a);
              }
            }),
            (d.updateMultipliers = function (a, b, c) {
              for (var d = a.length; d--; ) a[d].multiplier = b[d] * c;
            }),
            (d.iterateEquation = function (a, b, c, d, e, f, g, h, i) {
              var j = d[a],
                k = e[a],
                l = f[a],
                m = b.computeGWlambda(),
                n = b.maxForce,
                o = b.minForce;
              g && (j = 0);
              var p = k * (j - m - c * l),
                q = l + p;
              return q < o * h ? (p = o * h - l) : q > n * h && (p = n * h - l), (f[a] += p), b.addToWlambda(p), p;
            });
        },
        { "../equations/FrictionEquation": 23, "../math/vec2": 30, "../utils/Utils": 57, "./Solver": 47 },
      ],
      47: [
        function (a, b, c) {
          function d(a, b) {
            (a = a || {}), e.call(this), (this.type = b), (this.equations = []), (this.equationSortFunction = a.equationSortFunction || !1);
          }
          var e = (a("../utils/Utils"), a("../events/EventEmitter"));
          (b.exports = d),
            (d.prototype = new e()),
            (d.prototype.constructor = d),
            (d.prototype.solve = function (a, b) {
              throw new Error("Solver.solve should be implemented by subclasses!");
            });
          var f = { bodies: [] };
          (d.prototype.solveIsland = function (a, b) {
            this.removeAllEquations(), b.equations.length && (this.addEquations(b.equations), (f.bodies.length = 0), b.getBodies(f.bodies), f.bodies.length && this.solve(a, f));
          }),
            (d.prototype.sortEquations = function () {
              this.equationSortFunction && this.equations.sort(this.equationSortFunction);
            }),
            (d.prototype.addEquation = function (a) {
              a.enabled && this.equations.push(a);
            }),
            (d.prototype.addEquations = function (a) {
              for (var b = 0, c = a.length; b !== c; b++) {
                var d = a[b];
                d.enabled && this.equations.push(d);
              }
            }),
            (d.prototype.removeEquation = function (a) {
              var b = this.equations.indexOf(a);
              b !== -1 && this.equations.splice(b, 1);
            }),
            (d.prototype.removeAllEquations = function () {
              this.equations.length = 0;
            }),
            (d.GS = 1),
            (d.ISLAND = 2);
        },
        { "../events/EventEmitter": 26, "../utils/Utils": 57 },
      ],
      48: [
        function (a, b, c) {
          function d() {
            f.apply(this, arguments);
          }
          var e = a("../equations/ContactEquation"),
            f = a("./Pool");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.create = function () {
              return new e();
            }),
            (d.prototype.destroy = function (a) {
              return (a.bodyA = a.bodyB = null), this;
            });
        },
        { "../equations/ContactEquation": 21, "./Pool": 55 },
      ],
      49: [
        function (a, b, c) {
          function d() {
            f.apply(this, arguments);
          }
          var e = a("../equations/FrictionEquation"),
            f = a("./Pool");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.create = function () {
              return new e();
            }),
            (d.prototype.destroy = function (a) {
              return (a.bodyA = a.bodyB = null), this;
            });
        },
        { "../equations/FrictionEquation": 23, "./Pool": 55 },
      ],
      50: [
        function (a, b, c) {
          function d() {
            f.apply(this, arguments);
          }
          var e = a("../world/IslandNode"),
            f = a("./Pool");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.create = function () {
              return new e();
            }),
            (d.prototype.destroy = function (a) {
              return a.reset(), this;
            });
        },
        { "../world/IslandNode": 60, "./Pool": 55 },
      ],
      51: [
        function (a, b, c) {
          function d() {
            f.apply(this, arguments);
          }
          var e = a("../world/Island"),
            f = a("./Pool");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.create = function () {
              return new e();
            }),
            (d.prototype.destroy = function (a) {
              return a.reset(), this;
            });
        },
        { "../world/Island": 58, "./Pool": 55 },
      ],
      52: [
        function (a, b, c) {
          function d() {
            (this.overlappingShapesLastState = new e()), (this.overlappingShapesCurrentState = new e()), (this.recordPool = new f({ size: 16 })), (this.tmpDict = new e()), (this.tmpArray1 = []);
          }
          var e = a("./TupleDictionary"),
            f = (a("./OverlapKeeperRecord"), a("./OverlapKeeperRecordPool"));
          a("./Utils"),
            (b.exports = d),
            (d.prototype.tick = function () {
              for (var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--; ) {
                var d = a.keys[c],
                  e = a.getByKey(d);
                b.getByKey(d), e && this.recordPool.release(e);
              }
              a.reset(), a.copy(b), b.reset();
            }),
            (d.prototype.setOverlapping = function (a, b, c, d) {
              var e = (this.overlappingShapesLastState, this.overlappingShapesCurrentState);
              if (!e.get(b.id, d.id)) {
                var f = this.recordPool.get();
                f.set(a, b, c, d), e.set(b.id, d.id, f);
              }
            }),
            (d.prototype.getNewOverlaps = function (a) {
              return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a);
            }),
            (d.prototype.getEndOverlaps = function (a) {
              return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a);
            }),
            (d.prototype.bodiesAreOverlapping = function (a, b) {
              for (var c = this.overlappingShapesCurrentState, d = c.keys.length; d--; ) {
                var e = c.keys[d],
                  f = c.data[e];
                if ((f.bodyA === a && f.bodyB === b) || (f.bodyA === b && f.bodyB === a)) return !0;
              }
              return !1;
            }),
            (d.prototype.getDiff = function (a, b, c) {
              var c = c || [],
                d = a,
                e = b;
              c.length = 0;
              for (var f = e.keys.length; f--; ) {
                var g = e.keys[f],
                  h = e.data[g];
                if (!h) throw new Error("Key " + g + " had no data!");
                var i = d.data[g];
                i || c.push(h);
              }
              return c;
            }),
            (d.prototype.isNewOverlap = function (a, b) {
              var c = 0 | a.id,
                d = 0 | b.id,
                e = this.overlappingShapesLastState,
                f = this.overlappingShapesCurrentState;
              return !e.get(c, d) && !!f.get(c, d);
            }),
            (d.prototype.getNewBodyOverlaps = function (a) {
              this.tmpArray1.length = 0;
              var b = this.getNewOverlaps(this.tmpArray1);
              return this.getBodyDiff(b, a);
            }),
            (d.prototype.getEndBodyOverlaps = function (a) {
              this.tmpArray1.length = 0;
              var b = this.getEndOverlaps(this.tmpArray1);
              return this.getBodyDiff(b, a);
            }),
            (d.prototype.getBodyDiff = function (a, b) {
              b = b || [];
              for (var c = this.tmpDict, d = a.length; d--; ) {
                var e = a[d];
                c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e);
              }
              for (d = c.keys.length; d--; ) {
                var e = c.getByKey(c.keys[d]);
                e && b.push(e.bodyA, e.bodyB);
              }
              return c.reset(), b;
            });
        },
        { "./OverlapKeeperRecord": 53, "./OverlapKeeperRecordPool": 54, "./TupleDictionary": 56, "./Utils": 57 },
      ],
      53: [
        function (a, b, c) {
          function d(a, b, c, d) {
            (this.shapeA = b), (this.shapeB = d), (this.bodyA = a), (this.bodyB = c);
          }
          (b.exports = d),
            (d.prototype.set = function (a, b, c, e) {
              d.call(this, a, b, c, e);
            });
        },
        {},
      ],
      54: [
        function (a, b, c) {
          function d() {
            f.apply(this, arguments);
          }
          var e = a("./OverlapKeeperRecord"),
            f = a("./Pool");
          (b.exports = d),
            (d.prototype = new f()),
            (d.prototype.constructor = d),
            (d.prototype.create = function () {
              return new e();
            }),
            (d.prototype.destroy = function (a) {
              return (a.bodyA = a.bodyB = a.shapeA = a.shapeB = null), this;
            });
        },
        { "./OverlapKeeperRecord": 53, "./Pool": 55 },
      ],
      55: [
        function (a, b, c) {
          function d(a) {
            (a = a || {}), (this.objects = []), void 0 !== a.size && this.resize(a.size);
          }
          (b.exports = d),
            (d.prototype.resize = function (a) {
              for (var b = this.objects; b.length > a; ) b.pop();
              for (; b.length < a; ) b.push(this.create());
              return this;
            }),
            (d.prototype.get = function () {
              var a = this.objects;
              return a.length ? a.pop() : this.create();
            }),
            (d.prototype.release = function (a) {
              return this.destroy(a), this.objects.push(a), this;
            });
        },
        {},
      ],
      56: [
        function (a, b, c) {
          function d() {
            (this.data = {}), (this.keys = []);
          }
          var e = a("./Utils");
          (b.exports = d),
            (d.prototype.getKey = function (a, b) {
              return (a = 0 | a), (b = 0 | b), (0 | a) === (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? (a << 16) | (65535 & b) : (b << 16) | (65535 & a));
            }),
            (d.prototype.getByKey = function (a) {
              return (a = 0 | a), this.data[a];
            }),
            (d.prototype.get = function (a, b) {
              return this.data[this.getKey(a, b)];
            }),
            (d.prototype.set = function (a, b, c) {
              if (!c) throw new Error("No data!");
              var d = this.getKey(a, b);
              return this.data[d] || this.keys.push(d), (this.data[d] = c), d;
            }),
            (d.prototype.reset = function () {
              for (var a = this.data, b = this.keys, c = b.length; c--; ) delete a[b[c]];
              b.length = 0;
            }),
            (d.prototype.copy = function (a) {
              this.reset(), e.appendArray(this.keys, a.keys);
              for (var b = a.keys.length; b--; ) {
                var c = a.keys[b];
                this.data[c] = a.data[c];
              }
            });
        },
        { "./Utils": 57 },
      ],
      57: [
        function (a, b, c) {
          function d() {}
          (b.exports = d),
            (d.appendArray = function (a, b) {
              if (b.length < 15e4) a.push.apply(a, b);
              else for (var c = 0, d = b.length; c !== d; ++c) a.push(b[c]);
            }),
            (d.splice = function (a, b, c) {
              c = c || 1;
              for (var d = b, e = a.length - c; d < e; d++) a[d] = a[d + c];
              a.length = e;
            }),
            "undefined" != typeof P2_ARRAY_TYPE ? (d.ARRAY_TYPE = P2_ARRAY_TYPE) : "undefined" != typeof Float32Array ? (d.ARRAY_TYPE = Float32Array) : (d.ARRAY_TYPE = Array),
            (d.extend = function (a, b) {
              for (var c in b) a[c] = b[c];
            }),
            (d.defaults = function (a, b) {
              a = a || {};
              for (var c in b) c in a || (a[c] = b[c]);
              return a;
            });
        },
        {},
      ],
      58: [
        function (a, b, c) {
          function d() {
            (this.equations = []), (this.bodies = []);
          }
          var e = a("../objects/Body");
          (b.exports = d),
            (d.prototype.reset = function () {
              this.equations.length = this.bodies.length = 0;
            });
          var f = [];
          (d.prototype.getBodies = function (a) {
            var b = a || [],
              c = this.equations;
            f.length = 0;
            for (var d = 0; d !== c.length; d++) {
              var e = c[d];
              f.indexOf(e.bodyA.id) === -1 && (b.push(e.bodyA), f.push(e.bodyA.id)), f.indexOf(e.bodyB.id) === -1 && (b.push(e.bodyB), f.push(e.bodyB.id));
            }
            return b;
          }),
            (d.prototype.wantsToSleep = function () {
              for (var a = 0; a < this.bodies.length; a++) {
                var b = this.bodies[a];
                if (b.type === e.DYNAMIC && !b.wantsToSleep) return !1;
              }
              return !0;
            }),
            (d.prototype.sleep = function () {
              for (var a = 0; a < this.bodies.length; a++) {
                var b = this.bodies[a];
                b.sleep();
              }
              return !0;
            });
        },
        { "../objects/Body": 31 },
      ],
      59: [
        function (a, b, c) {
          function d(a) {
            (this.nodePool = new e({ size: 16 })), (this.islandPool = new f({ size: 8 })), (this.equations = []), (this.islands = []), (this.nodes = []), (this.queue = []);
          }
          var e = (a("../math/vec2"), a("./Island"), a("./IslandNode"), a("./../utils/IslandNodePool")),
            f = a("./../utils/IslandPool"),
            g = a("../objects/Body");
          (b.exports = d),
            (d.getUnvisitedNode = function (a) {
              for (var b = a.length, c = 0; c !== b; c++) {
                var d = a[c];
                if (!d.visited && d.body.type === g.DYNAMIC) return d;
              }
              return !1;
            }),
            (d.prototype.visit = function (a, b, c) {
              b.push(a.body);
              for (var d = a.equations.length, e = 0; e !== d; e++) {
                var f = a.equations[e];
                c.indexOf(f) === -1 && c.push(f);
              }
            }),
            (d.prototype.bfs = function (a, b, c) {
              var e = this.queue;
              for (e.length = 0, e.push(a), a.visited = !0, this.visit(a, b, c); e.length; ) for (var f, h = e.pop(); (f = d.getUnvisitedNode(h.neighbors)); ) (f.visited = !0), this.visit(f, b, c), f.body.type === g.DYNAMIC && e.push(f);
            }),
            (d.prototype.split = function (a) {
              for (var b = a.bodies, c = this.nodes, e = this.equations; c.length; ) this.nodePool.release(c.pop());
              for (var f = 0; f !== b.length; f++) {
                var g = this.nodePool.get();
                (g.body = b[f]), c.push(g);
              }
              for (var h = 0; h !== e.length; h++) {
                var i = e[h],
                  f = b.indexOf(i.bodyA),
                  j = b.indexOf(i.bodyB),
                  k = c[f],
                  l = c[j];
                k.neighbors.push(l), l.neighbors.push(k), k.equations.push(i), l.equations.push(i);
              }
              for (var m = this.islands, f = 0; f < m.length; f++) this.islandPool.release(m[f]);
              m.length = 0;
              for (var n; (n = d.getUnvisitedNode(c)); ) {
                var o = this.islandPool.get();
                this.bfs(n, o.bodies, o.equations), m.push(o);
              }
              return m;
            });
        },
        { "../math/vec2": 30, "../objects/Body": 31, "./../utils/IslandNodePool": 50, "./../utils/IslandPool": 51, "./Island": 58, "./IslandNode": 60 },
      ],
      60: [
        function (a, b, c) {
          function d(a) {
            (this.body = a), (this.neighbors = []), (this.equations = []), (this.visited = !1);
          }
          (b.exports = d),
            (d.prototype.reset = function () {
              (this.equations.length = 0), (this.neighbors.length = 0), (this.visited = !1), (this.body = null);
            });
        },
        {},
      ],
      61: [
        function (a, b, c) {
          function d(a) {
            l.apply(this),
              (a = a || {}),
              (this.springs = []),
              (this.bodies = []),
              (this.disabledBodyCollisionPairs = []),
              (this.solver = a.solver || new e()),
              (this.narrowphase = new r(this)),
              (this.islandManager = new u()),
              (this.gravity = f.fromValues(0, -9.78)),
              a.gravity && f.copy(this.gravity, a.gravity),
              (this.frictionGravity = f.length(this.gravity) || 10),
              (this.useWorldGravityAsFrictionGravity = !0),
              (this.useFrictionGravityOnZeroGravity = !0),
              (this.broadphase = a.broadphase || new q()),
              this.broadphase.setWorld(this),
              (this.constraints = []),
              (this.defaultMaterial = new n()),
              (this.defaultContactMaterial = new o(this.defaultMaterial, this.defaultMaterial)),
              (this.lastTimeStep = 1 / 60),
              (this.applySpringForces = !0),
              (this.applyDamping = !0),
              (this.applyGravity = !0),
              (this.solveConstraints = !0),
              (this.contactMaterials = []),
              (this.time = 0),
              (this.accumulator = 0),
              (this.stepping = !1),
              (this.bodiesToBeRemoved = []),
              (this.islandSplit = "undefined" == typeof a.islandSplit || !!a.islandSplit),
              (this.emitImpactEvent = !0),
              (this._constraintIdCounter = 0),
              (this._bodyIdCounter = 0),
              (this.postStepEvent = { type: "postStep" }),
              (this.addBodyEvent = { type: "addBody", body: null }),
              (this.removeBodyEvent = { type: "removeBody", body: null }),
              (this.addSpringEvent = { type: "addSpring", spring: null }),
              (this.impactEvent = { type: "impact", bodyA: null, bodyB: null, shapeA: null, shapeB: null, contactEquation: null }),
              (this.postBroadphaseEvent = { type: "postBroadphase", pairs: null }),
              (this.sleepMode = d.NO_SLEEPING),
              (this.beginContactEvent = { type: "beginContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null, contactEquations: [] }),
              (this.endContactEvent = { type: "endContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null }),
              (this.preSolveEvent = { type: "preSolve", contactEquations: null, frictionEquations: null }),
              (this.overlappingShapesLastState = { keys: [] }),
              (this.overlappingShapesCurrentState = { keys: [] }),
              (this.overlapKeeper = new t());
          }
          var e = a("../solver/GSSolver"),
            f = (a("../solver/Solver"), a("../collision/Ray"), a("../math/vec2")),
            g = a("../shapes/Circle"),
            h = a("../shapes/Convex"),
            i = (a("../shapes/Line"), a("../shapes/Plane")),
            j = a("../shapes/Capsule"),
            k = a("../shapes/Particle"),
            l = a("../events/EventEmitter"),
            m = a("../objects/Body"),
            n = (a("../shapes/Shape"), a("../objects/LinearSpring"), a("../material/Material")),
            o = a("../material/ContactMaterial"),
            p =
              (a("../constraints/DistanceConstraint"),
              a("../constraints/Constraint"),
              a("../constraints/LockConstraint"),
              a("../constraints/RevoluteConstraint"),
              a("../constraints/PrismaticConstraint"),
              a("../constraints/GearConstraint"),
              a("../../package.json"),
              a("../collision/Broadphase"),
              a("../collision/AABB")),
            q = a("../collision/SAPBroadphase"),
            r = a("../collision/Narrowphase"),
            s = a("../utils/Utils"),
            t = a("../utils/OverlapKeeper"),
            u = a("./IslandManager");
          a("../objects/RotationalSpring"),
            (b.exports = d),
            (d.prototype = new Object(l.prototype)),
            (d.prototype.constructor = d),
            (d.NO_SLEEPING = 1),
            (d.BODY_SLEEPING = 2),
            (d.ISLAND_SLEEPING = 4),
            (d.prototype.addConstraint = function (a) {
              this.constraints.push(a);
            }),
            (d.prototype.addContactMaterial = function (a) {
              this.contactMaterials.push(a);
            }),
            (d.prototype.removeContactMaterial = function (a) {
              var b = this.contactMaterials.indexOf(a);
              b !== -1 && s.splice(this.contactMaterials, b, 1);
            }),
            (d.prototype.getContactMaterial = function (a, b) {
              for (var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++) {
                var f = c[d];
                if ((f.materialA.id === a.id && f.materialB.id === b.id) || (f.materialA.id === b.id && f.materialB.id === a.id)) return f;
              }
              return !1;
            }),
            (d.prototype.removeConstraint = function (a) {
              var b = this.constraints.indexOf(a);
              b !== -1 && s.splice(this.constraints, b, 1);
            });
          var v = (f.create(), f.create(), f.create(), f.create(), f.create(), f.create(), f.create()),
            w = f.fromValues(0, 0),
            x = f.fromValues(0, 0);
          f.fromValues(0, 0),
            f.fromValues(0, 0),
            (d.prototype.step = function (a, b, c) {
              if (((c = c || 10), (b = b || 0), 0 === b)) this.internalStep(a), (this.time += a);
              else {
                this.accumulator += b;
                for (var d = 0; this.accumulator >= a && d < c; ) this.internalStep(a), (this.time += a), (this.accumulator -= a), d++;
                for (var e = (this.accumulator % a) / a, g = 0; g !== this.bodies.length; g++) {
                  var h = this.bodies[g];
                  f.lerp(h.interpolatedPosition, h.previousPosition, h.position, e), (h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle));
                }
              }
            });
          var y = [];
          (d.prototype.internalStep = function (a) {
            this.stepping = !0;
            var b = this.springs.length,
              c = this.springs,
              e = this.bodies,
              g = this.gravity,
              h = this.solver,
              i = this.bodies.length,
              j = this.broadphase,
              k = this.narrowphase,
              l = this.constraints,
              n = v,
              o = (f.scale, f.add),
              p = (f.rotate, this.islandManager);
            if ((this.overlapKeeper.tick(), (this.lastTimeStep = a), this.useWorldGravityAsFrictionGravity)) {
              var q = f.length(this.gravity);
              (0 === q && this.useFrictionGravityOnZeroGravity) || (this.frictionGravity = q);
            }
            if (this.applyGravity)
              for (var r = 0; r !== i; r++) {
                var t = e[r],
                  u = t.force;
                t.type === m.DYNAMIC && t.sleepState !== m.SLEEPING && (f.scale(n, g, t.mass * t.gravityScale), o(u, u, n));
              }
            if (this.applySpringForces)
              for (var r = 0; r !== b; r++) {
                var w = c[r];
                w.applyForce();
              }
            if (this.applyDamping)
              for (var r = 0; r !== i; r++) {
                var t = e[r];
                t.type === m.DYNAMIC && t.applyDamping(a);
              }
            for (var x = j.getCollisionPairs(this), z = this.disabledBodyCollisionPairs, r = z.length - 2; r >= 0; r -= 2)
              for (var A = x.length - 2; A >= 0; A -= 2) ((z[r] === x[A] && z[r + 1] === x[A + 1]) || (z[r + 1] === x[A] && z[r] === x[A + 1])) && x.splice(A, 2);
            var B = l.length;
            for (r = 0; r !== B; r++) {
              var C = l[r];
              if (!C.collideConnected) for (var A = x.length - 2; A >= 0; A -= 2) ((C.bodyA === x[A] && C.bodyB === x[A + 1]) || (C.bodyB === x[A] && C.bodyA === x[A + 1])) && x.splice(A, 2);
            }
            (this.postBroadphaseEvent.pairs = x), this.emit(this.postBroadphaseEvent), (this.postBroadphaseEvent.pairs = null), k.reset(this);
            for (var r = 0, D = x.length; r !== D; r += 2)
              for (var E = x[r], F = x[r + 1], G = 0, H = E.shapes.length; G !== H; G++)
                for (var I = E.shapes[G], J = I.position, K = I.angle, L = 0, M = F.shapes.length; L !== M; L++) {
                  var N = F.shapes[L],
                    O = N.position,
                    P = N.angle,
                    Q = this.defaultContactMaterial;
                  if (I.material && N.material) {
                    var R = this.getContactMaterial(I.material, N.material);
                    R && (Q = R);
                  }
                  this.runNarrowphase(k, E, I, J, K, F, N, O, P, Q, this.frictionGravity);
                }
            for (var r = 0; r !== i; r++) {
              var S = e[r];
              S._wakeUpAfterNarrowphase && (S.wakeUp(), (S._wakeUpAfterNarrowphase = !1));
            }
            if (this.has("endContact")) {
              this.overlapKeeper.getEndOverlaps(y);
              for (var T = this.endContactEvent, L = y.length; L--; ) {
                var U = y[L];
                (T.shapeA = U.shapeA), (T.shapeB = U.shapeB), (T.bodyA = U.bodyA), (T.bodyB = U.bodyB), this.emit(T);
              }
              y.length = 0;
            }
            var V = this.preSolveEvent;
            (V.contactEquations = k.contactEquations), (V.frictionEquations = k.frictionEquations), this.emit(V), (V.contactEquations = V.frictionEquations = null);
            var B = l.length;
            for (r = 0; r !== B; r++) l[r].update();
            if (k.contactEquations.length || k.frictionEquations.length || B)
              if (this.islandSplit) {
                for (p.equations.length = 0, s.appendArray(p.equations, k.contactEquations), s.appendArray(p.equations, k.frictionEquations), r = 0; r !== B; r++) s.appendArray(p.equations, l[r].equations);
                p.split(this);
                for (var r = 0; r !== p.islands.length; r++) {
                  var W = p.islands[r];
                  W.equations.length && h.solveIsland(a, W);
                }
              } else {
                for (h.addEquations(k.contactEquations), h.addEquations(k.frictionEquations), r = 0; r !== B; r++) h.addEquations(l[r].equations);
                this.solveConstraints && h.solve(a, this), h.removeAllEquations();
              }
            for (var r = 0; r !== i; r++) {
              var S = e[r];
              S.integrate(a);
            }
            for (var r = 0; r !== i; r++) e[r].setZeroForce();
            if (this.emitImpactEvent && this.has("impact"))
              for (var X = this.impactEvent, r = 0; r !== k.contactEquations.length; r++) {
                var Y = k.contactEquations[r];
                Y.firstImpact && ((X.bodyA = Y.bodyA), (X.bodyB = Y.bodyB), (X.shapeA = Y.shapeA), (X.shapeB = Y.shapeB), (X.contactEquation = Y), this.emit(X));
              }
            if (this.sleepMode === d.BODY_SLEEPING) for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !1, a);
            else if (this.sleepMode === d.ISLAND_SLEEPING && this.islandSplit) {
              for (r = 0; r !== i; r++) e[r].sleepTick(this.time, !0, a);
              for (var r = 0; r < this.islandManager.islands.length; r++) {
                var W = this.islandManager.islands[r];
                W.wantsToSleep() && W.sleep();
              }
            }
            this.stepping = !1;
            for (var Z = this.bodiesToBeRemoved, r = 0; r !== Z.length; r++) this.removeBody(Z[r]);
            (Z.length = 0), this.emit(this.postStepEvent);
          }),
            (d.prototype.runNarrowphase = function (a, b, c, d, e, g, h, i, j, k, l) {
              if (0 !== (c.collisionGroup & h.collisionMask) && 0 !== (h.collisionGroup & c.collisionMask)) {
                f.rotate(w, d, b.angle), f.rotate(x, i, g.angle), f.add(w, w, b.position), f.add(x, x, g.position);
                var n = e + b.angle,
                  o = j + g.angle;
                (a.enableFriction = k.friction > 0), (a.frictionCoefficient = k.friction);
                var p;
                (p = b.type === m.STATIC || b.type === m.KINEMATIC ? g.mass : g.type === m.STATIC || g.type === m.KINEMATIC ? b.mass : (b.mass * g.mass) / (b.mass + g.mass)),
                  (a.slipForce = k.friction * l * p),
                  (a.restitution = k.restitution),
                  (a.surfaceVelocity = k.surfaceVelocity),
                  (a.frictionStiffness = k.frictionStiffness),
                  (a.frictionRelaxation = k.frictionRelaxation),
                  (a.stiffness = k.stiffness),
                  (a.relaxation = k.relaxation),
                  (a.contactSkinSize = k.contactSkinSize),
                  (a.enabledEquations = b.collisionResponse && g.collisionResponse && c.collisionResponse && h.collisionResponse);
                var q = a[c.type | h.type],
                  r = 0;
                if (q) {
                  var s = c.sensor || h.sensor,
                    t = a.frictionEquations.length;
                  r = c.type < h.type ? q.call(a, b, c, w, n, g, h, x, o, s) : q.call(a, g, h, x, o, b, c, w, n, s);
                  var u = a.frictionEquations.length - t;
                  if (r) {
                    if (b.allowSleep && b.type === m.DYNAMIC && b.sleepState === m.SLEEPING && g.sleepState === m.AWAKE && g.type !== m.STATIC) {
                      var v = f.squaredLength(g.velocity) + Math.pow(g.angularVelocity, 2),
                        y = Math.pow(g.sleepSpeedLimit, 2);
                      v >= 2 * y && (b._wakeUpAfterNarrowphase = !0);
                    }
                    if (g.allowSleep && g.type === m.DYNAMIC && g.sleepState === m.SLEEPING && b.sleepState === m.AWAKE && b.type !== m.STATIC) {
                      var z = f.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2),
                        A = Math.pow(b.sleepSpeedLimit, 2);
                      z >= 2 * A && (g._wakeUpAfterNarrowphase = !0);
                    }
                    if ((this.overlapKeeper.setOverlapping(b, c, g, h), this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h))) {
                      var B = this.beginContactEvent;
                      if (((B.shapeA = c), (B.shapeB = h), (B.bodyA = b), (B.bodyB = g), (B.contactEquations.length = 0), "number" == typeof r))
                        for (var C = a.contactEquations.length - r; C < a.contactEquations.length; C++) B.contactEquations.push(a.contactEquations[C]);
                      this.emit(B);
                    }
                    if ("number" == typeof r && u > 1)
                      for (var C = a.frictionEquations.length - u; C < a.frictionEquations.length; C++) {
                        var D = a.frictionEquations[C];
                        D.setSlipForce(D.getSlipForce() / u);
                      }
                  }
                }
              }
            }),
            (d.prototype.addSpring = function (a) {
              this.springs.push(a);
              var b = this.addSpringEvent;
              (b.spring = a), this.emit(b), (b.spring = null);
            }),
            (d.prototype.removeSpring = function (a) {
              var b = this.springs.indexOf(a);
              b !== -1 && s.splice(this.springs, b, 1);
            }),
            (d.prototype.addBody = function (a) {
              if (this.bodies.indexOf(a) === -1) {
                this.bodies.push(a), (a.world = this);
                var b = this.addBodyEvent;
                (b.body = a), this.emit(b), (b.body = null);
              }
            }),
            (d.prototype.removeBody = function (a) {
              if (this.stepping) this.bodiesToBeRemoved.push(a);
              else {
                a.world = null;
                var b = this.bodies.indexOf(a);
                b !== -1 && (s.splice(this.bodies, b, 1), (this.removeBodyEvent.body = a), a.resetConstraintVelocity(), this.emit(this.removeBodyEvent), (this.removeBodyEvent.body = null));
              }
            }),
            (d.prototype.getBodyById = function (a) {
              for (var b = this.bodies, c = 0; c < b.length; c++) {
                var d = b[c];
                if (d.id === a) return d;
              }
              return !1;
            }),
            (d.prototype.disableBodyCollision = function (a, b) {
              this.disabledBodyCollisionPairs.push(a, b);
            }),
            (d.prototype.enableBodyCollision = function (a, b) {
              for (var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2) if ((c[d] === a && c[d + 1] === b) || (c[d + 1] === a && c[d] === b)) return void c.splice(d, 2);
            }),
            (d.prototype.clear = function () {
              (this.time = 0), this.solver && this.solver.equations.length && this.solver.removeAllEquations();
              for (var a = this.constraints, b = a.length - 1; b >= 0; b--) this.removeConstraint(a[b]);
              for (var c = this.bodies, b = c.length - 1; b >= 0; b--) this.removeBody(c[b]);
              for (var e = this.springs, b = e.length - 1; b >= 0; b--) this.removeSpring(e[b]);
              for (var f = this.contactMaterials, b = f.length - 1; b >= 0; b--) this.removeContactMaterial(f[b]);
              d.apply(this);
            });
          var z = f.create(),
            A = (f.fromValues(0, 0), f.fromValues(0, 0));
          (d.prototype.hitTest = function (a, b, c) {
            c = c || 0;
            var d = new m({ position: a }),
              e = new k(),
              l = a,
              n = 0,
              o = z,
              p = A;
            d.addShape(e);
            for (var q = this.narrowphase, r = [], s = 0, t = b.length; s !== t; s++)
              for (var u = b[s], v = 0, w = u.shapes.length; v !== w; v++) {
                var x = u.shapes[v];
                f.rotate(o, x.position, u.angle), f.add(o, o, u.position);
                var y = x.angle + u.angle;
                ((x instanceof g && q.circleParticle(u, x, o, y, d, e, l, n, !0)) ||
                  (x instanceof h && q.particleConvex(d, e, l, n, u, x, o, y, !0)) ||
                  (x instanceof i && q.particlePlane(d, e, l, n, u, x, o, y, !0)) ||
                  (x instanceof j && q.particleCapsule(d, e, l, n, u, x, o, y, !0)) ||
                  (x instanceof k && f.squaredLength(f.sub(p, o, a)) < c * c)) &&
                  r.push(u);
              }
            return r;
          }),
            (d.prototype.setGlobalStiffness = function (a) {
              for (var b = this.constraints, c = 0; c !== b.length; c++)
                for (var d = b[c], e = 0; e !== d.equations.length; e++) {
                  var f = d.equations[e];
                  (f.stiffness = a), (f.needsUpdate = !0);
                }
              for (var g = this.contactMaterials, c = 0; c !== g.length; c++) {
                var d = g[c];
                d.stiffness = d.frictionStiffness = a;
              }
              var d = this.defaultContactMaterial;
              d.stiffness = d.frictionStiffness = a;
            }),
            (d.prototype.setGlobalRelaxation = function (a) {
              for (var b = 0; b !== this.constraints.length; b++)
                for (var c = this.constraints[b], d = 0; d !== c.equations.length; d++) {
                  var e = c.equations[d];
                  (e.relaxation = a), (e.needsUpdate = !0);
                }
              for (var b = 0; b !== this.contactMaterials.length; b++) {
                var c = this.contactMaterials[b];
                c.relaxation = c.frictionRelaxation = a;
              }
              var c = this.defaultContactMaterial;
              c.relaxation = c.frictionRelaxation = a;
            });
          var B = new p(),
            C = [];
          d.prototype.raycast = function (a, b) {
            return b.getAABB(B), this.broadphase.aabbQuery(this, B, C), b.intersectBodies(a, C), (C.length = 0), a.hasHit();
          };
        },
        {
          "../../package.json": 6,
          "../collision/AABB": 7,
          "../collision/Broadphase": 8,
          "../collision/Narrowphase": 10,
          "../collision/Ray": 11,
          "../collision/SAPBroadphase": 13,
          "../constraints/Constraint": 14,
          "../constraints/DistanceConstraint": 15,
          "../constraints/GearConstraint": 16,
          "../constraints/LockConstraint": 17,
          "../constraints/PrismaticConstraint": 18,
          "../constraints/RevoluteConstraint": 19,
          "../events/EventEmitter": 26,
          "../material/ContactMaterial": 27,
          "../material/Material": 28,
          "../math/vec2": 30,
          "../objects/Body": 31,
          "../objects/LinearSpring": 32,
          "../objects/RotationalSpring": 33,
          "../shapes/Capsule": 38,
          "../shapes/Circle": 39,
          "../shapes/Convex": 40,
          "../shapes/Line": 42,
          "../shapes/Particle": 43,
          "../shapes/Plane": 44,
          "../shapes/Shape": 45,
          "../solver/GSSolver": 46,
          "../solver/Solver": 47,
          "../utils/OverlapKeeper": 52,
          "../utils/Utils": 57,
          "./IslandManager": 59,
        },
      ],
    },
    {},
    [36]
  )(36);
}),
  function () {
    var a = this,
      b = b || {};
    return (
      (b.game = null),
      (b.WEBGL_RENDERER = 0),
      (b.CANVAS_RENDERER = 1),
      (b.VERSION = "v2.2.9"),
      (b._UID = 0),
      "undefined" != typeof Float32Array ? ((b.Float32Array = Float32Array), (b.Uint16Array = Uint16Array), (b.Uint32Array = Uint32Array), (b.ArrayBuffer = ArrayBuffer)) : ((b.Float32Array = Array), (b.Uint16Array = Array)),
      (b.PI_2 = 2 * Math.PI),
      (b.RAD_TO_DEG = 180 / Math.PI),
      (b.DEG_TO_RAD = Math.PI / 180),
      (b.RETINA_PREFIX = "@2x"),
      (b.DisplayObject = function () {
        (this.position = new b.Point(0, 0)),
          (this.scale = new b.Point(1, 1)),
          (this.pivot = new b.Point(0, 0)),
          (this.rotation = 0),
          (this.alpha = 1),
          (this.visible = !0),
          (this.hitArea = null),
          (this.renderable = !1),
          (this.parent = null),
          (this.worldAlpha = 1),
          (this.worldTransform = new b.Matrix()),
          (this.worldPosition = new b.Point(0, 0)),
          (this.worldScale = new b.Point(1, 1)),
          (this.worldRotation = 0),
          (this.filterArea = null),
          (this._sr = 0),
          (this._cr = 1),
          (this._bounds = new b.Rectangle(0, 0, 0, 0)),
          (this._currentBounds = null),
          (this._mask = null),
          (this._cacheAsBitmap = !1),
          (this._cacheIsDirty = !1);
      }),
      (b.DisplayObject.prototype.constructor = b.DisplayObject),
      (b.DisplayObject.prototype = {
        destroy: function () {
          if (this.children) {
            for (var a = this.children.length; a--; ) this.children[a].destroy();
            this.children = [];
          }
          (this.hitArea = null), (this.parent = null), (this.worldTransform = null), (this.filterArea = null), (this.renderable = !1), (this._bounds = null), (this._currentBounds = null), (this._mask = null), this._destroyCachedSprite();
        },
        updateTransform: function (a) {
          if (!a && !this.parent && !this.game) return this;
          var c = this.parent;
          a ? (c = a) : this.parent || (c = this.game.world);
          var d,
            e,
            f,
            g,
            h,
            i,
            j = c.worldTransform,
            k = this.worldTransform;
          return (
            this.rotation % b.PI_2
              ? (this.rotation !== this.rotationCache && ((this.rotationCache = this.rotation), (this._sr = Math.sin(this.rotation)), (this._cr = Math.cos(this.rotation))),
                (d = this._cr * this.scale.x),
                (e = this._sr * this.scale.x),
                (f = -this._sr * this.scale.y),
                (g = this._cr * this.scale.y),
                (h = this.position.x),
                (i = this.position.y),
                (this.pivot.x || this.pivot.y) && ((h -= this.pivot.x * d + this.pivot.y * f), (i -= this.pivot.x * e + this.pivot.y * g)),
                (k.a = d * j.a + e * j.c),
                (k.b = d * j.b + e * j.d),
                (k.c = f * j.a + g * j.c),
                (k.d = f * j.b + g * j.d),
                (k.tx = h * j.a + i * j.c + j.tx),
                (k.ty = h * j.b + i * j.d + j.ty))
              : ((d = this.scale.x),
                (g = this.scale.y),
                (h = this.position.x - this.pivot.x * d),
                (i = this.position.y - this.pivot.y * g),
                (k.a = d * j.a),
                (k.b = d * j.b),
                (k.c = g * j.c),
                (k.d = g * j.d),
                (k.tx = h * j.a + i * j.c + j.tx),
                (k.ty = h * j.b + i * j.d + j.ty)),
            (this.worldAlpha = this.alpha * c.worldAlpha),
            this.worldPosition.set(k.tx, k.ty),
            this.worldScale.set(this.scale.x * Math.sqrt(k.a * k.a + k.c * k.c), this.scale.y * Math.sqrt(k.b * k.b + k.d * k.d)),
            (this.worldRotation = Math.atan2(-k.c, k.d)),
            (this._currentBounds = null),
            this.transformCallback && this.transformCallback.call(this.transformCallbackContext, k, j),
            this
          );
        },
        preUpdate: function () {},
        generateTexture: function (a, c, d) {
          var e = this.getLocalBounds(),
            f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
          return (b.DisplayObject._tempMatrix.tx = -e.x), (b.DisplayObject._tempMatrix.ty = -e.y), f.render(this, b.DisplayObject._tempMatrix), f;
        },
        updateCache: function () {
          return this._generateCachedSprite(), this;
        },
        toGlobal: function (a) {
          return this.updateTransform(), this.worldTransform.apply(a);
        },
        toLocal: function (a, b) {
          return b && (a = b.toGlobal(a)), this.updateTransform(), this.worldTransform.applyInverse(a);
        },
        _renderCachedSprite: function (a) {
          (this._cachedSprite.worldAlpha = this.worldAlpha), a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
        },
        _generateCachedSprite: function () {
          this._cacheAsBitmap = !1;
          var a = this.getLocalBounds();
          if (((a.width = Math.max(1, Math.ceil(a.width))), (a.height = Math.max(1, Math.ceil(a.height))), this.updateTransform(), this._cachedSprite)) this._cachedSprite.texture.resize(a.width, a.height);
          else {
            var c = new b.RenderTexture(a.width, a.height);
            (this._cachedSprite = new b.Sprite(c)), (this._cachedSprite.worldTransform = this.worldTransform);
          }
          var d = this._filters;
          (this._filters = null),
            (this._cachedSprite.filters = d),
            (b.DisplayObject._tempMatrix.tx = -a.x),
            (b.DisplayObject._tempMatrix.ty = -a.y),
            this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0),
            (this._cachedSprite.anchor.x = -(a.x / a.width)),
            (this._cachedSprite.anchor.y = -(a.y / a.height)),
            (this._filters = d),
            (this._cacheAsBitmap = !0);
        },
        _destroyCachedSprite: function () {
          this._cachedSprite && (this._cachedSprite.texture.destroy(!0), (this._cachedSprite = null));
        },
      }),
      (b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform),
      Object.defineProperties(b.DisplayObject.prototype, {
        x: {
          get: function () {
            return this.position.x;
          },
          set: function (a) {
            this.position.x = a;
          },
        },
        y: {
          get: function () {
            return this.position.y;
          },
          set: function (a) {
            this.position.y = a;
          },
        },
        worldVisible: {
          get: function () {
            if (this.visible) {
              var a = this.parent;
              if (!a) return this.visible;
              do {
                if (!a.visible) return !1;
                a = a.parent;
              } while (a);
              return !0;
            }
            return !1;
          },
        },
        mask: {
          get: function () {
            return this._mask;
          },
          set: function (a) {
            this._mask && (this._mask.isMask = !1), (this._mask = a), a && (this._mask.isMask = !0);
          },
        },
        filters: {
          get: function () {
            return this._filters;
          },
          set: function (a) {
            if (Array.isArray(a)) {
              for (var c = [], d = 0; d < a.length; d++) for (var e = a[d].passes, f = 0; f < e.length; f++) c.push(e[f]);
              this._filterBlock = { target: this, filterPasses: c };
            }
            (this._filters = a), this.blendMode && this.blendMode === b.blendModes.MULTIPLY && (this.blendMode = b.blendModes.NORMAL);
          },
        },
        cacheAsBitmap: {
          get: function () {
            return this._cacheAsBitmap;
          },
          set: function (a) {
            this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(), (this._cacheAsBitmap = a));
          },
        },
      }),
      (b.DisplayObjectContainer = function () {
        b.DisplayObject.call(this), (this.children = []), (this.ignoreChildInput = !1);
      }),
      (b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype)),
      (b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer),
      (b.DisplayObjectContainer.prototype.addChild = function (a) {
        return this.addChildAt(a, this.children.length);
      }),
      (b.DisplayObjectContainer.prototype.addChildAt = function (a, b) {
        if (b >= 0 && b <= this.children.length) return a.parent && a.parent.removeChild(a), (a.parent = this), this.children.splice(b, 0, a), a;
        throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length);
      }),
      (b.DisplayObjectContainer.prototype.swapChildren = function (a, b) {
        if (a !== b) {
          var c = this.getChildIndex(a),
            d = this.getChildIndex(b);
          if (c < 0 || d < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
          (this.children[c] = b), (this.children[d] = a);
        }
      }),
      (b.DisplayObjectContainer.prototype.getChildIndex = function (a) {
        var b = this.children.indexOf(a);
        if (b === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
        return b;
      }),
      (b.DisplayObjectContainer.prototype.setChildIndex = function (a, b) {
        if (b < 0 || b >= this.children.length) throw new Error("The supplied index is out of bounds");
        var c = this.getChildIndex(a);
        this.children.splice(c, 1), this.children.splice(b, 0, a);
      }),
      (b.DisplayObjectContainer.prototype.getChildAt = function (a) {
        if (a < 0 || a >= this.children.length) throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[a];
      }),
      (b.DisplayObjectContainer.prototype.removeChild = function (a) {
        var b = this.children.indexOf(a);
        if (b !== -1) return this.removeChildAt(b);
      }),
      (b.DisplayObjectContainer.prototype.removeChildAt = function (a) {
        var b = this.getChildAt(a);
        return b && ((b.parent = void 0), this.children.splice(a, 1)), b;
      }),
      (b.DisplayObjectContainer.prototype.removeChildren = function (a, b) {
        void 0 === a && (a = 0), void 0 === b && (b = this.children.length);
        var c = b - a;
        if (c > 0 && c <= b) {
          for (var d = this.children.splice(begin, c), e = 0; e < d.length; e++) {
            var f = d[e];
            f.parent = void 0;
          }
          return d;
        }
        if (0 === c && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
      }),
      (b.DisplayObjectContainer.prototype.updateTransform = function () {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform();
      }),
      (b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform),
      (b.DisplayObjectContainer.prototype.getBounds = function (a) {
        var c = a && a instanceof b.DisplayObject,
          d = !0;
        c ? (d = a instanceof b.DisplayObjectContainer && a.contains(this)) : (a = this);
        var e;
        if (c) {
          var f = a.worldTransform;
          for (a.worldTransform = b.identityMatrix, e = 0; e < a.children.length; e++) a.children[e].updateTransform();
        }
        var g,
          h,
          i,
          j = 1 / 0,
          k = 1 / 0,
          l = -(1 / 0),
          m = -(1 / 0),
          n = !1;
        for (e = 0; e < this.children.length; e++) {
          var o = this.children[e];
          o.visible && ((n = !0), (g = this.children[e].getBounds()), (j = j < g.x ? j : g.x), (k = k < g.y ? k : g.y), (h = g.width + g.x), (i = g.height + g.y), (l = l > h ? l : h), (m = m > i ? m : i));
        }
        var p = this._bounds;
        if (!n) {
          p = new b.Rectangle();
          var q = p.x,
            r = p.width + p.x,
            s = p.y,
            t = p.height + p.y,
            u = this.worldTransform,
            v = u.a,
            w = u.b,
            x = u.c,
            y = u.d,
            z = u.tx,
            A = u.ty,
            B = v * r + x * t + z,
            C = y * t + w * r + A,
            D = v * q + x * t + z,
            E = y * t + w * q + A,
            F = v * q + x * s + z,
            G = y * s + w * q + A,
            H = v * r + x * s + z,
            I = y * s + w * r + A;
          (l = B),
            (m = C),
            (j = B),
            (k = C),
            (j = D < j ? D : j),
            (j = F < j ? F : j),
            (j = H < j ? H : j),
            (k = E < k ? E : k),
            (k = G < k ? G : k),
            (k = I < k ? I : k),
            (l = D > l ? D : l),
            (l = F > l ? F : l),
            (l = H > l ? H : l),
            (m = E > m ? E : m),
            (m = G > m ? G : m),
            (m = I > m ? I : m);
        }
        if (((p.x = j), (p.y = k), (p.width = l - j), (p.height = m - k), c)) for (a.worldTransform = f, e = 0; e < a.children.length; e++) a.children[e].updateTransform();
        if (!d) {
          var J = a.getBounds();
          (p.x -= J.x), (p.y -= J.y);
        }
        return p;
      }),
      (b.DisplayObjectContainer.prototype.getLocalBounds = function () {
        return this.getBounds(this);
      }),
      (b.DisplayObjectContainer.prototype.contains = function (a) {
        return !!a && (a === this || this.contains(a.parent));
      }),
      (b.DisplayObjectContainer.prototype._renderWebGL = function (a) {
        if (this.visible && !(this.alpha <= 0)) {
          if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
          var b;
          if (this._mask || this._filters) {
            for (
              this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), b = 0;
              b < this.children.length;
              b++
            )
              this.children[b]._renderWebGL(a);
            a.spriteBatch.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), a.spriteBatch.start();
          } else for (b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
        }
      }),
      (b.DisplayObjectContainer.prototype._renderCanvas = function (a) {
        if (this.visible !== !1 && 0 !== this.alpha) {
          if (this._cacheAsBitmap) return void this._renderCachedSprite(a);
          this._mask && a.maskManager.pushMask(this._mask, a);
          for (var b = 0; b < this.children.length; b++) this.children[b]._renderCanvas(a);
          this._mask && a.maskManager.popMask(a);
        }
      }),
      Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
        get: function () {
          return this.getLocalBounds().width * this.scale.x;
        },
        set: function (a) {
          var b = this.getLocalBounds().width;
          0 !== b ? (this.scale.x = a / b) : (this.scale.x = 1), (this._width = a);
        },
      }),
      Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
        get: function () {
          return this.getLocalBounds().height * this.scale.y;
        },
        set: function (a) {
          var b = this.getLocalBounds().height;
          0 !== b ? (this.scale.y = a / b) : (this.scale.y = 1), (this._height = a);
        },
      }),
      (b.Sprite = function (a) {
        b.DisplayObjectContainer.call(this),
          (this.anchor = new b.Point()),
          (this.texture = a || b.Texture.emptyTexture),
          (this._width = 0),
          (this._height = 0),
          (this.tint = 16777215),
          (this.cachedTint = -1),
          (this.tintedTexture = null),
          (this.blendMode = b.blendModes.NORMAL),
          (this.shader = null),
          (this.exists = !0),
          this.texture.baseTexture.hasLoaded && this.onTextureUpdate(),
          (this.renderable = !0);
      }),
      (b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype)),
      (b.Sprite.prototype.constructor = b.Sprite),
      Object.defineProperty(b.Sprite.prototype, "width", {
        get: function () {
          return this.scale.x * this.texture.frame.width;
        },
        set: function (a) {
          (this.scale.x = a / this.texture.frame.width), (this._width = a);
        },
      }),
      Object.defineProperty(b.Sprite.prototype, "height", {
        get: function () {
          return this.scale.y * this.texture.frame.height;
        },
        set: function (a) {
          (this.scale.y = a / this.texture.frame.height), (this._height = a);
        },
      }),
      (b.Sprite.prototype.setTexture = function (a, b) {
        void 0 !== b && this.texture.baseTexture.destroy(), (this.texture.baseTexture.skipRender = !1), (this.texture = a), (this.texture.valid = !0), (this.cachedTint = -1);
      }),
      (b.Sprite.prototype.onTextureUpdate = function () {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height);
      }),
      (b.Sprite.prototype.getBounds = function (a) {
        var b = this.texture.frame.width,
          c = this.texture.frame.height,
          d = b * (1 - this.anchor.x),
          e = b * -this.anchor.x,
          f = c * (1 - this.anchor.y),
          g = c * -this.anchor.y,
          h = a || this.worldTransform,
          i = h.a,
          j = h.b,
          k = h.c,
          l = h.d,
          m = h.tx,
          n = h.ty,
          o = -(1 / 0),
          p = -(1 / 0),
          q = 1 / 0,
          r = 1 / 0;
        if (0 === j && 0 === k) {
          if (i < 0) {
            i *= -1;
            var s = d;
            (d = -e), (e = -s);
          }
          if (l < 0) {
            l *= -1;
            var s = f;
            (f = -g), (g = -s);
          }
          (q = i * e + m), (o = i * d + m), (r = l * g + n), (p = l * f + n);
        } else {
          var t = i * e + k * g + m,
            u = l * g + j * e + n,
            v = i * d + k * g + m,
            w = l * g + j * d + n,
            x = i * d + k * f + m,
            y = l * f + j * d + n,
            z = i * e + k * f + m,
            A = l * f + j * e + n;
          (q = t < q ? t : q),
            (q = v < q ? v : q),
            (q = x < q ? x : q),
            (q = z < q ? z : q),
            (r = u < r ? u : r),
            (r = w < r ? w : r),
            (r = y < r ? y : r),
            (r = A < r ? A : r),
            (o = t > o ? t : o),
            (o = v > o ? v : o),
            (o = x > o ? x : o),
            (o = z > o ? z : o),
            (p = u > p ? u : p),
            (p = w > p ? w : p),
            (p = y > p ? y : p),
            (p = A > p ? A : p);
        }
        var B = this._bounds;
        return (B.x = q), (B.width = o - q), (B.y = r), (B.height = p - r), (this._currentBounds = B), B;
      }),
      (b.Sprite.prototype.getLocalBounds = function () {
        var a = this.worldTransform;
        this.worldTransform = b.identityMatrix;
        for (var c = 0; c < this.children.length; c++) this.children[c].updateTransform();
        var d = this.getBounds();
        for (this.worldTransform = a, c = 0; c < this.children.length; c++) this.children[c].updateTransform();
        return d;
      }),
      (b.Sprite.prototype._renderWebGL = function (a, b) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
          var c = this.worldTransform;
          if ((b && (c = b), this._mask || this._filters)) {
            var d = a.spriteBatch;
            this._filters && (d.flush(), a.filterManager.pushFilter(this._filterBlock)), this._mask && (d.stop(), a.maskManager.pushMask(this.mask, a), d.start()), d.render(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a);
            d.stop(), this._mask && a.maskManager.popMask(this._mask, a), this._filters && a.filterManager.popFilter(), d.start();
          } else {
            a.spriteBatch.render(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(a, c);
          }
        }
      }),
      (b.Sprite.prototype._renderCanvas = function (a, c) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
          var d = this.worldTransform;
          if (
            (c && (d = c),
            this.blendMode !== a.currentBlendMode && ((a.currentBlendMode = this.blendMode), (a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode])),
            this._mask && a.maskManager.pushMask(this._mask, a),
            this.texture.valid)
          ) {
            var e = this.texture.baseTexture.resolution / a.resolution;
            (a.context.globalAlpha = this.worldAlpha),
              a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && ((a.scaleMode = this.texture.baseTexture.scaleMode), (a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR));
            var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
              g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
              h = d.tx * a.resolution + a.shakeX,
              i = d.ty * a.resolution + a.shakeY;
            a.roundPixels ? (a.context.setTransform(d.a, d.b, d.c, d.d, 0 | h, 0 | i), (f |= 0), (g |= 0)) : a.context.setTransform(d.a, d.b, d.c, d.d, h, i);
            var j = this.texture.crop.width,
              k = this.texture.crop.height;
            if (((f /= e), (g /= e), 16777215 !== this.tint))
              (this.texture.requiresReTint || this.cachedTint !== this.tint) && ((this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint)), (this.cachedTint = this.tint), (this.texture.requiresReTint = !1)),
                a.context.drawImage(this.tintedTexture, 0, 0, j, k, f, g, j / e, k / e);
            else {
              var l = this.texture.crop.x,
                m = this.texture.crop.y;
              a.context.drawImage(this.texture.baseTexture.source, l, m, j, k, f, g, j / e, k / e);
            }
          }
          for (var n = 0; n < this.children.length; n++) this.children[n]._renderCanvas(a);
          this._mask && a.maskManager.popMask(a);
        }
      }),
      (b.SpriteBatch = function (a) {
        b.DisplayObjectContainer.call(this), (this.textureThing = a), (this.ready = !1);
      }),
      (b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype)),
      (b.SpriteBatch.prototype.constructor = b.SpriteBatch),
      (b.SpriteBatch.prototype.initWebGL = function (a) {
        (this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a)), (this.ready = !0);
      }),
      (b.SpriteBatch.prototype.updateTransform = function () {
        this.displayObjectUpdateTransform();
      }),
      (b.SpriteBatch.prototype._renderWebGL = function (a) {
        !this.visible ||
          this.alpha <= 0 ||
          !this.children.length ||
          (this.ready || this.initWebGL(a.gl),
          this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl),
          a.spriteBatch.stop(),
          a.shaderManager.setShader(a.shaderManager.fastShader),
          this.fastSpriteBatch.begin(this, a),
          this.fastSpriteBatch.render(this),
          a.spriteBatch.start());
      }),
      (b.SpriteBatch.prototype._renderCanvas = function (a) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
          var b = a.context;
          (b.globalAlpha = this.worldAlpha), this.displayObjectUpdateTransform();
          for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
            var f = this.children[e];
            if (f.visible) {
              var g = f.texture,
                h = g.frame;
              if (((b.globalAlpha = this.worldAlpha * f.alpha), f.rotation % (2 * Math.PI) === 0))
                d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty), (d = !1)),
                  b.drawImage(
                    g.baseTexture.source,
                    h.x,
                    h.y,
                    h.width,
                    h.height,
                    (f.anchor.x * (-h.width * f.scale.x) + f.position.x + 0.5 + a.shakeX) | 0,
                    (f.anchor.y * (-h.height * f.scale.y) + f.position.y + 0.5 + a.shakeY) | 0,
                    h.width * f.scale.x,
                    h.height * f.scale.y
                  );
              else {
                d || (d = !0), f.displayObjectUpdateTransform();
                var i = f.worldTransform,
                  j = i.tx * a.resolution + a.shakeX,
                  k = i.ty * a.resolution + a.shakeY;
                a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k) : b.setTransform(i.a, i.b, i.c, i.d, j, k),
                  b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, (f.anchor.x * -h.width + 0.5) | 0, (f.anchor.y * -h.height + 0.5) | 0, h.width, h.height);
              }
            }
          }
        }
      }),
      (b.hex2rgb = function (a) {
        return [((a >> 16) & 255) / 255, ((a >> 8) & 255) / 255, (255 & a) / 255];
      }),
      (b.rgb2hex = function (a) {
        return ((255 * a[0]) << 16) + ((255 * a[1]) << 8) + 255 * a[2];
      }),
      (b.canUseNewCanvasBlendModes = function () {
        if (void 0 === document) return !1;
        var a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
          c = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
          d = new Image();
        d.src = a + "AP804Oa6" + c;
        var e = new Image();
        e.src = a + "/wCKxvRF" + c;
        var f = b.CanvasPool.create(this, 6, 1),
          g = f.getContext("2d");
        if (((g.globalCompositeOperation = "multiply"), g.drawImage(d, 0, 0), g.drawImage(e, 2, 0), !g.getImageData(2, 0, 1, 1))) return !1;
        var h = g.getImageData(2, 0, 1, 1).data;
        return b.CanvasPool.remove(this), 255 === h[0] && 0 === h[1] && 0 === h[2];
      }),
      (b.getNextPowerOfTwo = function (a) {
        if (a > 0 && 0 === (a & (a - 1))) return a;
        for (var b = 1; b < a; ) b <<= 1;
        return b;
      }),
      (b.isPowerOfTwo = function (a, b) {
        return a > 0 && 0 === (a & (a - 1)) && b > 0 && 0 === (b & (b - 1));
      }),
      (b.CanvasPool = {
        create: function (a, c, d) {
          var e,
            f = b.CanvasPool.getFirst();
          if (f === -1) {
            var g = { parent: a, canvas: document.createElement("canvas") };
            b.CanvasPool.pool.push(g), (e = g.canvas);
          } else (b.CanvasPool.pool[f].parent = a), (e = b.CanvasPool.pool[f].canvas);
          return void 0 !== c && ((e.width = c), (e.height = d)), e;
        },
        getFirst: function () {
          for (var a = b.CanvasPool.pool, c = 0; c < a.length; c++) if (!a[c].parent) return c;
          return -1;
        },
        remove: function (a) {
          for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].parent === a && ((c[d].parent = null), (c[d].canvas.width = 1), (c[d].canvas.height = 1));
        },
        removeByCanvas: function (a) {
          for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++) c[d].canvas === a && ((c[d].parent = null), (c[d].canvas.width = 1), (c[d].canvas.height = 1));
        },
        getTotal: function () {
          for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent && c++;
          return c;
        },
        getFree: function () {
          for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++) a[d].parent || c++;
          return c;
        },
      }),
      (b.CanvasPool.pool = []),
      (b.initDefaultShaders = function () {}),
      (b.CompileVertexShader = function (a, c) {
        return b._CompileShader(a, c, a.VERTEX_SHADER);
      }),
      (b.CompileFragmentShader = function (a, c) {
        return b._CompileShader(a, c, a.FRAGMENT_SHADER);
      }),
      (b._CompileShader = function (a, b, c) {
        var d = b;
        Array.isArray(b) && (d = b.join("\n"));
        var e = a.createShader(c);
        return a.shaderSource(e, d), a.compileShader(e), a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), null);
      }),
      (b.compileProgram = function (a, c, d) {
        var e = b.CompileFragmentShader(a, d),
          f = b.CompileVertexShader(a, c),
          g = a.createProgram();
        return a.attachShader(g, f), a.attachShader(g, e), a.linkProgram(g), a.getProgramParameter(g, a.LINK_STATUS) || (window.console.log(a.getProgramInfoLog(g)), window.console.log("Could not initialise shaders")), g;
      }),
      (b.PixiShader = function (a) {
        (this._UID = b._UID++),
          (this.gl = a),
          (this.program = null),
          (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]),
          (this.textureCount = 0),
          (this.firstRun = !0),
          (this.dirty = !0),
          (this.attributes = []),
          this.init();
      }),
      (b.PixiShader.prototype.constructor = b.PixiShader),
      (b.PixiShader.prototype.init = function () {
        var a = this.gl,
          c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(c),
          (this.uSampler = a.getUniformLocation(c, "uSampler")),
          (this.projectionVector = a.getUniformLocation(c, "projectionVector")),
          (this.offsetVector = a.getUniformLocation(c, "offsetVector")),
          (this.dimensions = a.getUniformLocation(c, "dimensions")),
          (this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition")),
          (this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord")),
          (this.colorAttribute = a.getAttribLocation(c, "aColor")),
          this.colorAttribute === -1 && (this.colorAttribute = 2),
          (this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute]);
        for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
        this.initUniforms(), (this.program = c);
      }),
      (b.PixiShader.prototype.initUniforms = function () {
        this.textureCount = 1;
        var a,
          b = this.gl;
        for (var c in this.uniforms) {
          a = this.uniforms[c];
          var d = a.type;
          "sampler2D" === d
            ? ((a._init = !1), null !== a.value && this.initSampler2D(a))
            : "mat2" === d || "mat3" === d || "mat4" === d
            ? ((a.glMatrix = !0), (a.glValueLength = 1), "mat2" === d ? (a.glFunc = b.uniformMatrix2fv) : "mat3" === d ? (a.glFunc = b.uniformMatrix3fv) : "mat4" === d && (a.glFunc = b.uniformMatrix4fv))
            : ((a.glFunc = b["uniform" + d]), "2f" === d || "2i" === d ? (a.glValueLength = 2) : "3f" === d || "3i" === d ? (a.glValueLength = 3) : "4f" === d || "4i" === d ? (a.glValueLength = 4) : (a.glValueLength = 1));
        }
      }),
      (b.PixiShader.prototype.initSampler2D = function (a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
          var b = this.gl;
          if ((b.activeTexture(b["TEXTURE" + this.textureCount]), b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]), a.textureData)) {
            var c = a.textureData,
              d = c.magFilter ? c.magFilter : b.LINEAR,
              e = c.minFilter ? c.minFilter : b.LINEAR,
              f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE,
              g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE,
              h = c.luminance ? b.LUMINANCE : b.RGBA;
            if ((c.repeat && ((f = b.REPEAT), (g = b.REPEAT)), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY), c.width)) {
              var i = c.width ? c.width : 512,
                j = c.height ? c.height : 2,
                k = c.border ? c.border : 0;
              b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null);
            } else b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
            b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g);
          }
          b.uniform1i(a.uniformLocation, this.textureCount), (a._init = !0), this.textureCount++;
        }
      }),
      (b.PixiShader.prototype.syncUniforms = function () {
        this.textureCount = 1;
        var a,
          c = this.gl;
        for (var d in this.uniforms)
          (a = this.uniforms[d]),
            1 === a.glValueLength
              ? a.glMatrix === !0
                ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value)
                : a.glFunc.call(c, a.uniformLocation, a.value)
              : 2 === a.glValueLength
              ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y)
              : 3 === a.glValueLength
              ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z)
              : 4 === a.glValueLength
              ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w)
              : "sampler2D" === a.type &&
                (a._init
                  ? (c.activeTexture(c["TEXTURE" + this.textureCount]),
                    a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]),
                    c.uniform1i(a.uniformLocation, this.textureCount),
                    this.textureCount++)
                  : this.initSampler2D(a));
      }),
      (b.PixiShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), (this.uniforms = null), (this.gl = null), (this.attributes = null);
      }),
      (b.PixiShader.defaultVertexSrc = [
        "attribute vec2 aVertexPosition;",
        "attribute vec2 aTextureCoord;",
        "attribute vec4 aColor;",
        "uniform vec2 projectionVector;",
        "uniform vec2 offsetVector;",
        "varying vec2 vTextureCoord;",
        "varying vec4 vColor;",
        "const vec2 center = vec2(-1.0, 1.0);",
        "void main(void) {",
        "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);",
        "   vTextureCoord = aTextureCoord;",
        "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);",
        "}",
      ]),
      (b.PixiFastShader = function (a) {
        (this._UID = b._UID++),
          (this.gl = a),
          (this.program = null),
          (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]),
          (this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "attribute vec2 aPositionCoord;",
            "attribute vec2 aScale;",
            "attribute float aRotation;",
            "attribute vec2 aTextureCoord;",
            "attribute float aColor;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform mat3 uMatrix;",
            "varying vec2 vTextureCoord;",
            "varying float vColor;",
            "const vec2 center = vec2(-1.0, 1.0);",
            "void main(void) {",
            "   vec2 v;",
            "   vec2 sv = aVertexPosition * aScale;",
            "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);",
            "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);",
            "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;",
            "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);",
            "   vTextureCoord = aTextureCoord;",
            "   vColor = aColor;",
            "}",
          ]),
          (this.textureCount = 0),
          this.init();
      }),
      (b.PixiFastShader.prototype.constructor = b.PixiFastShader),
      (b.PixiFastShader.prototype.init = function () {
        var a = this.gl,
          c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
          (this.uSampler = a.getUniformLocation(c, "uSampler")),
          (this.projectionVector = a.getUniformLocation(c, "projectionVector")),
          (this.offsetVector = a.getUniformLocation(c, "offsetVector")),
          (this.dimensions = a.getUniformLocation(c, "dimensions")),
          (this.uMatrix = a.getUniformLocation(c, "uMatrix")),
          (this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition")),
          (this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord")),
          (this.aScale = a.getAttribLocation(c, "aScale")),
          (this.aRotation = a.getAttribLocation(c, "aRotation")),
          (this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord")),
          (this.colorAttribute = a.getAttribLocation(c, "aColor")),
          this.colorAttribute === -1 && (this.colorAttribute = 2),
          (this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute]),
          (this.program = c);
      }),
      (b.PixiFastShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), (this.uniforms = null), (this.gl = null), (this.attributes = null);
      }),
      (b.StripShader = function (a) {
        (this._UID = b._UID++),
          (this.gl = a),
          (this.program = null),
          (this.fragmentSrc = [
            "precision mediump float;",
            "varying vec2 vTextureCoord;",
            "uniform float alpha;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;",
            "}",
          ]),
          (this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "attribute vec2 aTextureCoord;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "varying vec2 vTextureCoord;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);",
            "   vTextureCoord = aTextureCoord;",
            "}",
          ]),
          this.init();
      }),
      (b.StripShader.prototype.constructor = b.StripShader),
      (b.StripShader.prototype.init = function () {
        var a = this.gl,
          c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
          (this.uSampler = a.getUniformLocation(c, "uSampler")),
          (this.projectionVector = a.getUniformLocation(c, "projectionVector")),
          (this.offsetVector = a.getUniformLocation(c, "offsetVector")),
          (this.colorAttribute = a.getAttribLocation(c, "aColor")),
          (this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition")),
          (this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord")),
          (this.attributes = [this.aVertexPosition, this.aTextureCoord]),
          (this.translationMatrix = a.getUniformLocation(c, "translationMatrix")),
          (this.alpha = a.getUniformLocation(c, "alpha")),
          (this.program = c);
      }),
      (b.StripShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), (this.uniforms = null), (this.gl = null), (this.attribute = null);
      }),
      (b.PrimitiveShader = function (a) {
        (this._UID = b._UID++),
          (this.gl = a),
          (this.program = null),
          (this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"]),
          (this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "attribute vec4 aColor;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform float alpha;",
            "uniform float flipY;",
            "uniform vec3 tint;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);",
            "   vColor = aColor * vec4(tint * alpha, alpha);",
            "}",
          ]),
          this.init();
      }),
      (b.PrimitiveShader.prototype.constructor = b.PrimitiveShader),
      (b.PrimitiveShader.prototype.init = function () {
        var a = this.gl,
          c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
          (this.projectionVector = a.getUniformLocation(c, "projectionVector")),
          (this.offsetVector = a.getUniformLocation(c, "offsetVector")),
          (this.tintColor = a.getUniformLocation(c, "tint")),
          (this.flipY = a.getUniformLocation(c, "flipY")),
          (this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition")),
          (this.colorAttribute = a.getAttribLocation(c, "aColor")),
          (this.attributes = [this.aVertexPosition, this.colorAttribute]),
          (this.translationMatrix = a.getUniformLocation(c, "translationMatrix")),
          (this.alpha = a.getUniformLocation(c, "alpha")),
          (this.program = c);
      }),
      (b.PrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), (this.uniforms = null), (this.gl = null), (this.attributes = null);
      }),
      (b.ComplexPrimitiveShader = function (a) {
        (this._UID = b._UID++),
          (this.gl = a),
          (this.program = null),
          (this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"]),
          (this.vertexSrc = [
            "attribute vec2 aVertexPosition;",
            "uniform mat3 translationMatrix;",
            "uniform vec2 projectionVector;",
            "uniform vec2 offsetVector;",
            "uniform vec3 tint;",
            "uniform float alpha;",
            "uniform vec3 color;",
            "uniform float flipY;",
            "varying vec4 vColor;",
            "void main(void) {",
            "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);",
            "   v -= offsetVector.xyx;",
            "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);",
            "   vColor = vec4(color * alpha * tint, alpha);",
            "}",
          ]),
          this.init();
      }),
      (b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader),
      (b.ComplexPrimitiveShader.prototype.init = function () {
        var a = this.gl,
          c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
          (this.projectionVector = a.getUniformLocation(c, "projectionVector")),
          (this.offsetVector = a.getUniformLocation(c, "offsetVector")),
          (this.tintColor = a.getUniformLocation(c, "tint")),
          (this.color = a.getUniformLocation(c, "color")),
          (this.flipY = a.getUniformLocation(c, "flipY")),
          (this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition")),
          (this.attributes = [this.aVertexPosition, this.colorAttribute]),
          (this.translationMatrix = a.getUniformLocation(c, "translationMatrix")),
          (this.alpha = a.getUniformLocation(c, "alpha")),
          (this.program = c);
      }),
      (b.ComplexPrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program), (this.uniforms = null), (this.gl = null), (this.attribute = null);
      }),
      (b.glContexts = []),
      (b.instances = []),
      (b.WebGLRenderer = function (a) {
        (this.game = a),
          b.defaultRenderer || (b.defaultRenderer = this),
          (this.type = b.WEBGL_RENDERER),
          (this.resolution = a.resolution),
          (this.transparent = a.transparent),
          (this.autoResize = !1),
          (this.preserveDrawingBuffer = a.preserveDrawingBuffer),
          (this.clearBeforeRender = a.clearBeforeRender),
          (this.width = a.width),
          (this.height = a.height),
          (this.view = a.canvas),
          (this._contextOptions = { alpha: this.transparent, antialias: a.antialias, premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent, stencil: !0, preserveDrawingBuffer: this.preserveDrawingBuffer }),
          (this.projection = new b.Point()),
          (this.offset = new b.Point()),
          (this.shaderManager = new b.WebGLShaderManager()),
          (this.spriteBatch = new b.WebGLSpriteBatch()),
          (this.maskManager = new b.WebGLMaskManager()),
          (this.filterManager = new b.WebGLFilterManager()),
          (this.stencilManager = new b.WebGLStencilManager()),
          (this.blendModeManager = new b.WebGLBlendModeManager()),
          (this.renderSession = {}),
          (this.renderSession.game = this.game),
          (this.renderSession.gl = this.gl),
          (this.renderSession.drawCount = 0),
          (this.renderSession.shaderManager = this.shaderManager),
          (this.renderSession.maskManager = this.maskManager),
          (this.renderSession.filterManager = this.filterManager),
          (this.renderSession.blendModeManager = this.blendModeManager),
          (this.renderSession.spriteBatch = this.spriteBatch),
          (this.renderSession.stencilManager = this.stencilManager),
          (this.renderSession.renderer = this),
          (this.renderSession.resolution = this.resolution),
          this.initContext(),
          this.mapBlendModes();
      }),
      (b.WebGLRenderer.prototype.constructor = b.WebGLRenderer),
      (b.WebGLRenderer.prototype.initContext = function () {
        var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (((this.gl = a), !a)) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        (this.glContextId = a.id = b.WebGLRenderer.glContextId++),
          (b.glContexts[this.glContextId] = a),
          (b.instances[this.glContextId] = this),
          a.disable(a.DEPTH_TEST),
          a.disable(a.CULL_FACE),
          a.enable(a.BLEND),
          this.shaderManager.setContext(a),
          this.spriteBatch.setContext(a),
          this.maskManager.setContext(a),
          this.filterManager.setContext(a),
          this.blendModeManager.setContext(a),
          this.stencilManager.setContext(a),
          (this.renderSession.gl = this.gl),
          this.resize(this.width, this.height);
      }),
      (b.WebGLRenderer.prototype.render = function (a) {
        if (!this.contextLost) {
          var b = this.gl;
          b.viewport(0, 0, this.width, this.height),
            b.bindFramebuffer(b.FRAMEBUFFER, null),
            this.game.clearBeforeRender && (b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a), b.clear(b.COLOR_BUFFER_BIT)),
            (this.offset.x = this.game.camera._shake.x),
            (this.offset.y = this.game.camera._shake.y),
            this.renderDisplayObject(a, this.projection);
        }
      }),
      (b.WebGLRenderer.prototype.renderDisplayObject = function (a, c, d, e) {
        this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL),
          (this.renderSession.drawCount = 0),
          (this.renderSession.flipY = d ? -1 : 1),
          (this.renderSession.projection = c),
          (this.renderSession.offset = this.offset),
          this.spriteBatch.begin(this.renderSession),
          this.filterManager.begin(this.renderSession, d),
          a._renderWebGL(this.renderSession, e),
          this.spriteBatch.end();
      }),
      (b.WebGLRenderer.prototype.resize = function (a, b) {
        (this.width = a * this.resolution),
          (this.height = b * this.resolution),
          (this.view.width = this.width),
          (this.view.height = this.height),
          this.autoResize && ((this.view.style.width = this.width / this.resolution + "px"), (this.view.style.height = this.height / this.resolution + "px")),
          this.gl.viewport(0, 0, this.width, this.height),
          (this.projection.x = this.width / 2 / this.resolution),
          (this.projection.y = -this.height / 2 / this.resolution);
      }),
      (b.WebGLRenderer.prototype.updateTexture = function (a) {
        if (!a.hasLoaded) return !1;
        var c = this.gl;
        return (
          a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()),
          c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]),
          c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha),
          c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source),
          c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST),
          a.mipmap && b.isPowerOfTwo(a.width, a.height)
            ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST), c.generateMipmap(c.TEXTURE_2D))
            : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST),
          a._powerOf2
            ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT))
            : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)),
          (a._dirty[c.id] = !1),
          !0
        );
      }),
      (b.WebGLRenderer.prototype.destroy = function () {
        (b.glContexts[this.glContextId] = null),
          (this.projection = null),
          (this.offset = null),
          this.shaderManager.destroy(),
          this.spriteBatch.destroy(),
          this.maskManager.destroy(),
          this.filterManager.destroy(),
          (this.shaderManager = null),
          (this.spriteBatch = null),
          (this.maskManager = null),
          (this.filterManager = null),
          (this.gl = null),
          (this.renderSession = null),
          b.CanvasPool.remove(this),
          (b.instances[this.glContextId] = null),
          b.WebGLRenderer.glContextId--;
      }),
      (b.WebGLRenderer.prototype.mapBlendModes = function () {
        var a = this.gl;
        if (!b.blendModesWebGL) {
          var c = [],
            d = b.blendModes;
          (c[d.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.ADD] = [a.SRC_ALPHA, a.DST_ALPHA]),
            (c[d.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.SCREEN] = [a.SRC_ALPHA, a.ONE]),
            (c[d.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (c[d.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA]),
            (b.blendModesWebGL = c);
        }
      }),
      (b.WebGLRenderer.glContextId = 0),
      (b.WebGLBlendModeManager = function () {
        this.currentBlendMode = 99999;
      }),
      (b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager),
      (b.WebGLBlendModeManager.prototype.setContext = function (a) {
        this.gl = a;
      }),
      (b.WebGLBlendModeManager.prototype.setBlendMode = function (a) {
        if (this.currentBlendMode === a) return !1;
        this.currentBlendMode = a;
        var c = b.blendModesWebGL[this.currentBlendMode];
        return c && this.gl.blendFunc(c[0], c[1]), !0;
      }),
      (b.WebGLBlendModeManager.prototype.destroy = function () {
        this.gl = null;
      }),
      (b.WebGLMaskManager = function () {}),
      (b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager),
      (b.WebGLMaskManager.prototype.setContext = function (a) {
        this.gl = a;
      }),
      (b.WebGLMaskManager.prototype.pushMask = function (a, c) {
        var d = c.gl;
        a.dirty && b.WebGLGraphics.updateGraphics(a, d), void 0 !== a._webGL[d.id] && void 0 !== a._webGL[d.id].data && 0 !== a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c);
      }),
      (b.WebGLMaskManager.prototype.popMask = function (a, b) {
        var c = this.gl;
        void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b);
      }),
      (b.WebGLMaskManager.prototype.destroy = function () {
        this.gl = null;
      }),
      (b.WebGLStencilManager = function () {
        (this.stencilStack = []), (this.reverse = !0), (this.count = 0);
      }),
      (b.WebGLStencilManager.prototype.setContext = function (a) {
        this.gl = a;
      }),
      (b.WebGLStencilManager.prototype.pushStencil = function (a, b, c) {
        var d = this.gl;
        this.bindGraphics(a, b, c), 0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST), d.clear(d.STENCIL_BUFFER_BIT), (this.reverse = !0), (this.count = 0)), this.stencilStack.push(b);
        var e = this.count;
        d.colorMask(!1, !1, !1, !1),
          d.stencilFunc(d.ALWAYS, 0, 255),
          d.stencilOp(d.KEEP, d.KEEP, d.INVERT),
          1 === b.mode
            ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0),
              this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)),
              d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)),
              this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255),
              (this.reverse = !this.reverse))
            : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)),
              d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0),
              this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)),
          d.colorMask(!0, !0, !0, !0),
          d.stencilOp(d.KEEP, d.KEEP, d.KEEP),
          this.count++;
      }),
      (b.WebGLStencilManager.prototype.bindGraphics = function (a, c, d) {
        this._currentGraphics = a;
        var e,
          f = this.gl,
          g = d.projection,
          h = d.offset;
        1 === c.mode
          ? ((e = d.shaderManager.complexPrimitiveShader),
            d.shaderManager.setShader(e),
            f.uniform1f(e.flipY, d.flipY),
            f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)),
            f.uniform2f(e.projectionVector, g.x, -g.y),
            f.uniform2f(e.offsetVector, -h.x, -h.y),
            f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)),
            f.uniform3fv(e.color, c.color),
            f.uniform1f(e.alpha, a.worldAlpha * c.alpha),
            f.bindBuffer(f.ARRAY_BUFFER, c.buffer),
            f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 8, 0),
            f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer))
          : ((e = d.shaderManager.primitiveShader),
            d.shaderManager.setShader(e),
            f.uniformMatrix3fv(e.translationMatrix, !1, a.worldTransform.toArray(!0)),
            f.uniform1f(e.flipY, d.flipY),
            f.uniform2f(e.projectionVector, g.x, -g.y),
            f.uniform2f(e.offsetVector, -h.x, -h.y),
            f.uniform3fv(e.tintColor, b.hex2rgb(a.tint)),
            f.uniform1f(e.alpha, a.worldAlpha),
            f.bindBuffer(f.ARRAY_BUFFER, c.buffer),
            f.vertexAttribPointer(e.aVertexPosition, 2, f.FLOAT, !1, 24, 0),
            f.vertexAttribPointer(e.colorAttribute, 4, f.FLOAT, !1, 24, 8),
            f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.indexBuffer));
      }),
      (b.WebGLStencilManager.prototype.popStencil = function (a, b, c) {
        var d = this.gl;
        if ((this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length)) d.disable(d.STENCIL_TEST);
        else {
          var e = this.count;
          this.bindGraphics(a, b, c),
            d.colorMask(!1, !1, !1, !1),
            1 === b.mode
              ? ((this.reverse = !this.reverse),
                this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)),
                d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)),
                d.stencilFunc(d.ALWAYS, 0, 255),
                d.stencilOp(d.KEEP, d.KEEP, d.INVERT),
                d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0),
                this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255))
              : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255), d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255), d.stencilOp(d.KEEP, d.KEEP, d.INCR)),
                d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0),
                this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)),
            d.colorMask(!0, !0, !0, !0),
            d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
        }
      }),
      (b.WebGLStencilManager.prototype.destroy = function () {
        (this.stencilStack = null), (this.gl = null);
      }),
      (b.WebGLShaderManager = function () {
        (this.maxAttibs = 10), (this.attribState = []), (this.tempAttribState = []);
        for (var a = 0; a < this.maxAttibs; a++) this.attribState[a] = !1;
        this.stack = [];
      }),
      (b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager),
      (b.WebGLShaderManager.prototype.setContext = function (a) {
        (this.gl = a),
          (this.primitiveShader = new b.PrimitiveShader(a)),
          (this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a)),
          (this.defaultShader = new b.PixiShader(a)),
          (this.fastShader = new b.PixiFastShader(a)),
          (this.stripShader = new b.StripShader(a)),
          this.setShader(this.defaultShader);
      }),
      (b.WebGLShaderManager.prototype.setAttribs = function (a) {
        var b;
        for (b = 0; b < this.tempAttribState.length; b++) this.tempAttribState[b] = !1;
        for (b = 0; b < a.length; b++) {
          var c = a[b];
          this.tempAttribState[c] = !0;
        }
        var d = this.gl;
        for (b = 0; b < this.attribState.length; b++)
          this.attribState[b] !== this.tempAttribState[b] && ((this.attribState[b] = this.tempAttribState[b]), this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b));
      }),
      (b.WebGLShaderManager.prototype.setShader = function (a) {
        return this._currentId !== a._UID && ((this._currentId = a._UID), (this.currentShader = a), this.gl.useProgram(a.program), this.setAttribs(a.attributes), !0);
      }),
      (b.WebGLShaderManager.prototype.destroy = function () {
        (this.attribState = null), (this.tempAttribState = null), this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), (this.gl = null);
      }),
      (b.WebGLSpriteBatch = function () {
        (this.vertSize = 5), (this.size = 2e3);
        var a = 4 * this.size * 4 * this.vertSize,
          c = 6 * this.size;
        (this.vertices = new b.ArrayBuffer(a)), (this.positions = new b.Float32Array(this.vertices)), (this.colors = new b.Uint32Array(this.vertices)), (this.indices = new b.Uint16Array(c)), (this.lastIndexCount = 0);
        for (var d = 0, e = 0; d < c; d += 6, e += 4) (this.indices[d + 0] = e + 0), (this.indices[d + 1] = e + 1), (this.indices[d + 2] = e + 2), (this.indices[d + 3] = e + 0), (this.indices[d + 4] = e + 2), (this.indices[d + 5] = e + 3);
        (this.drawing = !1),
          (this.currentBatchSize = 0),
          (this.currentBaseTexture = null),
          (this.dirty = !0),
          (this.textures = []),
          (this.blendModes = []),
          (this.shaders = []),
          (this.sprites = []),
          (this.defaultShader = new b.AbstractFilter([
            "precision lowp float;",
            "varying vec2 vTextureCoord;",
            "varying vec4 vColor;",
            "uniform sampler2D uSampler;",
            "void main(void) {",
            "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;",
            "}",
          ]));
      }),
      (b.WebGLSpriteBatch.prototype.setContext = function (a) {
        (this.gl = a),
          (this.vertexBuffer = a.createBuffer()),
          (this.indexBuffer = a.createBuffer()),
          a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
          a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW),
          a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
          a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW),
          (this.currentBlendMode = 99999);
        var c = new b.PixiShader(a);
        (c.fragmentSrc = this.defaultShader.fragmentSrc), (c.uniforms = {}), c.init(), (this.defaultShader.shaders[a.id] = c);
      }),
      (b.WebGLSpriteBatch.prototype.begin = function (a) {
        (this.renderSession = a), (this.shader = this.renderSession.shaderManager.defaultShader), this.start();
      }),
      (b.WebGLSpriteBatch.prototype.end = function () {
        this.flush();
      }),
      (b.WebGLSpriteBatch.prototype.render = function (a, b) {
        var c = a.texture,
          d = a.worldTransform;
        b && (d = b), this.currentBatchSize >= this.size && (this.flush(), (this.currentBaseTexture = c.baseTexture));
        var e = c._uvs;
        if (e) {
          var f,
            g,
            h,
            i,
            j = a.anchor.x,
            k = a.anchor.y;
          if (c.trim) {
            var l = c.trim;
            (g = l.x - j * l.width), (f = g + c.crop.width), (i = l.y - k * l.height), (h = i + c.crop.height);
          } else (f = c.frame.width * (1 - j)), (g = c.frame.width * -j), (h = c.frame.height * (1 - k)), (i = c.frame.height * -k);
          var m = 4 * this.currentBatchSize * this.vertSize,
            n = c.baseTexture.resolution,
            o = d.a / n,
            p = d.b / n,
            q = d.c / n,
            r = d.d / n,
            s = d.tx,
            t = d.ty,
            u = this.colors,
            v = this.positions;
          this.renderSession.roundPixels
            ? ((v[m] = (o * g + q * i + s) | 0),
              (v[m + 1] = (r * i + p * g + t) | 0),
              (v[m + 5] = (o * f + q * i + s) | 0),
              (v[m + 6] = (r * i + p * f + t) | 0),
              (v[m + 10] = (o * f + q * h + s) | 0),
              (v[m + 11] = (r * h + p * f + t) | 0),
              (v[m + 15] = (o * g + q * h + s) | 0),
              (v[m + 16] = (r * h + p * g + t) | 0))
            : ((v[m] = o * g + q * i + s),
              (v[m + 1] = r * i + p * g + t),
              (v[m + 5] = o * f + q * i + s),
              (v[m + 6] = r * i + p * f + t),
              (v[m + 10] = o * f + q * h + s),
              (v[m + 11] = r * h + p * f + t),
              (v[m + 15] = o * g + q * h + s),
              (v[m + 16] = r * h + p * g + t)),
            (v[m + 2] = e.x0),
            (v[m + 3] = e.y0),
            (v[m + 7] = e.x1),
            (v[m + 8] = e.y1),
            (v[m + 12] = e.x2),
            (v[m + 13] = e.y2),
            (v[m + 17] = e.x3),
            (v[m + 18] = e.y3);
          var w = a.tint;
          (u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + ((255 * a.worldAlpha) << 24)), (this.sprites[this.currentBatchSize++] = a);
        }
      }),
      (b.WebGLSpriteBatch.prototype.renderTilingSprite = function (a) {
        var c = a.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), (this.currentBaseTexture = c.baseTexture)), a._uvs || (a._uvs = new b.TextureUvs());
        var d = a._uvs,
          e = c.baseTexture.width,
          f = c.baseTexture.height;
        (a.tilePosition.x %= e * a.tileScaleOffset.x), (a.tilePosition.y %= f * a.tileScaleOffset.y);
        var g = a.tilePosition.x / (e * a.tileScaleOffset.x),
          h = a.tilePosition.y / (f * a.tileScaleOffset.y),
          i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x),
          j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
        (d.x0 = 0 - g), (d.y0 = 0 - h), (d.x1 = 1 * i - g), (d.y1 = 0 - h), (d.x2 = 1 * i - g), (d.y2 = 1 * j - h), (d.x3 = 0 - g), (d.y3 = 1 * j - h);
        var k = a.tint,
          l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + ((255 * a.worldAlpha) << 24),
          m = this.positions,
          n = this.colors,
          o = a.width,
          p = a.height,
          q = a.anchor.x,
          r = a.anchor.y,
          s = o * (1 - q),
          t = o * -q,
          u = p * (1 - r),
          v = p * -r,
          w = 4 * this.currentBatchSize * this.vertSize,
          x = c.baseTexture.resolution,
          y = a.worldTransform,
          z = y.a / x,
          A = y.b / x,
          B = y.c / x,
          C = y.d / x,
          D = y.tx,
          E = y.ty;
        (m[w++] = z * t + B * v + D),
          (m[w++] = C * v + A * t + E),
          (m[w++] = d.x0),
          (m[w++] = d.y0),
          (n[w++] = l),
          (m[w++] = z * s + B * v + D),
          (m[w++] = C * v + A * s + E),
          (m[w++] = d.x1),
          (m[w++] = d.y1),
          (n[w++] = l),
          (m[w++] = z * s + B * u + D),
          (m[w++] = C * u + A * s + E),
          (m[w++] = d.x2),
          (m[w++] = d.y2),
          (n[w++] = l),
          (m[w++] = z * t + B * u + D),
          (m[w++] = C * u + A * t + E),
          (m[w++] = d.x3),
          (m[w++] = d.y3),
          (n[w++] = l),
          (this.sprites[this.currentBatchSize++] = a);
      }),
      (b.WebGLSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
          var a,
            c = this.gl;
          if (this.dirty) {
            (this.dirty = !1), c.activeTexture(c.TEXTURE0), c.bindBuffer(c.ARRAY_BUFFER, this.vertexBuffer), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this.indexBuffer), (a = this.defaultShader.shaders[c.id]);
            var d = 4 * this.vertSize;
            c.vertexAttribPointer(a.aVertexPosition, 2, c.FLOAT, !1, d, 0), c.vertexAttribPointer(a.aTextureCoord, 2, c.FLOAT, !1, d, 8), c.vertexAttribPointer(a.colorAttribute, 4, c.UNSIGNED_BYTE, !0, d, 16);
          }
          if (this.currentBatchSize > 0.5 * this.size) c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices);
          else {
            var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
            c.bufferSubData(c.ARRAY_BUFFER, 0, e);
          }
          for (var f, g, h, i, j = 0, k = 0, l = null, m = this.renderSession.blendModeManager.currentBlendMode, n = null, o = !1, p = !1, q = 0, r = this.currentBatchSize; q < r; q++) {
            (i = this.sprites[q]), (f = i.tilingTexture ? i.tilingTexture.baseTexture : i.texture.baseTexture), (g = i.blendMode), (h = i.shader || this.defaultShader), (o = m !== g), (p = n !== h);
            var s = f.skipRender;
            if ((s && i.children.length > 0 && (s = !1), ((l !== f && !s) || o || p) && (this.renderBatch(l, j, k), (k = q), (j = 0), (l = f), o && ((m = g), this.renderSession.blendModeManager.setBlendMode(m)), p))) {
              (n = h),
                (a = n.shaders[c.id]),
                a || ((a = new b.PixiShader(c)), (a.fragmentSrc = n.fragmentSrc), (a.uniforms = n.uniforms), a.init(), (n.shaders[c.id] = a)),
                this.renderSession.shaderManager.setShader(a),
                a.dirty && a.syncUniforms();
              var t = this.renderSession.projection;
              c.uniform2f(a.projectionVector, t.x, t.y);
              var u = this.renderSession.offset;
              c.uniform2f(a.offsetVector, u.x, u.y);
            }
            j++;
          }
          this.renderBatch(l, j, k), (this.currentBatchSize = 0);
        }
      }),
      (b.WebGLSpriteBatch.prototype.renderBatch = function (a, b, c) {
        if (0 !== b) {
          var d = this.gl;
          if (a._dirty[d.id]) {
            if (!this.renderSession.renderer.updateTexture(a)) return;
          } else d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
          d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2), this.renderSession.drawCount++;
        }
      }),
      (b.WebGLSpriteBatch.prototype.stop = function () {
        this.flush(), (this.dirty = !0);
      }),
      (b.WebGLSpriteBatch.prototype.start = function () {
        this.dirty = !0;
      }),
      (b.WebGLSpriteBatch.prototype.destroy = function () {
        (this.vertices = null), (this.indices = null), this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), (this.currentBaseTexture = null), (this.gl = null);
      }),
      (b.WebGLFastSpriteBatch = function (a) {
        (this.vertSize = 10), (this.maxSize = 6e3), (this.size = this.maxSize);
        var c = 4 * this.size * this.vertSize,
          d = 6 * this.maxSize;
        (this.vertices = new b.Float32Array(c)), (this.indices = new b.Uint16Array(d)), (this.vertexBuffer = null), (this.indexBuffer = null), (this.lastIndexCount = 0);
        for (var e = 0, f = 0; e < d; e += 6, f += 4) (this.indices[e + 0] = f + 0), (this.indices[e + 1] = f + 1), (this.indices[e + 2] = f + 2), (this.indices[e + 3] = f + 0), (this.indices[e + 4] = f + 2), (this.indices[e + 5] = f + 3);
        (this.drawing = !1), (this.currentBatchSize = 0), (this.currentBaseTexture = null), (this.currentBlendMode = 0), (this.renderSession = null), (this.shader = null), (this.matrix = null), this.setContext(a);
      }),
      (b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch),
      (b.WebGLFastSpriteBatch.prototype.setContext = function (a) {
        (this.gl = a),
          (this.vertexBuffer = a.createBuffer()),
          (this.indexBuffer = a.createBuffer()),
          a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
          a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW),
          a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
          a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
      }),
      (b.WebGLFastSpriteBatch.prototype.begin = function (a, b) {
        (this.renderSession = b), (this.shader = this.renderSession.shaderManager.fastShader), (this.matrix = a.worldTransform.toArray(!0)), this.start();
      }),
      (b.WebGLFastSpriteBatch.prototype.end = function () {
        this.flush();
      }),
      (b.WebGLFastSpriteBatch.prototype.render = function (a) {
        var b = a.children,
          c = b[0];
        if (c.texture._uvs) {
          (this.currentBaseTexture = c.texture.baseTexture), c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(c.blendMode));
          for (var d = 0, e = b.length; d < e; d++) this.renderSprite(b[d]);
          this.flush();
        }
      }),
      (b.WebGLFastSpriteBatch.prototype.renderSprite = function (a) {
        if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || a.texture.baseTexture.skipRender || (this.flush(), (this.currentBaseTexture = a.texture.baseTexture), a.texture._uvs))) {
          var b,
            c,
            d,
            e,
            f,
            g,
            h,
            i,
            j = this.vertices;
          if (((b = a.texture._uvs), (c = a.texture.frame.width), (d = a.texture.frame.height), a.texture.trim)) {
            var k = a.texture.trim;
            (f = k.x - a.anchor.x * k.width), (e = f + a.texture.crop.width), (h = k.y - a.anchor.y * k.height), (g = h + a.texture.crop.height);
          } else (e = a.texture.frame.width * (1 - a.anchor.x)), (f = a.texture.frame.width * -a.anchor.x), (g = a.texture.frame.height * (1 - a.anchor.y)), (h = a.texture.frame.height * -a.anchor.y);
          (i = 4 * this.currentBatchSize * this.vertSize),
            (j[i++] = f),
            (j[i++] = h),
            (j[i++] = a.position.x),
            (j[i++] = a.position.y),
            (j[i++] = a.scale.x),
            (j[i++] = a.scale.y),
            (j[i++] = a.rotation),
            (j[i++] = b.x0),
            (j[i++] = b.y1),
            (j[i++] = a.alpha),
            (j[i++] = e),
            (j[i++] = h),
            (j[i++] = a.position.x),
            (j[i++] = a.position.y),
            (j[i++] = a.scale.x),
            (j[i++] = a.scale.y),
            (j[i++] = a.rotation),
            (j[i++] = b.x1),
            (j[i++] = b.y1),
            (j[i++] = a.alpha),
            (j[i++] = e),
            (j[i++] = g),
            (j[i++] = a.position.x),
            (j[i++] = a.position.y),
            (j[i++] = a.scale.x),
            (j[i++] = a.scale.y),
            (j[i++] = a.rotation),
            (j[i++] = b.x2),
            (j[i++] = b.y2),
            (j[i++] = a.alpha),
            (j[i++] = f),
            (j[i++] = g),
            (j[i++] = a.position.x),
            (j[i++] = a.position.y),
            (j[i++] = a.scale.x),
            (j[i++] = a.scale.y),
            (j[i++] = a.rotation),
            (j[i++] = b.x3),
            (j[i++] = b.y3),
            (j[i++] = a.alpha),
            this.currentBatchSize++,
            this.currentBatchSize >= this.size && this.flush();
        }
      }),
      (b.WebGLFastSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
          var a = this.gl;
          if (
            (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a),
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]),
            this.currentBatchSize > 0.5 * this.size)
          )
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
          else {
            var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
            a.bufferSubData(a.ARRAY_BUFFER, 0, b);
          }
          a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0), (this.currentBatchSize = 0), this.renderSession.drawCount++;
        }
      }),
      (b.WebGLFastSpriteBatch.prototype.stop = function () {
        this.flush();
      }),
      (b.WebGLFastSpriteBatch.prototype.start = function () {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y), a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var c = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0),
          a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8),
          a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16),
          a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24),
          a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28),
          a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36);
      }),
      (b.WebGLFilterManager = function () {
        (this.filterStack = []), (this.offsetX = 0), (this.offsetY = 0);
      }),
      (b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager),
      (b.WebGLFilterManager.prototype.setContext = function (a) {
        (this.gl = a), (this.texturePool = []), this.initShaderBuffers();
      }),
      (b.WebGLFilterManager.prototype.begin = function (a, b) {
        (this.renderSession = a), (this.defaultShader = a.shaderManager.defaultShader);
        var c = this.renderSession.projection;
        (this.width = 2 * c.x), (this.height = 2 * -c.y), (this.buffer = b);
      }),
      (b.WebGLFilterManager.prototype.pushFilter = function (a) {
        var c = this.gl,
          d = this.renderSession.projection,
          e = this.renderSession.offset;
        (a._filterArea = a.target.filterArea || a.target.getBounds()),
          (a._previous_stencil_mgr = this.renderSession.stencilManager),
          (this.renderSession.stencilManager = new b.WebGLStencilManager()),
          this.renderSession.stencilManager.setContext(c),
          c.disable(c.STENCIL_TEST),
          this.filterStack.push(a);
        var f = a.filterPasses[0];
        (this.offsetX += a._filterArea.x), (this.offsetY += a._filterArea.y);
        var g = this.texturePool.pop();
        g ? g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : (g = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)),
          c.bindTexture(c.TEXTURE_2D, g.texture);
        var h = a._filterArea,
          i = f.padding;
        (h.x -= i),
          (h.y -= i),
          (h.width += 2 * i),
          (h.height += 2 * i),
          h.x < 0 && (h.x = 0),
          h.width > this.width && (h.width = this.width),
          h.y < 0 && (h.y = 0),
          h.height > this.height && (h.height = this.height),
          c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer),
          c.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution),
          (d.x = h.width / 2),
          (d.y = -h.height / 2),
          (e.x = -h.x),
          (e.y = -h.y),
          c.colorMask(!0, !0, !0, !0),
          c.clearColor(0, 0, 0, 0),
          c.clear(c.COLOR_BUFFER_BIT),
          (a._glFilterTexture = g);
      }),
      (b.WebGLFilterManager.prototype.popFilter = function () {
        var a = this.gl,
          c = this.filterStack.pop(),
          d = c._filterArea,
          e = c._glFilterTexture,
          f = this.renderSession.projection,
          g = this.renderSession.offset;
        if (c.filterPasses.length > 1) {
          a.viewport(0, 0, d.width * this.renderSession.resolution, d.height * this.renderSession.resolution),
            a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
            (this.vertexArray[0] = 0),
            (this.vertexArray[1] = d.height),
            (this.vertexArray[2] = d.width),
            (this.vertexArray[3] = d.height),
            (this.vertexArray[4] = 0),
            (this.vertexArray[5] = 0),
            (this.vertexArray[6] = d.width),
            (this.vertexArray[7] = 0),
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray),
            a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
            (this.uvArray[2] = d.width / this.width),
            (this.uvArray[5] = d.height / this.height),
            (this.uvArray[6] = d.width / this.width),
            (this.uvArray[7] = d.height / this.height),
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
          var h = e,
            i = this.texturePool.pop();
          i || (i = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)),
            i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
            a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer),
            a.clear(a.COLOR_BUFFER_BIT),
            a.disable(a.BLEND);
          for (var j = 0; j < c.filterPasses.length - 1; j++) {
            var k = c.filterPasses[j];
            a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.texture), this.applyFilterPass(k, d, d.width, d.height);
            var l = h;
            (h = i), (i = l);
          }
          a.enable(a.BLEND), (e = h), this.texturePool.push(i);
        }
        var m = c.filterPasses[c.filterPasses.length - 1];
        (this.offsetX -= d.x), (this.offsetY -= d.y);
        var n = this.width,
          o = this.height,
          p = 0,
          q = 0,
          r = this.buffer;
        if (0 === this.filterStack.length) a.colorMask(!0, !0, !0, !0);
        else {
          var s = this.filterStack[this.filterStack.length - 1];
          (d = s._filterArea), (n = d.width), (o = d.height), (p = d.x), (q = d.y), (r = s._glFilterTexture.frameBuffer);
        }
        (f.x = n / 2), (f.y = -o / 2), (g.x = p), (g.y = q), (d = c._filterArea);
        var t = d.x - p,
          u = d.y - q;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
          (this.vertexArray[0] = t),
          (this.vertexArray[1] = u + d.height),
          (this.vertexArray[2] = t + d.width),
          (this.vertexArray[3] = u + d.height),
          (this.vertexArray[4] = t),
          (this.vertexArray[5] = u),
          (this.vertexArray[6] = t + d.width),
          (this.vertexArray[7] = u),
          a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray),
          a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
          (this.uvArray[2] = d.width / this.width),
          (this.uvArray[5] = d.height / this.height),
          (this.uvArray[6] = d.width / this.width),
          (this.uvArray[7] = d.height / this.height),
          a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray),
          a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution),
          a.bindFramebuffer(a.FRAMEBUFFER, r),
          a.activeTexture(a.TEXTURE0),
          a.bindTexture(a.TEXTURE_2D, e.texture),
          this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(),
          (this.renderSession.stencilManager = c._previous_stencil_mgr),
          (c._previous_stencil_mgr = null),
          this.renderSession.stencilManager.count > 0 ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST),
          this.applyFilterPass(m, d, n, o),
          this.texturePool.push(e),
          (c._glFilterTexture = null);
      }),
      (b.WebGLFilterManager.prototype.applyFilterPass = function (a, c, d, e) {
        var f = this.gl,
          g = a.shaders[f.id];
        g || ((g = new b.PixiShader(f)), (g.fragmentSrc = a.fragmentSrc), (g.uniforms = a.uniforms), g.init(), (a.shaders[f.id] = g)),
          this.renderSession.shaderManager.setShader(g),
          f.uniform2f(g.projectionVector, d / 2, -e / 2),
          f.uniform2f(g.offsetVector, 0, 0),
          a.uniforms.dimensions &&
            ((a.uniforms.dimensions.value[0] = this.width), (a.uniforms.dimensions.value[1] = this.height), (a.uniforms.dimensions.value[2] = this.vertexArray[0]), (a.uniforms.dimensions.value[3] = this.vertexArray[5])),
          g.syncUniforms(),
          f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer),
          f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0),
          f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer),
          f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0),
          f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer),
          f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0),
          f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
          f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0),
          this.renderSession.drawCount++;
      }),
      (b.WebGLFilterManager.prototype.initShaderBuffers = function () {
        var a = this.gl;
        (this.vertexBuffer = a.createBuffer()),
          (this.uvBuffer = a.createBuffer()),
          (this.colorBuffer = a.createBuffer()),
          (this.indexBuffer = a.createBuffer()),
          (this.vertexArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1])),
          a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
          a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW),
          (this.uvArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1])),
          a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
          a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW),
          (this.colorArray = new b.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215])),
          a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer),
          a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW),
          a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
          a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW);
      }),
      (b.WebGLFilterManager.prototype.destroy = function () {
        var a = this.gl;
        (this.filterStack = null), (this.offsetX = 0), (this.offsetY = 0);
        for (var b = 0; b < this.texturePool.length; b++) this.texturePool[b].destroy();
        (this.texturePool = null), a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.uvBuffer), a.deleteBuffer(this.colorBuffer), a.deleteBuffer(this.indexBuffer);
      }),
      (b.FilterTexture = function (a, c, d, e) {
        (this.gl = a),
          (this.frameBuffer = a.createFramebuffer()),
          (this.texture = a.createTexture()),
          (e = e || b.scaleModes.DEFAULT),
          a.bindTexture(a.TEXTURE_2D, this.texture),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
          a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
          a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer),
          a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer),
          a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0),
          (this.renderBuffer = a.createRenderbuffer()),
          a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer),
          a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer),
          this.resize(c, d);
      }),
      (b.FilterTexture.prototype.constructor = b.FilterTexture),
      (b.FilterTexture.prototype.clear = function () {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT);
      }),
      (b.FilterTexture.prototype.resize = function (a, b) {
        if (this.width !== a || this.height !== b) {
          (this.width = a), (this.height = b);
          var c = this.gl;
          c.bindTexture(c.TEXTURE_2D, this.texture),
            c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null),
            c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer),
            c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b);
        }
      }),
      (b.FilterTexture.prototype.destroy = function () {
        var a = this.gl;
        a.deleteFramebuffer(this.frameBuffer), a.deleteTexture(this.texture), (this.frameBuffer = null), (this.texture = null);
      }),
      (b.CanvasBuffer = function (a, c) {
        (this.width = a), (this.height = c), (this.canvas = b.CanvasPool.create(this, this.width, this.height)), (this.context = this.canvas.getContext("2d")), (this.canvas.width = a), (this.canvas.height = c);
      }),
      (b.CanvasBuffer.prototype.constructor = b.CanvasBuffer),
      (b.CanvasBuffer.prototype.clear = function () {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height);
      }),
      (b.CanvasBuffer.prototype.resize = function (a, b) {
        (this.width = this.canvas.width = a), (this.height = this.canvas.height = b);
      }),
      (b.CanvasBuffer.prototype.destroy = function () {
        b.CanvasPool.remove(this);
      }),
      (b.CanvasMaskManager = function () {}),
      (b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager),
      (b.CanvasMaskManager.prototype.pushMask = function (a, c) {
        var d = c.context;
        d.save();
        var e = a.alpha,
          f = a.worldTransform,
          g = c.resolution;
        d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g), b.CanvasGraphics.renderGraphicsMask(a, d), d.clip(), (a.worldAlpha = e);
      }),
      (b.CanvasMaskManager.prototype.popMask = function (a) {
        a.context.restore();
      }),
      (b.CanvasTinter = function () {}),
      (b.CanvasTinter.getTintedTexture = function (a, c) {
        var d = a.tintedTexture || b.CanvasPool.create(this);
        return b.CanvasTinter.tintMethod(a.texture, c, d), d;
      }),
      (b.CanvasTinter.tintWithMultiply = function (a, b, c) {
        var d = c.getContext("2d"),
          e = a.crop;
        (c.width === e.width && c.height === e.height) || ((c.width = e.width), (c.height = e.height)),
          d.clearRect(0, 0, e.width, e.height),
          (d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6)),
          d.fillRect(0, 0, e.width, e.height),
          (d.globalCompositeOperation = "multiply"),
          d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height),
          (d.globalCompositeOperation = "destination-atop"),
          d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
      }),
      (b.CanvasTinter.tintWithPerPixel = function (a, c, d) {
        var e = d.getContext("2d"),
          f = a.crop;
        (d.width = f.width), (d.height = f.height), (e.globalCompositeOperation = "copy"), e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
        for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4)
          if (((l[m + 0] *= h), (l[m + 1] *= i), (l[m + 2] *= j), !b.CanvasTinter.canHandleAlpha)) {
            var n = l[m + 3];
            (l[m + 0] /= 255 / n), (l[m + 1] /= 255 / n), (l[m + 2] /= 255 / n);
          }
        e.putImageData(k, 0, 0);
      }),
      (b.CanvasTinter.checkInverseAlpha = function () {
        var a = new b.CanvasBuffer(2, 1);
        (a.context.fillStyle = "rgba(10, 20, 30, 0.5)"), a.context.fillRect(0, 0, 1, 1);
        var c = a.context.getImageData(0, 0, 1, 1);
        if (null === c) return !1;
        a.context.putImageData(c, 1, 0);
        var d = a.context.getImageData(1, 0, 1, 1);
        return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3];
      }),
      (b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha()),
      (b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes()),
      (b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel),
      (b.CanvasRenderer = function (a) {
        (this.game = a),
          b.defaultRenderer || (b.defaultRenderer = this),
          (this.type = b.CANVAS_RENDERER),
          (this.resolution = a.resolution),
          (this.clearBeforeRender = a.clearBeforeRender),
          (this.transparent = a.transparent),
          (this.autoResize = !1),
          (this.width = a.width * this.resolution),
          (this.height = a.height * this.resolution),
          (this.view = a.canvas),
          (this.context = this.view.getContext("2d", { alpha: this.transparent })),
          (this.refresh = !0),
          (this.count = 0),
          (this.maskManager = new b.CanvasMaskManager()),
          (this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context), roundPixels: !1 }),
          this.mapBlendModes(),
          this.resize(this.width, this.height);
      }),
      (b.CanvasRenderer.prototype.constructor = b.CanvasRenderer),
      (b.CanvasRenderer.prototype.render = function (a) {
        this.context.setTransform(1, 0, 0, 1, 0, 0),
          (this.context.globalAlpha = 1),
          (this.renderSession.currentBlendMode = 0),
          (this.renderSession.shakeX = this.game.camera._shake.x),
          (this.renderSession.shakeY = this.game.camera._shake.y),
          (this.context.globalCompositeOperation = "source-over"),
          navigator.isCocoonJS && this.view.screencanvas && ((this.context.fillStyle = "black"), this.context.clear()),
          this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : a._bgColor && ((this.context.fillStyle = a._bgColor.rgba), this.context.fillRect(0, 0, this.width, this.height))),
          this.renderDisplayObject(a);
      }),
      (b.CanvasRenderer.prototype.destroy = function (a) {
        void 0 === a && (a = !0), a && this.view.parent && this.view.parent.removeChild(this.view), (this.view = null), (this.context = null), (this.maskManager = null), (this.renderSession = null);
      }),
      (b.CanvasRenderer.prototype.resize = function (a, c) {
        (this.width = a * this.resolution),
          (this.height = c * this.resolution),
          (this.view.width = this.width),
          (this.view.height = this.height),
          this.autoResize && ((this.view.style.width = this.width / this.resolution + "px"), (this.view.style.height = this.height / this.resolution + "px")),
          this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === b.scaleModes.LINEAR);
      }),
      (b.CanvasRenderer.prototype.renderDisplayObject = function (a, b, c) {
        (this.renderSession.context = b || this.context), (this.renderSession.resolution = this.resolution), a._renderCanvas(this.renderSession, c);
      }),
      (b.CanvasRenderer.prototype.mapBlendModes = function () {
        if (!b.blendModesCanvas) {
          var a = [],
            c = b.blendModes,
            d = b.canUseNewCanvasBlendModes();
          (a[c.NORMAL] = "source-over"),
            (a[c.ADD] = "lighter"),
            (a[c.MULTIPLY] = d ? "multiply" : "source-over"),
            (a[c.SCREEN] = d ? "screen" : "source-over"),
            (a[c.OVERLAY] = d ? "overlay" : "source-over"),
            (a[c.DARKEN] = d ? "darken" : "source-over"),
            (a[c.LIGHTEN] = d ? "lighten" : "source-over"),
            (a[c.COLOR_DODGE] = d ? "color-dodge" : "source-over"),
            (a[c.COLOR_BURN] = d ? "color-burn" : "source-over"),
            (a[c.HARD_LIGHT] = d ? "hard-light" : "source-over"),
            (a[c.SOFT_LIGHT] = d ? "soft-light" : "source-over"),
            (a[c.DIFFERENCE] = d ? "difference" : "source-over"),
            (a[c.EXCLUSION] = d ? "exclusion" : "source-over"),
            (a[c.HUE] = d ? "hue" : "source-over"),
            (a[c.SATURATION] = d ? "saturation" : "source-over"),
            (a[c.COLOR] = d ? "color" : "source-over"),
            (a[c.LUMINOSITY] = d ? "luminosity" : "source-over"),
            (b.blendModesCanvas = a);
        }
      }),
      (b.BaseTexture = function (a, c) {
        (this.resolution = 1),
          (this.width = 100),
          (this.height = 100),
          (this.scaleMode = c || b.scaleModes.DEFAULT),
          (this.hasLoaded = !1),
          (this.source = a),
          (this.premultipliedAlpha = !0),
          (this._glTextures = []),
          (this.mipmap = !1),
          (this._dirty = [!0, !0, !0, !0]),
          a &&
            ((this.source.complete || this.source.getContext) &&
              this.source.width &&
              this.source.height &&
              ((this.hasLoaded = !0), (this.width = this.source.naturalWidth || this.source.width), (this.height = this.source.naturalHeight || this.source.height), this.dirty()),
            (this.skipRender = !1),
            (this._powerOf2 = !1));
      }),
      (b.BaseTexture.prototype.constructor = b.BaseTexture),
      (b.BaseTexture.prototype.forceLoaded = function (a, b) {
        (this.hasLoaded = !0), (this.width = a), (this.height = b), this.dirty();
      }),
      (b.BaseTexture.prototype.destroy = function () {
        this.source && b.CanvasPool.removeByCanvas(this.source), (this.source = null), this.unloadFromGPU();
      }),
      (b.BaseTexture.prototype.updateSourceImage = function (a) {}),
      (b.BaseTexture.prototype.dirty = function () {
        for (var a = 0; a < this._glTextures.length; a++) this._dirty[a] = !0;
      }),
      (b.BaseTexture.prototype.unloadFromGPU = function () {
        this.dirty();
        for (var a = this._glTextures.length - 1; a >= 0; a--) {
          var c = this._glTextures[a],
            d = b.glContexts[a];
          d && c && d.deleteTexture(c);
        }
        (this._glTextures.length = 0), this.dirty();
      }),
      (b.BaseTexture.fromCanvas = function (a, c) {
        return 0 === a.width && (a.width = 1), 0 === a.height && (a.height = 1), new b.BaseTexture(a, c);
      }),
      (b.TextureSilentFail = !1),
      (b.Texture = function (a, c, d, e) {
        (this.noFrame = !1),
          c || ((this.noFrame = !0), (c = new b.Rectangle(0, 0, 1, 1))),
          a instanceof b.Texture && (a = a.baseTexture),
          (this.baseTexture = a),
          (this.frame = c),
          (this.trim = e),
          (this.valid = !1),
          (this.isTiling = !1),
          (this.requiresUpdate = !1),
          (this.requiresReTint = !1),
          (this._uvs = null),
          (this.width = 0),
          (this.height = 0),
          (this.crop = d || new b.Rectangle(0, 0, 1, 1)),
          a.hasLoaded && (this.noFrame && (c = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(c));
      }),
      (b.Texture.prototype.constructor = b.Texture),
      (b.Texture.prototype.onBaseTextureLoaded = function () {
        var a = this.baseTexture;
        this.noFrame && (this.frame = new b.Rectangle(0, 0, a.width, a.height)), this.setFrame(this.frame);
      }),
      (b.Texture.prototype.destroy = function (a) {
        a && this.baseTexture.destroy(), (this.valid = !1);
      }),
      (b.Texture.prototype.setFrame = function (a) {
        if (
          ((this.noFrame = !1),
          (this.frame = a),
          (this.width = a.width),
          (this.height = a.height),
          (this.crop.x = a.x),
          (this.crop.y = a.y),
          (this.crop.width = a.width),
          (this.crop.height = a.height),
          !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height))
        ) {
          if (!b.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
          return void (this.valid = !1);
        }
        (this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded),
          this.trim && ((this.width = this.trim.width), (this.height = this.trim.height), (this.frame.width = this.trim.width), (this.frame.height = this.trim.height)),
          this.valid && this._updateUvs();
      }),
      (b.Texture.prototype._updateUvs = function () {
        this._uvs || (this._uvs = new b.TextureUvs());
        var a = this.crop,
          c = this.baseTexture.width,
          d = this.baseTexture.height;
        (this._uvs.x0 = a.x / c),
          (this._uvs.y0 = a.y / d),
          (this._uvs.x1 = (a.x + a.width) / c),
          (this._uvs.y1 = a.y / d),
          (this._uvs.x2 = (a.x + a.width) / c),
          (this._uvs.y2 = (a.y + a.height) / d),
          (this._uvs.x3 = a.x / c),
          (this._uvs.y3 = (a.y + a.height) / d);
      }),
      (b.Texture.fromCanvas = function (a, c) {
        var d = b.BaseTexture.fromCanvas(a, c);
        return new b.Texture(d);
      }),
      (b.TextureUvs = function () {
        (this.x0 = 0), (this.y0 = 0), (this.x1 = 0), (this.y1 = 0), (this.x2 = 0), (this.y2 = 0), (this.x3 = 0), (this.y3 = 0);
      }),
      (b.RenderTexture = function (a, c, d, e, f) {
        if (
          ((this.width = a || 100),
          (this.height = c || 100),
          (this.resolution = f || 1),
          (this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)),
          (this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)),
          (this.baseTexture = new b.BaseTexture()),
          (this.baseTexture.width = this.width * this.resolution),
          (this.baseTexture.height = this.height * this.resolution),
          (this.baseTexture._glTextures = []),
          (this.baseTexture.resolution = this.resolution),
          (this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT),
          (this.baseTexture.hasLoaded = !0),
          b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)),
          (this.renderer = d || b.defaultRenderer),
          this.renderer.type === b.WEBGL_RENDERER)
        ) {
          var g = this.renderer.gl;
          (this.baseTexture._dirty[g.id] = !1),
            (this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode)),
            (this.baseTexture._glTextures[g.id] = this.textureBuffer.texture),
            (this.render = this.renderWebGL),
            (this.projection = new b.Point(0.5 * this.width, 0.5 * -this.height));
        } else (this.render = this.renderCanvas), (this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution)), (this.baseTexture.source = this.textureBuffer.canvas);
        (this.valid = !0), (this.tempMatrix = new Phaser.Matrix()), this._updateUvs();
      }),
      (b.RenderTexture.prototype = Object.create(b.Texture.prototype)),
      (b.RenderTexture.prototype.constructor = b.RenderTexture),
      (b.RenderTexture.prototype.resize = function (a, c, d) {
        (a === this.width && c === this.height) ||
          ((this.valid = a > 0 && c > 0),
          (this.width = a),
          (this.height = c),
          (this.frame.width = this.crop.width = a * this.resolution),
          (this.frame.height = this.crop.height = c * this.resolution),
          d && ((this.baseTexture.width = this.width * this.resolution), (this.baseTexture.height = this.height * this.resolution)),
          this.renderer.type === b.WEBGL_RENDERER && ((this.projection.x = this.width / 2), (this.projection.y = -this.height / 2)),
          this.valid && this.textureBuffer.resize(this.width, this.height));
      }),
      (b.RenderTexture.prototype.clear = function () {
        this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear());
      }),
      (b.RenderTexture.prototype.renderWebGL = function (a, b, c) {
        if (this.valid && 0 !== a.alpha) {
          var d = a.worldTransform;
          d.identity(), d.translate(0, 2 * this.projection.y), b && d.append(b), d.scale(1, -1);
          for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
          var f = this.renderer.gl;
          f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution),
            f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            c && this.textureBuffer.clear(),
            (this.renderer.spriteBatch.dirty = !0),
            this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b),
            (this.renderer.spriteBatch.dirty = !0);
        }
      }),
      (b.RenderTexture.prototype.renderCanvas = function (a, b, c) {
        if (this.valid && 0 !== a.alpha) {
          var d = a.worldTransform;
          d.identity(), b && d.append(b);
          for (var e = 0; e < a.children.length; e++) a.children[e].updateTransform();
          c && this.textureBuffer.clear();
          var f = this.renderer.resolution;
          (this.renderer.resolution = this.resolution), this.renderer.renderDisplayObject(a, this.textureBuffer.context, b), (this.renderer.resolution = f);
        }
      }),
      (b.RenderTexture.prototype.getImage = function () {
        var a = new Image();
        return (a.src = this.getBase64()), a;
      }),
      (b.RenderTexture.prototype.getBase64 = function () {
        return this.getCanvas().toDataURL();
      }),
      (b.RenderTexture.prototype.getCanvas = function () {
        if (this.renderer.type === b.WEBGL_RENDERER) {
          var a = this.renderer.gl,
            c = this.textureBuffer.width,
            d = this.textureBuffer.height,
            e = new Uint8Array(4 * c * d);
          a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e), a.bindFramebuffer(a.FRAMEBUFFER, null);
          var f = new b.CanvasBuffer(c, d),
            g = f.context.getImageData(0, 0, c, d);
          return g.data.set(e), f.context.putImageData(g, 0, 0), f.canvas;
        }
        return this.textureBuffer.canvas;
      }),
      (b.AbstractFilter = function (a, b) {
        (this.passes = [this]), (this.shaders = []), (this.dirty = !0), (this.padding = 0), (this.uniforms = b || {}), (this.fragmentSrc = a || []);
      }),
      (b.AbstractFilter.prototype.constructor = b.AbstractFilter),
      (b.AbstractFilter.prototype.syncUniforms = function () {
        for (var a = 0, b = this.shaders.length; a < b; a++) this.shaders[a].dirty = !0;
      }),
      (b.Strip = function (a) {
        b.DisplayObjectContainer.call(this),
          (this.texture = a),
          (this.uvs = new b.Float32Array([0, 1, 1, 1, 1, 0, 0, 1])),
          (this.vertices = new b.Float32Array([0, 0, 100, 0, 100, 100, 0, 100])),
          (this.colors = new b.Float32Array([1, 1, 1, 1])),
          (this.indices = new b.Uint16Array([0, 1, 2, 3])),
          (this.dirty = !0),
          (this.blendMode = b.blendModes.NORMAL),
          (this.canvasPadding = 0),
          (this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP);
      }),
      (b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype)),
      (b.Strip.prototype.constructor = b.Strip),
      (b.Strip.prototype._renderWebGL = function (a) {
        !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(a), a.shaderManager.setShader(a.shaderManager.stripShader), this._renderStrip(a), a.spriteBatch.start());
      }),
      (b.Strip.prototype._initWebGL = function (a) {
        var b = a.gl;
        (this._vertexBuffer = b.createBuffer()),
          (this._indexBuffer = b.createBuffer()),
          (this._uvBuffer = b.createBuffer()),
          (this._colorBuffer = b.createBuffer()),
          b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer),
          b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW),
          b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer),
          b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW),
          b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer),
          b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW),
          b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
          b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW);
      }),
      (b.Strip.prototype._renderStrip = function (a) {
        var c = a.gl,
          d = a.projection,
          e = a.offset,
          f = a.shaderManager.stripShader,
          g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
        a.blendModeManager.setBlendMode(this.blendMode),
          c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)),
          c.uniform2f(f.projectionVector, d.x, -d.y),
          c.uniform2f(f.offsetVector, -e.x, -e.y),
          c.uniform1f(f.alpha, this.worldAlpha),
          this.dirty
            ? ((this.dirty = !1),
              c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer),
              c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW),
              c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0),
              c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer),
              c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW),
              c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0),
              c.activeTexture(c.TEXTURE0),
              this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]),
              c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
              c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW))
            : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer),
              c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices),
              c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0),
              c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer),
              c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0),
              c.activeTexture(c.TEXTURE0),
              this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]),
              c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)),
          c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0);
      }),
      (b.Strip.prototype._renderCanvas = function (a) {
        var c = a.context,
          d = this.worldTransform,
          e = d.tx * a.resolution + a.shakeX,
          f = d.ty * a.resolution + a.shakeY;
        a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f) : c.setTransform(d.a, d.b, d.c, d.d, e, f), this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c);
      }),
      (b.Strip.prototype._renderCanvasTriangleStrip = function (a) {
        var b = this.vertices,
          c = this.uvs,
          d = b.length / 2;
        this.count++;
        for (var e = 0; e < d - 2; e++) {
          var f = 2 * e;
          this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4);
        }
      }),
      (b.Strip.prototype._renderCanvasTriangles = function (a) {
        var b = this.vertices,
          c = this.uvs,
          d = this.indices,
          e = d.length;
        this.count++;
        for (var f = 0; f < e; f += 3) {
          var g = 2 * d[f],
            h = 2 * d[f + 1],
            i = 2 * d[f + 2];
          this._renderCanvasDrawTriangle(a, b, c, g, h, i);
        }
      }),
      (b.Strip.prototype._renderCanvasDrawTriangle = function (a, b, c, d, e, f) {
        var g = this.texture.baseTexture.source,
          h = this.texture.width,
          i = this.texture.height,
          j = b[d],
          k = b[e],
          l = b[f],
          m = b[d + 1],
          n = b[e + 1],
          o = b[f + 1],
          p = c[d] * h,
          q = c[e] * h,
          r = c[f] * h,
          s = c[d + 1] * i,
          t = c[e + 1] * i,
          u = c[f + 1] * i;
        if (this.canvasPadding > 0) {
          var v = this.canvasPadding / this.worldTransform.a,
            w = this.canvasPadding / this.worldTransform.d,
            x = (j + k + l) / 3,
            y = (m + n + o) / 3,
            z = j - x,
            A = m - y,
            B = Math.sqrt(z * z + A * A);
          (j = x + (z / B) * (B + v)),
            (m = y + (A / B) * (B + w)),
            (z = k - x),
            (A = n - y),
            (B = Math.sqrt(z * z + A * A)),
            (k = x + (z / B) * (B + v)),
            (n = y + (A / B) * (B + w)),
            (z = l - x),
            (A = o - y),
            (B = Math.sqrt(z * z + A * A)),
            (l = x + (z / B) * (B + v)),
            (o = y + (A / B) * (B + w));
        }
        a.save(), a.beginPath(), a.moveTo(j, m), a.lineTo(k, n), a.lineTo(l, o), a.closePath(), a.clip();
        var C = p * t + s * r + q * u - t * r - s * q - p * u,
          D = j * t + s * l + k * u - t * l - s * k - j * u,
          E = p * k + j * r + q * l - k * r - j * q - p * l,
          F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u,
          G = m * t + s * o + n * u - t * o - s * n - m * u,
          H = p * n + m * r + q * o - n * r - m * q - p * o,
          I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
        a.transform(D / C, G / C, E / C, H / C, F / C, I / C), a.drawImage(g, 0, 0), a.restore();
      }),
      (b.Strip.prototype.renderStripFlat = function (a) {
        var b = this.context,
          c = a.vertices,
          d = c.length / 2;
        this.count++, b.beginPath();
        for (var e = 1; e < d - 2; e++) {
          var f = 2 * e,
            g = c[f],
            h = c[f + 2],
            i = c[f + 4],
            j = c[f + 1],
            k = c[f + 3],
            l = c[f + 5];
          b.moveTo(g, j), b.lineTo(h, k), b.lineTo(i, l);
        }
        (b.fillStyle = "#FF0000"), b.fill(), b.closePath();
      }),
      (b.Strip.prototype.onTextureUpdate = function () {
        this.updateFrame = !0;
      }),
      (b.Strip.prototype.getBounds = function (a) {
        for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -(1 / 0), k = -(1 / 0), l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; o < p; o += 2) {
          var q = n[o],
            r = n[o + 1],
            s = d * q + f * r + h,
            t = g * r + e * q + i;
          (l = s < l ? s : l), (m = t < m ? t : m), (j = s > j ? s : j), (k = t > k ? t : k);
        }
        if (l === -(1 / 0) || k === 1 / 0) return b.EmptyRectangle;
        var u = this._bounds;
        return (u.x = l), (u.width = j - l), (u.y = m), (u.height = k - m), (this._currentBounds = u), u;
      }),
      (b.Strip.DrawModes = { TRIANGLE_STRIP: 0, TRIANGLES: 1 }),
      (b.Rope = function (a, c) {
        b.Strip.call(this, a),
          (this.points = c),
          (this.vertices = new b.Float32Array(4 * c.length)),
          (this.uvs = new b.Float32Array(4 * c.length)),
          (this.colors = new b.Float32Array(2 * c.length)),
          (this.indices = new b.Uint16Array(2 * c.length)),
          this.refresh();
      }),
      (b.Rope.prototype = Object.create(b.Strip.prototype)),
      (b.Rope.prototype.constructor = b.Rope),
      (b.Rope.prototype.refresh = function () {
        var a = this.points;
        if (!(a.length < 1)) {
          var b = this.uvs,
            c = a[0],
            d = this.indices,
            e = this.colors;
          (this.count -= 0.2), (b[0] = 0), (b[1] = 0), (b[2] = 0), (b[3] = 1), (e[0] = 1), (e[1] = 1), (d[0] = 0), (d[1] = 1);
          for (var f, g, h, i = a.length, j = 1; j < i; j++)
            (f = a[j]),
              (g = 4 * j),
              (h = j / (i - 1)),
              j % 2 ? ((b[g] = h), (b[g + 1] = 0), (b[g + 2] = h), (b[g + 3] = 1)) : ((b[g] = h), (b[g + 1] = 0), (b[g + 2] = h), (b[g + 3] = 1)),
              (g = 2 * j),
              (e[g] = 1),
              (e[g + 1] = 1),
              (g = 2 * j),
              (d[g] = g),
              (d[g + 1] = g + 1),
              (c = f);
        }
      }),
      (b.Rope.prototype.updateTransform = function () {
        var a = this.points;
        if (!(a.length < 1)) {
          var c,
            d = a[0],
            e = { x: 0, y: 0 };
          this.count -= 0.2;
          for (var f, g, h, i, j, k = this.vertices, l = a.length, m = 0; m < l; m++)
            (f = a[m]),
              (g = 4 * m),
              (c = m < a.length - 1 ? a[m + 1] : f),
              (e.y = -(c.x - d.x)),
              (e.x = c.y - d.y),
              (h = 10 * (1 - m / (l - 1))),
              h > 1 && (h = 1),
              (i = Math.sqrt(e.x * e.x + e.y * e.y)),
              (j = this.texture.height / 2),
              (e.x /= i),
              (e.y /= i),
              (e.x *= j),
              (e.y *= j),
              (k[g] = f.x + e.x),
              (k[g + 1] = f.y + e.y),
              (k[g + 2] = f.x - e.x),
              (k[g + 3] = f.y - e.y),
              (d = f);
          b.DisplayObjectContainer.prototype.updateTransform.call(this);
        }
      }),
      (b.Rope.prototype.setTexture = function (a) {
        this.texture = a;
      }),
      (b.TilingSprite = function (a, c, d) {
        b.Sprite.call(this, a),
          (this._width = c || 128),
          (this._height = d || 128),
          (this.tileScale = new b.Point(1, 1)),
          (this.tileScaleOffset = new b.Point(1, 1)),
          (this.tilePosition = new b.Point()),
          (this.renderable = !0),
          (this.tint = 16777215),
          (this.textureDebug = !1),
          (this.blendMode = b.blendModes.NORMAL),
          (this.canvasBuffer = null),
          (this.tilingTexture = null),
          (this.tilePattern = null),
          (this.refreshTexture = !0),
          (this.frameWidth = 0),
          (this.frameHeight = 0);
      }),
      (b.TilingSprite.prototype = Object.create(b.Sprite.prototype)),
      (b.TilingSprite.prototype.constructor = b.TilingSprite),
      (b.TilingSprite.prototype.setTexture = function (a) {
        this.texture !== a && ((this.texture = a), (this.refreshTexture = !0), (this.cachedTint = 16777215));
      }),
      (b.TilingSprite.prototype._renderWebGL = function (a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
          if ((this._mask && (a.spriteBatch.stop(), a.maskManager.pushMask(this.mask, a), a.spriteBatch.start()), this._filters && (a.spriteBatch.flush(), a.filterManager.pushFilter(this._filterBlock)), this.refreshTexture)) {
            if ((this.generateTilingTexture(!0, a), !this.tilingTexture)) return;
            this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture), (this.tilingTexture.needsUpdate = !1));
          }
          a.spriteBatch.renderTilingSprite(this);
          for (var b = 0; b < this.children.length; b++) this.children[b]._renderWebGL(a);
          a.spriteBatch.stop(), this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this._mask, a), a.spriteBatch.start();
        }
      }),
      (b.TilingSprite.prototype._renderCanvas = function (a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
          var c = a.context;
          this._mask && a.maskManager.pushMask(this._mask, a), (c.globalAlpha = this.worldAlpha);
          var d = this.worldTransform,
            e = a.resolution,
            f = d.tx * e + a.shakeX,
            g = d.ty * e + a.shakeY;
          if ((c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, f, g), this.refreshTexture)) {
            if ((this.generateTilingTexture(!1, a), !this.tilingTexture)) return;
            this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat");
          }
          var h = a.currentBlendMode;
          this.blendMode !== a.currentBlendMode && ((a.currentBlendMode = this.blendMode), (c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]));
          var i = this.tilePosition,
            j = this.tileScale;
          (i.x %= this.tilingTexture.baseTexture.width),
            (i.y %= this.tilingTexture.baseTexture.height),
            c.scale(j.x, j.y),
            c.translate(i.x + this.anchor.x * -this._width, i.y + this.anchor.y * -this._height),
            (c.fillStyle = this.tilePattern);
          var f = -i.x,
            g = -i.y,
            k = this._width / j.x,
            l = this._height / j.y;
          a.roundPixels && ((f |= 0), (g |= 0), (k |= 0), (l |= 0)),
            c.fillRect(f, g, k, l),
            c.scale(1 / j.x, 1 / j.y),
            c.translate(-i.x + this.anchor.x * this._width, -i.y + this.anchor.y * this._height),
            this._mask && a.maskManager.popMask(a);
          for (var m = 0; m < this.children.length; m++) this.children[m]._renderCanvas(a);
          h !== this.blendMode && ((a.currentBlendMode = h), (c.globalCompositeOperation = b.blendModesCanvas[h]));
        }
      }),
      (b.TilingSprite.prototype.onTextureUpdate = function () {}),
      (b.TilingSprite.prototype.generateTilingTexture = function (a, c) {
        if (this.texture.baseTexture.hasLoaded) {
          var d = this.texture,
            e = d.frame,
            f = this._frame.sourceSizeW || this._frame.width,
            g = this._frame.sourceSizeH || this._frame.height,
            h = 0,
            i = 0;
          this._frame.trimmed && ((h = this._frame.spriteSourceSizeX), (i = this._frame.spriteSourceSizeY)),
            a && ((f = b.getNextPowerOfTwo(f)), (g = b.getNextPowerOfTwo(g))),
            this.canvasBuffer
              ? (this.canvasBuffer.resize(f, g), (this.tilingTexture.baseTexture.width = f), (this.tilingTexture.baseTexture.height = g), (this.tilingTexture.needsUpdate = !0))
              : ((this.canvasBuffer = new b.CanvasBuffer(f, g)), (this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas)), (this.tilingTexture.isTiling = !0), (this.tilingTexture.needsUpdate = !0)),
            this.textureDebug && ((this.canvasBuffer.context.strokeStyle = "#00ff00"), this.canvasBuffer.context.strokeRect(0, 0, f, g));
          var j = d.crop.width,
            k = d.crop.height;
          (j === f && k === g) || ((j = f), (k = g)),
            this.canvasBuffer.context.drawImage(d.baseTexture.source, d.crop.x, d.crop.y, d.crop.width, d.crop.height, h, i, j, k),
            (this.tileScaleOffset.x = e.width / f),
            (this.tileScaleOffset.y = e.height / g),
            (this.refreshTexture = !1),
            (this.tilingTexture.baseTexture._powerOf2 = !0);
        }
      }),
      (b.TilingSprite.prototype.getBounds = function () {
        var a = this._width,
          b = this._height,
          c = a * (1 - this.anchor.x),
          d = a * -this.anchor.x,
          e = b * (1 - this.anchor.y),
          f = b * -this.anchor.y,
          g = this.worldTransform,
          h = g.a,
          i = g.b,
          j = g.c,
          k = g.d,
          l = g.tx,
          m = g.ty,
          n = h * d + j * f + l,
          o = k * f + i * d + m,
          p = h * c + j * f + l,
          q = k * f + i * c + m,
          r = h * c + j * e + l,
          s = k * e + i * c + m,
          t = h * d + j * e + l,
          u = k * e + i * d + m,
          v = -(1 / 0),
          w = -(1 / 0),
          x = 1 / 0,
          y = 1 / 0;
        (x = n < x ? n : x),
          (x = p < x ? p : x),
          (x = r < x ? r : x),
          (x = t < x ? t : x),
          (y = o < y ? o : y),
          (y = q < y ? q : y),
          (y = s < y ? s : y),
          (y = u < y ? u : y),
          (v = n > v ? n : v),
          (v = p > v ? p : v),
          (v = r > v ? r : v),
          (v = t > v ? t : v),
          (w = o > w ? o : w),
          (w = q > w ? q : w),
          (w = s > w ? s : w),
          (w = u > w ? u : w);
        var z = this._bounds;
        return (z.x = x), (z.width = v - x), (z.y = y), (z.height = w - y), (this._currentBounds = z), z;
      }),
      (b.TilingSprite.prototype.destroy = function () {
        b.Sprite.prototype.destroy.call(this),
          this.canvasBuffer && (this.canvasBuffer.destroy(), (this.canvasBuffer = null)),
          (this.tileScale = null),
          (this.tileScaleOffset = null),
          (this.tilePosition = null),
          this.tilingTexture && (this.tilingTexture.destroy(!0), (this.tilingTexture = null));
      }),
      Object.defineProperty(b.TilingSprite.prototype, "width", {
        get: function () {
          return this._width;
        },
        set: function (a) {
          this._width = a;
        },
      }),
      Object.defineProperty(b.TilingSprite.prototype, "height", {
        get: function () {
          return this._height;
        },
        set: function (a) {
          this._height = a;
        },
      }),
      "undefined" != typeof exports
        ? ("undefined" != typeof module && module.exports && (exports = module.exports = b), (exports.PIXI = b))
        : "undefined" != typeof define && define.amd
        ? define("PIXI", (function () {
            return (a.PIXI = b);
          })())
        : (a.PIXI = b),
      b
    );
  }.call(this),
  function () {
    function a(a, b) {
      (this._scaleFactor = a), (this._deltaMode = b), (this.originalEvent = null);
    }
    var b = this,
      c = c || {
        VERSION: "2.6.2",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        PENDING_ATLAS: -1,
        HORIZONTAL: 0,
        VERTICAL: 1,
        LANDSCAPE: 0,
        PORTRAIT: 1,
        ANGLE_UP: 270,
        ANGLE_DOWN: 90,
        ANGLE_LEFT: 180,
        ANGLE_RIGHT: 0,
        ANGLE_NORTH_EAST: 315,
        ANGLE_NORTH_WEST: 225,
        ANGLE_SOUTH_EAST: 45,
        ANGLE_SOUTH_WEST: 135,
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12,
        blendModes: {
          NORMAL: 0,
          ADD: 1,
          MULTIPLY: 2,
          SCREEN: 3,
          OVERLAY: 4,
          DARKEN: 5,
          LIGHTEN: 6,
          COLOR_DODGE: 7,
          COLOR_BURN: 8,
          HARD_LIGHT: 9,
          SOFT_LIGHT: 10,
          DIFFERENCE: 11,
          EXCLUSION: 12,
          HUE: 13,
          SATURATION: 14,
          COLOR: 15,
          LUMINOSITY: 16,
        },
        scaleModes: { DEFAULT: 0, LINEAR: 0, NEAREST: 1 },
        PIXI: PIXI || {},
      };
    if (
      (Math.trunc ||
        (Math.trunc = function (a) {
          return a < 0 ? Math.ceil(a) : Math.floor(a);
        }),
      Function.prototype.bind ||
        (Function.prototype.bind = (function () {
          var a = Array.prototype.slice;
          return function (b) {
            function c() {
              var f = e.concat(a.call(arguments));
              d.apply(this instanceof c ? this : b, f);
            }
            var d = this,
              e = a.call(arguments, 1);
            if ("function" != typeof d) throw new TypeError();
            return (
              (c.prototype = (function f(a) {
                if ((a && (f.prototype = a), !(this instanceof f))) return new f();
              })(d.prototype)),
              c
            );
          };
        })()),
      Array.isArray ||
        (Array.isArray = function (a) {
          return "[object Array]" === Object.prototype.toString.call(a);
        }),
      Array.prototype.forEach ||
        (Array.prototype.forEach = function (a) {
          "use strict";
          if (void 0 === this || null === this) throw new TypeError();
          var b = Object(this),
            c = b.length >>> 0;
          if ("function" != typeof a) throw new TypeError();
          for (var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; e < c; e++) e in b && a.call(d, b[e], e, b);
        }),
      "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array)
    ) {
      var d = function (a) {
        var b = new Array();
        (window[a] = function (a) {
          if ("number" == typeof a) {
            Array.call(this, a), (this.length = a);
            for (var b = 0; b < this.length; b++) this[b] = 0;
          } else {
            Array.call(this, a.length), (this.length = a.length);
            for (var b = 0; b < this.length; b++) this[b] = a[b];
          }
        }),
          (window[a].prototype = b),
          (window[a].constructor = window[a]);
      };
      d("Uint32Array"), d("Int16Array");
    }
    window.console || ((window.console = {}), (window.console.log = window.console.assert = function () {}), (window.console.warn = window.console.assert = function () {})),
      (c.Utils = {
        reverseString: function (a) {
          return a.split("").reverse().join("");
        },
        getProperty: function (a, b) {
          for (var c = b.split("."), d = c.pop(), e = c.length, f = 1, g = c[0]; f < e && (a = a[g]); ) (g = c[f]), f++;
          return a ? a[d] : null;
        },
        setProperty: function (a, b, c) {
          for (var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; g < f && (a = a[h]); ) (h = d[g]), g++;
          return a && (a[e] = c), a;
        },
        chanceRoll: function (a) {
          return void 0 === a && (a = 50), a > 0 && 100 * Math.random() <= a;
        },
        randomChoice: function (a, b) {
          return Math.random() < 0.5 ? a : b;
        },
        parseDimension: function (a, b) {
          var c = 0,
            d = 0;
          return "string" == typeof a ? ("%" === a.substr(-1) ? ((c = parseInt(a, 10) / 100), (d = 0 === b ? window.innerWidth * c : window.innerHeight * c)) : (d = parseInt(a, 10))) : (d = a), d;
        },
        pad: function (a, b, c, d) {
          if (void 0 === b) var b = 0;
          if (void 0 === c) var c = " ";
          if (void 0 === d) var d = 3;
          a = a.toString();
          var e = 0;
          if (b + 1 >= a.length)
            switch (d) {
              case 1:
                a = new Array(b + 1 - a.length).join(c) + a;
                break;
              case 3:
                var f = Math.ceil((e = b - a.length) / 2),
                  g = e - f;
                a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                break;
              default:
                a += new Array(b + 1 - a.length).join(c);
            }
          return a;
        },
        isPlainObject: function (a) {
          if ("object" != typeof a || a.nodeType || a === a.window) return !1;
          try {
            if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) return !1;
          } catch (a) {
            return !1;
          }
          return !0;
        },
        extend: function () {
          var a,
            b,
            d,
            e,
            f,
            g,
            h = arguments[0] || {},
            i = 1,
            j = arguments.length,
            k = !1;
          for ("boolean" == typeof h && ((k = h), (h = arguments[1] || {}), (i = 2)), j === i && ((h = this), --i); i < j; i++)
            if (null != (a = arguments[i]))
              for (b in a)
                (d = h[b]),
                  (e = a[b]),
                  h !== e &&
                    (k && e && (c.Utils.isPlainObject(e) || (f = Array.isArray(e)))
                      ? (f ? ((f = !1), (g = d && Array.isArray(d) ? d : [])) : (g = d && c.Utils.isPlainObject(d) ? d : {}), (h[b] = c.Utils.extend(k, g, e)))
                      : void 0 !== e && (h[b] = e));
          return h;
        },
        mixinPrototype: function (a, b, c) {
          void 0 === c && (c = !1);
          for (var d = Object.keys(b), e = 0; e < d.length; e++) {
            var f = d[e],
              g = b[f];
            (!c && f in a) || (!g || ("function" != typeof g.get && "function" != typeof g.set) ? (a[f] = g) : "function" == typeof g.clone ? (a[f] = g.clone()) : Object.defineProperty(a, f, g));
          }
        },
        mixin: function (a, b) {
          if (!a || "object" != typeof a) return b;
          for (var d in a) {
            var e = a[d];
            if (!e.childNodes && !e.cloneNode) {
              var f = typeof a[d];
              a[d] && "object" === f ? (typeof b[d] === f ? (b[d] = c.Utils.mixin(a[d], b[d])) : (b[d] = c.Utils.mixin(a[d], new e.constructor()))) : (b[d] = a[d]);
            }
          }
          return b;
        },
      }),
      (c.Circle = function (a, b, d) {
        (a = a || 0), (b = b || 0), (d = d || 0), (this.x = a), (this.y = b), (this._diameter = d), (this._radius = 0), d > 0 && (this._radius = 0.5 * d), (this.type = c.CIRCLE);
      }),
      (c.Circle.prototype = {
        circumference: function () {
          return 2 * (Math.PI * this._radius);
        },
        random: function (a) {
          void 0 === a && (a = new c.Point());
          var b = 2 * Math.PI * Math.random(),
            d = Math.random() + Math.random(),
            e = d > 1 ? 2 - d : d,
            f = e * Math.cos(b),
            g = e * Math.sin(b);
          return (a.x = this.x + f * this.radius), (a.y = this.y + g * this.radius), a;
        },
        getBounds: function () {
          return new c.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
        },
        setTo: function (a, b, c) {
          return (this.x = a), (this.y = b), (this._diameter = c), (this._radius = 0.5 * c), this;
        },
        copyFrom: function (a) {
          return this.setTo(a.x, a.y, a.diameter);
        },
        copyTo: function (a) {
          return (a.x = this.x), (a.y = this.y), (a.diameter = this._diameter), a;
        },
        distance: function (a, b) {
          var d = c.Math.distance(this.x, this.y, a.x, a.y);
          return b ? Math.round(d) : d;
        },
        clone: function (a) {
          return void 0 === a || null === a ? (a = new c.Circle(this.x, this.y, this.diameter)) : a.setTo(this.x, this.y, this.diameter), a;
        },
        contains: function (a, b) {
          return c.Circle.contains(this, a, b);
        },
        circumferencePoint: function (a, b, d) {
          return c.Circle.circumferencePoint(this, a, b, d);
        },
        offset: function (a, b) {
          return (this.x += a), (this.y += b), this;
        },
        offsetPoint: function (a) {
          return this.offset(a.x, a.y);
        },
        toString: function () {
          return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
        },
      }),
      (c.Circle.prototype.constructor = c.Circle),
      Object.defineProperty(c.Circle.prototype, "diameter", {
        get: function () {
          return this._diameter;
        },
        set: function (a) {
          a > 0 && ((this._diameter = a), (this._radius = 0.5 * a));
        },
      }),
      Object.defineProperty(c.Circle.prototype, "radius", {
        get: function () {
          return this._radius;
        },
        set: function (a) {
          a > 0 && ((this._radius = a), (this._diameter = 2 * a));
        },
      }),
      Object.defineProperty(c.Circle.prototype, "left", {
        get: function () {
          return this.x - this._radius;
        },
        set: function (a) {
          a > this.x ? ((this._radius = 0), (this._diameter = 0)) : (this.radius = this.x - a);
        },
      }),
      Object.defineProperty(c.Circle.prototype, "right", {
        get: function () {
          return this.x + this._radius;
        },
        set: function (a) {
          a < this.x ? ((this._radius = 0), (this._diameter = 0)) : (this.radius = a - this.x);
        },
      }),
      Object.defineProperty(c.Circle.prototype, "top", {
        get: function () {
          return this.y - this._radius;
        },
        set: function (a) {
          a > this.y ? ((this._radius = 0), (this._diameter = 0)) : (this.radius = this.y - a);
        },
      }),
      Object.defineProperty(c.Circle.prototype, "bottom", {
        get: function () {
          return this.y + this._radius;
        },
        set: function (a) {
          a < this.y ? ((this._radius = 0), (this._diameter = 0)) : (this.radius = a - this.y);
        },
      }),
      Object.defineProperty(c.Circle.prototype, "area", {
        get: function () {
          return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
        },
      }),
      Object.defineProperty(c.Circle.prototype, "empty", {
        get: function () {
          return 0 === this._diameter;
        },
        set: function (a) {
          a === !0 && this.setTo(0, 0, 0);
        },
      }),
      (c.Circle.contains = function (a, b, c) {
        if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
          var d = (a.x - b) * (a.x - b),
            e = (a.y - c) * (a.y - c);
          return d + e <= a.radius * a.radius;
        }
        return !1;
      }),
      (c.Circle.equals = function (a, b) {
        return a.x === b.x && a.y === b.y && a.diameter === b.diameter;
      }),
      (c.Circle.intersects = function (a, b) {
        return c.Math.distance(a.x, a.y, b.x, b.y) <= a.radius + b.radius;
      }),
      (c.Circle.circumferencePoint = function (a, b, d, e) {
        return void 0 === d && (d = !1), void 0 === e && (e = new c.Point()), d === !0 && (b = c.Math.degToRad(b)), (e.x = a.x + a.radius * Math.cos(b)), (e.y = a.y + a.radius * Math.sin(b)), e;
      }),
      (c.Circle.intersectsRectangle = function (a, b) {
        var c = Math.abs(a.x - b.x - b.halfWidth),
          d = b.halfWidth + a.radius;
        if (c > d) return !1;
        var e = Math.abs(a.y - b.y - b.halfHeight),
          f = b.halfHeight + a.radius;
        if (e > f) return !1;
        if (c <= b.halfWidth || e <= b.halfHeight) return !0;
        var g = c - b.halfWidth,
          h = e - b.halfHeight,
          i = g * g,
          j = h * h,
          k = a.radius * a.radius;
        return i + j <= k;
      }),
      (PIXI.Circle = c.Circle),
      (c.Ellipse = function (a, b, d, e) {
        (a = a || 0), (b = b || 0), (d = d || 0), (e = e || 0), (this.x = a), (this.y = b), (this.width = d), (this.height = e), (this.type = c.ELLIPSE);
      }),
      (c.Ellipse.prototype = {
        setTo: function (a, b, c, d) {
          return (this.x = a), (this.y = b), (this.width = c), (this.height = d), this;
        },
        getBounds: function () {
          return new c.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
        },
        copyFrom: function (a) {
          return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function (a) {
          return (a.x = this.x), (a.y = this.y), (a.width = this.width), (a.height = this.height), a;
        },
        clone: function (a) {
          return void 0 === a || null === a ? (a = new c.Ellipse(this.x, this.y, this.width, this.height)) : a.setTo(this.x, this.y, this.width, this.height), a;
        },
        contains: function (a, b) {
          return c.Ellipse.contains(this, a, b);
        },
        random: function (a) {
          void 0 === a && (a = new c.Point());
          var b = Math.random() * Math.PI * 2,
            d = Math.random();
          return (a.x = Math.sqrt(d) * Math.cos(b)), (a.y = Math.sqrt(d) * Math.sin(b)), (a.x = this.x + (a.x * this.width) / 2), (a.y = this.y + (a.y * this.height) / 2), a;
        },
        toString: function () {
          return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
        },
      }),
      (c.Ellipse.prototype.constructor = c.Ellipse),
      Object.defineProperty(c.Ellipse.prototype, "left", {
        get: function () {
          return this.x;
        },
        set: function (a) {
          this.x = a;
        },
      }),
      Object.defineProperty(c.Ellipse.prototype, "right", {
        get: function () {
          return this.x + this.width;
        },
        set: function (a) {
          a < this.x ? (this.width = 0) : (this.width = a - this.x);
        },
      }),
      Object.defineProperty(c.Ellipse.prototype, "top", {
        get: function () {
          return this.y;
        },
        set: function (a) {
          this.y = a;
        },
      }),
      Object.defineProperty(c.Ellipse.prototype, "bottom", {
        get: function () {
          return this.y + this.height;
        },
        set: function (a) {
          a < this.y ? (this.height = 0) : (this.height = a - this.y);
        },
      }),
      Object.defineProperty(c.Ellipse.prototype, "empty", {
        get: function () {
          return 0 === this.width || 0 === this.height;
        },
        set: function (a) {
          a === !0 && this.setTo(0, 0, 0, 0);
        },
      }),
      (c.Ellipse.contains = function (a, b, c) {
        if (a.width <= 0 || a.height <= 0) return !1;
        var d = (b - a.x) / a.width - 0.5,
          e = (c - a.y) / a.height - 0.5;
        return (d *= d), (e *= e), d + e < 0.25;
      }),
      (PIXI.Ellipse = c.Ellipse),
      (c.Line = function (a, b, d, e) {
        (a = a || 0), (b = b || 0), (d = d || 0), (e = e || 0), (this.start = new c.Point(a, b)), (this.end = new c.Point(d, e)), (this.type = c.LINE);
      }),
      (c.Line.prototype = {
        setTo: function (a, b, c, d) {
          return this.start.setTo(a, b), this.end.setTo(c, d), this;
        },
        fromSprite: function (a, b, c) {
          return void 0 === c && (c = !1), c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y);
        },
        fromAngle: function (a, b, c, d) {
          return this.start.setTo(a, b), this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d), this;
        },
        rotate: function (a, b) {
          var c = (this.start.x + this.end.x) / 2,
            d = (this.start.y + this.end.y) / 2;
          return this.start.rotate(c, d, a, b), this.end.rotate(c, d, a, b), this;
        },
        rotateAround: function (a, b, c, d) {
          return this.start.rotate(a, b, c, d), this.end.rotate(a, b, c, d), this;
        },
        intersects: function (a, b, d) {
          return c.Line.intersectsPoints(this.start, this.end, a.start, a.end, b, d);
        },
        reflect: function (a) {
          return c.Line.reflect(this, a);
        },
        midPoint: function (a) {
          return void 0 === a && (a = new c.Point()), (a.x = (this.start.x + this.end.x) / 2), (a.y = (this.start.y + this.end.y) / 2), a;
        },
        centerOn: function (a, b) {
          var c = (this.start.x + this.end.x) / 2,
            d = (this.start.y + this.end.y) / 2,
            e = a - c,
            f = b - d;
          this.start.add(e, f), this.end.add(e, f);
        },
        pointOnLine: function (a, b) {
          return (a - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (b - this.start.y);
        },
        pointOnSegment: function (a, b) {
          var c = Math.min(this.start.x, this.end.x),
            d = Math.max(this.start.x, this.end.x),
            e = Math.min(this.start.y, this.end.y),
            f = Math.max(this.start.y, this.end.y);
          return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f;
        },
        random: function (a) {
          void 0 === a && (a = new c.Point());
          var b = Math.random();
          return (a.x = this.start.x + b * (this.end.x - this.start.x)), (a.y = this.start.y + b * (this.end.y - this.start.y)), a;
        },
        coordinatesOnLine: function (a, b) {
          void 0 === a && (a = 1), void 0 === b && (b = []);
          var c = Math.round(this.start.x),
            d = Math.round(this.start.y),
            e = Math.round(this.end.x),
            f = Math.round(this.end.y),
            g = Math.abs(e - c),
            h = Math.abs(f - d),
            i = c < e ? 1 : -1,
            j = d < f ? 1 : -1,
            k = g - h;
          b.push([c, d]);
          for (var l = 1; c !== e || d !== f; ) {
            var m = k << 1;
            m > -h && ((k -= h), (c += i)), m < g && ((k += g), (d += j)), l % a === 0 && b.push([c, d]), l++;
          }
          return b;
        },
        clone: function (a) {
          return void 0 === a || null === a ? (a = new c.Line(this.start.x, this.start.y, this.end.x, this.end.y)) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y), a;
        },
      }),
      Object.defineProperty(c.Line.prototype, "length", {
        get: function () {
          return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
        },
      }),
      Object.defineProperty(c.Line.prototype, "angle", {
        get: function () {
          return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "slope", {
        get: function () {
          return (this.end.y - this.start.y) / (this.end.x - this.start.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "perpSlope", {
        get: function () {
          return -((this.end.x - this.start.x) / (this.end.y - this.start.y));
        },
      }),
      Object.defineProperty(c.Line.prototype, "x", {
        get: function () {
          return Math.min(this.start.x, this.end.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "y", {
        get: function () {
          return Math.min(this.start.y, this.end.y);
        },
      }),
      Object.defineProperty(c.Line.prototype, "left", {
        get: function () {
          return Math.min(this.start.x, this.end.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "right", {
        get: function () {
          return Math.max(this.start.x, this.end.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "top", {
        get: function () {
          return Math.min(this.start.y, this.end.y);
        },
      }),
      Object.defineProperty(c.Line.prototype, "bottom", {
        get: function () {
          return Math.max(this.start.y, this.end.y);
        },
      }),
      Object.defineProperty(c.Line.prototype, "width", {
        get: function () {
          return Math.abs(this.start.x - this.end.x);
        },
      }),
      Object.defineProperty(c.Line.prototype, "height", {
        get: function () {
          return Math.abs(this.start.y - this.end.y);
        },
      }),
      Object.defineProperty(c.Line.prototype, "normalX", {
        get: function () {
          return Math.cos(this.angle - 1.5707963267948966);
        },
      }),
      Object.defineProperty(c.Line.prototype, "normalY", {
        get: function () {
          return Math.sin(this.angle - 1.5707963267948966);
        },
      }),
      Object.defineProperty(c.Line.prototype, "normalAngle", {
        get: function () {
          return c.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
        },
      }),
      (c.Line.intersectsPoints = function (a, b, d, e, f, g) {
        void 0 === f && (f = !0), void 0 === g && (g = new c.Point());
        var h = b.y - a.y,
          i = e.y - d.y,
          j = a.x - b.x,
          k = d.x - e.x,
          l = b.x * a.y - a.x * b.y,
          m = e.x * d.y - d.x * e.y,
          n = h * k - i * j;
        if (0 === n) return null;
        if (((g.x = (j * m - k * l) / n), (g.y = (i * l - h * m) / n), f)) {
          var o = (e.y - d.y) * (b.x - a.x) - (e.x - d.x) * (b.y - a.y),
            p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o,
            q = ((b.x - a.x) * (a.y - d.y) - (b.y - a.y) * (a.x - d.x)) / o;
          return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null;
        }
        return g;
      }),
      (c.Line.intersects = function (a, b, d, e) {
        return c.Line.intersectsPoints(a.start, a.end, b.start, b.end, d, e);
      }),
      (c.Line.intersectsRectangle = function (a, b) {
        if (!c.Rectangle.intersects(a, b)) return !1;
        var d = a.start.x,
          e = a.start.y,
          f = a.end.x,
          g = a.end.y,
          h = b.x,
          i = b.y,
          j = b.right,
          k = b.bottom,
          l = 0;
        if ((d >= h && d <= j && e >= i && e <= k) || (f >= h && f <= j && g >= i && g <= k)) return !0;
        if (d < h && f >= h) {
          if (((l = e + ((g - e) * (h - d)) / (f - d)), l > i && l <= k)) return !0;
        } else if (d > j && f <= j && ((l = e + ((g - e) * (j - d)) / (f - d)), l >= i && l <= k)) return !0;
        if (e < i && g >= i) {
          if (((l = d + ((f - d) * (i - e)) / (g - e)), l >= h && l <= j)) return !0;
        } else if (e > k && g <= k && ((l = d + ((f - d) * (k - e)) / (g - e)), l >= h && l <= j)) return !0;
        return !1;
      }),
      (c.Line.reflect = function (a, b) {
        return 2 * b.normalAngle - 3.141592653589793 - a.angle;
      }),
      (c.Matrix = function (a, b, d, e, f, g) {
        (void 0 !== a && null !== a) || (a = 1),
          (void 0 !== b && null !== b) || (b = 0),
          (void 0 !== d && null !== d) || (d = 0),
          (void 0 !== e && null !== e) || (e = 1),
          (void 0 !== f && null !== f) || (f = 0),
          (void 0 !== g && null !== g) || (g = 0),
          (this.a = a),
          (this.b = b),
          (this.c = d),
          (this.d = e),
          (this.tx = f),
          (this.ty = g),
          (this.type = c.MATRIX);
      }),
      (c.Matrix.prototype = {
        fromArray: function (a) {
          return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5]);
        },
        setTo: function (a, b, c, d, e, f) {
          return (this.a = a), (this.b = b), (this.c = c), (this.d = d), (this.tx = e), (this.ty = f), this;
        },
        clone: function (a) {
          return void 0 === a || null === a ? (a = new c.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty)) : ((a.a = this.a), (a.b = this.b), (a.c = this.c), (a.d = this.d), (a.tx = this.tx), (a.ty = this.ty)), a;
        },
        copyTo: function (a) {
          return a.copyFrom(this), a;
        },
        copyFrom: function (a) {
          return (this.a = a.a), (this.b = a.b), (this.c = a.c), (this.d = a.d), (this.tx = a.tx), (this.ty = a.ty), this;
        },
        toArray: function (a, b) {
          return (
            void 0 === b && (b = new PIXI.Float32Array(9)),
            a
              ? ((b[0] = this.a), (b[1] = this.b), (b[2] = 0), (b[3] = this.c), (b[4] = this.d), (b[5] = 0), (b[6] = this.tx), (b[7] = this.ty), (b[8] = 1))
              : ((b[0] = this.a), (b[1] = this.c), (b[2] = this.tx), (b[3] = this.b), (b[4] = this.d), (b[5] = this.ty), (b[6] = 0), (b[7] = 0), (b[8] = 1)),
            b
          );
        },
        apply: function (a, b) {
          return void 0 === b && (b = new c.Point()), (b.x = this.a * a.x + this.c * a.y + this.tx), (b.y = this.b * a.x + this.d * a.y + this.ty), b;
        },
        applyInverse: function (a, b) {
          void 0 === b && (b = new c.Point());
          var d = 1 / (this.a * this.d + this.c * -this.b),
            e = a.x,
            f = a.y;
          return (b.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d), (b.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d), b;
        },
        translate: function (a, b) {
          return (this.tx += a), (this.ty += b), this;
        },
        scale: function (a, b) {
          return (this.a *= a), (this.d *= b), (this.c *= a), (this.b *= b), (this.tx *= a), (this.ty *= b), this;
        },
        rotate: function (a) {
          var b = Math.cos(a),
            c = Math.sin(a),
            d = this.a,
            e = this.c,
            f = this.tx;
          return (this.a = d * b - this.b * c), (this.b = d * c + this.b * b), (this.c = e * b - this.d * c), (this.d = e * c + this.d * b), (this.tx = f * b - this.ty * c), (this.ty = f * c + this.ty * b), this;
        },
        append: function (a) {
          var b = this.a,
            c = this.b,
            d = this.c,
            e = this.d;
          return (this.a = a.a * b + a.b * d), (this.b = a.a * c + a.b * e), (this.c = a.c * b + a.d * d), (this.d = a.c * c + a.d * e), (this.tx = a.tx * b + a.ty * d + this.tx), (this.ty = a.tx * c + a.ty * e + this.ty), this;
        },
        identity: function () {
          return this.setTo(1, 0, 0, 1, 0, 0);
        },
      }),
      (c.identityMatrix = new c.Matrix()),
      (PIXI.Matrix = c.Matrix),
      (PIXI.identityMatrix = c.identityMatrix),
      (c.Point = function (a, b) {
        (a = a || 0), (b = b || 0), (this.x = a), (this.y = b), (this.type = c.POINT);
      }),
      (c.Point.prototype = {
        copyFrom: function (a) {
          return this.setTo(a.x, a.y);
        },
        invert: function () {
          return this.setTo(this.y, this.x);
        },
        setTo: function (a, b) {
          return (this.x = a || 0), (this.y = b || (0 !== b ? this.x : 0)), this;
        },
        set: function (a, b) {
          return (this.x = a || 0), (this.y = b || (0 !== b ? this.x : 0)), this;
        },
        add: function (a, b) {
          return (this.x += a), (this.y += b), this;
        },
        subtract: function (a, b) {
          return (this.x -= a), (this.y -= b), this;
        },
        multiply: function (a, b) {
          return (this.x *= a), (this.y *= b), this;
        },
        divide: function (a, b) {
          return (this.x /= a), (this.y /= b), this;
        },
        clampX: function (a, b) {
          return (this.x = c.Math.clamp(this.x, a, b)), this;
        },
        clampY: function (a, b) {
          return (this.y = c.Math.clamp(this.y, a, b)), this;
        },
        clamp: function (a, b) {
          return (this.x = c.Math.clamp(this.x, a, b)), (this.y = c.Math.clamp(this.y, a, b)), this;
        },
        clone: function (a) {
          return void 0 === a || null === a ? (a = new c.Point(this.x, this.y)) : a.setTo(this.x, this.y), a;
        },
        copyTo: function (a) {
          return (a.x = this.x), (a.y = this.y), a;
        },
        distance: function (a, b) {
          return c.Point.distance(this, a, b);
        },
        equals: function (a) {
          return a.x === this.x && a.y === this.y;
        },
        angle: function (a, b) {
          return void 0 === b && (b = !1), b ? c.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x);
        },
        rotate: function (a, b, d, e, f) {
          return c.Point.rotate(this, a, b, d, e, f);
        },
        getMagnitude: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        getMagnitudeSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        setMagnitude: function (a) {
          return this.normalize().multiply(a, a);
        },
        normalize: function () {
          if (!this.isZero()) {
            var a = this.getMagnitude();
            (this.x /= a), (this.y /= a);
          }
          return this;
        },
        isZero: function () {
          return 0 === this.x && 0 === this.y;
        },
        dot: function (a) {
          return this.x * a.x + this.y * a.y;
        },
        cross: function (a) {
          return this.x * a.y - this.y * a.x;
        },
        perp: function () {
          return this.setTo(-this.y, this.x);
        },
        rperp: function () {
          return this.setTo(this.y, -this.x);
        },
        normalRightHand: function () {
          return this.setTo(this.y * -1, this.x);
        },
        floor: function () {
          return this.setTo(Math.floor(this.x), Math.floor(this.y));
        },
        ceil: function () {
          return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
        },
        toString: function () {
          return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
        },
      }),
      (c.Point.prototype.constructor = c.Point),
      (c.Point.add = function (a, b, d) {
        return void 0 === d && (d = new c.Point()), (d.x = a.x + b.x), (d.y = a.y + b.y), d;
      }),
      (c.Point.subtract = function (a, b, d) {
        return void 0 === d && (d = new c.Point()), (d.x = a.x - b.x), (d.y = a.y - b.y), d;
      }),
      (c.Point.multiply = function (a, b, d) {
        return void 0 === d && (d = new c.Point()), (d.x = a.x * b.x), (d.y = a.y * b.y), d;
      }),
      (c.Point.divide = function (a, b, d) {
        return void 0 === d && (d = new c.Point()), (d.x = a.x / b.x), (d.y = a.y / b.y), d;
      }),
      (c.Point.equals = function (a, b) {
        return a.x === b.x && a.y === b.y;
      }),
      (c.Point.angle = function (a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x);
      }),
      (c.Point.negative = function (a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(-a.x, -a.y);
      }),
      (c.Point.multiplyAdd = function (a, b, d, e) {
        return void 0 === e && (e = new c.Point()), e.setTo(a.x + b.x * d, a.y + b.y * d);
      }),
      (c.Point.interpolate = function (a, b, d, e) {
        return void 0 === e && (e = new c.Point()), e.setTo(a.x + (b.x - a.x) * d, a.y + (b.y - a.y) * d);
      }),
      (c.Point.perp = function (a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(-a.y, a.x);
      }),
      (c.Point.rperp = function (a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(a.y, -a.x);
      }),
      (c.Point.distance = function (a, b, d) {
        var e = c.Math.distance(a.x, a.y, b.x, b.y);
        return d ? Math.round(e) : e;
      }),
      (c.Point.project = function (a, b, d) {
        void 0 === d && (d = new c.Point());
        var e = a.dot(b) / b.getMagnitudeSq();
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
      }),
      (c.Point.projectUnit = function (a, b, d) {
        void 0 === d && (d = new c.Point());
        var e = a.dot(b);
        return 0 !== e && d.setTo(e * b.x, e * b.y), d;
      }),
      (c.Point.normalRightHand = function (a, b) {
        return void 0 === b && (b = new c.Point()), b.setTo(a.y * -1, a.x);
      }),
      (c.Point.normalize = function (a, b) {
        void 0 === b && (b = new c.Point());
        var d = a.getMagnitude();
        return 0 !== d && b.setTo(a.x / d, a.y / d), b;
      }),
      (c.Point.rotate = function (a, b, d, e, f, g) {
        if ((f && (e = c.Math.degToRad(e)), void 0 === g)) {
          a.subtract(b, d);
          var h = Math.sin(e),
            i = Math.cos(e),
            j = i * a.x - h * a.y,
            k = h * a.x + i * a.y;
          (a.x = j + b), (a.y = k + d);
        } else {
          var l = e + Math.atan2(a.y - d, a.x - b);
          (a.x = b + g * Math.cos(l)), (a.y = d + g * Math.sin(l));
        }
        return a;
      }),
      (c.Point.centroid = function (a, b) {
        if ((void 0 === b && (b = new c.Point()), "[object Array]" !== Object.prototype.toString.call(a))) throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var d = a.length;
        if (d < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === d) return b.copyFrom(a[0]), b;
        for (var e = 0; e < d; e++) c.Point.add(b, a[e], b);
        return b.divide(d, d), b;
      }),
      (c.Point.parse = function (a, b, d) {
        (b = b || "x"), (d = d || "y");
        var e = new c.Point();
        return a[b] && (e.x = parseInt(a[b], 10)), a[d] && (e.y = parseInt(a[d], 10)), e;
      }),
      (PIXI.Point = c.Point),
      (c.Polygon = function () {
        (this.area = 0), (this._points = []), arguments.length > 0 && this.setTo.apply(this, arguments), (this.closed = !0), (this.flattened = !1), (this.type = c.POLYGON);
      }),
      (c.Polygon.prototype = {
        toNumberArray: function (a) {
          void 0 === a && (a = []);
          for (var b = 0; b < this._points.length; b++) "number" == typeof this._points[b] ? (a.push(this._points[b]), a.push(this._points[b + 1]), b++) : (a.push(this._points[b].x), a.push(this._points[b].y));
          return a;
        },
        flatten: function () {
          return (this._points = this.toNumberArray()), (this.flattened = !0), this;
        },
        clone: function (a) {
          var b = this._points.slice();
          return void 0 === a || null === a ? (a = new c.Polygon(b)) : a.setTo(b), a;
        },
        contains: function (a, b) {
          var c = !1;
          if (this.flattened)
            for (var d = -2, e = this._points.length - 2; (d += 2) < this._points.length; e = d) {
              var f = this._points[d],
                g = this._points[d + 1],
                h = this._points[e],
                i = this._points[e + 1];
              ((g <= b && b < i) || (i <= b && b < g)) && a < ((h - f) * (b - g)) / (i - g) + f && (c = !c);
            }
          else
            for (var d = -1, e = this._points.length - 1; ++d < this._points.length; e = d) {
              var f = this._points[d].x,
                g = this._points[d].y,
                h = this._points[e].x,
                i = this._points[e].y;
              ((g <= b && b < i) || (i <= b && b < g)) && a < ((h - f) * (b - g)) / (i - g) + f && (c = !c);
            }
          return c;
        },
        setTo: function (a) {
          if (((this.area = 0), (this._points = []), arguments.length > 0)) {
            Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
            for (var b = Number.MAX_VALUE, c = 0, d = a.length; c < d; c++) {
              if ("number" == typeof a[c]) {
                var e = new PIXI.Point(a[c], a[c + 1]);
                c++;
              } else if (Array.isArray(a[c])) var e = new PIXI.Point(a[c][0], a[c][1]);
              else var e = new PIXI.Point(a[c].x, a[c].y);
              this._points.push(e), e.y < b && (b = e.y);
            }
            this.calculateArea(b);
          }
          return this;
        },
        calculateArea: function (a) {
          for (var b, c, d, e, f = 0, g = this._points.length; f < g; f++) (b = this._points[f]), (c = f === g - 1 ? this._points[0] : this._points[f + 1]), (d = (b.y - a + (c.y - a)) / 2), (e = b.x - c.x), (this.area += d * e);
          return this.area;
        },
      }),
      (c.Polygon.prototype.constructor = c.Polygon),
      Object.defineProperty(c.Polygon.prototype, "points", {
        get: function () {
          return this._points;
        },
        set: function (a) {
          null != a ? this.setTo(a) : this.setTo();
        },
      }),
      (PIXI.Polygon = c.Polygon),
      (c.Rectangle = function (a, b, d, e) {
        (a = a || 0), (b = b || 0), (d = d || 0), (e = e || 0), (this.x = a), (this.y = b), (this.width = d), (this.height = e), (this.type = c.RECTANGLE);
      }),
      (c.Rectangle.prototype = {
        offset: function (a, b) {
          return (this.x += a), (this.y += b), this;
        },
        offsetPoint: function (a) {
          return this.offset(a.x, a.y);
        },
        setTo: function (a, b, c, d) {
          return (this.x = a), (this.y = b), (this.width = c), (this.height = d), this;
        },
        scale: function (a, b) {
          return void 0 === b && (b = a), (this.width *= a), (this.height *= b), this;
        },
        centerOn: function (a, b) {
          return (this.centerX = a), (this.centerY = b), this;
        },
        floor: function () {
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y));
        },
        floorAll: function () {
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.width = Math.floor(this.width)), (this.height = Math.floor(this.height));
        },
        ceil: function () {
          (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y));
        },
        ceilAll: function () {
          (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.width = Math.ceil(this.width)), (this.height = Math.ceil(this.height));
        },
        copyFrom: function (a) {
          return this.setTo(a.x, a.y, a.width, a.height);
        },
        copyTo: function (a) {
          return (a.x = this.x), (a.y = this.y), (a.width = this.width), (a.height = this.height), a;
        },
        inflate: function (a, b) {
          return c.Rectangle.inflate(this, a, b);
        },
        size: function (a) {
          return c.Rectangle.size(this, a);
        },
        resize: function (a, b) {
          return (this.width = a), (this.height = b), this;
        },
        clone: function (a) {
          return c.Rectangle.clone(this, a);
        },
        contains: function (a, b) {
          return c.Rectangle.contains(this, a, b);
        },
        containsRect: function (a) {
          return c.Rectangle.containsRect(a, this);
        },
        equals: function (a) {
          return c.Rectangle.equals(this, a);
        },
        intersection: function (a, b) {
          return c.Rectangle.intersection(this, a, b);
        },
        intersects: function (a) {
          return c.Rectangle.intersects(this, a);
        },
        intersectsRaw: function (a, b, d, e, f) {
          return c.Rectangle.intersectsRaw(this, a, b, d, e, f);
        },
        union: function (a, b) {
          return c.Rectangle.union(this, a, b);
        },
        random: function (a) {
          return void 0 === a && (a = new c.Point()), (a.x = this.randomX), (a.y = this.randomY), a;
        },
        getPoint: function (a, b) {
          switch ((void 0 === b && (b = new c.Point()), a)) {
            default:
            case c.TOP_LEFT:
              return b.set(this.x, this.y);
            case c.TOP_CENTER:
              return b.set(this.centerX, this.y);
            case c.TOP_RIGHT:
              return b.set(this.right, this.y);
            case c.LEFT_CENTER:
              return b.set(this.x, this.centerY);
            case c.CENTER:
              return b.set(this.centerX, this.centerY);
            case c.RIGHT_CENTER:
              return b.set(this.right, this.centerY);
            case c.BOTTOM_LEFT:
              return b.set(this.x, this.bottom);
            case c.BOTTOM_CENTER:
              return b.set(this.centerX, this.bottom);
            case c.BOTTOM_RIGHT:
              return b.set(this.right, this.bottom);
          }
        },
        toString: function () {
          return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "halfWidth", {
        get: function () {
          return Math.round(this.width / 2);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "halfHeight", {
        get: function () {
          return Math.round(this.height / 2);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "bottom", {
        get: function () {
          return this.y + this.height;
        },
        set: function (a) {
          a <= this.y ? (this.height = 0) : (this.height = a - this.y);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "bottomLeft", {
        get: function () {
          return new c.Point(this.x, this.bottom);
        },
        set: function (a) {
          (this.x = a.x), (this.bottom = a.y);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "bottomRight", {
        get: function () {
          return new c.Point(this.right, this.bottom);
        },
        set: function (a) {
          (this.right = a.x), (this.bottom = a.y);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "left", {
        get: function () {
          return this.x;
        },
        set: function (a) {
          a >= this.right ? (this.width = 0) : (this.width = this.right - a), (this.x = a);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "right", {
        get: function () {
          return this.x + this.width;
        },
        set: function (a) {
          a <= this.x ? (this.width = 0) : (this.width = a - this.x);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "volume", {
        get: function () {
          return this.width * this.height;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "perimeter", {
        get: function () {
          return 2 * this.width + 2 * this.height;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "centerX", {
        get: function () {
          return this.x + this.halfWidth;
        },
        set: function (a) {
          this.x = a - this.halfWidth;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "centerY", {
        get: function () {
          return this.y + this.halfHeight;
        },
        set: function (a) {
          this.y = a - this.halfHeight;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "randomX", {
        get: function () {
          return this.x + Math.random() * this.width;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "randomY", {
        get: function () {
          return this.y + Math.random() * this.height;
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "top", {
        get: function () {
          return this.y;
        },
        set: function (a) {
          a >= this.bottom ? ((this.height = 0), (this.y = a)) : (this.height = this.bottom - a);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "topLeft", {
        get: function () {
          return new c.Point(this.x, this.y);
        },
        set: function (a) {
          (this.x = a.x), (this.y = a.y);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "topRight", {
        get: function () {
          return new c.Point(this.x + this.width, this.y);
        },
        set: function (a) {
          (this.right = a.x), (this.y = a.y);
        },
      }),
      Object.defineProperty(c.Rectangle.prototype, "empty", {
        get: function () {
          return !this.width || !this.height;
        },
        set: function (a) {
          a === !0 && this.setTo(0, 0, 0, 0);
        },
      }),
      (c.Rectangle.prototype.constructor = c.Rectangle),
      (c.Rectangle.inflate = function (a, b, c) {
        return (a.x -= b), (a.width += 2 * b), (a.y -= c), (a.height += 2 * c), a;
      }),
      (c.Rectangle.inflatePoint = function (a, b) {
        return c.Rectangle.inflate(a, b.x, b.y);
      }),
      (c.Rectangle.size = function (a, b) {
        return void 0 === b || null === b ? (b = new c.Point(a.width, a.height)) : b.setTo(a.width, a.height), b;
      }),
      (c.Rectangle.clone = function (a, b) {
        return void 0 === b || null === b ? (b = new c.Rectangle(a.x, a.y, a.width, a.height)) : b.setTo(a.x, a.y, a.width, a.height), b;
      }),
      (c.Rectangle.contains = function (a, b, c) {
        return !(a.width <= 0 || a.height <= 0) && b >= a.x && b < a.right && c >= a.y && c < a.bottom;
      }),
      (c.Rectangle.containsRaw = function (a, b, c, d, e, f) {
        return e >= a && e < a + c && f >= b && f < b + d;
      }),
      (c.Rectangle.containsPoint = function (a, b) {
        return c.Rectangle.contains(a, b.x, b.y);
      }),
      (c.Rectangle.containsRect = function (a, b) {
        return !(a.volume > b.volume) && a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
      }),
      (c.Rectangle.equals = function (a, b) {
        return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
      }),
      (c.Rectangle.sameDimensions = function (a, b) {
        return a.width === b.width && a.height === b.height;
      }),
      (c.Rectangle.intersection = function (a, b, d) {
        return (
          void 0 === d && (d = new c.Rectangle()), c.Rectangle.intersects(a, b) && ((d.x = Math.max(a.x, b.x)), (d.y = Math.max(a.y, b.y)), (d.width = Math.min(a.right, b.right) - d.x), (d.height = Math.min(a.bottom, b.bottom) - d.y)), d
        );
      }),
      (c.Rectangle.intersects = function (a, b) {
        return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0 || a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
      }),
      (c.Rectangle.intersectsRaw = function (a, b, c, d, e, f) {
        return void 0 === f && (f = 0), !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f);
      }),
      (c.Rectangle.union = function (a, b, d) {
        return void 0 === d && (d = new c.Rectangle()), d.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));
      }),
      (c.Rectangle.aabb = function (a, b) {
        void 0 === b && (b = new c.Rectangle());
        var d = Number.NEGATIVE_INFINITY,
          e = Number.POSITIVE_INFINITY,
          f = Number.NEGATIVE_INFINITY,
          g = Number.POSITIVE_INFINITY;
        return (
          a.forEach(function (a) {
            a.x > d && (d = a.x), a.x < e && (e = a.x), a.y > f && (f = a.y), a.y < g && (g = a.y);
          }),
          b.setTo(e, g, d - e, f - g),
          b
        );
      }),
      (PIXI.Rectangle = c.Rectangle),
      (PIXI.EmptyRectangle = new c.Rectangle(0, 0, 0, 0)),
      (c.RoundedRectangle = function (a, b, d, e, f) {
        void 0 === a && (a = 0),
          void 0 === b && (b = 0),
          void 0 === d && (d = 0),
          void 0 === e && (e = 0),
          void 0 === f && (f = 20),
          (this.x = a),
          (this.y = b),
          (this.width = d),
          (this.height = e),
          (this.radius = f || 20),
          (this.type = c.ROUNDEDRECTANGLE);
      }),
      (c.RoundedRectangle.prototype = {
        clone: function () {
          return new c.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        },
        contains: function (a, b) {
          if (this.width <= 0 || this.height <= 0) return !1;
          var c = this.x;
          if (a >= c && a <= c + this.width) {
            var d = this.y;
            if (b >= d && b <= d + this.height) return !0;
          }
          return !1;
        },
      }),
      (c.RoundedRectangle.prototype.constructor = c.RoundedRectangle),
      (PIXI.RoundedRectangle = c.RoundedRectangle),
      (c.Camera = function (a, b, d, e, f, g) {
        (this.game = a),
          (this.world = a.world),
          (this.id = 0),
          (this.view = new c.Rectangle(d, e, f, g)),
          (this.bounds = new c.Rectangle(d, e, f, g)),
          (this.deadzone = null),
          (this.visible = !0),
          (this.roundPx = !0),
          (this.atLimit = { x: !1, y: !1 }),
          (this.target = null),
          (this.displayObject = null),
          (this.scale = null),
          (this.totalInView = 0),
          (this.lerp = new c.Point(1, 1)),
          (this.onShakeComplete = new c.Signal()),
          (this.onFlashComplete = new c.Signal()),
          (this.onFadeComplete = new c.Signal()),
          (this.fx = null),
          (this._targetPosition = new c.Point()),
          (this._edge = 0),
          (this._position = new c.Point()),
          (this._shake = { intensity: 0, duration: 0, horizontal: !1, vertical: !1, shakeBounds: !0, x: 0, y: 0 }),
          (this._fxDuration = 0),
          (this._fxType = 0);
      }),
      (c.Camera.FOLLOW_LOCKON = 0),
      (c.Camera.FOLLOW_PLATFORMER = 1),
      (c.Camera.FOLLOW_TOPDOWN = 2),
      (c.Camera.FOLLOW_TOPDOWN_TIGHT = 3),
      (c.Camera.SHAKE_BOTH = 4),
      (c.Camera.SHAKE_HORIZONTAL = 5),
      (c.Camera.SHAKE_VERTICAL = 6),
      (c.Camera.ENABLE_FX = !0),
      (c.Camera.prototype = {
        boot: function () {
          (this.displayObject = this.game.world), (this.scale = this.game.world.scale), (this.game.camera = this), c.Graphics && c.Camera.ENABLE_FX && ((this.fx = new c.Graphics(this.game)), this.game.stage.addChild(this.fx));
        },
        preUpdate: function () {
          this.totalInView = 0;
        },
        follow: function (a, b, d, e) {
          void 0 === b && (b = c.Camera.FOLLOW_LOCKON), void 0 === d && (d = 1), void 0 === e && (e = 1), (this.target = a), this.lerp.set(d, e);
          var f;
          switch (b) {
            case c.Camera.FOLLOW_PLATFORMER:
              var g = this.width / 8,
                h = this.height / 3;
              this.deadzone = new c.Rectangle((this.width - g) / 2, (this.height - h) / 2 - 0.25 * h, g, h);
              break;
            case c.Camera.FOLLOW_TOPDOWN:
              (f = Math.max(this.width, this.height) / 4), (this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f));
              break;
            case c.Camera.FOLLOW_TOPDOWN_TIGHT:
              (f = Math.max(this.width, this.height) / 8), (this.deadzone = new c.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f));
              break;
            case c.Camera.FOLLOW_LOCKON:
              this.deadzone = null;
              break;
            default:
              this.deadzone = null;
          }
        },
        unfollow: function () {
          this.target = null;
        },
        focusOn: function (a) {
          this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight));
        },
        focusOnXY: function (a, b) {
          this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight));
        },
        shake: function (a, b, d, e, f) {
          return (
            void 0 === a && (a = 0.05),
            void 0 === b && (b = 500),
            void 0 === d && (d = !0),
            void 0 === e && (e = c.Camera.SHAKE_BOTH),
            void 0 === f && (f = !0),
            !(
              (!d && this._shake.duration > 0) ||
              ((this._shake.intensity = a),
              (this._shake.duration = b),
              (this._shake.shakeBounds = f),
              (this._shake.x = 0),
              (this._shake.y = 0),
              (this._shake.horizontal = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_HORIZONTAL),
              (this._shake.vertical = e === c.Camera.SHAKE_BOTH || e === c.Camera.SHAKE_VERTICAL),
              0)
            )
          );
        },
        flash: function (a, b, c) {
          return (
            void 0 === a && (a = 16777215),
            void 0 === b && (b = 500),
            void 0 === c && (c = !1),
            !(!this.fx || (!c && this._fxDuration > 0) || (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), (this.fx.alpha = 1), (this._fxDuration = b), (this._fxType = 0), 0))
          );
        },
        fade: function (a, b, c) {
          return (
            void 0 === a && (a = 0),
            void 0 === b && (b = 500),
            void 0 === c && (c = !1),
            !(!this.fx || (!c && this._fxDuration > 0) || (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), (this.fx.alpha = 0), (this._fxDuration = b), (this._fxType = 1), 0))
          );
        },
        update: function () {
          this._fxDuration > 0 && this.updateFX(),
            this._shake.duration > 0 && this.updateShake(),
            this.bounds && this.checkBounds(),
            this.roundPx && (this.view.floor(), (this._shake.x = Math.floor(this._shake.x)), (this._shake.y = Math.floor(this._shake.y))),
            (this.displayObject.position.x = -this.view.x),
            (this.displayObject.position.y = -this.view.y);
        },
        updateFX: function () {
          0 === this._fxType
            ? ((this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration), this.fx.alpha <= 0 && ((this._fxDuration = 0), (this.fx.alpha = 0), this.onFlashComplete.dispatch()))
            : ((this.fx.alpha += this.game.time.elapsedMS / this._fxDuration), this.fx.alpha >= 1 && ((this._fxDuration = 0), (this.fx.alpha = 1), this.onFadeComplete.dispatch()));
        },
        updateShake: function () {
          (this._shake.duration -= this.game.time.elapsedMS),
            this._shake.duration <= 0
              ? (this.onShakeComplete.dispatch(), (this._shake.x = 0), (this._shake.y = 0))
              : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width),
                this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height));
        },
        updateTarget: function () {
          (this._targetPosition.x = this.view.x + this.target.worldPosition.x),
            (this._targetPosition.y = this.view.y + this.target.worldPosition.y),
            this.deadzone
              ? ((this._edge = this._targetPosition.x - this.view.x),
                this._edge < this.deadzone.left
                  ? (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x))
                  : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)),
                (this._edge = this._targetPosition.y - this.view.y),
                this._edge < this.deadzone.top
                  ? (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y))
                  : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y)))
              : ((this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x)), (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y))),
            this.bounds && this.checkBounds(),
            this.roundPx && this.view.floor(),
            (this.displayObject.position.x = -this.view.x),
            (this.displayObject.position.y = -this.view.y);
        },
        setBoundsToWorld: function () {
          this.bounds && this.bounds.copyFrom(this.game.world.bounds);
        },
        checkBounds: function () {
          (this.atLimit.x = !1), (this.atLimit.y = !1);
          var a = this.view.x + this._shake.x,
            b = this.view.right + this._shake.x,
            c = this.view.y + this._shake.y,
            d = this.view.bottom + this._shake.y;
          a <= this.bounds.x * this.scale.x && ((this.atLimit.x = !0), (this.view.x = this.bounds.x * this.scale.x), this._shake.shakeBounds || (this._shake.x = 0)),
            b >= this.bounds.right * this.scale.x && ((this.atLimit.x = !0), (this.view.x = this.bounds.right * this.scale.x - this.width), this._shake.shakeBounds || (this._shake.x = 0)),
            c <= this.bounds.top * this.scale.y && ((this.atLimit.y = !0), (this.view.y = this.bounds.top * this.scale.y), this._shake.shakeBounds || (this._shake.y = 0)),
            d >= this.bounds.bottom * this.scale.y && ((this.atLimit.y = !0), (this.view.y = this.bounds.bottom * this.scale.y - this.height), this._shake.shakeBounds || (this._shake.y = 0));
        },
        setPosition: function (a, b) {
          (this.view.x = a), (this.view.y = b), this.bounds && this.checkBounds();
        },
        setSize: function (a, b) {
          (this.view.width = a), (this.view.height = b);
        },
        reset: function () {
          (this.target = null), (this.view.x = 0), (this.view.y = 0), (this._shake.duration = 0), this.resetFX();
        },
        resetFX: function () {
          this.fx.clear(), (this.fx.alpha = 0), (this._fxDuration = 0);
        },
      }),
      (c.Camera.prototype.constructor = c.Camera),
      Object.defineProperty(c.Camera.prototype, "x", {
        get: function () {
          return this.view.x;
        },
        set: function (a) {
          (this.view.x = a), this.bounds && this.checkBounds();
        },
      }),
      Object.defineProperty(c.Camera.prototype, "y", {
        get: function () {
          return this.view.y;
        },
        set: function (a) {
          (this.view.y = a), this.bounds && this.checkBounds();
        },
      }),
      Object.defineProperty(c.Camera.prototype, "position", {
        get: function () {
          return this._position.set(this.view.x, this.view.y), this._position;
        },
        set: function (a) {
          "undefined" != typeof a.x && (this.view.x = a.x), "undefined" != typeof a.y && (this.view.y = a.y), this.bounds && this.checkBounds();
        },
      }),
      Object.defineProperty(c.Camera.prototype, "width", {
        get: function () {
          return this.view.width;
        },
        set: function (a) {
          this.view.width = a;
        },
      }),
      Object.defineProperty(c.Camera.prototype, "height", {
        get: function () {
          return this.view.height;
        },
        set: function (a) {
          this.view.height = a;
        },
      }),
      Object.defineProperty(c.Camera.prototype, "shakeIntensity", {
        get: function () {
          return this._shake.intensity;
        },
        set: function (a) {
          this._shake.intensity = a;
        },
      }),
      (c.State = function () {
        (this.game = null),
          (this.key = ""),
          (this.add = null),
          (this.make = null),
          (this.camera = null),
          (this.cache = null),
          (this.input = null),
          (this.load = null),
          (this.math = null),
          (this.sound = null),
          (this.scale = null),
          (this.stage = null),
          (this.state = null),
          (this.time = null),
          (this.tweens = null),
          (this.world = null),
          (this.particles = null),
          (this.physics = null),
          (this.rnd = null);
      }),
      (c.State.prototype = {
        init: function () {},
        preload: function () {},
        loadUpdate: function () {},
        loadRender: function () {},
        create: function () {},
        update: function () {},
        preRender: function () {},
        render: function () {},
        resize: function () {},
        paused: function () {},
        resumed: function () {},
        pauseUpdate: function () {},
        shutdown: function () {},
      }),
      (c.State.prototype.constructor = c.State),
      (c.StateManager = function (a, b) {
        (this.game = a),
          (this.states = {}),
          (this._pendingState = null),
          "undefined" != typeof b && null !== b && (this._pendingState = b),
          (this._clearWorld = !1),
          (this._clearCache = !1),
          (this._created = !1),
          (this._args = []),
          (this.current = ""),
          (this.onStateChange = new c.Signal()),
          (this.onInitCallback = null),
          (this.onPreloadCallback = null),
          (this.onCreateCallback = null),
          (this.onUpdateCallback = null),
          (this.onRenderCallback = null),
          (this.onResizeCallback = null),
          (this.onPreRenderCallback = null),
          (this.onLoadUpdateCallback = null),
          (this.onLoadRenderCallback = null),
          (this.onPausedCallback = null),
          (this.onResumedCallback = null),
          (this.onPauseUpdateCallback = null),
          (this.onShutDownCallback = null);
      }),
      (c.StateManager.prototype = {
        boot: function () {
          this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0);
        },
        add: function (a, b, d) {
          void 0 === d && (d = !1);
          var e;
          return (
            b instanceof c.State ? (e = b) : "object" == typeof b ? ((e = b), (e.game = this.game)) : "function" == typeof b && (e = new b(this.game)),
            (this.states[a] = e),
            d && (this.game.isBooted ? this.start(a) : (this._pendingState = a)),
            e
          );
        },
        remove: function (a) {
          this.current === a &&
            ((this.callbackContext = null),
            (this.onInitCallback = null),
            (this.onShutDownCallback = null),
            (this.onPreloadCallback = null),
            (this.onLoadRenderCallback = null),
            (this.onLoadUpdateCallback = null),
            (this.onCreateCallback = null),
            (this.onUpdateCallback = null),
            (this.onPreRenderCallback = null),
            (this.onRenderCallback = null),
            (this.onResizeCallback = null),
            (this.onPausedCallback = null),
            (this.onResumedCallback = null),
            (this.onPauseUpdateCallback = null)),
            delete this.states[a];
        },
        start: function (a, b, c) {
          void 0 === b && (b = !0),
            void 0 === c && (c = !1),
            this.checkState(a) && ((this._pendingState = a), (this._clearWorld = b), (this._clearCache = c), arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)));
        },
        restart: function (a, b) {
          void 0 === a && (a = !0), void 0 === b && (b = !1), (this._pendingState = this.current), (this._clearWorld = a), (this._clearCache = b), arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2));
        },
        dummy: function () {},
        preUpdate: function () {
          if (this._pendingState && this.game.isBooted) {
            var a = this.current;
            if ((this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, a), this.current !== this._pendingState)) return;
            (this._pendingState = null),
              this.onPreloadCallback
                ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start())
                : this.loadComplete();
          }
        },
        clearCurrentState: function () {
          this.current &&
            (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game),
            this.game.tweens.removeAll(),
            this.game.camera.reset(),
            this.game.input.reset(!0),
            this.game.physics.clear(),
            this.game.time.removeAll(),
            this.game.scale.reset(this._clearWorld),
            this.game.debug && this.game.debug.reset(),
            this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()));
        },
        checkState: function (a) {
          return !!this.states[a] && (!!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) || !1);
        },
        link: function (a) {
          (this.states[a].game = this.game),
            (this.states[a].add = this.game.add),
            (this.states[a].make = this.game.make),
            (this.states[a].camera = this.game.camera),
            (this.states[a].cache = this.game.cache),
            (this.states[a].input = this.game.input),
            (this.states[a].load = this.game.load),
            (this.states[a].math = this.game.math),
            (this.states[a].sound = this.game.sound),
            (this.states[a].scale = this.game.scale),
            (this.states[a].state = this),
            (this.states[a].stage = this.game.stage),
            (this.states[a].time = this.game.time),
            (this.states[a].tweens = this.game.tweens),
            (this.states[a].world = this.game.world),
            (this.states[a].particles = this.game.particles),
            (this.states[a].rnd = this.game.rnd),
            (this.states[a].physics = this.game.physics),
            (this.states[a].key = a);
        },
        unlink: function (a) {
          this.states[a] &&
            ((this.states[a].game = null),
            (this.states[a].add = null),
            (this.states[a].make = null),
            (this.states[a].camera = null),
            (this.states[a].cache = null),
            (this.states[a].input = null),
            (this.states[a].load = null),
            (this.states[a].math = null),
            (this.states[a].sound = null),
            (this.states[a].scale = null),
            (this.states[a].state = null),
            (this.states[a].stage = null),
            (this.states[a].time = null),
            (this.states[a].tweens = null),
            (this.states[a].world = null),
            (this.states[a].particles = null),
            (this.states[a].rnd = null),
            (this.states[a].physics = null));
        },
        setCurrentState: function (a) {
          (this.callbackContext = this.states[a]),
            this.link(a),
            (this.onInitCallback = this.states[a].init || this.dummy),
            (this.onPreloadCallback = this.states[a].preload || null),
            (this.onLoadRenderCallback = this.states[a].loadRender || null),
            (this.onLoadUpdateCallback = this.states[a].loadUpdate || null),
            (this.onCreateCallback = this.states[a].create || null),
            (this.onUpdateCallback = this.states[a].update || null),
            (this.onPreRenderCallback = this.states[a].preRender || null),
            (this.onRenderCallback = this.states[a].render || null),
            (this.onResizeCallback = this.states[a].resize || null),
            (this.onPausedCallback = this.states[a].paused || null),
            (this.onResumedCallback = this.states[a].resumed || null),
            (this.onPauseUpdateCallback = this.states[a].pauseUpdate || null),
            (this.onShutDownCallback = this.states[a].shutdown || this.dummy),
            "" !== this.current && this.game.physics.reset(),
            (this.current = a),
            (this._created = !1),
            this.onInitCallback.apply(this.callbackContext, this._args),
            a === this._pendingState && (this._args = []),
            (this.game._kickstart = !0);
        },
        getCurrentState: function () {
          return this.states[this.current];
        },
        loadComplete: function () {
          this._created === !1 && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game),
            this._created === !1 && this.onCreateCallback ? ((this._created = !0), this.onCreateCallback.call(this.callbackContext, this.game)) : (this._created = !0);
        },
        pause: function () {
          this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game);
        },
        resume: function () {
          this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game);
        },
        update: function () {
          this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        pauseUpdate: function () {
          this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        },
        preRender: function (a) {
          this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a);
        },
        resize: function (a, b) {
          this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b);
        },
        render: function () {
          this._created
            ? this.onRenderCallback &&
              (this.game.renderType === c.CANVAS
                ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore())
                : this.onRenderCallback.call(this.callbackContext, this.game))
            : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game);
        },
        destroy: function () {
          (this._clearWorld = !0),
            (this._clearCache = !0),
            this.clearCurrentState(),
            (this.callbackContext = null),
            (this.onInitCallback = null),
            (this.onShutDownCallback = null),
            (this.onPreloadCallback = null),
            (this.onLoadRenderCallback = null),
            (this.onLoadUpdateCallback = null),
            (this.onCreateCallback = null),
            (this.onUpdateCallback = null),
            (this.onRenderCallback = null),
            (this.onPausedCallback = null),
            (this.onResumedCallback = null),
            (this.onPauseUpdateCallback = null),
            (this.game = null),
            (this.states = {}),
            (this._pendingState = null),
            (this.current = "");
        },
      }),
      (c.StateManager.prototype.constructor = c.StateManager),
      Object.defineProperty(c.StateManager.prototype, "created", {
        get: function () {
          return this._created;
        },
      }),
      (c.Signal = function () {}),
      (c.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !1,
        validateListener: function (a, b) {
          if ("function" != typeof a) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
        },
        _registerListener: function (a, b, d, e, f) {
          var g,
            h = this._indexOfListener(a, d);
          if (h !== -1) {
            if (((g = this._bindings[h]), g.isOnce() !== b)) throw new Error("You cannot add" + (b ? "" : "Once") + "() then add" + (b ? "Once" : "") + "() the same listener without removing the relationship first.");
          } else (g = new c.SignalBinding(this, a, b, d, e, f)), this._addBinding(g);
          return this.memorize && this._prevParams && g.execute(this._prevParams), g;
        },
        _addBinding: function (a) {
          this._bindings || (this._bindings = []);
          var b = this._bindings.length;
          do b--;
          while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
          this._bindings.splice(b + 1, 0, a);
        },
        _indexOfListener: function (a, b) {
          if (!this._bindings) return -1;
          void 0 === b && (b = null);
          for (var c, d = this._bindings.length; d--; ) if (((c = this._bindings[d]), c._listener === a && c.context === b)) return d;
          return -1;
        },
        has: function (a, b) {
          return this._indexOfListener(a, b) !== -1;
        },
        add: function (a, b, c) {
          this.validateListener(a, "add");
          var d = [];
          if (arguments.length > 3) for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
          return this._registerListener(a, !1, b, c, d);
        },
        addOnce: function (a, b, c) {
          this.validateListener(a, "addOnce");
          var d = [];
          if (arguments.length > 3) for (var e = 3; e < arguments.length; e++) d.push(arguments[e]);
          return this._registerListener(a, !0, b, c, d);
        },
        remove: function (a, b) {
          this.validateListener(a, "remove");
          var c = this._indexOfListener(a, b);
          return c !== -1 && (this._bindings[c]._destroy(), this._bindings.splice(c, 1)), a;
        },
        removeAll: function (a) {
          if ((void 0 === a && (a = null), this._bindings)) {
            for (var b = this._bindings.length; b--; ) a ? this._bindings[b].context === a && (this._bindings[b]._destroy(), this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
            a || (this._bindings.length = 0);
          }
        },
        getNumListeners: function () {
          return this._bindings ? this._bindings.length : 0;
        },
        halt: function () {
          this._shouldPropagate = !1;
        },
        dispatch: function () {
          if (this.active && this._bindings) {
            var a,
              b = Array.prototype.slice.call(arguments),
              c = this._bindings.length;
            if ((this.memorize && (this._prevParams = b), c)) {
              (a = this._bindings.slice()), (this._shouldPropagate = !0);
              do c--;
              while (a[c] && this._shouldPropagate && a[c].execute(b) !== !1);
            }
          }
        },
        forget: function () {
          this._prevParams && (this._prevParams = null);
        },
        dispose: function () {
          this.removeAll(), (this._bindings = null), this._prevParams && (this._prevParams = null);
        },
        toString: function () {
          return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
        },
      }),
      Object.defineProperty(c.Signal.prototype, "boundDispatch", {
        get: function () {
          var a = this;
          return (
            this._boundDispatch ||
            (this._boundDispatch = function () {
              return a.dispatch.apply(a, arguments);
            })
          );
        },
      }),
      (c.Signal.prototype.constructor = c.Signal),
      (c.SignalBinding = function (a, b, c, d, e, f) {
        (this._listener = b), c && (this._isOnce = !0), null != d && (this.context = d), (this._signal = a), e && (this._priority = e), f && f.length && (this._args = f);
      }),
      (c.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function (a) {
          var b, c;
          return this.active && this._listener && ((c = this.params ? this.params.concat(a) : a), this._args && (c = c.concat(this._args)), (b = this._listener.apply(this.context, c)), this.callCount++, this._isOnce && this.detach()), b;
        },
        detach: function () {
          return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        },
        isBound: function () {
          return !!this._signal && !!this._listener;
        },
        isOnce: function () {
          return this._isOnce;
        },
        getListener: function () {
          return this._listener;
        },
        getSignal: function () {
          return this._signal;
        },
        _destroy: function () {
          delete this._signal, delete this._listener, delete this.context;
        },
        toString: function () {
          return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
        },
      }),
      (c.SignalBinding.prototype.constructor = c.SignalBinding),
      (c.Filter = function (a, b, d) {
        (this.game = a), (this.type = c.WEBGL_FILTER), (this.passes = [this]), (this.shaders = []), (this.dirty = !0), (this.padding = 0), (this.prevPoint = new c.Point());
        var e = new Date();
        if (
          ((this.uniforms = {
            resolution: { type: "2f", value: { x: 256, y: 256 } },
            time: { type: "1f", value: 0 },
            mouse: { type: "2f", value: { x: 0, y: 0 } },
            date: { type: "4fv", value: [e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()] },
            sampleRate: { type: "1f", value: 44100 },
            iChannel0: { type: "sampler2D", value: null, textureData: { repeat: !0 } },
            iChannel1: { type: "sampler2D", value: null, textureData: { repeat: !0 } },
            iChannel2: { type: "sampler2D", value: null, textureData: { repeat: !0 } },
            iChannel3: { type: "sampler2D", value: null, textureData: { repeat: !0 } },
          }),
          b)
        )
          for (var f in b) this.uniforms[f] = b[f];
        this.fragmentSrc = d || "";
      }),
      (c.Filter.prototype = {
        init: function () {},
        setResolution: function (a, b) {
          (this.uniforms.resolution.value.x = a), (this.uniforms.resolution.value.y = b);
        },
        update: function (a) {
          if ("undefined" != typeof a) {
            var b = a.x / this.game.width,
              c = 1 - a.y / this.game.height;
            (b === this.prevPoint.x && c === this.prevPoint.y) || ((this.uniforms.mouse.value.x = b.toFixed(2)), (this.uniforms.mouse.value.y = c.toFixed(2)), this.prevPoint.set(b, c));
          }
          this.uniforms.time.value = this.game.time.totalElapsedSeconds();
        },
        addToWorld: function (a, b, c, d, e, f) {
          void 0 === e && (e = 0), void 0 === f && (f = 0), void 0 !== c && null !== c ? (this.width = c) : (c = this.width), void 0 !== d && null !== d ? (this.height = d) : (d = this.height);
          var g = this.game.add.image(a, b, "__default");
          return (g.width = c), (g.height = d), g.anchor.set(e, f), (g.filters = [this]), g;
        },
        destroy: function () {
          this.game = null;
        },
      }),
      (c.Filter.prototype.constructor = c.Filter),
      Object.defineProperty(c.Filter.prototype, "width", {
        get: function () {
          return this.uniforms.resolution.value.x;
        },
        set: function (a) {
          this.uniforms.resolution.value.x = a;
        },
      }),
      Object.defineProperty(c.Filter.prototype, "height", {
        get: function () {
          return this.uniforms.resolution.value.y;
        },
        set: function (a) {
          this.uniforms.resolution.value.y = a;
        },
      }),
      (c.Plugin = function (a, b) {
        void 0 === b && (b = null), (this.game = a), (this.parent = b), (this.active = !1), (this.visible = !1), (this.hasPreUpdate = !1), (this.hasUpdate = !1), (this.hasPostUpdate = !1), (this.hasRender = !1), (this.hasPostRender = !1);
      }),
      (c.Plugin.prototype = {
        preUpdate: function () {},
        update: function () {},
        render: function () {},
        postRender: function () {},
        destroy: function () {
          (this.game = null), (this.parent = null), (this.active = !1), (this.visible = !1);
        },
      }),
      (c.Plugin.prototype.constructor = c.Plugin),
      (c.PluginManager = function (a) {
        (this.game = a), (this.plugins = []), (this._len = 0), (this._i = 0);
      }),
      (c.PluginManager.prototype = {
        add: function (a) {
          var b = Array.prototype.slice.call(arguments, 1),
            c = !1;
          return (
            "function" == typeof a ? (a = new a(this.game, this)) : ((a.game = this.game), (a.parent = this)),
            "function" == typeof a.preUpdate && ((a.hasPreUpdate = !0), (c = !0)),
            "function" == typeof a.update && ((a.hasUpdate = !0), (c = !0)),
            "function" == typeof a.postUpdate && ((a.hasPostUpdate = !0), (c = !0)),
            "function" == typeof a.render && ((a.hasRender = !0), (c = !0)),
            "function" == typeof a.postRender && ((a.hasPostRender = !0), (c = !0)),
            c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0), (a.hasRender || a.hasPostRender) && (a.visible = !0), (this._len = this.plugins.push(a)), "function" == typeof a.init && a.init.apply(a, b), a) : null
          );
        },
        remove: function (a, b) {
          for (void 0 === b && (b = !0), this._i = this._len; this._i--; ) if (this.plugins[this._i] === a) return b && a.destroy(), this.plugins.splice(this._i, 1), void this._len--;
        },
        removeAll: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].destroy();
          (this.plugins.length = 0), (this._len = 0);
        },
        preUpdate: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate();
        },
        update: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update();
        },
        postUpdate: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate();
        },
        render: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render();
        },
        postRender: function () {
          for (this._i = this._len; this._i--; ) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender();
        },
        destroy: function () {
          this.removeAll(), (this.game = null);
        },
      }),
      (c.PluginManager.prototype.constructor = c.PluginManager),
      (c.Stage = function (a) {
        (this.game = a),
          PIXI.DisplayObjectContainer.call(this),
          (this.name = "_stage_root"),
          (this.disableVisibilityChange = !1),
          (this.exists = !0),
          (this.worldTransform = new PIXI.Matrix()),
          (this.stage = this),
          (this.currentRenderOrderID = 0),
          (this._hiddenVar = "hidden"),
          (this._onChange = null),
          (this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: "#000000" }),
          this.game.transparent || (this._bgColor.a = 1),
          a.config && this.parseConfig(a.config);
      }),
      (c.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype)),
      (c.Stage.prototype.constructor = c.Stage),
      (c.Stage.prototype.parseConfig = function (a) {
        a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange), a.backgroundColor && this.setBackgroundColor(a.backgroundColor);
      }),
      (c.Stage.prototype.boot = function () {
        c.DOM.getOffset(this.game.canvas, this.offset), c.Canvas.setUserSelect(this.game.canvas, "none"), c.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility();
      }),
      (c.Stage.prototype.preUpdate = function () {
        this.currentRenderOrderID = 0;
        for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
      }),
      (c.Stage.prototype.update = function () {
        for (var a = this.children.length; a--; ) this.children[a].update();
      }),
      (c.Stage.prototype.postUpdate = function () {
        this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
        for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
        this.updateTransform();
      }),
      (c.Stage.prototype.updateTransform = function () {
        this.worldAlpha = 1;
        for (var a = 0; a < this.children.length; a++) this.children[a].updateTransform();
      }),
      (c.Stage.prototype.checkVisibility = function () {
        void 0 !== document.hidden
          ? (this._hiddenVar = "visibilitychange")
          : void 0 !== document.webkitHidden
          ? (this._hiddenVar = "webkitvisibilitychange")
          : void 0 !== document.mozHidden
          ? (this._hiddenVar = "mozvisibilitychange")
          : void 0 !== document.msHidden
          ? (this._hiddenVar = "msvisibilitychange")
          : (this._hiddenVar = null);
        var a = this;
        (this._onChange = function (b) {
          return a.visibilityChange(b);
        }),
          this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1),
          (window.onblur = this._onChange),
          (window.onfocus = this._onChange),
          (window.onpagehide = this._onChange),
          (window.onpageshow = this._onChange),
          this.game.device.cocoonJSApp &&
            (CocoonJS.App.onSuspended.addEventListener(function () {
              c.Stage.prototype.visibilityChange.call(a, { type: "pause" });
            }),
            CocoonJS.App.onActivated.addEventListener(function () {
              c.Stage.prototype.visibilityChange.call(a, { type: "resume" });
            }));
      }),
      (c.Stage.prototype.visibilityChange = function (a) {
        return "pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type
          ? void ("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : ("pageshow" !== a.type && "focus" !== a.type) || this.game.focusGain(a))
          : void (this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a)));
      }),
      (c.Stage.prototype.setBackgroundColor = function (a) {
        this.game.transparent || (c.Color.valueToColor(a, this._bgColor), c.Color.updateColor(this._bgColor), (this._bgColor.r /= 255), (this._bgColor.g /= 255), (this._bgColor.b /= 255), (this._bgColor.a = 1));
      }),
      (c.Stage.prototype.destroy = function () {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), (window.onpagehide = null), (window.onpageshow = null), (window.onblur = null), (window.onfocus = null);
      }),
      Object.defineProperty(c.Stage.prototype, "backgroundColor", {
        get: function () {
          return this._bgColor.color;
        },
        set: function (a) {
          this.setBackgroundColor(a);
        },
      }),
      Object.defineProperty(c.Stage.prototype, "smoothed", {
        get: function () {
          return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
        },
        set: function (a) {
          a ? (PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR) : (PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST);
        },
      }),
      (c.Group = function (a, b, d, e, f, g) {
        void 0 === e && (e = !1),
          void 0 === f && (f = !1),
          void 0 === g && (g = c.Physics.ARCADE),
          (this.game = a),
          void 0 === b && (b = a.world),
          (this.name = d || "group"),
          (this.z = 0),
          PIXI.DisplayObjectContainer.call(this),
          e ? (this.game.stage.addChild(this), (this.z = this.game.stage.children.length)) : b && (b.addChild(this), (this.z = b.children.length)),
          (this.type = c.GROUP),
          (this.physicsType = c.GROUP),
          (this.alive = !0),
          (this.exists = !0),
          (this.ignoreDestroy = !1),
          (this.pendingDestroy = !1),
          (this.classType = c.Sprite),
          (this.cursor = null),
          (this.inputEnableChildren = !1),
          (this.onChildInputDown = new c.Signal()),
          (this.onChildInputUp = new c.Signal()),
          (this.onChildInputOver = new c.Signal()),
          (this.onChildInputOut = new c.Signal()),
          (this.enableBody = f),
          (this.enableBodyDebug = !1),
          (this.physicsBodyType = g),
          (this.physicsSortDirection = null),
          (this.onDestroy = new c.Signal()),
          (this.cursorIndex = 0),
          (this.fixedToCamera = !1),
          (this.cameraOffset = new c.Point()),
          (this.hash = []),
          (this._sortProperty = "z");
      }),
      (c.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype)),
      (c.Group.prototype.constructor = c.Group),
      (c.Group.RETURN_NONE = 0),
      (c.Group.RETURN_TOTAL = 1),
      (c.Group.RETURN_CHILD = 2),
      (c.Group.RETURN_ALL = 3),
      (c.Group.SORT_ASCENDING = -1),
      (c.Group.SORT_DESCENDING = 1),
      (c.Group.prototype.add = function (a, b, c) {
        return (
          void 0 === b && (b = !1),
          a.parent === this
            ? a
            : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a),
              void 0 === c ? ((a.z = this.children.length), this.addChild(a)) : (this.addChildAt(a, c), this.updateZ()),
              this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a),
              !this.inputEnableChildren || (a.input && !a.inputEnabled) || (a.inputEnabled = !0),
              !b && a.events && a.events.onAddedToGroup$dispatch(a, this),
              null === this.cursor && (this.cursor = a),
              a)
        );
      }),
      (c.Group.prototype.addAt = function (a, b, c) {
        this.add(a, c, b);
      }),
      (c.Group.prototype.addToHash = function (a) {
        if (a.parent === this) {
          var b = this.hash.indexOf(a);
          if (b === -1) return this.hash.push(a), !0;
        }
        return !1;
      }),
      (c.Group.prototype.removeFromHash = function (a) {
        if (a) {
          var b = this.hash.indexOf(a);
          if (b !== -1) return this.hash.splice(b, 1), !0;
        }
        return !1;
      }),
      (c.Group.prototype.addMultiple = function (a, b) {
        if (a instanceof c.Group) a.moveAll(this, b);
        else if (Array.isArray(a)) for (var d = 0; d < a.length; d++) this.add(a[d], b);
        return a;
      }),
      (c.Group.prototype.getAt = function (a) {
        return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a);
      }),
      (c.Group.prototype.create = function (a, b, c, d, e, f) {
        void 0 === e && (e = !0);
        var g = new this.classType(this.game, a, b, c, d);
        return (g.exists = e), (g.visible = e), (g.alive = e), this.add(g, !1, f);
      }),
      (c.Group.prototype.createMultiple = function (a, b, c, d) {
        void 0 === c && (c = 0), void 0 === d && (d = !1), Array.isArray(b) || (b = [b]), Array.isArray(c) || (c = [c]);
        var e = this,
          f = [];
        return (
          b.forEach(function (b) {
            c.forEach(function (c) {
              for (var g = 0; g < a; g++) f.push(e.create(0, 0, b, c, d));
            });
          }),
          f
        );
      }),
      (c.Group.prototype.updateZ = function () {
        for (var a = this.children.length; a--; ) this.children[a].z = a;
      }),
      (c.Group.prototype.align = function (a, b, d, e, f, g) {
        if ((void 0 === f && (f = c.TOP_LEFT), void 0 === g && (g = 0), 0 === this.children.length || g > this.children.length || (a === -1 && b === -1))) return !1;
        for (var h = new c.Rectangle(0, 0, d, e), i = a * d, j = b * e, k = g; k < this.children.length; k++) {
          var l = this.children[k];
          if (l.alignIn)
            if ((l.alignIn(h, f), a === -1)) (h.y += e), h.y === j && ((h.x += d), (h.y = 0));
            else if (b === -1) (h.x += d), h.x === i && ((h.x = 0), (h.y += e));
            else if (((h.x += d), h.x === i && ((h.x = 0), (h.y += e), h.y === j))) return !0;
        }
        return !0;
      }),
      (c.Group.prototype.resetCursor = function (a) {
        if ((void 0 === a && (a = 0), a > this.children.length - 1 && (a = 0), this.cursor)) return (this.cursorIndex = a), (this.cursor = this.children[this.cursorIndex]), this.cursor;
      }),
      (c.Group.prototype.next = function () {
        if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? (this.cursorIndex = 0) : this.cursorIndex++, (this.cursor = this.children[this.cursorIndex]), this.cursor;
      }),
      (c.Group.prototype.previous = function () {
        if (this.cursor) return 0 === this.cursorIndex ? (this.cursorIndex = this.children.length - 1) : this.cursorIndex--, (this.cursor = this.children[this.cursorIndex]), this.cursor;
      }),
      (c.Group.prototype.swap = function (a, b) {
        this.swapChildren(a, b), this.updateZ();
      }),
      (c.Group.prototype.bringToTop = function (a) {
        return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0), this.add(a, !0)), a;
      }),
      (c.Group.prototype.sendToBack = function (a) {
        return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0), this.addAt(a, 0, !0)), a;
      }),
      (c.Group.prototype.moveUp = function (a) {
        if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
          var b = this.getIndex(a),
            c = this.getAt(b + 1);
          c && this.swap(a, c);
        }
        return a;
      }),
      (c.Group.prototype.moveDown = function (a) {
        if (a.parent === this && this.getIndex(a) > 0) {
          var b = this.getIndex(a),
            c = this.getAt(b - 1);
          c && this.swap(a, c);
        }
        return a;
      }),
      (c.Group.prototype.xy = function (a, b, c) {
        return a < 0 || a > this.children.length ? -1 : ((this.getChildAt(a).x = b), void (this.getChildAt(a).y = c));
      }),
      (c.Group.prototype.reverse = function () {
        this.children.reverse(), this.updateZ();
      }),
      (c.Group.prototype.getIndex = function (a) {
        return this.children.indexOf(a);
      }),
      (c.Group.prototype.getByName = function (a) {
        for (var b = 0; b < this.children.length; b++) if (this.children[b].name === a) return this.children[b];
        return null;
      }),
      (c.Group.prototype.replace = function (a, b) {
        var d = this.getIndex(a);
        if (d !== -1) return b.parent && (b.parent instanceof c.Group ? b.parent.remove(b) : b.parent.removeChild(b)), this.remove(a), this.addAt(b, d), a;
      }),
      (c.Group.prototype.hasProperty = function (a, b) {
        var c = b.length;
        return (
          (1 === c && b[0] in a) ||
          (2 === c && b[0] in a && b[1] in a[b[0]]) ||
          (3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]]) ||
          (4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]])
        );
      }),
      (c.Group.prototype.setProperty = function (a, b, c, d, e) {
        if ((void 0 === e && (e = !1), (d = d || 0), !this.hasProperty(a, b) && (!e || d > 0))) return !1;
        var f = b.length;
        return (
          1 === f
            ? 0 === d
              ? (a[b[0]] = c)
              : 1 === d
              ? (a[b[0]] += c)
              : 2 === d
              ? (a[b[0]] -= c)
              : 3 === d
              ? (a[b[0]] *= c)
              : 4 === d && (a[b[0]] /= c)
            : 2 === f
            ? 0 === d
              ? (a[b[0]][b[1]] = c)
              : 1 === d
              ? (a[b[0]][b[1]] += c)
              : 2 === d
              ? (a[b[0]][b[1]] -= c)
              : 3 === d
              ? (a[b[0]][b[1]] *= c)
              : 4 === d && (a[b[0]][b[1]] /= c)
            : 3 === f
            ? 0 === d
              ? (a[b[0]][b[1]][b[2]] = c)
              : 1 === d
              ? (a[b[0]][b[1]][b[2]] += c)
              : 2 === d
              ? (a[b[0]][b[1]][b[2]] -= c)
              : 3 === d
              ? (a[b[0]][b[1]][b[2]] *= c)
              : 4 === d && (a[b[0]][b[1]][b[2]] /= c)
            : 4 === f &&
              (0 === d ? (a[b[0]][b[1]][b[2]][b[3]] = c) : 1 === d ? (a[b[0]][b[1]][b[2]][b[3]] += c) : 2 === d ? (a[b[0]][b[1]][b[2]][b[3]] -= c) : 3 === d ? (a[b[0]][b[1]][b[2]][b[3]] *= c) : 4 === d && (a[b[0]][b[1]][b[2]][b[3]] /= c)),
          !0
        );
      }),
      (c.Group.prototype.checkProperty = function (a, b, d, e) {
        return void 0 === e && (e = !1), !(!c.Utils.getProperty(a, b) && e) && c.Utils.getProperty(a, b) === d;
      }),
      (c.Group.prototype.set = function (a, b, c, d, e, f, g) {
        if ((void 0 === g && (g = !1), (b = b.split(".")), void 0 === d && (d = !1), void 0 === e && (e = !1), (d === !1 || (d && a.alive)) && (e === !1 || (e && a.visible)))) return this.setProperty(a, b, c, f, g);
      }),
      (c.Group.prototype.setAll = function (a, b, c, d, e, f) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === f && (f = !1), (a = a.split(".")), (e = e || 0);
        for (var g = 0; g < this.children.length; g++) (!c || (c && this.children[g].alive)) && (!d || (d && this.children[g].visible)) && this.setProperty(this.children[g], a, b, e, f);
      }),
      (c.Group.prototype.setAllChildren = function (a, b, d, e, f, g) {
        void 0 === d && (d = !1), void 0 === e && (e = !1), void 0 === g && (g = !1), (f = f || 0);
        for (var h = 0; h < this.children.length; h++)
          (!d || (d && this.children[h].alive)) &&
            (!e || (e && this.children[h].visible)) &&
            (this.children[h] instanceof c.Group ? this.children[h].setAllChildren(a, b, d, e, f, g) : this.setProperty(this.children[h], a.split("."), b, f, g));
      }),
      (c.Group.prototype.checkAll = function (a, b, c, d, e) {
        void 0 === c && (c = !1), void 0 === d && (d = !1), void 0 === e && (e = !1);
        for (var f = 0; f < this.children.length; f++) if ((!c || (c && this.children[f].alive)) && (!d || (d && this.children[f].visible)) && !this.checkProperty(this.children[f], a, b, e)) return !1;
        return !0;
      }),
      (c.Group.prototype.addAll = function (a, b, c, d) {
        this.setAll(a, b, c, d, 1);
      }),
      (c.Group.prototype.subAll = function (a, b, c, d) {
        this.setAll(a, b, c, d, 2);
      }),
      (c.Group.prototype.multiplyAll = function (a, b, c, d) {
        this.setAll(a, b, c, d, 3);
      }),
      (c.Group.prototype.divideAll = function (a, b, c, d) {
        this.setAll(a, b, c, d, 4);
      }),
      (c.Group.prototype.callAllExists = function (a, b) {
        var c;
        if (arguments.length > 2) {
          c = [];
          for (var d = 2; d < arguments.length; d++) c.push(arguments[d]);
        }
        for (var d = 0; d < this.children.length; d++) this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c);
      }),
      (c.Group.prototype.callbackFromArray = function (a, b, c) {
        if (1 === c) {
          if (a[b[0]]) return a[b[0]];
        } else if (2 === c) {
          if (a[b[0]][b[1]]) return a[b[0]][b[1]];
        } else if (3 === c) {
          if (a[b[0]][b[1]][b[2]]) return a[b[0]][b[1]][b[2]];
        } else if (4 === c) {
          if (a[b[0]][b[1]][b[2]][b[3]]) return a[b[0]][b[1]][b[2]][b[3]];
        } else if (a[b]) return a[b];
        return !1;
      }),
      (c.Group.prototype.callAll = function (a, b) {
        if (void 0 !== a) {
          a = a.split(".");
          var c = a.length;
          if (void 0 === b || null === b || "" === b) b = null;
          else if ("string" == typeof b) {
            b = b.split(".");
            var d = b.length;
          }
          var e;
          if (arguments.length > 2) {
            e = [];
            for (var f = 2; f < arguments.length; f++) e.push(arguments[f]);
          }
          for (var g = null, h = null, f = 0; f < this.children.length; f++)
            (g = this.callbackFromArray(this.children[f], a, c)), b && g ? ((h = this.callbackFromArray(this.children[f], b, d)), g && g.apply(h, e)) : g && g.apply(this.children[f], e);
        }
      }),
      (c.Group.prototype.preUpdate = function () {
        if (this.pendingDestroy) return this.destroy(), !1;
        if (!this.exists || !this.parent.exists) return (this.renderOrderID = -1), !1;
        for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
        return !0;
      }),
      (c.Group.prototype.update = function () {
        for (var a = this.children.length; a--; ) this.children[a].update();
      }),
      (c.Group.prototype.postUpdate = function () {
        this.fixedToCamera && ((this.x = this.game.camera.view.x + this.cameraOffset.x), (this.y = this.game.camera.view.y + this.cameraOffset.y));
        for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
      }),
      (c.Group.prototype.filter = function (a, b) {
        for (var d = -1, e = this.children.length, f = []; ++d < e; ) {
          var g = this.children[d];
          (!b || (b && g.exists)) && a(g, d, this.children) && f.push(g);
        }
        return new c.ArraySet(f);
      }),
      (c.Group.prototype.forEach = function (a, b, c) {
        if ((void 0 === c && (c = !1), arguments.length <= 3)) for (var d = 0; d < this.children.length; d++) (!c || (c && this.children[d].exists)) && a.call(b, this.children[d]);
        else {
          for (var e = [null], d = 3; d < arguments.length; d++) e.push(arguments[d]);
          for (var d = 0; d < this.children.length; d++) (!c || (c && this.children[d].exists)) && ((e[0] = this.children[d]), a.apply(b, e));
        }
      }),
      (c.Group.prototype.forEachExists = function (a, b) {
        var d;
        if (arguments.length > 2) {
          d = [null];
          for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("exists", !0, c.Group.RETURN_TOTAL, a, b, d);
      }),
      (c.Group.prototype.forEachAlive = function (a, b) {
        var d;
        if (arguments.length > 2) {
          d = [null];
          for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("alive", !0, c.Group.RETURN_TOTAL, a, b, d);
      }),
      (c.Group.prototype.forEachDead = function (a, b) {
        var d;
        if (arguments.length > 2) {
          d = [null];
          for (var e = 2; e < arguments.length; e++) d.push(arguments[e]);
        }
        this.iterate("alive", !1, c.Group.RETURN_TOTAL, a, b, d);
      }),
      (c.Group.prototype.sort = function (a, b) {
        this.children.length < 2 ||
          (void 0 === a && (a = "z"),
          void 0 === b && (b = c.Group.SORT_ASCENDING),
          (this._sortProperty = a),
          b === c.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)),
          this.updateZ());
      }),
      (c.Group.prototype.customSort = function (a, b) {
        this.children.length < 2 || (this.children.sort(a.bind(b)), this.updateZ());
      }),
      (c.Group.prototype.ascendingSortHandler = function (a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
      }),
      (c.Group.prototype.descendingSortHandler = function (a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
      }),
      (c.Group.prototype.iterate = function (a, b, d, e, f, g) {
        if (0 === this.children.length) {
          if (d === c.Group.RETURN_TOTAL) return 0;
          if (d === c.Group.RETURN_ALL) return [];
        }
        var h = 0;
        if (d === c.Group.RETURN_ALL) var i = [];
        for (var j = 0; j < this.children.length; j++)
          if (this.children[j][a] === b) {
            if ((h++, e && (g ? ((g[0] = this.children[j]), e.apply(f, g)) : e.call(f, this.children[j])), d === c.Group.RETURN_CHILD)) return this.children[j];
            d === c.Group.RETURN_ALL && i.push(this.children[j]);
          }
        return d === c.Group.RETURN_TOTAL ? h : d === c.Group.RETURN_ALL ? i : null;
      }),
      (c.Group.prototype.getFirstExists = function (a, b, d, e, f, g) {
        void 0 === b && (b = !1), "boolean" != typeof a && (a = !0);
        var h = this.iterate("exists", a, c.Group.RETURN_CHILD);
        return null === h && b ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g);
      }),
      (c.Group.prototype.getFirstAlive = function (a, b, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !0, c.Group.RETURN_CHILD);
        return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f);
      }),
      (c.Group.prototype.getFirstDead = function (a, b, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !1, c.Group.RETURN_CHILD);
        return null === g && a ? this.create(b, d, e, f) : this.resetChild(g, b, d, e, f);
      }),
      (c.Group.prototype.resetChild = function (a, b, c, d, e) {
        return null === a ? null : (void 0 === b && (b = null), void 0 === c && (c = null), null !== b && null !== c && a.reset(b, c), void 0 !== d && a.loadTexture(d, e), a);
      }),
      (c.Group.prototype.getTop = function () {
        if (this.children.length > 0) return this.children[this.children.length - 1];
      }),
      (c.Group.prototype.getBottom = function () {
        if (this.children.length > 0) return this.children[0];
      }),
      (c.Group.prototype.getClosestTo = function (a, b, d) {
        for (var e = Number.MAX_VALUE, f = 0, g = null, h = 0; h < this.children.length; h++) {
          var i = this.children[h];
          i.exists && ((f = Math.abs(c.Point.distance(a, i))), f < e && (!b || b.call(d, i, f)) && ((e = f), (g = i)));
        }
        return g;
      }),
      (c.Group.prototype.getFurthestFrom = function (a, b, d) {
        for (var e = 0, f = 0, g = null, h = 0; h < this.children.length; h++) {
          var i = this.children[h];
          i.exists && ((f = Math.abs(c.Point.distance(a, i))), f > e && (!b || b.call(d, i, f)) && ((e = f), (g = i)));
        }
        return g;
      }),
      (c.Group.prototype.countLiving = function () {
        return this.iterate("alive", !0, c.Group.RETURN_TOTAL);
      }),
      (c.Group.prototype.countDead = function () {
        return this.iterate("alive", !1, c.Group.RETURN_TOTAL);
      }),
      (c.Group.prototype.getRandom = function (a, b) {
        return void 0 === a && (a = 0), void 0 === b && (b = this.children.length), 0 === b ? null : c.ArrayUtils.getRandomItem(this.children, a, b);
      }),
      (c.Group.prototype.getRandomExists = function (a, b) {
        var c = this.getAll("exists", !0, a, b);
        return this.game.rnd.pick(c);
      }),
      (c.Group.prototype.getAll = function (a, b, c, d) {
        void 0 === c && (c = 0), void 0 === d && (d = this.children.length);
        for (var e = [], f = c; f < d; f++) {
          var g = this.children[f];
          a && g[a] === b && e.push(g);
        }
        return e;
      }),
      (c.Group.prototype.remove = function (a, b, c) {
        if ((void 0 === b && (b = !1), void 0 === c && (c = !1), 0 === this.children.length || this.children.indexOf(a) === -1)) return !1;
        c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
        var d = this.removeChild(a);
        return this.removeFromHash(a), this.updateZ(), this.cursor === a && this.next(), b && d && d.destroy(!0), !0;
      }),
      (c.Group.prototype.moveAll = function (a, b) {
        if ((void 0 === b && (b = !1), this.children.length > 0 && a instanceof c.Group)) {
          do a.add(this.children[0], b);
          while (this.children.length > 0);
          (this.hash = []), (this.cursor = null);
        }
        return a;
      }),
      (c.Group.prototype.removeAll = function (a, b, c) {
        if ((void 0 === a && (a = !1), void 0 === b && (b = !1), void 0 === c && (c = !1), 0 !== this.children.length)) {
          do {
            !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
            var d = this.removeChild(this.children[0]);
            this.removeFromHash(d), a && d && d.destroy(!0, c);
          } while (this.children.length > 0);
          (this.hash = []), (this.cursor = null);
        }
      }),
      (c.Group.prototype.removeBetween = function (a, b, c, d) {
        if ((void 0 === b && (b = this.children.length - 1), void 0 === c && (c = !1), void 0 === d && (d = !1), 0 !== this.children.length)) {
          if (a > b || a < 0 || b > this.children.length) return !1;
          for (var e = b; e >= a; ) {
            !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
            var f = this.removeChild(this.children[e]);
            this.removeFromHash(f), c && f && f.destroy(!0), this.cursor === this.children[e] && (this.cursor = null), e--;
          }
          this.updateZ();
        }
      }),
      (c.Group.prototype.destroy = function (a, b) {
        null === this.game ||
          this.ignoreDestroy ||
          (void 0 === a && (a = !0),
          void 0 === b && (b = !1),
          this.onDestroy.dispatch(this, a, b),
          this.removeAll(a),
          (this.cursor = null),
          (this.filters = null),
          (this.pendingDestroy = !1),
          b || (this.parent && this.parent.removeChild(this), (this.game = null), (this.exists = !1)));
      }),
      Object.defineProperty(c.Group.prototype, "total", {
        get: function () {
          return this.iterate("exists", !0, c.Group.RETURN_TOTAL);
        },
      }),
      Object.defineProperty(c.Group.prototype, "length", {
        get: function () {
          return this.children.length;
        },
      }),
      Object.defineProperty(c.Group.prototype, "angle", {
        get: function () {
          return c.Math.radToDeg(this.rotation);
        },
        set: function (a) {
          this.rotation = c.Math.degToRad(a);
        },
      }),
      Object.defineProperty(c.Group.prototype, "centerX", {
        get: function () {
          return this.getBounds(this.parent).centerX;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.x - b.x;
          this.x = a + c - b.halfWidth;
        },
      }),
      Object.defineProperty(c.Group.prototype, "centerY", {
        get: function () {
          return this.getBounds(this.parent).centerY;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.y - b.y;
          this.y = a + c - b.halfHeight;
        },
      }),
      Object.defineProperty(c.Group.prototype, "left", {
        get: function () {
          return this.getBounds(this.parent).left;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.x - b.x;
          this.x = a + c;
        },
      }),
      Object.defineProperty(c.Group.prototype, "right", {
        get: function () {
          return this.getBounds(this.parent).right;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.x - b.x;
          this.x = a + c - b.width;
        },
      }),
      Object.defineProperty(c.Group.prototype, "top", {
        get: function () {
          return this.getBounds(this.parent).top;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.y - b.y;
          this.y = a + c;
        },
      }),
      Object.defineProperty(c.Group.prototype, "bottom", {
        get: function () {
          return this.getBounds(this.parent).bottom;
        },
        set: function (a) {
          var b = this.getBounds(this.parent),
            c = this.y - b.y;
          this.y = a + c - b.height;
        },
      }),
      (c.World = function (a) {
        c.Group.call(this, a, null, "__world", !1),
          (this.bounds = new c.Rectangle(0, 0, a.width, a.height)),
          (this.camera = null),
          (this._definedSize = !1),
          (this._width = a.width),
          (this._height = a.height),
          this.game.state.onStateChange.add(this.stateChange, this);
      }),
      (c.World.prototype = Object.create(c.Group.prototype)),
      (c.World.prototype.constructor = c.World),
      (c.World.prototype.boot = function () {
        (this.camera = new c.Camera(this.game, 0, 0, 0, this.game.width, this.game.height)), this.game.stage.addChild(this), this.camera.boot();
      }),
      (c.World.prototype.stateChange = function () {
        (this.x = 0), (this.y = 0), this.camera.reset();
      }),
      (c.World.prototype.setBounds = function (a, b, c, d) {
        (this._definedSize = !0),
          (this._width = c),
          (this._height = d),
          this.bounds.setTo(a, b, c, d),
          (this.x = a),
          (this.y = b),
          this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)),
          this.game.physics.setBoundsToWorld();
      }),
      (c.World.prototype.resize = function (a, b) {
        this._definedSize && (a < this._width && (a = this._width), b < this._height && (b = this._height)), (this.bounds.width = a), (this.bounds.height = b), this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld();
      }),
      (c.World.prototype.shutdown = function () {
        this.destroy(!0, !0);
      }),
      (c.World.prototype.wrap = function (a, b, c, d, e) {
        void 0 === b && (b = 0),
          void 0 === c && (c = !1),
          void 0 === d && (d = !0),
          void 0 === e && (e = !0),
          c
            ? (a.getBounds(),
              d && (a.x + a._currentBounds.width < this.bounds.x ? (a.x = this.bounds.right) : a.x > this.bounds.right && (a.x = this.bounds.left)),
              e && (a.y + a._currentBounds.height < this.bounds.top ? (a.y = this.bounds.bottom) : a.y > this.bounds.bottom && (a.y = this.bounds.top)))
            : (d && a.x + b < this.bounds.x ? (a.x = this.bounds.right + b) : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b),
              e && a.y + b < this.bounds.top ? (a.y = this.bounds.bottom + b) : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b));
      }),
      Object.defineProperty(c.World.prototype, "width", {
        get: function () {
          return this.bounds.width;
        },
        set: function (a) {
          a < this.game.width && (a = this.game.width), (this.bounds.width = a), (this._width = a), (this._definedSize = !0);
        },
      }),
      Object.defineProperty(c.World.prototype, "height", {
        get: function () {
          return this.bounds.height;
        },
        set: function (a) {
          a < this.game.height && (a = this.game.height), (this.bounds.height = a), (this._height = a), (this._definedSize = !0);
        },
      }),
      Object.defineProperty(c.World.prototype, "centerX", {
        get: function () {
          return this.bounds.halfWidth + this.bounds.x;
        },
      }),
      Object.defineProperty(c.World.prototype, "centerY", {
        get: function () {
          return this.bounds.halfHeight + this.bounds.y;
        },
      }),
      Object.defineProperty(c.World.prototype, "randomX", {
        get: function () {
          return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width);
        },
      }),
      Object.defineProperty(c.World.prototype, "randomY", {
        get: function () {
          return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height);
        },
      }),
      (c.Game = function (a, b, d, e, f, g, h, i) {
        return (
          (this.id = c.GAMES.push(this) - 1),
          (this.config = null),
          (this.physicsConfig = i),
          (this.parent = ""),
          (this.width = 800),
          (this.height = 600),
          (this.resolution = 1),
          (this._width = 800),
          (this._height = 600),
          (this.transparent = !1),
          (this.antialias = !0),
          (this.preserveDrawingBuffer = !1),
          (this.clearBeforeRender = !0),
          (this.renderer = null),
          (this.renderType = c.AUTO),
          (this.state = null),
          (this.isBooted = !1),
          (this.isRunning = !1),
          (this.raf = null),
          (this.add = null),
          (this.make = null),
          (this.cache = null),
          (this.input = null),
          (this.load = null),
          (this.math = null),
          (this.net = null),
          (this.scale = null),
          (this.sound = null),
          (this.stage = null),
          (this.time = null),
          (this.tweens = null),
          (this.world = null),
          (this.physics = null),
          (this.plugins = null),
          (this.rnd = null),
          (this.device = c.Device),
          (this.camera = null),
          (this.canvas = null),
          (this.context = null),
          (this.debug = null),
          (this.particles = null),
          (this.create = null),
          (this.lockRender = !1),
          (this.stepping = !1),
          (this.pendingStep = !1),
          (this.stepCount = 0),
          (this.onPause = null),
          (this.onResume = null),
          (this.onBlur = null),
          (this.onFocus = null),
          (this._paused = !1),
          (this._codePaused = !1),
          (this.currentUpdateID = 0),
          (this.updatesThisFrame = 1),
          (this._deltaTime = 0),
          (this._lastCount = 0),
          (this._spiraling = 0),
          (this._kickstart = !0),
          (this.fpsProblemNotifier = new c.Signal()),
          (this.forceSingleUpdate = !0),
          (this._nextFpsNotification = 0),
          1 === arguments.length && "object" == typeof arguments[0]
            ? this.parseConfig(arguments[0])
            : ((this.config = { enableDebug: !0 }),
              "undefined" != typeof a && (this._width = a),
              "undefined" != typeof b && (this._height = b),
              "undefined" != typeof d && (this.renderType = d),
              "undefined" != typeof e && (this.parent = e),
              "undefined" != typeof g && (this.transparent = g),
              "undefined" != typeof h && (this.antialias = h),
              (this.rnd = new c.RandomDataGenerator([(Date.now() * Math.random()).toString()])),
              (this.state = new c.StateManager(this, f))),
          this.device.whenReady(this.boot, this),
          this
        );
      }),
      (c.Game.prototype = {
        parseConfig: function (a) {
          (this.config = a),
            void 0 === a.enableDebug && (this.config.enableDebug = !0),
            a.width && (this._width = a.width),
            a.height && (this._height = a.height),
            a.renderer && (this.renderType = a.renderer),
            a.parent && (this.parent = a.parent),
            void 0 !== a.transparent && (this.transparent = a.transparent),
            void 0 !== a.antialias && (this.antialias = a.antialias),
            a.resolution && (this.resolution = a.resolution),
            void 0 !== a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer),
            a.physicsConfig && (this.physicsConfig = a.physicsConfig);
          var b = [(Date.now() * Math.random()).toString()];
          a.seed && (b = a.seed), (this.rnd = new c.RandomDataGenerator(b));
          var d = null;
          a.state && (d = a.state), (this.state = new c.StateManager(this, d));
        },
        boot: function () {
          this.isBooted ||
            ((this.onPause = new c.Signal()),
            (this.onResume = new c.Signal()),
            (this.onBlur = new c.Signal()),
            (this.onFocus = new c.Signal()),
            (this.isBooted = !0),
            (PIXI.game = this),
            (this.math = c.Math),
            (this.scale = new c.ScaleManager(this, this._width, this._height)),
            (this.stage = new c.Stage(this)),
            this.setUpRenderer(),
            (this.world = new c.World(this)),
            (this.add = new c.GameObjectFactory(this)),
            (this.make = new c.GameObjectCreator(this)),
            (this.cache = new c.Cache(this)),
            (this.load = new c.Loader(this)),
            (this.time = new c.Time(this)),
            (this.tweens = new c.TweenManager(this)),
            (this.input = new c.Input(this)),
            (this.sound = new c.SoundManager(this)),
            (this.physics = new c.Physics(this, this.physicsConfig)),
            (this.particles = new c.Particles(this)),
            (this.create = new c.Create(this)),
            (this.plugins = new c.PluginManager(this)),
            (this.net = new c.Net(this)),
            this.time.boot(),
            this.stage.boot(),
            this.world.boot(),
            this.scale.boot(),
            this.input.boot(),
            this.sound.boot(),
            this.state.boot(),
            this.config.enableDebug ? ((this.debug = new c.Utils.Debug(this)), this.debug.boot()) : (this.debug = { preUpdate: function () {}, update: function () {}, reset: function () {} }),
            this.showDebugHeader(),
            (this.isRunning = !0),
            this.config && this.config.forceSetTimeOut ? (this.raf = new c.RequestAnimationFrame(this, this.config.forceSetTimeOut)) : (this.raf = new c.RequestAnimationFrame(this, !1)),
            (this._kickstart = !0),
            window.focus && (!window.PhaserGlobal || (window.PhaserGlobal && !window.PhaserGlobal.stopFocus)) && window.focus(),
            this.raf.start());
        },
        showDebugHeader: function () {
          if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
            var a = c.VERSION,
              b = "Canvas",
              d = "HTML Audio",
              e = 1;
            if ((this.renderType === c.WEBGL ? ((b = "WebGL"), e++) : this.renderType === c.HEADLESS && (b = "Headless"), this.device.webAudio && ((d = "WebAudio"), e++), this.device.chrome))
              for (
                var f = [
                    "%c %c %c Phaser v" + a + " | Pixi.js | " + b + " | " + d + "  %c %c %c http://phaser.io %c♥%c♥%c♥",
                    "background: #fb8cb3",
                    "background: #d44a52",
                    "color: #ffffff; background: #871905;",
                    "background: #d44a52",
                    "background: #fb8cb3",
                    "background: #ffffff",
                  ],
                  g = 0;
                g < 3;
                g++
              )
                g < e ? f.push("color: #ff2424; background: #fff") : f.push("color: #959595; background: #fff");
            else window.console && void 0;
          }
        },
        setUpRenderer: function () {
          if (
            (this.config.canvas ? (this.canvas = this.config.canvas) : (this.canvas = c.Canvas.create(this, this.width, this.height, this.config.canvasID, !0)),
            this.config.canvasStyle ? (this.canvas.style = this.config.canvasStyle) : (this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%"),
            this.renderType === c.HEADLESS || this.renderType === c.CANVAS || (this.renderType === c.AUTO && !this.device.webGL))
          ) {
            if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
            (this.renderType = c.CANVAS), (this.renderer = new PIXI.CanvasRenderer(this)), (this.context = this.renderer.context);
          } else
            (this.renderType = c.WEBGL),
              (this.renderer = new PIXI.WebGLRenderer(this)),
              (this.context = null),
              this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1),
              this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
          this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === c.CANVAS),
            this.renderType !== c.HEADLESS && ((this.stage.smoothed = this.antialias), c.Canvas.addToDOM(this.canvas, this.parent, !1), c.Canvas.setTouchAction(this.canvas));
        },
        contextLost: function (a) {
          a.preventDefault(), (this.renderer.contextLost = !0);
        },
        contextRestored: function () {
          this.renderer.initContext(), this.cache.clearGLTextures(), (this.renderer.contextLost = !1);
        },
        update: function (a) {
          if ((this.time.update(a), this._kickstart)) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void (this._kickstart = !1);
          if (this._spiraling > 1 && !this.forceSingleUpdate)
            this.time.time > this._nextFpsNotification && ((this._nextFpsNotification = this.time.time + 1e4), this.fpsProblemNotifier.dispatch()),
              (this._deltaTime = 0),
              (this._spiraling = 0),
              this.updateRender(this.time.slowMotion * this.time.desiredFps);
          else {
            var b = (1e3 * this.time.slowMotion) / this.time.desiredFps;
            this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
            var c = 0;
            for (
              this.updatesThisFrame = Math.floor(this._deltaTime / b), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame));
              this._deltaTime >= b && ((this._deltaTime -= b), (this.currentUpdateID = c), this.updateLogic(this.time.desiredFpsMult), c++, !this.forceSingleUpdate || 1 !== c);

            )
              this.time.refresh();
            c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0), (this._lastCount = c), this.updateRender(this._deltaTime / b);
          }
        },
        updateLogic: function (a) {
          this._paused || this.pendingStep
            ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate())
            : (this.stepping && (this.pendingStep = !0),
              this.scale.preUpdate(),
              this.debug.preUpdate(),
              this.camera.preUpdate(),
              this.physics.preUpdate(),
              this.state.preUpdate(a),
              this.plugins.preUpdate(a),
              this.stage.preUpdate(),
              this.state.update(),
              this.stage.update(),
              this.tweens.update(),
              this.sound.update(),
              this.input.update(),
              this.physics.update(),
              this.particles.update(),
              this.plugins.update(),
              this.stage.postUpdate(),
              this.plugins.postUpdate()),
            this.stage.updateTransform();
        },
        updateRender: function (a) {
          this.lockRender || (this.state.preRender(a), this.renderType !== c.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(a), this.state.render(a)), this.plugins.postRender(a));
        },
        enableStep: function () {
          (this.stepping = !0), (this.pendingStep = !1), (this.stepCount = 0);
        },
        disableStep: function () {
          (this.stepping = !1), (this.pendingStep = !1);
        },
        step: function () {
          (this.pendingStep = !1), this.stepCount++;
        },
        destroy: function () {
          this.raf.stop(),
            this.state.destroy(),
            this.sound.destroy(),
            this.scale.destroy(),
            this.stage.destroy(),
            this.input.destroy(),
            this.physics.destroy(),
            this.plugins.destroy(),
            (this.state = null),
            (this.sound = null),
            (this.scale = null),
            (this.stage = null),
            (this.input = null),
            (this.physics = null),
            (this.plugins = null),
            (this.cache = null),
            (this.load = null),
            (this.time = null),
            (this.world = null),
            (this.isBooted = !1),
            this.renderer.destroy(!1),
            c.Canvas.removeFromDOM(this.canvas),
            (PIXI.defaultRenderer = null),
            (c.GAMES[this.id] = null);
        },
        gamePaused: function (a) {
          this._paused || ((this._paused = !0), this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !0));
        },
        gameResumed: function (a) {
          this._paused &&
            !this._codePaused &&
            ((this._paused = !1), this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(a), this.device.cordova && this.device.iOS && (this.lockRender = !1));
        },
        focusLoss: function (a) {
          this.onBlur.dispatch(a), this.stage.disableVisibilityChange || this.gamePaused(a);
        },
        focusGain: function (a) {
          this.onFocus.dispatch(a), this.stage.disableVisibilityChange || this.gameResumed(a);
        },
      }),
      (c.Game.prototype.constructor = c.Game),
      Object.defineProperty(c.Game.prototype, "paused", {
        get: function () {
          return this._paused;
        },
        set: function (a) {
          a === !0
            ? (this._paused === !1 && ((this._paused = !0), this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), (this._codePaused = !0))
            : (this._paused && ((this._paused = !1), this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), (this._codePaused = !1));
        },
      }),
      (c.Input = function (a) {
        (this.game = a),
          (this.hitCanvas = null),
          (this.hitContext = null),
          (this.moveCallbacks = []),
          (this.customCandidateHandler = null),
          (this.customCandidateHandlerContext = null),
          (this.pollRate = 0),
          (this.enabled = !0),
          (this.multiInputOverride = c.Input.MOUSE_TOUCH_COMBINE),
          (this.position = null),
          (this.speed = null),
          (this.circle = null),
          (this.scale = null),
          (this.maxPointers = -1),
          (this.tapRate = 200),
          (this.doubleTapRate = 300),
          (this.holdRate = 2e3),
          (this.justPressedRate = 200),
          (this.justReleasedRate = 200),
          (this.recordPointerHistory = !1),
          (this.recordRate = 100),
          (this.recordLimit = 100),
          (this.pointer1 = null),
          (this.pointer2 = null),
          (this.pointer3 = null),
          (this.pointer4 = null),
          (this.pointer5 = null),
          (this.pointer6 = null),
          (this.pointer7 = null),
          (this.pointer8 = null),
          (this.pointer9 = null),
          (this.pointer10 = null),
          (this.pointers = []),
          (this.activePointer = null),
          (this.mousePointer = null),
          (this.mouse = null),
          (this.keyboard = null),
          (this.touch = null),
          (this.mspointer = null),
          (this.gamepad = null),
          (this.resetLocked = !1),
          (this.onDown = null),
          (this.onUp = null),
          (this.onTap = null),
          (this.onHold = null),
          (this.minPriorityID = 0),
          (this.interactiveItems = new c.ArraySet()),
          (this._localPoint = new c.Point()),
          (this._pollCounter = 0),
          (this._oldPosition = null),
          (this._x = 0),
          (this._y = 0);
      }),
      (c.Input.MOUSE_OVERRIDES_TOUCH = 0),
      (c.Input.TOUCH_OVERRIDES_MOUSE = 1),
      (c.Input.MOUSE_TOUCH_COMBINE = 2),
      (c.Input.MAX_POINTERS = 10),
      (c.Input.prototype = {
        boot: function () {
          (this.mousePointer = new c.Pointer(this.game, 0, c.PointerMode.CURSOR)),
            this.addPointer(),
            this.addPointer(),
            (this.mouse = new c.Mouse(this.game)),
            (this.touch = new c.Touch(this.game)),
            (this.mspointer = new c.MSPointer(this.game)),
            c.Keyboard && (this.keyboard = new c.Keyboard(this.game)),
            c.Gamepad && (this.gamepad = new c.Gamepad(this.game)),
            (this.onDown = new c.Signal()),
            (this.onUp = new c.Signal()),
            (this.onTap = new c.Signal()),
            (this.onHold = new c.Signal()),
            (this.scale = new c.Point(1, 1)),
            (this.speed = new c.Point()),
            (this.position = new c.Point()),
            (this._oldPosition = new c.Point()),
            (this.circle = new c.Circle(0, 0, 44)),
            (this.activePointer = this.mousePointer),
            (this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1)),
            (this.hitContext = this.hitCanvas.getContext("2d")),
            this.mouse.start(),
            this.touch.start(),
            this.mspointer.start(),
            (this.mousePointer.active = !0),
            this.keyboard && this.keyboard.start();
          var a = this;
          (this._onClickTrampoline = function (b) {
            a.onClickTrampoline(b);
          }),
            this.game.canvas.addEventListener("click", this._onClickTrampoline, !1);
        },
        destroy: function () {
          this.mouse.stop(),
            this.touch.stop(),
            this.mspointer.stop(),
            this.keyboard && this.keyboard.stop(),
            this.gamepad && this.gamepad.stop(),
            (this.moveCallbacks = []),
            PIXI.CanvasPool.remove(this),
            this.game.canvas.removeEventListener("click", this._onClickTrampoline);
        },
        setInteractiveCandidateHandler: function (a, b) {
          (this.customCandidateHandler = a), (this.customCandidateHandlerContext = b);
        },
        addMoveCallback: function (a, b) {
          this.moveCallbacks.push({ callback: a, context: b });
        },
        deleteMoveCallback: function (a, b) {
          for (var c = this.moveCallbacks.length; c--; ) if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) return void this.moveCallbacks.splice(c, 1);
        },
        addPointer: function () {
          if (this.pointers.length >= c.Input.MAX_POINTERS) return null;
          var a = this.pointers.length + 1,
            b = new c.Pointer(this.game, a, c.PointerMode.TOUCH);
          return this.pointers.push(b), (this["pointer" + a] = b), b;
        },
        update: function () {
          if ((this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate)) return void this._pollCounter++;
          (this.speed.x = this.position.x - this._oldPosition.x),
            (this.speed.y = this.position.y - this._oldPosition.y),
            this._oldPosition.copyFrom(this.position),
            this.mousePointer.update(),
            this.gamepad && this.gamepad.active && this.gamepad.update();
          for (var a = 0; a < this.pointers.length; a++) this.pointers[a].update();
          this._pollCounter = 0;
        },
        reset: function (a) {
          if (this.game.isBooted && !this.resetLocked) {
            void 0 === a && (a = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(a), this.gamepad && this.gamepad.reset();
            for (var b = 0; b < this.pointers.length; b++) this.pointers[b].reset();
            "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"),
              a &&
                (this.onDown.dispose(),
                this.onUp.dispose(),
                this.onTap.dispose(),
                this.onHold.dispose(),
                (this.onDown = new c.Signal()),
                (this.onUp = new c.Signal()),
                (this.onTap = new c.Signal()),
                (this.onHold = new c.Signal()),
                (this.moveCallbacks = [])),
              (this._pollCounter = 0);
          }
        },
        resetSpeed: function (a, b) {
          this._oldPosition.setTo(a, b), this.speed.setTo(0, 0);
        },
        startPointer: function (a) {
          if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
          if (!this.pointer1.active) return this.pointer1.start(a);
          if (!this.pointer2.active) return this.pointer2.start(a);
          for (var b = 2; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (!c.active) return c.start(a);
          }
          return null;
        },
        updatePointer: function (a) {
          if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.move(a);
          if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.move(a);
          for (var b = 2; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (c.active && c.identifier === a.identifier) return c.move(a);
          }
          return null;
        },
        stopPointer: function (a) {
          if (this.pointer1.active && this.pointer1.identifier === a.identifier) return this.pointer1.stop(a);
          if (this.pointer2.active && this.pointer2.identifier === a.identifier) return this.pointer2.stop(a);
          for (var b = 2; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (c.active && c.identifier === a.identifier) return c.stop(a);
          }
          return null;
        },
        countActivePointers: function (a) {
          void 0 === a && (a = this.pointers.length);
          for (var b = a, c = 0; c < this.pointers.length && b > 0; c++) {
            var d = this.pointers[c];
            d.active && b--;
          }
          return a - b;
        },
        getPointer: function (a) {
          void 0 === a && (a = !1);
          for (var b = 0; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (c.active === a) return c;
          }
          return null;
        },
        getPointerFromIdentifier: function (a) {
          for (var b = 0; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (c.identifier === a) return c;
          }
          return null;
        },
        getPointerFromId: function (a) {
          for (var b = 0; b < this.pointers.length; b++) {
            var c = this.pointers[b];
            if (c.pointerId === a) return c;
          }
          return null;
        },
        getLocalPosition: function (a, b, d) {
          void 0 === d && (d = new c.Point());
          var e = a.worldTransform,
            f = 1 / (e.a * e.d + e.c * -e.b);
          return d.setTo(e.d * f * b.x + -e.c * f * b.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * b.y + -e.b * f * b.x + (-e.ty * e.a + e.tx * e.b) * f);
        },
        hitTest: function (a, b, d) {
          if (!a.worldVisible) return !1;
          if ((this.getLocalPosition(a, b, this._localPoint), d.copyFrom(this._localPoint), a.hitArea && a.hitArea.contains)) return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
          if (a instanceof c.TileSprite) {
            var e = a.width,
              f = a.height,
              g = -e * a.anchor.x;
            if (this._localPoint.x >= g && this._localPoint.x < g + e) {
              var h = -f * a.anchor.y;
              if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
            }
          } else if (a instanceof PIXI.Sprite) {
            var e = a.texture.frame.width,
              f = a.texture.frame.height,
              g = -e * a.anchor.x;
            if (this._localPoint.x >= g && this._localPoint.x < g + e) {
              var h = -f * a.anchor.y;
              if (this._localPoint.y >= h && this._localPoint.y < h + f) return !0;
            }
          } else if (a instanceof c.Graphics)
            for (var i = 0; i < a.graphicsData.length; i++) {
              var j = a.graphicsData[i];
              if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) return !0;
            }
          for (var i = 0; i < a.children.length; i++) if (this.hitTest(a.children[i], b, d)) return !0;
          return !1;
        },
        onClickTrampoline: function () {
          this.activePointer.processClickTrampolines();
        },
      }),
      (c.Input.prototype.constructor = c.Input),
      Object.defineProperty(c.Input.prototype, "x", {
        get: function () {
          return this._x;
        },
        set: function (a) {
          this._x = Math.floor(a);
        },
      }),
      Object.defineProperty(c.Input.prototype, "y", {
        get: function () {
          return this._y;
        },
        set: function (a) {
          this._y = Math.floor(a);
        },
      }),
      Object.defineProperty(c.Input.prototype, "pollLocked", {
        get: function () {
          return this.pollRate > 0 && this._pollCounter < this.pollRate;
        },
      }),
      Object.defineProperty(c.Input.prototype, "totalInactivePointers", {
        get: function () {
          return this.pointers.length - this.countActivePointers();
        },
      }),
      Object.defineProperty(c.Input.prototype, "totalActivePointers", {
        get: function () {
          return this.countActivePointers();
        },
      }),
      Object.defineProperty(c.Input.prototype, "worldX", {
        get: function () {
          return this.game.camera.view.x + this.x;
        },
      }),
      Object.defineProperty(c.Input.prototype, "worldY", {
        get: function () {
          return this.game.camera.view.y + this.y;
        },
      }),
      (c.Mouse = function (a) {
        (this.game = a),
          (this.input = a.input),
          (this.callbackContext = this.game),
          (this.mouseDownCallback = null),
          (this.mouseUpCallback = null),
          (this.mouseOutCallback = null),
          (this.mouseOverCallback = null),
          (this.mouseWheelCallback = null),
          (this.capture = !1),
          (this.button = -1),
          (this.wheelDelta = 0),
          (this.enabled = !0),
          (this.locked = !1),
          (this.stopOnGameOut = !1),
          (this.pointerLock = new c.Signal()),
          (this.event = null),
          (this._onMouseDown = null),
          (this._onMouseMove = null),
          (this._onMouseUp = null),
          (this._onMouseOut = null),
          (this._onMouseOver = null),
          (this._onMouseWheel = null),
          (this._wheelEvent = null);
      }),
      (c.Mouse.NO_BUTTON = -1),
      (c.Mouse.LEFT_BUTTON = 0),
      (c.Mouse.MIDDLE_BUTTON = 1),
      (c.Mouse.RIGHT_BUTTON = 2),
      (c.Mouse.BACK_BUTTON = 3),
      (c.Mouse.FORWARD_BUTTON = 4),
      (c.Mouse.WHEEL_UP = 1),
      (c.Mouse.WHEEL_DOWN = -1),
      (c.Mouse.prototype = {
        start: function () {
          if ((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
            var b = this;
            (this._onMouseDown = function (a) {
              return b.onMouseDown(a);
            }),
              (this._onMouseMove = function (a) {
                return b.onMouseMove(a);
              }),
              (this._onMouseUp = function (a) {
                return b.onMouseUp(a);
              }),
              (this._onMouseUpGlobal = function (a) {
                return b.onMouseUpGlobal(a);
              }),
              (this._onMouseOutGlobal = function (a) {
                return b.onMouseOutGlobal(a);
              }),
              (this._onMouseOut = function (a) {
                return b.onMouseOut(a);
              }),
              (this._onMouseOver = function (a) {
                return b.onMouseOver(a);
              }),
              (this._onMouseWheel = function (a) {
                return b.onMouseWheel(a);
              });
            var c = this.game.canvas;
            c.addEventListener("mousedown", this._onMouseDown, !0),
              c.addEventListener("mousemove", this._onMouseMove, !0),
              c.addEventListener("mouseup", this._onMouseUp, !0),
              this.game.device.cocoonJS ||
                (window.addEventListener("mouseup", this._onMouseUpGlobal, !0),
                window.addEventListener("mouseout", this._onMouseOutGlobal, !0),
                c.addEventListener("mouseover", this._onMouseOver, !0),
                c.addEventListener("mouseout", this._onMouseOut, !0));
            var d = this.game.device.wheelEvent;
            d && (c.addEventListener(d, this._onMouseWheel, !0), "mousewheel" === d ? (this._wheelEvent = new a(-0.025, 1)) : "DOMMouseScroll" === d && (this._wheelEvent = new a(1, 1)));
          }
        },
        onMouseDown: function (a) {
          (this.event = a), this.capture && a.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && ((a.identifier = 0), this.input.mousePointer.start(a));
        },
        onMouseMove: function (a) {
          (this.event = a), this.capture && a.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && ((a.identifier = 0), this.input.mousePointer.move(a));
        },
        onMouseUp: function (a) {
          (this.event = a), this.capture && a.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), this.input.enabled && this.enabled && ((a.identifier = 0), this.input.mousePointer.stop(a));
        },
        onMouseUpGlobal: function (a) {
          this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a), (a.identifier = 0), this.input.mousePointer.stop(a));
        },
        onMouseOutGlobal: function (a) {
          (this.event = a),
            this.capture && a.preventDefault(),
            (this.input.mousePointer.withinGame = !1),
            this.input.enabled && this.enabled && (this.input.mousePointer.stop(a), this.input.mousePointer.leftButton.stop(a), this.input.mousePointer.rightButton.stop(a));
        },
        onMouseOut: function (a) {
          (this.event = a),
            this.capture && a.preventDefault(),
            (this.input.mousePointer.withinGame = !1),
            this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && this.stopOnGameOut && ((a.identifier = 0), this.input.mousePointer.stop(a));
        },
        onMouseOver: function (a) {
          (this.event = a), this.capture && a.preventDefault(), (this.input.mousePointer.withinGame = !0), this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a);
        },
        onMouseWheel: function (a) {
          this._wheelEvent && (a = this._wheelEvent.bindEvent(a)),
            (this.event = a),
            this.capture && a.preventDefault(),
            (this.wheelDelta = c.Math.clamp(-a.deltaY, -1, 1)),
            this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a);
        },
        requestPointerLock: function () {
          if (this.game.device.pointerLock) {
            var a = this.game.canvas;
            (a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock), a.requestPointerLock();
            var b = this;
            (this._pointerLockChange = function (a) {
              return b.pointerLockChange(a);
            }),
              document.addEventListener("pointerlockchange", this._pointerLockChange, !0),
              document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0),
              document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
          }
        },
        pointerLockChange: function (a) {
          var b = this.game.canvas;
          document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b
            ? ((this.locked = !0), this.pointerLock.dispatch(!0, a))
            : ((this.locked = !1), this.pointerLock.dispatch(!1, a));
        },
        releasePointerLock: function () {
          (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock),
            document.exitPointerLock(),
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        },
        stop: function () {
          var a = this.game.canvas;
          a.removeEventListener("mousedown", this._onMouseDown, !0),
            a.removeEventListener("mousemove", this._onMouseMove, !0),
            a.removeEventListener("mouseup", this._onMouseUp, !0),
            a.removeEventListener("mouseover", this._onMouseOver, !0),
            a.removeEventListener("mouseout", this._onMouseOut, !0);
          var b = this.game.device.wheelEvent;
          b && a.removeEventListener(b, this._onMouseWheel, !0),
            window.removeEventListener("mouseup", this._onMouseUpGlobal, !0),
            window.removeEventListener("mouseout", this._onMouseOutGlobal, !0),
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0);
        },
      }),
      (c.Mouse.prototype.constructor = c.Mouse),
      (a.prototype = {}),
      (a.prototype.constructor = a),
      (a.prototype.bindEvent = function (b) {
        if (!a._stubsGenerated && b) {
          var c = function (a) {
            return function () {
              var b = this.originalEvent[a];
              return "function" != typeof b ? b : b.bind(this.originalEvent);
            };
          };
          for (var d in b) d in a.prototype || Object.defineProperty(a.prototype, d, { get: c(d) });
          a._stubsGenerated = !0;
        }
        return (this.originalEvent = b), this;
      }),
      Object.defineProperties(a.prototype, {
        type: { value: "wheel" },
        deltaMode: {
          get: function () {
            return this._deltaMode;
          },
        },
        deltaY: {
          get: function () {
            return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
          },
        },
        deltaX: {
          get: function () {
            return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
          },
        },
        deltaZ: { value: 0 },
      }),
      (c.MSPointer = function (a) {
        (this.game = a),
          (this.input = a.input),
          (this.callbackContext = this.game),
          (this.pointerDownCallback = null),
          (this.pointerMoveCallback = null),
          (this.pointerUpCallback = null),
          (this.capture = !0),
          (this.button = -1),
          (this.event = null),
          (this.enabled = !0),
          (this._onMSPointerDown = null),
          (this._onMSPointerMove = null),
          (this._onMSPointerUp = null),
          (this._onMSPointerUpGlobal = null),
          (this._onMSPointerOut = null),
          (this._onMSPointerOver = null);
      }),
      (c.MSPointer.prototype = {
        start: function () {
          if (null === this._onMSPointerDown) {
            var a = this;
            if (this.game.device.mspointer) {
              (this._onMSPointerDown = function (b) {
                return a.onPointerDown(b);
              }),
                (this._onMSPointerMove = function (b) {
                  return a.onPointerMove(b);
                }),
                (this._onMSPointerUp = function (b) {
                  return a.onPointerUp(b);
                }),
                (this._onMSPointerUpGlobal = function (b) {
                  return a.onPointerUpGlobal(b);
                }),
                (this._onMSPointerOut = function (b) {
                  return a.onPointerOut(b);
                }),
                (this._onMSPointerOver = function (b) {
                  return a.onPointerOver(b);
                });
              var b = this.game.canvas;
              b.addEventListener("MSPointerDown", this._onMSPointerDown, !1),
                b.addEventListener("MSPointerMove", this._onMSPointerMove, !1),
                b.addEventListener("MSPointerUp", this._onMSPointerUp, !1),
                b.addEventListener("pointerdown", this._onMSPointerDown, !1),
                b.addEventListener("pointermove", this._onMSPointerMove, !1),
                b.addEventListener("pointerup", this._onMSPointerUp, !1),
                (b.style["-ms-content-zooming"] = "none"),
                (b.style["-ms-touch-action"] = "none"),
                this.game.device.cocoonJS ||
                  (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
                  b.addEventListener("MSPointerOver", this._onMSPointerOver, !0),
                  b.addEventListener("MSPointerOut", this._onMSPointerOut, !0),
                  window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0),
                  b.addEventListener("pointerover", this._onMSPointerOver, !0),
                  b.addEventListener("pointerout", this._onMSPointerOut, !0));
            }
          }
        },
        onPointerDown: function (a) {
          (this.event = a),
            this.capture && a.preventDefault(),
            this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && ((a.identifier = a.pointerId), "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a));
        },
        onPointerMove: function (a) {
          (this.event = a),
            this.capture && a.preventDefault(),
            this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && ((a.identifier = a.pointerId), "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a));
        },
        onPointerUp: function (a) {
          (this.event = a),
            this.capture && a.preventDefault(),
            this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && ((a.identifier = a.pointerId), "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a));
        },
        onPointerUpGlobal: function (a) {
          if (("mouse" !== a.pointerType && 4 !== a.pointerType) || this.input.mousePointer.withinGame) {
            var b = this.input.getPointerFromIdentifier(a.identifier);
            b && b.withinGame && this.onPointerUp(a);
          } else this.onPointerUp(a);
        },
        onPointerOut: function (a) {
          if (((this.event = a), this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType)) this.input.mousePointer.withinGame = !1;
          else {
            var b = this.input.getPointerFromIdentifier(a.identifier);
            b && (b.withinGame = !1);
          }
          this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a),
            this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && ((a.identifier = 0), b ? b.stop(a) : this.input.mousePointer.stop(a));
        },
        onPointerOver: function (a) {
          if (((this.event = a), this.capture && a.preventDefault(), "mouse" === a.pointerType || 4 === a.pointerType)) this.input.mousePointer.withinGame = !0;
          else {
            var b = this.input.getPointerFromIdentifier(a.identifier);
            b && (b.withinGame = !0);
          }
          this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a);
        },
        stop: function () {
          var a = this.game.canvas;
          a.removeEventListener("MSPointerDown", this._onMSPointerDown, !1),
            a.removeEventListener("MSPointerMove", this._onMSPointerMove, !1),
            a.removeEventListener("MSPointerUp", this._onMSPointerUp, !1),
            a.removeEventListener("pointerdown", this._onMSPointerDown, !1),
            a.removeEventListener("pointermove", this._onMSPointerMove, !1),
            a.removeEventListener("pointerup", this._onMSPointerUp, !1),
            window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
            a.removeEventListener("MSPointerOver", this._onMSPointerOver, !0),
            a.removeEventListener("MSPointerOut", this._onMSPointerOut, !0),
            window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0),
            a.removeEventListener("pointerover", this._onMSPointerOver, !0),
            a.removeEventListener("pointerout", this._onMSPointerOut, !0);
        },
      }),
      (c.MSPointer.prototype.constructor = c.MSPointer),
      (c.DeviceButton = function (a, b) {
        (this.parent = a),
          (this.game = a.game),
          (this.event = null),
          (this.isDown = !1),
          (this.isUp = !0),
          (this.timeDown = 0),
          (this.timeUp = 0),
          (this.repeats = 0),
          (this.altKey = !1),
          (this.shiftKey = !1),
          (this.ctrlKey = !1),
          (this.value = 0),
          (this.buttonCode = b),
          (this.onDown = new c.Signal()),
          (this.onUp = new c.Signal()),
          (this.onFloat = new c.Signal());
      }),
      (c.DeviceButton.prototype = {
        start: function (a, b) {
          this.isDown ||
            ((this.isDown = !0),
            (this.isUp = !1),
            (this.timeDown = this.game.time.time),
            (this.repeats = 0),
            (this.event = a),
            (this.value = b),
            a && ((this.altKey = a.altKey), (this.shiftKey = a.shiftKey), (this.ctrlKey = a.ctrlKey)),
            this.onDown.dispatch(this, b));
        },
        stop: function (a, b) {
          this.isUp ||
            ((this.isDown = !1),
            (this.isUp = !0),
            (this.timeUp = this.game.time.time),
            (this.event = a),
            (this.value = b),
            a && ((this.altKey = a.altKey), (this.shiftKey = a.shiftKey), (this.ctrlKey = a.ctrlKey)),
            this.onUp.dispatch(this, b));
        },
        padFloat: function (a) {
          (this.value = a), this.onFloat.dispatch(this, a);
        },
        justPressed: function (a) {
          return (a = a || 250), this.isDown && this.timeDown + a > this.game.time.time;
        },
        justReleased: function (a) {
          return (a = a || 250), this.isUp && this.timeUp + a > this.game.time.time;
        },
        reset: function () {
          (this.isDown = !1), (this.isUp = !0), (this.timeDown = this.game.time.time), (this.repeats = 0), (this.altKey = !1), (this.shiftKey = !1), (this.ctrlKey = !1);
        },
        destroy: function () {
          this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), (this.parent = null), (this.game = null);
        },
      }),
      (c.DeviceButton.prototype.constructor = c.DeviceButton),
      Object.defineProperty(c.DeviceButton.prototype, "duration", {
        get: function () {
          return this.isUp ? -1 : this.game.time.time - this.timeDown;
        },
      }),
      (c.Pointer = function (a, b, d) {
        (this.game = a),
          (this.id = b),
          (this.type = c.POINTER),
          (this.exists = !0),
          (this.identifier = 0),
          (this.pointerId = null),
          (this.pointerMode = d || c.PointerMode.CURSOR | c.PointerMode.CONTACT),
          (this.target = null),
          (this.button = null),
          (this.leftButton = new c.DeviceButton(this, c.Pointer.LEFT_BUTTON)),
          (this.middleButton = new c.DeviceButton(this, c.Pointer.MIDDLE_BUTTON)),
          (this.rightButton = new c.DeviceButton(this, c.Pointer.RIGHT_BUTTON)),
          (this.backButton = new c.DeviceButton(this, c.Pointer.BACK_BUTTON)),
          (this.forwardButton = new c.DeviceButton(this, c.Pointer.FORWARD_BUTTON)),
          (this.eraserButton = new c.DeviceButton(this, c.Pointer.ERASER_BUTTON)),
          (this._holdSent = !1),
          (this._history = []),
          (this._nextDrop = 0),
          (this._stateReset = !1),
          (this.withinGame = !1),
          (this.clientX = -1),
          (this.clientY = -1),
          (this.pageX = -1),
          (this.pageY = -1),
          (this.screenX = -1),
          (this.screenY = -1),
          (this.rawMovementX = 0),
          (this.rawMovementY = 0),
          (this.movementX = 0),
          (this.movementY = 0),
          (this.x = -1),
          (this.y = -1),
          (this.isMouse = 0 === b),
          (this.isDown = !1),
          (this.isUp = !0),
          (this.timeDown = 0),
          (this.timeUp = 0),
          (this.previousTapTime = 0),
          (this.totalTouches = 0),
          (this.msSinceLastClick = Number.MAX_VALUE),
          (this.targetObject = null),
          (this.interactiveCandidates = []),
          (this.active = !1),
          (this.dirty = !1),
          (this.position = new c.Point()),
          (this.positionDown = new c.Point()),
          (this.positionUp = new c.Point()),
          (this.circle = new c.Circle(0, 0, 44)),
          (this._clickTrampolines = null),
          (this._trampolineTargetObject = null);
      }),
      (c.Pointer.NO_BUTTON = 0),
      (c.Pointer.LEFT_BUTTON = 1),
      (c.Pointer.RIGHT_BUTTON = 2),
      (c.Pointer.MIDDLE_BUTTON = 4),
      (c.Pointer.BACK_BUTTON = 8),
      (c.Pointer.FORWARD_BUTTON = 16),
      (c.Pointer.ERASER_BUTTON = 32),
      (c.Pointer.prototype = {
        resetButtons: function () {
          (this.isDown = !1), (this.isUp = !0), this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset());
        },
        processButtonsDown: function (a, b) {
          c.Pointer.LEFT_BUTTON & a && this.leftButton.start(b),
            c.Pointer.RIGHT_BUTTON & a && this.rightButton.start(b),
            c.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(b),
            c.Pointer.BACK_BUTTON & a && this.backButton.start(b),
            c.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(b),
            c.Pointer.ERASER_BUTTON & a && this.eraserButton.start(b);
        },
        processButtonsUp: function (a, b) {
          a === c.Mouse.LEFT_BUTTON && this.leftButton.stop(b),
            a === c.Mouse.RIGHT_BUTTON && this.rightButton.stop(b),
            a === c.Mouse.MIDDLE_BUTTON && this.middleButton.stop(b),
            a === c.Mouse.BACK_BUTTON && this.backButton.stop(b),
            a === c.Mouse.FORWARD_BUTTON && this.forwardButton.stop(b),
            5 === a && this.eraserButton.stop(b);
        },
        updateButtons: function (a) {
          this.button = a.button;
          var b = "down" === a.type.toLowerCase().substr(-4);
          void 0 !== a.buttons ? (b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a)) : b ? this.leftButton.start(a) : (this.leftButton.stop(a), this.rightButton.stop(a)),
            1 === a.buttons && a.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(a), this.rightButton.start(a)),
            (this.isUp = !0),
            (this.isDown = !1),
            (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && ((this.isUp = !1), (this.isDown = !0));
        },
        start: function (a) {
          var b = this.game.input;
          return (
            a.pointerId && (this.pointerId = a.pointerId),
            (this.identifier = a.identifier),
            (this.target = a.target),
            this.isMouse ? this.updateButtons(a) : ((this.isDown = !0), (this.isUp = !1)),
            (this.active = !0),
            (this.withinGame = !0),
            (this.dirty = !1),
            (this._history = []),
            (this._clickTrampolines = null),
            (this._trampolineTargetObject = null),
            (this.msSinceLastClick = this.game.time.time - this.timeDown),
            (this.timeDown = this.game.time.time),
            (this._holdSent = !1),
            this.move(a, !0),
            this.positionDown.setTo(this.x, this.y),
            (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || (b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers)) &&
              ((b.x = this.x), (b.y = this.y), b.position.setTo(this.x, this.y), b.onDown.dispatch(this, a), b.resetSpeed(this.x, this.y)),
            (this._stateReset = !1),
            this.totalTouches++,
            null !== this.targetObject && this.targetObject._touchedHandler(this),
            this
          );
        },
        update: function () {
          var a = this.game.input;
          this.active &&
            (this.dirty && (a.interactiveItems.total > 0 && this.processInteractiveObjects(!1), (this.dirty = !1)),
            this._holdSent === !1 &&
              this.duration >= a.holdRate &&
              ((a.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || (a.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers)) &&
                a.onHold.dispatch(this),
              (this._holdSent = !0)),
            a.recordPointerHistory &&
              this.game.time.time >= this._nextDrop &&
              ((this._nextDrop = this.game.time.time + a.recordRate), this._history.push({ x: this.position.x, y: this.position.y }), this._history.length > a.recordLimit && this._history.shift()));
        },
        move: function (a, b) {
          var d = this.game.input;
          if (!d.pollLocked) {
            if (
              (void 0 === b && (b = !1),
              void 0 !== a.button && (this.button = a.button),
              b && this.isMouse && this.updateButtons(a),
              (this.clientX = a.clientX),
              (this.clientY = a.clientY),
              (this.pageX = a.pageX),
              (this.pageY = a.pageY),
              (this.screenX = a.screenX),
              (this.screenY = a.screenY),
              this.isMouse &&
                d.mouse.locked &&
                !b &&
                ((this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0),
                (this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0),
                (this.movementX += this.rawMovementX),
                (this.movementY += this.rawMovementY)),
              (this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x),
              (this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y),
              this.position.setTo(this.x, this.y),
              (this.circle.x = this.x),
              (this.circle.y = this.y),
              (d.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || (d.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers)) &&
                ((d.activePointer = this), (d.x = this.x), (d.y = this.y), d.position.setTo(d.x, d.y), (d.circle.x = d.x), (d.circle.y = d.y)),
              (this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY)),
              this.game.paused)
            )
              return this;
            for (var e = d.moveCallbacks.length; e--; ) d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, b);
            return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : d.interactiveItems.total > 0 && this.processInteractiveObjects(b), this;
          }
        },
        processInteractiveObjects: function (a) {
          var b = 0,
            c = -1,
            d = null,
            e = this.game.input.interactiveItems.first;
          for (this.interactiveCandidates = []; e; )
            (e.checked = !1),
              e.validForInput(c, b, !1) && ((e.checked = !0), ((a && e.checkPointerDown(this, !0)) || (!a && e.checkPointerOver(this, !0))) && ((b = e.sprite.renderOrderID), (c = e.priorityID), (d = e), this.interactiveCandidates.push(e))),
              (e = this.game.input.interactiveItems.next);
          for (e = this.game.input.interactiveItems.first; e; )
            !e.checked && e.validForInput(c, b, !0) && ((a && e.checkPointerDown(this, !1)) || (!a && e.checkPointerOver(this, !1))) && ((b = e.sprite.renderOrderID), (c = e.priorityID), (d = e), this.interactiveCandidates.push(e)),
              (e = this.game.input.interactiveItems.next);
          return (
            this.game.input.customCandidateHandler && (d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d)), this.swapTarget(d, !1), null !== this.targetObject
          );
        },
        swapTarget: function (a, b) {
          void 0 === b && (b = !1),
            null === a
              ? this.targetObject && (this.targetObject._pointerOutHandler(this, b), (this.targetObject = null))
              : null === this.targetObject
              ? ((this.targetObject = a), a._pointerOverHandler(this, b))
              : this.targetObject === a
              ? a.update(this) === !1 && (this.targetObject = null)
              : (this.targetObject._pointerOutHandler(this, b), (this.targetObject = a), this.targetObject._pointerOverHandler(this, b));
        },
        leave: function (a) {
          (this.withinGame = !1), this.move(a, !1);
        },
        stop: function (a) {
          var b = this.game.input;
          return this._stateReset && this.withinGame
            ? void a.preventDefault()
            : ((this.timeUp = this.game.time.time),
              (b.multiInputOverride === c.Input.MOUSE_OVERRIDES_TOUCH || b.multiInputOverride === c.Input.MOUSE_TOUCH_COMBINE || (b.multiInputOverride === c.Input.TOUCH_OVERRIDES_MOUSE && 0 === b.totalActivePointers)) &&
                (b.onUp.dispatch(this, a),
                this.duration >= 0 && this.duration <= b.tapRate && (this.timeUp - this.previousTapTime < b.doubleTapRate ? b.onTap.dispatch(this, !0) : b.onTap.dispatch(this, !1), (this.previousTapTime = this.timeUp))),
              this.isMouse ? this.updateButtons(a) : ((this.isDown = !1), (this.isUp = !0)),
              this.id > 0 && (this.active = !1),
              (this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY)),
              (this.pointerId = null),
              (this.identifier = null),
              this.positionUp.setTo(this.x, this.y),
              this.isMouse === !1 && b.currentPointers--,
              b.interactiveItems.callAll("_releasedHandler", this),
              this._clickTrampolines && (this._trampolineTargetObject = this.targetObject),
              (this.targetObject = null),
              this);
        },
        justPressed: function (a) {
          return (a = a || this.game.input.justPressedRate), this.isDown === !0 && this.timeDown + a > this.game.time.time;
        },
        justReleased: function (a) {
          return (a = a || this.game.input.justReleasedRate), this.isUp && this.timeUp + a > this.game.time.time;
        },
        addClickTrampoline: function (a, b, c, d) {
          if (this.isDown) {
            for (var e = (this._clickTrampolines = this._clickTrampolines || []), f = 0; f < e.length; f++)
              if (e[f].name === a) {
                e.splice(f, 1);
                break;
              }
            e.push({ name: a, targetObject: this.targetObject, callback: b, callbackContext: c, callbackArgs: d });
          }
        },
        processClickTrampolines: function () {
          var a = this._clickTrampolines;
          if (a) {
            for (var b = 0; b < a.length; b++) {
              var c = a[b];
              c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs);
            }
            (this._clickTrampolines = null), (this._trampolineTargetObject = null);
          }
        },
        reset: function () {
          this.isMouse === !1 && (this.active = !1),
            (this.pointerId = null),
            (this.identifier = null),
            (this.dirty = !1),
            (this.totalTouches = 0),
            (this._holdSent = !1),
            (this._history.length = 0),
            (this._stateReset = !0),
            this.resetButtons(),
            this.targetObject && this.targetObject._releasedHandler(this),
            (this.targetObject = null);
        },
        resetMovement: function () {
          (this.movementX = 0), (this.movementY = 0);
        },
      }),
      (c.Pointer.prototype.constructor = c.Pointer),
      Object.defineProperty(c.Pointer.prototype, "duration", {
        get: function () {
          return this.isUp ? -1 : this.game.time.time - this.timeDown;
        },
      }),
      Object.defineProperty(c.Pointer.prototype, "worldX", {
        get: function () {
          return this.game.world.camera.x + this.x;
        },
      }),
      Object.defineProperty(c.Pointer.prototype, "worldY", {
        get: function () {
          return this.game.world.camera.y + this.y;
        },
      }),
      (c.PointerMode = { CURSOR: 1, CONTACT: 2 }),
      (c.Touch = function (a) {
        (this.game = a),
          (this.enabled = !0),
          (this.touchLockCallbacks = []),
          (this.callbackContext = this.game),
          (this.touchStartCallback = null),
          (this.touchMoveCallback = null),
          (this.touchEndCallback = null),
          (this.touchEnterCallback = null),
          (this.touchLeaveCallback = null),
          (this.touchCancelCallback = null),
          (this.preventDefault = !0),
          (this.event = null),
          (this._onTouchStart = null),
          (this._onTouchMove = null),
          (this._onTouchEnd = null),
          (this._onTouchEnter = null),
          (this._onTouchLeave = null),
          (this._onTouchCancel = null),
          (this._onTouchMove = null);
      }),
      (c.Touch.prototype = {
        start: function () {
          if (null === this._onTouchStart) {
            var a = this;
            this.game.device.touch &&
              ((this._onTouchStart = function (b) {
                return a.onTouchStart(b);
              }),
              (this._onTouchMove = function (b) {
                return a.onTouchMove(b);
              }),
              (this._onTouchEnd = function (b) {
                return a.onTouchEnd(b);
              }),
              (this._onTouchEnter = function (b) {
                return a.onTouchEnter(b);
              }),
              (this._onTouchLeave = function (b) {
                return a.onTouchLeave(b);
              }),
              (this._onTouchCancel = function (b) {
                return a.onTouchCancel(b);
              }),
              this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1),
              this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1),
              this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1),
              this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1),
              this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)));
          }
        },
        consumeDocumentTouches: function () {
          (this._documentTouchMove = function (a) {
            a.preventDefault();
          }),
            document.addEventListener("touchmove", this._documentTouchMove, !1);
        },
        addTouchLockCallback: function (a, b, c) {
          void 0 === c && (c = !1), this.touchLockCallbacks.push({ callback: a, context: b, onEnd: c });
        },
        removeTouchLockCallback: function (a, b) {
          for (var c = this.touchLockCallbacks.length; c--; ) if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) return this.touchLockCallbacks.splice(c, 1), !0;
          return !1;
        },
        onTouchStart: function (a) {
          for (var b = this.touchLockCallbacks.length; b--; ) {
            var c = this.touchLockCallbacks[b];
            !c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1);
          }
          if (((this.event = a), this.game.input.enabled && this.enabled)) {
            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.startPointer(a.changedTouches[b]);
          }
        },
        onTouchCancel: function (a) {
          if (((this.event = a), this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled)) {
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b]);
          }
        },
        onTouchEnter: function (a) {
          (this.event = a), this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a), this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault();
        },
        onTouchLeave: function (a) {
          (this.event = a), this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
        },
        onTouchMove: function (a) {
          (this.event = a), this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
          for (var b = 0; b < a.changedTouches.length; b++) this.game.input.updatePointer(a.changedTouches[b]);
        },
        onTouchEnd: function (a) {
          for (var b = this.touchLockCallbacks.length; b--; ) {
            var c = this.touchLockCallbacks[b];
            c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1);
          }
          (this.event = a), this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a), this.preventDefault && a.preventDefault();
          for (var b = 0; b < a.changedTouches.length; b++) this.game.input.stopPointer(a.changedTouches[b]);
        },
        stop: function () {
          this.game.device.touch &&
            (this.game.canvas.removeEventListener("touchstart", this._onTouchStart),
            this.game.canvas.removeEventListener("touchmove", this._onTouchMove),
            this.game.canvas.removeEventListener("touchend", this._onTouchEnd),
            this.game.canvas.removeEventListener("touchenter", this._onTouchEnter),
            this.game.canvas.removeEventListener("touchleave", this._onTouchLeave),
            this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel));
        },
      }),
      (c.Touch.prototype.constructor = c.Touch),
      (c.InputHandler = function (a) {
        (this.sprite = a),
          (this.game = a.game),
          (this.enabled = !1),
          (this.checked = !1),
          (this.priorityID = 0),
          (this.useHandCursor = !1),
          (this._setHandCursor = !1),
          (this.isDragged = !1),
          (this.allowHorizontalDrag = !0),
          (this.allowVerticalDrag = !0),
          (this.bringToTop = !1),
          (this.snapOffset = null),
          (this.snapOnDrag = !1),
          (this.snapOnRelease = !1),
          (this.snapX = 0),
          (this.snapY = 0),
          (this.snapOffsetX = 0),
          (this.snapOffsetY = 0),
          (this.pixelPerfectOver = !1),
          (this.pixelPerfectClick = !1),
          (this.pixelPerfectAlpha = 255),
          (this.draggable = !1),
          (this.boundsRect = null),
          (this.boundsSprite = null),
          (this.scaleLayer = !1),
          (this.dragOffset = new c.Point()),
          (this.dragFromCenter = !1),
          (this.dragStopBlocksInputUp = !1),
          (this.dragStartPoint = new c.Point()),
          (this.dragDistanceThreshold = 0),
          (this.dragTimeThreshold = 0),
          (this.downPoint = new c.Point()),
          (this.snapPoint = new c.Point()),
          (this._dragPoint = new c.Point()),
          (this._dragPhase = !1),
          (this._pendingDrag = !1),
          (this._dragTimePass = !1),
          (this._dragDistancePass = !1),
          (this._wasEnabled = !1),
          (this._tempPoint = new c.Point()),
          (this._pointerData = []),
          this._pointerData.push({ id: 0, x: 0, y: 0, camX: 0, camY: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 });
      }),
      (c.InputHandler.prototype = {
        start: function (a, b) {
          if (((a = a || 0), void 0 === b && (b = !1), this.enabled === !1)) {
            this.game.input.interactiveItems.add(this), (this.useHandCursor = b), (this.priorityID = a);
            for (var d = 0; d < 10; d++) this._pointerData[d] = { id: d, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 };
            (this.snapOffset = new c.Point()), (this.enabled = !0), (this._wasEnabled = !0);
          }
          return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite;
        },
        addedToGroup: function () {
          this._dragPhase || (this._wasEnabled && !this.enabled && this.start());
        },
        removedFromGroup: function () {
          this._dragPhase || (this.enabled ? ((this._wasEnabled = !0), this.stop()) : (this._wasEnabled = !1));
        },
        reset: function () {
          this.enabled = !1;
          for (var a = 0; a < 10; a++) this._pointerData[a] = { id: a, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 };
        },
        stop: function () {
          this.enabled !== !1 && ((this.enabled = !1), this.game.input.interactiveItems.remove(this));
        },
        destroy: function () {
          this.sprite &&
            (this._setHandCursor && ((this.game.canvas.style.cursor = "default"), (this._setHandCursor = !1)),
            (this.enabled = !1),
            this.game.input.interactiveItems.remove(this),
            (this._pointerData.length = 0),
            (this.boundsRect = null),
            (this.boundsSprite = null),
            (this.sprite = null));
        },
        validForInput: function (a, b, c) {
          return (
            void 0 === c && (c = !0),
            !(
              !this.enabled ||
              0 === this.sprite.scale.x ||
              0 === this.sprite.scale.y ||
              this.priorityID < this.game.input.minPriorityID ||
              (this.sprite.parent && this.sprite.parent.ignoreChildInput) ||
              (!c && (this.pixelPerfectClick || this.pixelPerfectOver)) ||
              !(this.priorityID > a || (this.priorityID === a && this.sprite.renderOrderID > b))
            )
          );
        },
        isPixelPerfect: function () {
          return this.pixelPerfectClick || this.pixelPerfectOver;
        },
        pointerX: function (a) {
          return (a = a || 0), this._pointerData[a].x;
        },
        pointerY: function (a) {
          return (a = a || 0), this._pointerData[a].y;
        },
        pointerDown: function (a) {
          return (a = a || 0), this._pointerData[a].isDown;
        },
        pointerUp: function (a) {
          return (a = a || 0), this._pointerData[a].isUp;
        },
        pointerTimeDown: function (a) {
          return (a = a || 0), this._pointerData[a].timeDown;
        },
        pointerTimeUp: function (a) {
          return (a = a || 0), this._pointerData[a].timeUp;
        },
        pointerOver: function (a) {
          if (!this.enabled) return !1;
          if (void 0 === a) {
            for (var b = 0; b < 10; b++) if (this._pointerData[b].isOver) return !0;
            return !1;
          }
          return this._pointerData[a].isOver;
        },
        pointerOut: function (a) {
          if (!this.enabled) return !1;
          if (void 0 !== a) return this._pointerData[a].isOut;
          for (var b = 0; b < 10; b++) if (this._pointerData[b].isOut) return !0;
        },
        pointerTimeOver: function (a) {
          return (a = a || 0), this._pointerData[a].timeOver;
        },
        pointerTimeOut: function (a) {
          return (a = a || 0), this._pointerData[a].timeOut;
        },
        pointerDragged: function (a) {
          return (a = a || 0), this._pointerData[a].isDragged;
        },
        checkPointerDown: function (a, b) {
          return (
            !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) &&
            !!this.game.input.hitTest(this.sprite, a, this._tempPoint) &&
            (void 0 === b && (b = !1), !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
          );
        },
        checkPointerOver: function (a, b) {
          return (
            !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) &&
            !!this.game.input.hitTest(this.sprite, a, this._tempPoint) &&
            (void 0 === b && (b = !1), !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
          );
        },
        checkPixel: function (a, b, c) {
          if (this.sprite.texture.baseTexture.source) {
            if (null === a && null === b) {
              this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
              var a = this._tempPoint.x,
                b = this._tempPoint.y;
            }
            if (
              (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x),
              0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y),
              (a += this.sprite.texture.frame.x),
              (b += this.sprite.texture.frame.y),
              this.sprite.texture.trim &&
                ((a -= this.sprite.texture.trim.x), (b -= this.sprite.texture.trim.y), a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom))
            )
              return (this._dx = a), (this._dy = b), !1;
            (this._dx = a), (this._dy = b), this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
            var d = this.game.input.hitContext.getImageData(0, 0, 1, 1);
            if (d.data[3] >= this.pixelPerfectAlpha) return !0;
          }
          return !1;
        },
        update: function (a) {
          if (null !== this.sprite && void 0 !== this.sprite.parent)
            return this.enabled && this.sprite.visible && this.sprite.parent.visible
              ? this._pendingDrag
                ? (this._dragDistancePass || (this._dragDistancePass = c.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(a), !0)
                : this.draggable && this._draggedPointerID === a.id
                ? this.updateDrag(a, !1)
                : this._pointerData[a.id].isOver
                ? this.checkPointerOver(a)
                  ? ((this._pointerData[a.id].x = a.x - this.sprite.x), (this._pointerData[a.id].y = a.y - this.sprite.y), !0)
                  : (this._pointerOutHandler(a), !1)
                : void 0
              : (this._pointerOutHandler(a), !1);
        },
        _pointerOverHandler: function (a, b) {
          if (null !== this.sprite) {
            var d = this._pointerData[a.id];
            if (d.isOver === !1 || a.dirty) {
              var e = d.isOver === !1;
              (d.isOver = !0),
                (d.isOut = !1),
                (d.timeOver = this.game.time.time),
                (d.x = a.x - this.sprite.x),
                (d.y = a.y - this.sprite.y),
                this.useHandCursor && d.isDragged === !1 && ((this.game.canvas.style.cursor = "pointer"), (this._setHandCursor = !0)),
                !b && e && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a),
                this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, a);
            }
          }
        },
        _pointerOutHandler: function (a, b) {
          if (null !== this.sprite) {
            var d = this._pointerData[a.id];
            (d.isOver = !1),
              (d.isOut = !0),
              (d.timeOut = this.game.time.time),
              this.useHandCursor && d.isDragged === !1 && ((this.game.canvas.style.cursor = "default"), (this._setHandCursor = !1)),
              !b &&
                this.sprite &&
                this.sprite.events &&
                (this.sprite.events.onInputOut$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, a));
          }
        },
        _touchedHandler: function (a) {
          if (null !== this.sprite) {
            var b = this._pointerData[a.id];
            if (!b.isDown && b.isOver) {
              if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) return;
              if (
                ((b.isDown = !0),
                (b.isUp = !1),
                (b.timeDown = this.game.time.time),
                this.downPoint.set(a.x, a.y),
                (a.dirty = !0),
                this.sprite &&
                  this.sprite.events &&
                  (this.sprite.events.onInputDown$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a), null === this.sprite))
              )
                return;
              this.draggable &&
                this.isDragged === !1 &&
                (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold
                  ? this.startDrag(a)
                  : ((this._pendingDrag = !0),
                    (this._dragDistancePass = 0 === this.dragDistanceThreshold),
                    this.dragTimeThreshold > 0 ? ((this._dragTimePass = !1), this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a)) : (this._dragTimePass = !0))),
                this.bringToTop && this.sprite.bringToTop();
            }
          }
        },
        dragTimeElapsed: function (a) {
          (this._dragTimePass = !0), this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(a);
        },
        _releasedHandler: function (a) {
          if (null !== this.sprite) {
            var b = this._pointerData[a.id];
            if (b.isDown && a.isUp) {
              (b.isDown = !1), (b.isUp = !0), (b.timeUp = this.game.time.time), (b.downDuration = b.timeUp - b.timeDown);
              var d = this.checkPointerOver(a);
              this.sprite &&
                this.sprite.events &&
                ((this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || (this.draggable && this.isDragged && this._draggedPointerID === a.id))) || this.sprite.events.onInputUp$dispatch(this.sprite, a, d),
                this.sprite && this.sprite.parent && this.sprite.parent.type === c.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d),
                d && (d = this.checkPointerOver(a))),
                (b.isOver = d),
                !d && this.useHandCursor && ((this.game.canvas.style.cursor = "default"), (this._setHandCursor = !1)),
                (a.dirty = !0),
                (this._pendingDrag = !1),
                this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a);
            }
          }
        },
        updateDrag: function (a, b) {
          if ((void 0 === b && (b = !1), a.isUp)) return this.stopDrag(a), !1;
          var c = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x,
            d = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
          if (this.sprite.fixedToCamera)
            this.allowHorizontalDrag && (this.sprite.cameraOffset.x = c),
              this.allowVerticalDrag && (this.sprite.cameraOffset.y = d),
              this.boundsRect && this.checkBoundsRect(),
              this.boundsSprite && this.checkBoundsSprite(),
              this.snapOnDrag &&
                ((this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX)),
                (this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY)),
                this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
          else {
            var e = this.game.camera.x - this._pointerData[a.id].camX,
              f = this.game.camera.y - this._pointerData[a.id].camY;
            this.allowHorizontalDrag && (this.sprite.x = c + e),
              this.allowVerticalDrag && (this.sprite.y = d + f),
              this.boundsRect && this.checkBoundsRect(),
              this.boundsSprite && this.checkBoundsSprite(),
              this.snapOnDrag &&
                ((this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX)),
                (this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY)),
                this.snapPoint.set(this.sprite.x, this.sprite.y));
          }
          return this.sprite.events.onDragUpdate.dispatch(this.sprite, a, c, d, this.snapPoint, b), !0;
        },
        justOver: function (a, b) {
          return (a = a || 0), (b = b || 500), this._pointerData[a].isOver && this.overDuration(a) < b;
        },
        justOut: function (a, b) {
          return (a = a || 0), (b = b || 500), this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b;
        },
        justPressed: function (a, b) {
          return (a = a || 0), (b = b || 500), this._pointerData[a].isDown && this.downDuration(a) < b;
        },
        justReleased: function (a, b) {
          return (a = a || 0), (b = b || 500), this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b;
        },
        overDuration: function (a) {
          return (a = a || 0), this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1;
        },
        downDuration: function (a) {
          return (a = a || 0), this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1;
        },
        enableDrag: function (a, b, d, e, f, g) {
          void 0 === a && (a = !1),
            void 0 === b && (b = !1),
            void 0 === d && (d = !1),
            void 0 === e && (e = 255),
            void 0 === f && (f = null),
            void 0 === g && (g = null),
            (this._dragPoint = new c.Point()),
            (this.draggable = !0),
            (this.bringToTop = b),
            (this.dragOffset = new c.Point()),
            (this.dragFromCenter = a),
            (this.pixelPerfectClick = d),
            (this.pixelPerfectAlpha = e),
            f && (this.boundsRect = f),
            g && (this.boundsSprite = g);
        },
        disableDrag: function () {
          if (this._pointerData) for (var a = 0; a < 10; a++) this._pointerData[a].isDragged = !1;
          (this.draggable = !1), (this.isDragged = !1), (this._draggedPointerID = -1), (this._pendingDrag = !1);
        },
        startDrag: function (a) {
          var b = this.sprite.x,
            c = this.sprite.y;
          if (
            ((this.isDragged = !0),
            (this._draggedPointerID = a.id),
            (this._pointerData[a.id].camX = this.game.camera.x),
            (this._pointerData[a.id].camY = this.game.camera.y),
            (this._pointerData[a.id].isDragged = !0),
            this.sprite.fixedToCamera)
          ) {
            if (this.dragFromCenter) {
              var d = this.sprite.getBounds();
              (this.sprite.cameraOffset.x = this.globalToLocalX(a.x) + (this.sprite.cameraOffset.x - d.centerX)), (this.sprite.cameraOffset.y = this.globalToLocalY(a.y) + (this.sprite.cameraOffset.y - d.centerY));
            }
            this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y);
          } else {
            if (this.dragFromCenter) {
              var d = this.sprite.getBounds();
              (this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX)), (this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY));
            }
            this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y));
          }
          this.updateDrag(a, !0), this.bringToTop && ((this._dragPhase = !0), this.sprite.bringToTop()), this.dragStartPoint.set(b, c), this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c), (this._pendingDrag = !1);
        },
        globalToLocalX: function (a) {
          return this.scaleLayer && ((a -= this.game.scale.grid.boundsFluid.x), (a *= this.game.scale.grid.scaleFluidInversed.x)), a;
        },
        globalToLocalY: function (a) {
          return this.scaleLayer && ((a -= this.game.scale.grid.boundsFluid.y), (a *= this.game.scale.grid.scaleFluidInversed.y)), a;
        },
        stopDrag: function (a) {
          (this.isDragged = !1),
            (this._draggedPointerID = -1),
            (this._pointerData[a.id].isDragged = !1),
            (this._dragPhase = !1),
            (this._pendingDrag = !1),
            this.snapOnRelease &&
              (this.sprite.fixedToCamera
                ? ((this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX)),
                  (this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY)))
                : ((this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX)),
                  (this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY)))),
            this.sprite.events.onDragStop$dispatch(this.sprite, a),
            this.checkPointerOver(a) === !1 && this._pointerOutHandler(a);
        },
        setDragLock: function (a, b) {
          void 0 === a && (a = !0), void 0 === b && (b = !0), (this.allowHorizontalDrag = a), (this.allowVerticalDrag = b);
        },
        enableSnap: function (a, b, c, d, e, f) {
          void 0 === c && (c = !0),
            void 0 === d && (d = !1),
            void 0 === e && (e = 0),
            void 0 === f && (f = 0),
            (this.snapX = a),
            (this.snapY = b),
            (this.snapOffsetX = e),
            (this.snapOffsetY = f),
            (this.snapOnDrag = c),
            (this.snapOnRelease = d);
        },
        disableSnap: function () {
          (this.snapOnDrag = !1), (this.snapOnRelease = !1);
        },
        checkBoundsRect: function () {
          this.sprite.fixedToCamera
            ? (this.sprite.cameraOffset.x < this.boundsRect.left
                ? (this.sprite.cameraOffset.x = this.boundsRect.left)
                : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width),
              this.sprite.cameraOffset.y < this.boundsRect.top
                ? (this.sprite.cameraOffset.y = this.boundsRect.top)
                : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height))
            : (this.sprite.left < this.boundsRect.left
                ? (this.sprite.x = this.boundsRect.x + this.sprite.offsetX)
                : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)),
              this.sprite.top < this.boundsRect.top
                ? (this.sprite.y = this.boundsRect.top + this.sprite.offsetY)
                : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)));
        },
        checkBoundsSprite: function () {
          this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera
            ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x
                ? (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x)
                : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width),
              this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y
                ? (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y)
                : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height &&
                  (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height))
            : (this.sprite.left < this.boundsSprite.left
                ? (this.sprite.x = this.boundsSprite.left + this.sprite.offsetX)
                : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)),
              this.sprite.top < this.boundsSprite.top
                ? (this.sprite.y = this.boundsSprite.top + this.sprite.offsetY)
                : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)));
        },
      }),
      (c.InputHandler.prototype.constructor = c.InputHandler),
      (c.Gamepad = function (a) {
        (this.game = a),
          (this._gamepadIndexMap = {}),
          (this._rawPads = []),
          (this._active = !1),
          (this.enabled = !0),
          (this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") !== -1 || !!navigator.getGamepads),
          (this._prevRawGamepadTypes = []),
          (this._prevTimestamps = []),
          (this.callbackContext = this),
          (this.onConnectCallback = null),
          (this.onDisconnectCallback = null),
          (this.onDownCallback = null),
          (this.onUpCallback = null),
          (this.onAxisCallback = null),
          (this.onFloatCallback = null),
          (this._ongamepadconnected = null),
          (this._gamepaddisconnected = null),
          (this._gamepads = [new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this), new c.SinglePad(a, this)]);
      }),
      (c.Gamepad.prototype = {
        addCallbacks: function (a, b) {
          "undefined" != typeof b &&
            ((this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback),
            (this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback),
            (this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback),
            (this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback),
            (this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback),
            (this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback),
            (this.callbackContext = a));
        },
        start: function () {
          if (!this._active) {
            this._active = !0;
            var a = this;
            (this._onGamepadConnected = function (b) {
              return a.onGamepadConnected(b);
            }),
              (this._onGamepadDisconnected = function (b) {
                return a.onGamepadDisconnected(b);
              }),
              window.addEventListener("gamepadconnected", this._onGamepadConnected, !1),
              window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1);
          }
        },
        onGamepadConnected: function (a) {
          var b = a.gamepad;
          this._rawPads.push(b), this._gamepads[b.index].connect(b);
        },
        onGamepadDisconnected: function (a) {
          var b = a.gamepad;
          for (var c in this._rawPads) this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
          this._gamepads[b.index].disconnect();
        },
        update: function () {
          this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus();
        },
        _pollGamepads: function () {
          if (this._active) {
            if (navigator.getGamepads) var a = navigator.getGamepads();
            else if (navigator.webkitGetGamepads) var a = navigator.webkitGetGamepads();
            else if (navigator.webkitGamepads) var a = navigator.webkitGamepads();
            if (a) {
              this._rawPads = [];
              for (var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && ((b = !0), (this._prevRawGamepadTypes[c] = typeof a[c])), a[c] && this._rawPads.push(a[c]), 3 !== c); c++);
              for (var d = 0; d < this._gamepads.length; d++) this._gamepads[d]._rawPad = this._rawPads[d];
              if (b) {
                for (var e, f = { rawIndices: {}, padIndices: {} }, g = 0; g < this._gamepads.length; g++)
                  if (((e = this._gamepads[g]), e.connected)) for (var h = 0; h < this._rawPads.length; h++) this._rawPads[h].index === e.index && ((f.rawIndices[e.index] = !0), (f.padIndices[g] = !0));
                for (var i = 0; i < this._gamepads.length; i++)
                  if (((e = this._gamepads[i]), !f.padIndices[i])) {
                    this._rawPads.length < 1 && e.disconnect();
                    for (var j = 0; j < this._rawPads.length && !f.padIndices[i]; j++) {
                      var k = this._rawPads[j];
                      if (k) {
                        if (f.rawIndices[k.index]) {
                          e.disconnect();
                          continue;
                        }
                        e.connect(k), (f.rawIndices[k.index] = !0), (f.padIndices[i] = !0);
                      } else e.disconnect();
                    }
                  }
              }
            }
          }
        },
        setDeadZones: function (a) {
          for (var b = 0; b < this._gamepads.length; b++) this._gamepads[b].deadZone = a;
        },
        stop: function () {
          (this._active = !1), window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
        },
        reset: function () {
          this.update();
          for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].reset();
        },
        justPressed: function (a, b) {
          for (var c = 0; c < this._gamepads.length; c++) if (this._gamepads[c].justPressed(a, b) === !0) return !0;
          return !1;
        },
        justReleased: function (a, b) {
          for (var c = 0; c < this._gamepads.length; c++) if (this._gamepads[c].justReleased(a, b) === !0) return !0;
          return !1;
        },
        isDown: function (a) {
          for (var b = 0; b < this._gamepads.length; b++) if (this._gamepads[b].isDown(a) === !0) return !0;
          return !1;
        },
        destroy: function () {
          this.stop();
          for (var a = 0; a < this._gamepads.length; a++) this._gamepads[a].destroy();
        },
      }),
      (c.Gamepad.prototype.constructor = c.Gamepad),
      Object.defineProperty(c.Gamepad.prototype, "active", {
        get: function () {
          return this._active;
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "supported", {
        get: function () {
          return this._gamepadSupportAvailable;
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "padsConnected", {
        get: function () {
          return this._rawPads.length;
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "pad1", {
        get: function () {
          return this._gamepads[0];
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "pad2", {
        get: function () {
          return this._gamepads[1];
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "pad3", {
        get: function () {
          return this._gamepads[2];
        },
      }),
      Object.defineProperty(c.Gamepad.prototype, "pad4", {
        get: function () {
          return this._gamepads[3];
        },
      }),
      (c.Gamepad.BUTTON_0 = 0),
      (c.Gamepad.BUTTON_1 = 1),
      (c.Gamepad.BUTTON_2 = 2),
      (c.Gamepad.BUTTON_3 = 3),
      (c.Gamepad.BUTTON_4 = 4),
      (c.Gamepad.BUTTON_5 = 5),
      (c.Gamepad.BUTTON_6 = 6),
      (c.Gamepad.BUTTON_7 = 7),
      (c.Gamepad.BUTTON_8 = 8),
      (c.Gamepad.BUTTON_9 = 9),
      (c.Gamepad.BUTTON_10 = 10),
      (c.Gamepad.BUTTON_11 = 11),
      (c.Gamepad.BUTTON_12 = 12),
      (c.Gamepad.BUTTON_13 = 13),
      (c.Gamepad.BUTTON_14 = 14),
      (c.Gamepad.BUTTON_15 = 15),
      (c.Gamepad.AXIS_0 = 0),
      (c.Gamepad.AXIS_1 = 1),
      (c.Gamepad.AXIS_2 = 2),
      (c.Gamepad.AXIS_3 = 3),
      (c.Gamepad.AXIS_4 = 4),
      (c.Gamepad.AXIS_5 = 5),
      (c.Gamepad.AXIS_6 = 6),
      (c.Gamepad.AXIS_7 = 7),
      (c.Gamepad.AXIS_8 = 8),
      (c.Gamepad.AXIS_9 = 9),
      (c.Gamepad.XBOX360_A = 0),
      (c.Gamepad.XBOX360_B = 1),
      (c.Gamepad.XBOX360_X = 2),
      (c.Gamepad.XBOX360_Y = 3),
      (c.Gamepad.XBOX360_LEFT_BUMPER = 4),
      (c.Gamepad.XBOX360_RIGHT_BUMPER = 5),
      (c.Gamepad.XBOX360_LEFT_TRIGGER = 6),
      (c.Gamepad.XBOX360_RIGHT_TRIGGER = 7),
      (c.Gamepad.XBOX360_BACK = 8),
      (c.Gamepad.XBOX360_START = 9),
      (c.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10),
      (c.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11),
      (c.Gamepad.XBOX360_DPAD_LEFT = 14),
      (c.Gamepad.XBOX360_DPAD_RIGHT = 15),
      (c.Gamepad.XBOX360_DPAD_UP = 12),
      (c.Gamepad.XBOX360_DPAD_DOWN = 13),
      (c.Gamepad.XBOX360_STICK_LEFT_X = 0),
      (c.Gamepad.XBOX360_STICK_LEFT_Y = 1),
      (c.Gamepad.XBOX360_STICK_RIGHT_X = 2),
      (c.Gamepad.XBOX360_STICK_RIGHT_Y = 3),
      (c.Gamepad.PS3XC_X = 0),
      (c.Gamepad.PS3XC_CIRCLE = 1),
      (c.Gamepad.PS3XC_SQUARE = 2),
      (c.Gamepad.PS3XC_TRIANGLE = 3),
      (c.Gamepad.PS3XC_L1 = 4),
      (c.Gamepad.PS3XC_R1 = 5),
      (c.Gamepad.PS3XC_L2 = 6),
      (c.Gamepad.PS3XC_R2 = 7),
      (c.Gamepad.PS3XC_SELECT = 8),
      (c.Gamepad.PS3XC_START = 9),
      (c.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10),
      (c.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11),
      (c.Gamepad.PS3XC_DPAD_UP = 12),
      (c.Gamepad.PS3XC_DPAD_DOWN = 13),
      (c.Gamepad.PS3XC_DPAD_LEFT = 14),
      (c.Gamepad.PS3XC_DPAD_RIGHT = 15),
      (c.Gamepad.PS3XC_STICK_LEFT_X = 0),
      (c.Gamepad.PS3XC_STICK_LEFT_Y = 1),
      (c.Gamepad.PS3XC_STICK_RIGHT_X = 2),
      (c.Gamepad.PS3XC_STICK_RIGHT_Y = 3),
      (c.SinglePad = function (a, b) {
        (this.game = a),
          (this.index = null),
          (this.connected = !1),
          (this.callbackContext = this),
          (this.onConnectCallback = null),
          (this.onDisconnectCallback = null),
          (this.onDownCallback = null),
          (this.onUpCallback = null),
          (this.onAxisCallback = null),
          (this.onFloatCallback = null),
          (this.deadZone = 0.26),
          (this._padParent = b),
          (this._rawPad = null),
          (this._prevTimestamp = null),
          (this._buttons = []),
          (this._buttonsLen = 0),
          (this._axes = []),
          (this._axesLen = 0);
      }),
      (c.SinglePad.prototype = {
        addCallbacks: function (a, b) {
          "undefined" != typeof b &&
            ((this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback),
            (this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback),
            (this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback),
            (this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback),
            (this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback),
            (this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback),
            (this.callbackContext = a));
        },
        getButton: function (a) {
          return this._buttons[a] ? this._buttons[a] : null;
        },
        pollStatus: function () {
          if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
            for (var a = 0; a < this._buttonsLen; a++) {
              var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
              b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b));
            }
            for (var c = 0; c < this._axesLen; c++) {
              var d = this._rawPad.axes[c];
              (d > 0 && d > this.deadZone) || (d < 0 && d < -this.deadZone) ? this.processAxisChange(c, d) : this.processAxisChange(c, 0);
            }
            this._prevTimestamp = this._rawPad.timestamp;
          }
        },
        connect: function (a) {
          var b = !this.connected;
          (this.connected = !0), (this.index = a.index), (this._rawPad = a), (this._buttons = []), (this._buttonsLen = a.buttons.length), (this._axes = []), (this._axesLen = a.axes.length);
          for (var d = 0; d < this._axesLen; d++) this._axes[d] = a.axes[d];
          for (var e in a.buttons) (e = parseInt(e, 10)), (this._buttons[e] = new c.DeviceButton(this, e));
          b && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), b && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext);
        },
        disconnect: function () {
          var a = this.connected,
            b = this.index;
          (this.connected = !1), (this.index = null), (this._rawPad = void 0);
          for (var c = 0; c < this._buttonsLen; c++) this._buttons[c].destroy();
          (this._buttons = []),
            (this._buttonsLen = 0),
            (this._axes = []),
            (this._axesLen = 0),
            a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b),
            a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext);
        },
        destroy: function () {
          this._rawPad = void 0;
          for (var a = 0; a < this._buttonsLen; a++) this._buttons[a].destroy();
          (this._buttons = []),
            (this._buttonsLen = 0),
            (this._axes = []),
            (this._axesLen = 0),
            (this.onConnectCallback = null),
            (this.onDisconnectCallback = null),
            (this.onDownCallback = null),
            (this.onUpCallback = null),
            (this.onAxisCallback = null),
            (this.onFloatCallback = null);
        },
        processAxisChange: function (a, b) {
          this._axes[a] !== b &&
            ((this._axes[a] = b), this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b));
        },
        processButtonDown: function (a, b) {
          this._buttons[a] && this._buttons[a].start(null, b),
            this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b);
        },
        processButtonUp: function (a, b) {
          this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b),
            this._buttons[a] && this._buttons[a].stop(null, b);
        },
        processButtonFloat: function (a, b) {
          this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b),
            this._buttons[a] && this._buttons[a].padFloat(b);
        },
        axis: function (a) {
          return !!this._axes[a] && this._axes[a];
        },
        isDown: function (a) {
          return !!this._buttons[a] && this._buttons[a].isDown;
        },
        isUp: function (a) {
          return !!this._buttons[a] && this._buttons[a].isUp;
        },
        justReleased: function (a, b) {
          if (this._buttons[a]) return this._buttons[a].justReleased(b);
        },
        justPressed: function (a, b) {
          if (this._buttons[a]) return this._buttons[a].justPressed(b);
        },
        buttonValue: function (a) {
          return this._buttons[a] ? this._buttons[a].value : null;
        },
        reset: function () {
          for (var a = 0; a < this._axes.length; a++) this._axes[a] = 0;
        },
      }),
      (c.SinglePad.prototype.constructor = c.SinglePad),
      (c.Key = function (a, b) {
        (this.game = a),
          (this._enabled = !0),
          (this.event = null),
          (this.isDown = !1),
          (this.isUp = !0),
          (this.altKey = !1),
          (this.ctrlKey = !1),
          (this.shiftKey = !1),
          (this.timeDown = 0),
          (this.duration = 0),
          (this.timeUp = -2500),
          (this.repeats = 0),
          (this.keyCode = b),
          (this.onDown = new c.Signal()),
          (this.onHoldCallback = null),
          (this.onHoldContext = null),
          (this.onUp = new c.Signal()),
          (this._justDown = !1),
          (this._justUp = !1);
      }),
      (c.Key.prototype = {
        update: function () {
          this._enabled && this.isDown && ((this.duration = this.game.time.time - this.timeDown), this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this));
        },
        processKeyDown: function (a) {
          this._enabled &&
            ((this.event = a),
            this.isDown ||
              ((this.altKey = a.altKey),
              (this.ctrlKey = a.ctrlKey),
              (this.shiftKey = a.shiftKey),
              (this.isDown = !0),
              (this.isUp = !1),
              (this.timeDown = this.game.time.time),
              (this.duration = 0),
              (this.repeats = 0),
              (this._justDown = !0),
              this.onDown.dispatch(this)));
        },
        processKeyUp: function (a) {
          this._enabled && ((this.event = a), this.isUp || ((this.isDown = !1), (this.isUp = !0), (this.timeUp = this.game.time.time), (this.duration = this.game.time.time - this.timeDown), (this._justUp = !0), this.onUp.dispatch(this)));
        },
        reset: function (a) {
          void 0 === a && (a = !0),
            (this.isDown = !1),
            (this.isUp = !0),
            (this.timeUp = this.game.time.time),
            (this.duration = 0),
            (this._enabled = !0),
            (this._justDown = !1),
            (this._justUp = !1),
            a && (this.onDown.removeAll(), this.onUp.removeAll(), (this.onHoldCallback = null), (this.onHoldContext = null));
        },
        downDuration: function (a) {
          return void 0 === a && (a = 50), this.isDown && this.duration < a;
        },
        upDuration: function (a) {
          return void 0 === a && (a = 50), !this.isDown && this.game.time.time - this.timeUp < a;
        },
      }),
      Object.defineProperty(c.Key.prototype, "justDown", {
        get: function () {
          var a = this._justDown;
          return (this._justDown = !1), a;
        },
      }),
      Object.defineProperty(c.Key.prototype, "justUp", {
        get: function () {
          var a = this._justUp;
          return (this._justUp = !1), a;
        },
      }),
      Object.defineProperty(c.Key.prototype, "enabled", {
        get: function () {
          return this._enabled;
        },
        set: function (a) {
          (a = !!a), a !== this._enabled && (a || this.reset(!1), (this._enabled = a));
        },
      }),
      (c.Key.prototype.constructor = c.Key),
      (c.Keyboard = function (a) {
        (this.game = a),
          (this.enabled = !0),
          (this.event = null),
          (this.pressEvent = null),
          (this.callbackContext = this),
          (this.onDownCallback = null),
          (this.onPressCallback = null),
          (this.onUpCallback = null),
          (this._keys = []),
          (this._capture = []),
          (this._onKeyDown = null),
          (this._onKeyPress = null),
          (this._onKeyUp = null),
          (this._i = 0),
          (this._k = 0);
      }),
      (c.Keyboard.prototype = {
        addCallbacks: function (a, b, c, d) {
          (this.callbackContext = a), void 0 !== b && null !== b && (this.onDownCallback = b), void 0 !== c && null !== c && (this.onUpCallback = c), void 0 !== d && null !== d && (this.onPressCallback = d);
        },
        addKey: function (a) {
          return this._keys[a] || ((this._keys[a] = new c.Key(this.game, a)), this.addKeyCapture(a)), this._keys[a];
        },
        addKeys: function (a) {
          var b = {};
          for (var c in a) b[c] = this.addKey(a[c]);
          return b;
        },
        removeKey: function (a) {
          this._keys[a] && ((this._keys[a] = null), this.removeKeyCapture(a));
        },
        createCursorKeys: function () {
          return this.addKeys({ up: c.KeyCode.UP, down: c.KeyCode.DOWN, left: c.KeyCode.LEFT, right: c.KeyCode.RIGHT });
        },
        start: function () {
          if (!this.game.device.cocoonJS && null === this._onKeyDown) {
            var a = this;
            (this._onKeyDown = function (b) {
              return a.processKeyDown(b);
            }),
              (this._onKeyUp = function (b) {
                return a.processKeyUp(b);
              }),
              (this._onKeyPress = function (b) {
                return a.processKeyPress(b);
              }),
              window.addEventListener("keydown", this._onKeyDown, !1),
              window.addEventListener("keyup", this._onKeyUp, !1),
              window.addEventListener("keypress", this._onKeyPress, !1);
          }
        },
        stop: function () {
          window.removeEventListener("keydown", this._onKeyDown),
            window.removeEventListener("keyup", this._onKeyUp),
            window.removeEventListener("keypress", this._onKeyPress),
            (this._onKeyDown = null),
            (this._onKeyUp = null),
            (this._onKeyPress = null);
        },
        destroy: function () {
          this.stop(), this.clearCaptures(), (this._keys.length = 0), (this._i = 0);
        },
        addKeyCapture: function (a) {
          if ("object" == typeof a) for (var b in a) this._capture[a[b]] = !0;
          else this._capture[a] = !0;
        },
        removeKeyCapture: function (a) {
          delete this._capture[a];
        },
        clearCaptures: function () {
          this._capture = {};
        },
        update: function () {
          for (this._i = this._keys.length; this._i--; ) this._keys[this._i] && this._keys[this._i].update();
        },
        processKeyDown: function (a) {
          if (((this.event = a), this.game.input.enabled && this.enabled)) {
            var b = a.keyCode;
            this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyDown(a), (this._k = b), this.onDownCallback && this.onDownCallback.call(this.callbackContext, a);
          }
        },
        processKeyPress: function (a) {
          (this.pressEvent = a), this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a);
        },
        processKeyUp: function (a) {
          if (((this.event = a), this.game.input.enabled && this.enabled)) {
            var b = a.keyCode;
            this._capture[b] && a.preventDefault(), this._keys[b] || (this._keys[b] = new c.Key(this.game, b)), this._keys[b].processKeyUp(a), this.onUpCallback && this.onUpCallback.call(this.callbackContext, a);
          }
        },
        reset: function (a) {
          void 0 === a && (a = !0), (this.event = null);
          for (var b = this._keys.length; b--; ) this._keys[b] && this._keys[b].reset(a);
        },
        downDuration: function (a, b) {
          return this._keys[a] ? this._keys[a].downDuration(b) : null;
        },
        upDuration: function (a, b) {
          return this._keys[a] ? this._keys[a].upDuration(b) : null;
        },
        isDown: function (a) {
          return this._keys[a] ? this._keys[a].isDown : null;
        },
      }),
      Object.defineProperty(c.Keyboard.prototype, "lastChar", {
        get: function () {
          return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode);
        },
      }),
      Object.defineProperty(c.Keyboard.prototype, "lastKey", {
        get: function () {
          return this._keys[this._k];
        },
      }),
      (c.Keyboard.prototype.constructor = c.Keyboard),
      (c.KeyCode = {
        A: "A".charCodeAt(0),
        B: "B".charCodeAt(0),
        C: "C".charCodeAt(0),
        D: "D".charCodeAt(0),
        E: "E".charCodeAt(0),
        F: "F".charCodeAt(0),
        G: "G".charCodeAt(0),
        H: "H".charCodeAt(0),
        I: "I".charCodeAt(0),
        J: "J".charCodeAt(0),
        K: "K".charCodeAt(0),
        L: "L".charCodeAt(0),
        M: "M".charCodeAt(0),
        N: "N".charCodeAt(0),
        O: "O".charCodeAt(0),
        P: "P".charCodeAt(0),
        Q: "Q".charCodeAt(0),
        R: "R".charCodeAt(0),
        S: "S".charCodeAt(0),
        T: "T".charCodeAt(0),
        U: "U".charCodeAt(0),
        V: "V".charCodeAt(0),
        W: "W".charCodeAt(0),
        X: "X".charCodeAt(0),
        Y: "Y".charCodeAt(0),
        Z: "Z".charCodeAt(0),
        ZERO: "0".charCodeAt(0),
        ONE: "1".charCodeAt(0),
        TWO: "2".charCodeAt(0),
        THREE: "3".charCodeAt(0),
        FOUR: "4".charCodeAt(0),
        FIVE: "5".charCodeAt(0),
        SIX: "6".charCodeAt(0),
        SEVEN: "7".charCodeAt(0),
        EIGHT: "8".charCodeAt(0),
        NINE: "9".charCodeAt(0),
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_ENTER: 108,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        F13: 124,
        F14: 125,
        F15: 126,
        COLON: 186,
        EQUALS: 187,
        COMMA: 188,
        UNDERSCORE: 189,
        PERIOD: 190,
        QUESTION_MARK: 191,
        TILDE: 192,
        OPEN_BRACKET: 219,
        BACKWARD_SLASH: 220,
        CLOSED_BRACKET: 221,
        QUOTES: 222,
        BACKSPACE: 8,
        TAB: 9,
        CLEAR: 12,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        CAPS_LOCK: 20,
        ESC: 27,
        SPACEBAR: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        PLUS: 43,
        MINUS: 44,
        INSERT: 45,
        DELETE: 46,
        HELP: 47,
        NUM_LOCK: 144,
      });
    for (var e in c.KeyCode) c.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/) && (c.Keyboard[e] = c.KeyCode[e]);
    (c.Component = function () {}),
      (c.Component.Angle = function () {}),
      (c.Component.Angle.prototype = {
        angle: {
          get: function () {
            return c.Math.wrapAngle(c.Math.radToDeg(this.rotation));
          },
          set: function (a) {
            this.rotation = c.Math.degToRad(c.Math.wrapAngle(a));
          },
        },
      }),
      (c.Component.Animation = function () {}),
      (c.Component.Animation.prototype = {
        play: function (a, b, c, d) {
          if (this.animations) return this.animations.play(a, b, c, d);
        },
      }),
      (c.Component.AutoCull = function () {}),
      (c.Component.AutoCull.prototype = {
        autoCull: !1,
        inCamera: {
          get: function () {
            return (
              this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), (this._bounds.x += this.game.camera.view.x), (this._bounds.y += this.game.camera.view.y)),
              this.game.world.camera.view.intersects(this._bounds)
            );
          },
        },
      }),
      (c.Component.Bounds = function () {}),
      (c.Component.Bounds.prototype = {
        offsetX: {
          get: function () {
            return this.anchor.x * this.width;
          },
        },
        offsetY: {
          get: function () {
            return this.anchor.y * this.height;
          },
        },
        centerX: {
          get: function () {
            return this.x - this.offsetX + 0.5 * this.width;
          },
          set: function (a) {
            this.x = a + this.offsetX - 0.5 * this.width;
          },
        },
        centerY: {
          get: function () {
            return this.y - this.offsetY + 0.5 * this.height;
          },
          set: function (a) {
            this.y = a + this.offsetY - 0.5 * this.height;
          },
        },
        left: {
          get: function () {
            return this.x - this.offsetX;
          },
          set: function (a) {
            this.x = a + this.offsetX;
          },
        },
        right: {
          get: function () {
            return this.x + this.width - this.offsetX;
          },
          set: function (a) {
            this.x = a - this.width + this.offsetX;
          },
        },
        top: {
          get: function () {
            return this.y - this.offsetY;
          },
          set: function (a) {
            this.y = a + this.offsetY;
          },
        },
        bottom: {
          get: function () {
            return this.y + this.height - this.offsetY;
          },
          set: function (a) {
            this.y = a - this.height + this.offsetY;
          },
        },
        alignIn: function (a, b, d, e) {
          switch ((void 0 === d && (d = 0), void 0 === e && (e = 0), b)) {
            default:
            case c.TOP_LEFT:
              (this.left = a.left - d), (this.top = a.top - e);
              break;
            case c.TOP_CENTER:
              (this.centerX = a.centerX + d), (this.top = a.top - e);
              break;
            case c.TOP_RIGHT:
              (this.right = a.right + d), (this.top = a.top - e);
              break;
            case c.LEFT_CENTER:
              (this.left = a.left - d), (this.centerY = a.centerY + e);
              break;
            case c.CENTER:
              (this.centerX = a.centerX + d), (this.centerY = a.centerY + e);
              break;
            case c.RIGHT_CENTER:
              (this.right = a.right + d), (this.centerY = a.centerY + e);
              break;
            case c.BOTTOM_LEFT:
              (this.left = a.left - d), (this.bottom = a.bottom + e);
              break;
            case c.BOTTOM_CENTER:
              (this.centerX = a.centerX + d), (this.bottom = a.bottom + e);
              break;
            case c.BOTTOM_RIGHT:
              (this.right = a.right + d), (this.bottom = a.bottom + e);
          }
          return this;
        },
        alignTo: function (a, b, d, e) {
          switch ((void 0 === d && (d = 0), void 0 === e && (e = 0), b)) {
            default:
            case c.TOP_LEFT:
              (this.left = a.left - d), (this.bottom = a.top - e);
              break;
            case c.TOP_CENTER:
              (this.centerX = a.centerX + d), (this.bottom = a.top - e);
              break;
            case c.TOP_RIGHT:
              (this.right = a.right + d), (this.bottom = a.top - e);
              break;
            case c.LEFT_TOP:
              (this.right = a.left - d), (this.top = a.top - e);
              break;
            case c.LEFT_CENTER:
              (this.right = a.left - d), (this.centerY = a.centerY + e);
              break;
            case c.LEFT_BOTTOM:
              (this.right = a.left - d), (this.bottom = a.bottom + e);
              break;
            case c.RIGHT_TOP:
              (this.left = a.right + d), (this.top = a.top - e);
              break;
            case c.RIGHT_CENTER:
              (this.left = a.right + d), (this.centerY = a.centerY + e);
              break;
            case c.RIGHT_BOTTOM:
              (this.left = a.right + d), (this.bottom = a.bottom + e);
              break;
            case c.BOTTOM_LEFT:
              (this.left = a.left - d), (this.top = a.bottom + e);
              break;
            case c.BOTTOM_CENTER:
              (this.centerX = a.centerX + d), (this.top = a.bottom + e);
              break;
            case c.BOTTOM_RIGHT:
              (this.right = a.right + d), (this.top = a.bottom + e);
          }
          return this;
        },
      }),
      (c.Group.prototype.alignIn = c.Component.Bounds.prototype.alignIn),
      (c.Group.prototype.alignTo = c.Component.Bounds.prototype.alignTo),
      (c.Component.BringToTop = function () {}),
      (c.Component.BringToTop.prototype.bringToTop = function () {
        return this.parent && this.parent.bringToTop(this), this;
      }),
      (c.Component.BringToTop.prototype.sendToBack = function () {
        return this.parent && this.parent.sendToBack(this), this;
      }),
      (c.Component.BringToTop.prototype.moveUp = function () {
        return this.parent && this.parent.moveUp(this), this;
      }),
      (c.Component.BringToTop.prototype.moveDown = function () {
        return this.parent && this.parent.moveDown(this), this;
      }),
      (c.Component.Core = function () {}),
      (c.Component.Core.install = function (a) {
        c.Utils.mixinPrototype(this, c.Component.Core.prototype), (this.components = {});
        for (var b = 0; b < a.length; b++) {
          var d = a[b],
            e = !1;
          "Destroy" === d && (e = !0), c.Utils.mixinPrototype(this, c.Component[d].prototype, e), (this.components[d] = !0);
        }
      }),
      (c.Component.Core.init = function (a, b, d, e, f) {
        (this.game = a),
          (this.key = e),
          (this.data = {}),
          this.position.set(b, d),
          (this.world = new c.Point(b, d)),
          (this.previousPosition = new c.Point(b, d)),
          (this.events = new c.Events(this)),
          (this._bounds = new c.Rectangle()),
          this.components.PhysicsBody && (this.body = this.body),
          this.components.Animation && (this.animations = new c.AnimationManager(this)),
          this.components.LoadTexture && null !== e && this.loadTexture(e, f),
          this.components.FixedToCamera && (this.cameraOffset = new c.Point(b, d));
      }),
      (c.Component.Core.preUpdate = function () {
        if (this.pendingDestroy) return void this.destroy();
        if ((this.previousPosition.set(this.world.x, this.world.y), (this.previousRotation = this.rotation), !this.exists || !this.parent.exists)) return (this.renderOrderID = -1), !1;
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty),
          this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++),
          this.animations && this.animations.update(),
          this.body && this.body.preUpdate();
        for (var a = 0; a < this.children.length; a++) this.children[a].preUpdate();
        return !0;
      }),
      (c.Component.Core.prototype = {
        game: null,
        name: "",
        data: {},
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
          get: function () {
            return this._exists;
          },
          set: function (a) {
            a
              ? ((this._exists = !0), this.body && this.body.type === c.Physics.P2JS && this.body.addToWorld(), (this.visible = !0))
              : ((this._exists = !1), this.body && this.body.type === c.Physics.P2JS && this.body.removeFromWorld(), (this.visible = !1));
          },
        },
        update: function () {},
        postUpdate: function () {
          this.customRender && this.key.render(), this.components.PhysicsBody && c.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && c.Component.FixedToCamera.postUpdate.call(this);
          for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
        },
      }),
      (c.Component.Crop = function () {}),
      (c.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function (a, b) {
          void 0 === b && (b = !1),
            a
              ? (b && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : b && null === this.cropRect ? (this.cropRect = new c.Rectangle(a.x, a.y, a.width, a.height)) : (this.cropRect = a), this.updateCrop())
              : ((this._crop = null), (this.cropRect = null), this.resetFrame());
        },
        updateCrop: function () {
          if (this.cropRect) {
            var a = this.texture.crop.x,
              b = this.texture.crop.y,
              d = this.texture.crop.width,
              e = this.texture.crop.height;
            (this._crop = c.Rectangle.clone(this.cropRect, this._crop)), (this._crop.x += this._frame.x), (this._crop.y += this._frame.y);
            var f = Math.max(this._frame.x, this._crop.x),
              g = Math.max(this._frame.y, this._crop.y),
              h = Math.min(this._frame.right, this._crop.right) - f,
              i = Math.min(this._frame.bottom, this._crop.bottom) - g;
            (this.texture.crop.x = f),
              (this.texture.crop.y = g),
              (this.texture.crop.width = h),
              (this.texture.crop.height = i),
              (this.texture.frame.width = Math.min(h, this.cropRect.width)),
              (this.texture.frame.height = Math.min(i, this.cropRect.height)),
              (this.texture.width = this.texture.frame.width),
              (this.texture.height = this.texture.frame.height),
              this.texture._updateUvs(),
              16777215 === this.tint || (a === f && b === g && d === h && e === i) || (this.texture.requiresReTint = !0);
          }
        },
      }),
      (c.Component.Delta = function () {}),
      (c.Component.Delta.prototype = {
        deltaX: {
          get: function () {
            return this.world.x - this.previousPosition.x;
          },
        },
        deltaY: {
          get: function () {
            return this.world.y - this.previousPosition.y;
          },
        },
        deltaZ: {
          get: function () {
            return this.rotation - this.previousRotation;
          },
        },
      }),
      (c.Component.Destroy = function () {}),
      (c.Component.Destroy.prototype = {
        destroyPhase: !1,
        destroy: function (a, b) {
          if (null !== this.game && !this.destroyPhase) {
            void 0 === a && (a = !0),
              void 0 === b && (b = !1),
              (this.destroyPhase = !0),
              this.events && this.events.onDestroy$dispatch(this),
              this.parent && (this.parent instanceof c.Group ? this.parent.remove(this) : this.parent.removeChild(this)),
              this.input && this.input.destroy(),
              this.animations && this.animations.destroy(),
              this.body && this.body.destroy(),
              this.events && this.events.destroy(),
              this.game.tweens.removeFrom(this);
            var d = this.children.length;
            if (a) for (; d--; ) this.children[d].destroy(a);
            else for (; d--; ) this.removeChild(this.children[d]);
            this._crop && ((this._crop = null), (this.cropRect = null)),
              this._frame && (this._frame = null),
              c.Video && this.key instanceof c.Video && this.key.onChangeSource.remove(this.resizeFrame, this),
              c.BitmapText && this._glyphs && (this._glyphs = []),
              (this.alive = !1),
              (this.exists = !1),
              (this.visible = !1),
              (this.filters = null),
              (this.mask = null),
              (this.game = null),
              (this.data = {}),
              (this.renderable = !1),
              this.transformCallback && ((this.transformCallback = null), (this.transformCallbackContext = null)),
              (this.hitArea = null),
              (this.parent = null),
              (this.stage = null),
              (this.worldTransform = null),
              (this.filterArea = null),
              (this._bounds = null),
              (this._currentBounds = null),
              (this._mask = null),
              this._destroyCachedSprite(),
              b && this.texture.destroy(!0),
              (this.destroyPhase = !1),
              (this.pendingDestroy = !1);
          }
        },
      }),
      (c.Events = function (a) {
        this.parent = a;
      }),
      (c.Events.prototype = {
        destroy: function () {
          (this._parent = null),
            this._onDestroy && this._onDestroy.dispose(),
            this._onAddedToGroup && this._onAddedToGroup.dispose(),
            this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(),
            this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(),
            this._onKilled && this._onKilled.dispose(),
            this._onRevived && this._onRevived.dispose(),
            this._onEnterBounds && this._onEnterBounds.dispose(),
            this._onOutOfBounds && this._onOutOfBounds.dispose(),
            this._onInputOver && this._onInputOver.dispose(),
            this._onInputOut && this._onInputOut.dispose(),
            this._onInputDown && this._onInputDown.dispose(),
            this._onInputUp && this._onInputUp.dispose(),
            this._onDragStart && this._onDragStart.dispose(),
            this._onDragUpdate && this._onDragUpdate.dispose(),
            this._onDragStop && this._onDragStop.dispose(),
            this._onAnimationStart && this._onAnimationStart.dispose(),
            this._onAnimationComplete && this._onAnimationComplete.dispose(),
            this._onAnimationLoop && this._onAnimationLoop.dispose();
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null,
      }),
      (c.Events.prototype.constructor = c.Events);
    for (var f in c.Events.prototype)
      c.Events.prototype.hasOwnProperty(f) &&
        0 === f.indexOf("on") &&
        null === c.Events.prototype[f] &&
        !(function (a, b) {
          "use strict";
          Object.defineProperty(c.Events.prototype, a, {
            get: function () {
              return this[b] || (this[b] = new c.Signal());
            },
          }),
            (c.Events.prototype[a + "$dispatch"] = function () {
              return this[b] ? this[b].dispatch.apply(this[b], arguments) : null;
            });
        })(f, "_" + f);
    (c.Component.FixedToCamera = function () {}),
      (c.Component.FixedToCamera.postUpdate = function () {
        this.fixedToCamera && ((this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x), (this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y));
      }),
      (c.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1,
        fixedToCamera: {
          get: function () {
            return this._fixedToCamera;
          },
          set: function (a) {
            a ? ((this._fixedToCamera = !0), this.cameraOffset.set(this.x, this.y)) : (this._fixedToCamera = !1);
          },
        },
        cameraOffset: new c.Point(),
      }),
      (c.Component.Health = function () {}),
      (c.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function (a) {
          return this.alive && ((this.health -= a), this.health <= 0 && this.kill()), this;
        },
        setHealth: function (a) {
          return (this.health = a), this.health > this.maxHealth && (this.health = this.maxHealth), this;
        },
        heal: function (a) {
          return this.alive && ((this.health += a), this.health > this.maxHealth && (this.health = this.maxHealth)), this;
        },
      }),
      (c.Component.InCamera = function () {}),
      (c.Component.InCamera.prototype = {
        inCamera: {
          get: function () {
            return this.game.world.camera.view.intersects(this._bounds);
          },
        },
      }),
      (c.Component.InputEnabled = function () {}),
      (c.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
          get: function () {
            return this.input && this.input.enabled;
          },
          set: function (a) {
            a ? (null === this.input ? ((this.input = new c.InputHandler(this)), this.input.start()) : this.input && !this.input.enabled && this.input.start()) : this.input && this.input.enabled && this.input.stop();
          },
        },
      }),
      (c.Component.InWorld = function () {}),
      (c.Component.InWorld.preUpdate = function () {
        if (this.autoCull || this.checkWorldBounds) {
          if ((this._bounds.copyFrom(this.getBounds()), (this._bounds.x += this.game.camera.view.x), (this._bounds.y += this.game.camera.view.y), this.autoCull))
            if (this.game.world.camera.view.intersects(this._bounds)) (this.renderable = !0), this.game.world.camera.totalInView++;
            else if (((this.renderable = !1), this.outOfCameraBoundsKill)) return this.kill(), !1;
          if (this.checkWorldBounds)
            if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) (this._outOfBoundsFired = !1), this.events.onEnterBounds$dispatch(this);
            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && ((this._outOfBoundsFired = !0), this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1;
        }
        return !0;
      }),
      (c.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        outOfCameraBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
          get: function () {
            return this.game.world.bounds.intersects(this.getBounds());
          },
        },
      }),
      (c.Component.LifeSpan = function () {}),
      (c.Component.LifeSpan.preUpdate = function () {
        return !(this.lifespan > 0 && ((this.lifespan -= this.game.time.physicsElapsedMS), this.lifespan <= 0) && (this.kill(), 1));
      }),
      (c.Component.LifeSpan.prototype = {
        alive: !0,
        lifespan: 0,
        revive: function (a) {
          return void 0 === a && (a = 100), (this.alive = !0), (this.exists = !0), (this.visible = !0), "function" == typeof this.setHealth && this.setHealth(a), this.events && this.events.onRevived$dispatch(this), this;
        },
        kill: function () {
          return (this.alive = !1), (this.exists = !1), (this.visible = !1), this.events && this.events.onKilled$dispatch(this), this;
        },
      }),
      (c.Component.LoadTexture = function () {}),
      (c.Component.LoadTexture.prototype = {
        customRender: !1,
        _frame: null,
        loadTexture: function (a, b, d) {
          a === c.PENDING_ATLAS ? ((a = b), (b = 0)) : (b = b || 0), (d || void 0 === d) && this.animations && this.animations.stop(), (this.key = a), (this.customRender = !1);
          var e = this.game.cache,
            f = !0,
            g = !this.texture.baseTexture.scaleMode;
          if (c.RenderTexture && a instanceof c.RenderTexture) (this.key = a.key), this.setTexture(a);
          else if (c.BitmapData && a instanceof c.BitmapData)
            (this.customRender = !0),
              this.setTexture(a.texture),
              (f = e.hasFrameData(a.key, c.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(a.key, c.Cache.BITMAPDATA), b) : !this.animations.loadFrameData(a.frameData, 0));
          else if (c.Video && a instanceof c.Video) {
            this.customRender = !0;
            var h = a.texture.valid;
            this.setTexture(a.texture), this.setFrame(a.texture.frame.clone()), a.onChangeSource.add(this.resizeFrame, this), (this.texture.valid = h);
          } else if (c.Tilemap && a instanceof c.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(a.canvas));
          else if (a instanceof PIXI.Texture) this.setTexture(a);
          else {
            var i = e.getImage(a, !0);
            (this.key = i.key), this.setTexture(new PIXI.Texture(i.base)), "__default" === a ? (this.texture.baseTexture.skipRender = !0) : (this.texture.baseTexture.skipRender = !1), (f = !this.animations.loadFrameData(i.frameData, b));
          }
          f && (this._frame = c.Rectangle.clone(this.texture.frame)), g || (this.texture.baseTexture.scaleMode = 1);
        },
        setFrame: function (a) {
          (this._frame = a),
            (this.texture.frame.x = a.x),
            (this.texture.frame.y = a.y),
            (this.texture.frame.width = a.width),
            (this.texture.frame.height = a.height),
            (this.texture.crop.x = a.x),
            (this.texture.crop.y = a.y),
            (this.texture.crop.width = a.width),
            (this.texture.crop.height = a.height),
            a.trimmed
              ? (this.texture.trim
                  ? ((this.texture.trim.x = a.spriteSourceSizeX), (this.texture.trim.y = a.spriteSourceSizeY), (this.texture.trim.width = a.sourceSizeW), (this.texture.trim.height = a.sourceSizeH))
                  : (this.texture.trim = { x: a.spriteSourceSizeX, y: a.spriteSourceSizeY, width: a.sourceSizeW, height: a.sourceSizeH }),
                (this.texture.width = a.sourceSizeW),
                (this.texture.height = a.sourceSizeH),
                (this.texture.frame.width = a.sourceSizeW),
                (this.texture.frame.height = a.sourceSizeH))
              : !a.trimmed && this.texture.trim && (this.texture.trim = null),
            this.cropRect && this.updateCrop(),
            (this.texture.requiresReTint = !0),
            this.texture._updateUvs(),
            this.tilingTexture && (this.refreshTexture = !0);
        },
        resizeFrame: function (a, b, c) {
          this.texture.frame.resize(b, c), this.texture.setFrame(this.texture.frame);
        },
        resetFrame: function () {
          this._frame && this.setFrame(this._frame);
        },
        frame: {
          get: function () {
            return this.animations.frame;
          },
          set: function (a) {
            this.animations.frame = a;
          },
        },
        frameName: {
          get: function () {
            return this.animations.frameName;
          },
          set: function (a) {
            this.animations.frameName = a;
          },
        },
      }),
      (c.Component.Overlap = function () {}),
      (c.Component.Overlap.prototype = {
        overlap: function (a) {
          return c.Rectangle.intersects(this.getBounds(), a.getBounds());
        },
      }),
      (c.Component.PhysicsBody = function () {}),
      (c.Component.PhysicsBody.preUpdate = function () {
        return this.fresh && this.exists
          ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y),
            (this.worldTransform.tx = this.world.x),
            (this.worldTransform.ty = this.world.y),
            this.previousPosition.set(this.world.x, this.world.y),
            (this.previousRotation = this.rotation),
            this.body && this.body.preUpdate(),
            (this.fresh = !1),
            !1)
          : (this.previousPosition.set(this.world.x, this.world.y), (this.previousRotation = this.rotation), !(!this._exists || !this.parent.exists) || ((this.renderOrderID = -1), !1));
      }),
      (c.Component.PhysicsBody.postUpdate = function () {
        this.exists && this.body && this.body.postUpdate();
      }),
      (c.Component.PhysicsBody.prototype = {
        body: null,
        x: {
          get: function () {
            return this.position.x;
          },
          set: function (a) {
            (this.position.x = a), this.body && !this.body.dirty && (this.body._reset = !0);
          },
        },
        y: {
          get: function () {
            return this.position.y;
          },
          set: function (a) {
            (this.position.y = a), this.body && !this.body.dirty && (this.body._reset = !0);
          },
        },
      }),
      (c.Component.Reset = function () {}),
      (c.Component.Reset.prototype.reset = function (a, b, c) {
        return (
          void 0 === c && (c = 1),
          this.world.set(a, b),
          this.position.set(a, b),
          (this.fresh = !0),
          (this.exists = !0),
          (this.visible = !0),
          (this.renderable = !0),
          this.components.InWorld && (this._outOfBoundsFired = !1),
          this.components.LifeSpan && ((this.alive = !0), (this.health = c)),
          this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1),
          this
        );
      }),
      (c.Component.ScaleMinMax = function () {}),
      (c.Component.ScaleMinMax.prototype = {
        transformCallback: null,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function (a) {
          this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x), a.d < this.scaleMin.y && (a.d = this.scaleMin.y)),
            this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x), a.d > this.scaleMax.y && (a.d = this.scaleMax.y));
        },
        setScaleMinMax: function (a, b, d, e) {
          void 0 === b ? (b = d = e = a) : void 0 === d && ((d = e = b), (b = a)),
            null === a ? (this.scaleMin = null) : this.scaleMin ? this.scaleMin.set(a, b) : (this.scaleMin = new c.Point(a, b)),
            null === d ? (this.scaleMax = null) : this.scaleMax ? this.scaleMax.set(d, e) : (this.scaleMax = new c.Point(d, e)),
            null === this.scaleMin ? (this.transformCallback = null) : ((this.transformCallback = this.checkTransform), (this.transformCallbackContext = this));
        },
      }),
      (c.Component.Smoothed = function () {}),
      (c.Component.Smoothed.prototype = {
        smoothed: {
          get: function () {
            return !this.texture.baseTexture.scaleMode;
          },
          set: function (a) {
            a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1);
          },
        },
      }),
      (c.GameObjectFactory = function (a) {
        (this.game = a), (this.world = this.game.world);
      }),
      (c.GameObjectFactory.prototype = {
        existing: function (a) {
          return this.world.add(a);
        },
        weapon: function (a, b, d, e) {
          var f = this.game.plugins.add(c.Weapon);
          return f.createBullets(a, b, d, e), f;
        },
        image: function (a, b, d, e, f) {
          return void 0 === f && (f = this.world), f.add(new c.Image(this.game, a, b, d, e));
        },
        sprite: function (a, b, c, d, e) {
          return void 0 === e && (e = this.world), e.create(a, b, c, d);
        },
        creature: function (a, b, d, e, f) {
          void 0 === f && (f = this.world);
          var g = new c.Creature(this.game, a, b, d, e);
          return f.add(g), g;
        },
        tween: function (a) {
          return this.game.tweens.create(a);
        },
        group: function (a, b, d, e, f) {
          return new c.Group(this.game, a, b, d, e, f);
        },
        physicsGroup: function (a, b, d, e) {
          return new c.Group(this.game, b, d, e, !0, a);
        },
        spriteBatch: function (a, b, d) {
          return void 0 === a && (a = null), void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d);
        },
        audio: function (a, b, c, d) {
          return this.game.sound.add(a, b, c, d);
        },
        sound: function (a, b, c, d) {
          return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function (a) {
          return this.game.sound.addSprite(a);
        },
        tileSprite: function (a, b, d, e, f, g, h) {
          return void 0 === h && (h = this.world), h.add(new c.TileSprite(this.game, a, b, d, e, f, g));
        },
        rope: function (a, b, d, e, f, g) {
          return void 0 === g && (g = this.world), g.add(new c.Rope(this.game, a, b, d, e, f));
        },
        text: function (a, b, d, e, f) {
          return void 0 === f && (f = this.world), f.add(new c.Text(this.game, a, b, d, e));
        },
        button: function (a, b, d, e, f, g, h, i, j, k) {
          return void 0 === k && (k = this.world), k.add(new c.Button(this.game, a, b, d, e, f, g, h, i, j));
        },
        graphics: function (a, b, d) {
          return void 0 === d && (d = this.world), d.add(new c.Graphics(this.game, a, b));
        },
        emitter: function (a, b, d) {
          return this.game.particles.add(new c.Particles.Arcade.Emitter(this.game, a, b, d));
        },
        retroFont: function (a, b, d, e, f, g, h, i, j) {
          return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function (a, b, d, e, f, g) {
          return void 0 === g && (g = this.world), g.add(new c.BitmapText(this.game, a, b, d, e, f));
        },
        tilemap: function (a, b, d, e, f) {
          return new c.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function (a, b, d, e) {
          (void 0 !== d && "" !== d) || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
          var f = new c.RenderTexture(this.game, a, b, d);
          return e && this.game.cache.addRenderTexture(d, f), f;
        },
        video: function (a, b) {
          return new c.Video(this.game, a, b);
        },
        bitmapData: function (a, b, d, e) {
          void 0 === e && (e = !1), (void 0 !== d && "" !== d) || (d = this.game.rnd.uuid());
          var f = new c.BitmapData(this.game, d, a, b);
          return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function (a) {
          var b = Array.prototype.slice.call(arguments, 1),
            a = new c.Filter[a](this.game);
          return a.init.apply(a, b), a;
        },
        plugin: function (a) {
          return this.game.plugins.add(a);
        },
      }),
      (c.GameObjectFactory.prototype.constructor = c.GameObjectFactory),
      (c.GameObjectCreator = function (a) {
        (this.game = a), (this.world = this.game.world);
      }),
      (c.GameObjectCreator.prototype = {
        image: function (a, b, d, e) {
          return new c.Image(this.game, a, b, d, e);
        },
        sprite: function (a, b, d, e) {
          return new c.Sprite(this.game, a, b, d, e);
        },
        tween: function (a) {
          return new c.Tween(a, this.game, this.game.tweens);
        },
        group: function (a, b, d, e, f) {
          return new c.Group(this.game, a, b, d, e, f);
        },
        spriteBatch: function (a, b, d) {
          return void 0 === b && (b = "group"), void 0 === d && (d = !1), new c.SpriteBatch(this.game, a, b, d);
        },
        audio: function (a, b, c, d) {
          return this.game.sound.add(a, b, c, d);
        },
        audioSprite: function (a) {
          return this.game.sound.addSprite(a);
        },
        sound: function (a, b, c, d) {
          return this.game.sound.add(a, b, c, d);
        },
        tileSprite: function (a, b, d, e, f, g) {
          return new c.TileSprite(this.game, a, b, d, e, f, g);
        },
        rope: function (a, b, d, e, f) {
          return new c.Rope(this.game, a, b, d, e, f);
        },
        text: function (a, b, d, e) {
          return new c.Text(this.game, a, b, d, e);
        },
        button: function (a, b, d, e, f, g, h, i, j) {
          return new c.Button(this.game, a, b, d, e, f, g, h, i, j);
        },
        graphics: function (a, b) {
          return new c.Graphics(this.game, a, b);
        },
        emitter: function (a, b, d) {
          return new c.Particles.Arcade.Emitter(this.game, a, b, d);
        },
        retroFont: function (a, b, d, e, f, g, h, i, j) {
          return new c.RetroFont(this.game, a, b, d, e, f, g, h, i, j);
        },
        bitmapText: function (a, b, d, e, f, g) {
          return new c.BitmapText(this.game, a, b, d, e, f, g);
        },
        tilemap: function (a, b, d, e, f) {
          return new c.Tilemap(this.game, a, b, d, e, f);
        },
        renderTexture: function (a, b, d, e) {
          (void 0 !== d && "" !== d) || (d = this.game.rnd.uuid()), void 0 === e && (e = !1);
          var f = new c.RenderTexture(this.game, a, b, d);
          return e && this.game.cache.addRenderTexture(d, f), f;
        },
        bitmapData: function (a, b, d, e) {
          void 0 === e && (e = !1), (void 0 !== d && "" !== d) || (d = this.game.rnd.uuid());
          var f = new c.BitmapData(this.game, d, a, b);
          return e && this.game.cache.addBitmapData(d, f), f;
        },
        filter: function (a) {
          var b = Array.prototype.slice.call(arguments, 1),
            a = new c.Filter[a](this.game);
          return a.init.apply(a, b), a;
        },
      }),
      (c.GameObjectCreator.prototype.constructor = c.GameObjectCreator),
      (c.Sprite = function (a, b, d, e, f) {
        (b = b || 0), (d = d || 0), (e = e || null), (f = f || null), (this.type = c.SPRITE), (this.physicsType = c.SPRITE), PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f);
      }),
      (c.Sprite.prototype = Object.create(PIXI.Sprite.prototype)),
      (c.Sprite.prototype.constructor = c.Sprite),
      c.Component.Core.install.call(c.Sprite.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Delta",
        "Destroy",
        "FixedToCamera",
        "Health",
        "InCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "ScaleMinMax",
        "Smoothed",
      ]),
      (c.Sprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate),
      (c.Sprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate),
      (c.Sprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.Sprite.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.Sprite.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
      }),
      (c.Image = function (a, b, d, e, f) {
        (b = b || 0), (d = d || 0), (e = e || null), (f = f || null), (this.type = c.IMAGE), PIXI.Sprite.call(this, c.Cache.DEFAULT), c.Component.Core.init.call(this, a, b, d, e, f);
      }),
      (c.Image.prototype = Object.create(PIXI.Sprite.prototype)),
      (c.Image.prototype.constructor = c.Image),
      c.Component.Core.install.call(c.Image.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Destroy",
        "FixedToCamera",
        "InputEnabled",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "Reset",
        "ScaleMinMax",
        "Smoothed",
      ]),
      (c.Image.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.Image.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.Image.prototype.preUpdate = function () {
        return !!this.preUpdateInWorld() && this.preUpdateCore();
      }),
      (c.Button = function (a, b, d, e, f, g, h, i, j, k) {
        (b = b || 0),
          (d = d || 0),
          (e = e || null),
          (f = f || null),
          (g = g || this),
          c.Image.call(this, a, b, d, e, i),
          (this.type = c.BUTTON),
          (this.physicsType = c.SPRITE),
          (this._onOverFrame = null),
          (this._onOutFrame = null),
          (this._onDownFrame = null),
          (this._onUpFrame = null),
          (this.onOverSound = null),
          (this.onOutSound = null),
          (this.onDownSound = null),
          (this.onUpSound = null),
          (this.onOverSoundMarker = ""),
          (this.onOutSoundMarker = ""),
          (this.onDownSoundMarker = ""),
          (this.onUpSoundMarker = ""),
          (this.onInputOver = new c.Signal()),
          (this.onInputOut = new c.Signal()),
          (this.onInputDown = new c.Signal()),
          (this.onInputUp = new c.Signal()),
          (this.onOverMouseOnly = !0),
          (this.justReleasedPreventsOver = c.PointerMode.TOUCH),
          (this.freezeFrames = !1),
          (this.forceOut = !1),
          (this.inputEnabled = !0),
          this.input.start(0, !0),
          (this.input.useHandCursor = !0),
          this.setFrames(h, i, j, k),
          null !== f && this.onInputUp.add(f, g),
          this.events.onInputOver.add(this.onInputOverHandler, this),
          this.events.onInputOut.add(this.onInputOutHandler, this),
          this.events.onInputDown.add(this.onInputDownHandler, this),
          this.events.onInputUp.add(this.onInputUpHandler, this),
          this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
      }),
      (c.Button.prototype = Object.create(c.Image.prototype)),
      (c.Button.prototype.constructor = c.Button);
    var g = "Over",
      h = "Out",
      i = "Down",
      j = "Up";
    (c.Button.prototype.clearFrames = function () {
      this.setFrames(null, null, null, null);
    }),
      (c.Button.prototype.removedFromWorld = function () {
        this.inputEnabled = !1;
      }),
      (c.Button.prototype.setStateFrame = function (a, b, c) {
        var d = "_on" + a + "Frame";
        null !== b ? ((this[d] = b), c && this.changeStateFrame(a)) : (this[d] = null);
      }),
      (c.Button.prototype.changeStateFrame = function (a) {
        if (this.freezeFrames) return !1;
        var b = "_on" + a + "Frame",
          c = this[b];
        return "string" == typeof c ? ((this.frameName = c), !0) : "number" == typeof c && ((this.frame = c), !0);
      }),
      (c.Button.prototype.setFrames = function (a, b, c, d) {
        this.setStateFrame(g, a, this.input.pointerOver()), this.setStateFrame(h, b, !this.input.pointerOver()), this.setStateFrame(i, c, this.input.pointerDown()), this.setStateFrame(j, d, this.input.pointerUp());
      }),
      (c.Button.prototype.setStateSound = function (a, b, d) {
        var e = "on" + a + "Sound",
          f = "on" + a + "SoundMarker";
        b instanceof c.Sound || b instanceof c.AudioSprite ? ((this[e] = b), (this[f] = "string" == typeof d ? d : "")) : ((this[e] = null), (this[f] = ""));
      }),
      (c.Button.prototype.playStateSound = function (a) {
        var b = "on" + a + "Sound",
          c = this[b];
        if (c) {
          var d = "on" + a + "SoundMarker",
            e = this[d];
          return c.play(e), !0;
        }
        return !1;
      }),
      (c.Button.prototype.setSounds = function (a, b, c, d, e, f, k, l) {
        this.setStateSound(g, a, b), this.setStateSound(h, e, f), this.setStateSound(i, c, d), this.setStateSound(j, k, l);
      }),
      (c.Button.prototype.setOverSound = function (a, b) {
        this.setStateSound(g, a, b);
      }),
      (c.Button.prototype.setOutSound = function (a, b) {
        this.setStateSound(h, a, b);
      }),
      (c.Button.prototype.setDownSound = function (a, b) {
        this.setStateSound(i, a, b);
      }),
      (c.Button.prototype.setUpSound = function (a, b) {
        this.setStateSound(j, a, b);
      }),
      (c.Button.prototype.onInputOverHandler = function (a, b) {
        (b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode) ||
          (this.changeStateFrame(g), (this.onOverMouseOnly && !b.isMouse) || (this.playStateSound(g), this.onInputOver && this.onInputOver.dispatch(this, b)));
      }),
      (c.Button.prototype.onInputOutHandler = function (a, b) {
        this.changeStateFrame(h), this.playStateSound(h), this.onInputOut && this.onInputOut.dispatch(this, b);
      }),
      (c.Button.prototype.onInputDownHandler = function (a, b) {
        this.changeStateFrame(i), this.playStateSound(i), this.onInputDown && this.onInputDown.dispatch(this, b);
      }),
      (c.Button.prototype.onInputUpHandler = function (a, b, c) {
        if ((this.playStateSound(j), this.onInputUp && this.onInputUp.dispatch(this, b, c), !this.freezeFrames))
          if (this.forceOut === !0 || (this.forceOut & b.pointerMode) === b.pointerMode) this.changeStateFrame(h);
          else {
            var d = this.changeStateFrame(j);
            d || (c ? this.changeStateFrame(g) : this.changeStateFrame(h));
          }
      }),
      (c.SpriteBatch = function (a, b, d, e) {
        (void 0 !== b && null !== b) || (b = a.world), PIXI.SpriteBatch.call(this), c.Group.call(this, a, b, d, e), (this.type = c.SPRITEBATCH);
      }),
      (c.SpriteBatch.prototype = c.Utils.extend(!0, c.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, c.Group.prototype)),
      (c.SpriteBatch.prototype.constructor = c.SpriteBatch),
      (c.BitmapData = function (a, b, d, e, f) {
        (void 0 !== d && 0 !== d) || (d = 256),
          (void 0 !== e && 0 !== e) || (e = 256),
          void 0 === f && (f = !1),
          (this.game = a),
          (this.key = b),
          (this.width = d),
          (this.height = e),
          (this.canvas = c.Canvas.create(this, d, e, null, f)),
          (this.context = this.canvas.getContext("2d", { alpha: !0 })),
          (this.ctx = this.context),
          (this.smoothProperty = a.renderType === c.CANVAS ? a.renderer.renderSession.smoothProperty : c.Canvas.getSmoothingPrefix(this.context)),
          (this.imageData = this.context.getImageData(0, 0, d, e)),
          (this.data = null),
          this.imageData && (this.data = this.imageData.data),
          (this.pixels = null),
          this.data &&
            (this.imageData.data.buffer
              ? ((this.buffer = this.imageData.data.buffer), (this.pixels = new Uint32Array(this.buffer)))
              : window.ArrayBuffer
              ? ((this.buffer = new ArrayBuffer(this.imageData.data.length)), (this.pixels = new Uint32Array(this.buffer)))
              : (this.pixels = this.imageData.data)),
          (this.baseTexture = new PIXI.BaseTexture(this.canvas)),
          (this.texture = new PIXI.Texture(this.baseTexture)),
          (this.frameData = new c.FrameData()),
          (this.textureFrame = this.frameData.addFrame(new c.Frame(0, 0, 0, d, e, "bitmapData"))),
          (this.texture.frame = this.textureFrame),
          (this.type = c.BITMAPDATA),
          (this.disableTextureUpload = !1),
          (this.dirty = !1),
          (this.cls = this.clear),
          (this._image = null),
          (this._pos = new c.Point()),
          (this._size = new c.Point()),
          (this._scale = new c.Point()),
          (this._rotate = 0),
          (this._alpha = { prev: 1, current: 1 }),
          (this._anchor = new c.Point()),
          (this._tempR = 0),
          (this._tempG = 0),
          (this._tempB = 0),
          (this._circle = new c.Circle()),
          (this._swapCanvas = void 0);
      }),
      (c.BitmapData.prototype = {
        move: function (a, b, c) {
          return 0 !== a && this.moveH(a, c), 0 !== b && this.moveV(b, c), this;
        },
        moveH: function (a, b) {
          void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
          var c = this._swapCanvas,
            d = c.getContext("2d"),
            e = this.height,
            f = this.canvas;
          if ((d.clearRect(0, 0, this.width, this.height), a < 0)) {
            a = Math.abs(a);
            var g = this.width - a;
            b && d.drawImage(f, 0, 0, a, e, g, 0, a, e), d.drawImage(f, a, 0, g, e, 0, 0, g, e);
          } else {
            var g = this.width - a;
            b && d.drawImage(f, g, 0, a, e, 0, 0, a, e), d.drawImage(f, 0, 0, g, e, a, 0, g, e);
          }
          return this.clear(), this.copy(this._swapCanvas);
        },
        moveV: function (a, b) {
          void 0 === b && (b = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
          var c = this._swapCanvas,
            d = c.getContext("2d"),
            e = this.width,
            f = this.canvas;
          if ((d.clearRect(0, 0, this.width, this.height), a < 0)) {
            a = Math.abs(a);
            var g = this.height - a;
            b && d.drawImage(f, 0, 0, e, a, 0, g, e, a), d.drawImage(f, 0, a, e, g, 0, 0, e, g);
          } else {
            var g = this.height - a;
            b && d.drawImage(f, 0, g, e, a, 0, 0, e, a), d.drawImage(f, 0, 0, e, g, 0, a, e, g);
          }
          return this.clear(), this.copy(this._swapCanvas);
        },
        add: function (a) {
          if (Array.isArray(a)) for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
          else a.loadTexture(this);
          return this;
        },
        load: function (a) {
          if (("string" == typeof a && (a = this.game.cache.getImage(a)), a)) return this.resize(a.width, a.height), this.cls(), this.draw(a), this.update(), this;
        },
        clear: function (a, b, c, d) {
          return void 0 === a && (a = 0), void 0 === b && (b = 0), void 0 === c && (c = this.width), void 0 === d && (d = this.height), this.context.clearRect(a, b, c, d), (this.dirty = !0), this;
        },
        fill: function (a, b, c, d) {
          return void 0 === d && (d = 1), (this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")"), this.context.fillRect(0, 0, this.width, this.height), (this.dirty = !0), this;
        },
        generateTexture: function (a) {
          var b = new Image();
          b.src = this.canvas.toDataURL("image/png");
          var c = this.game.cache.addImage(a, "", b);
          return new PIXI.Texture(c.base);
        },
        resize: function (a, b) {
          return (
            (a === this.width && b === this.height) ||
              ((this.width = a),
              (this.height = b),
              (this.canvas.width = a),
              (this.canvas.height = b),
              void 0 !== this._swapCanvas && ((this._swapCanvas.width = a), (this._swapCanvas.height = b)),
              (this.baseTexture.width = a),
              (this.baseTexture.height = b),
              (this.textureFrame.width = a),
              (this.textureFrame.height = b),
              (this.texture.width = a),
              (this.texture.height = b),
              (this.texture.crop.width = a),
              (this.texture.crop.height = b),
              this.update(),
              (this.dirty = !0)),
            this
          );
        },
        update: function (a, b, c, d) {
          return (
            void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            void 0 === c && (c = Math.max(1, this.width)),
            void 0 === d && (d = Math.max(1, this.height)),
            (this.imageData = this.context.getImageData(a, b, c, d)),
            (this.data = this.imageData.data),
            this.imageData.data.buffer
              ? ((this.buffer = this.imageData.data.buffer), (this.pixels = new Uint32Array(this.buffer)))
              : window.ArrayBuffer
              ? ((this.buffer = new ArrayBuffer(this.imageData.data.length)), (this.pixels = new Uint32Array(this.buffer)))
              : (this.pixels = this.imageData.data),
            this
          );
        },
        processPixelRGB: function (a, b, d, e, f, g) {
          void 0 === d && (d = 0), void 0 === e && (e = 0), void 0 === f && (f = this.width), void 0 === g && (g = this.height);
          for (var h = d + f, i = e + g, j = c.Color.createColor(), k = { r: 0, g: 0, b: 0, a: 0 }, l = !1, m = e; m < i; m++)
            for (var n = d; n < h; n++) c.Color.unpackPixel(this.getPixel32(n, m), j), (k = a.call(b, j, n, m)), k !== !1 && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1), (l = !0));
          return l && (this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0)), this;
        },
        processPixel: function (a, b, c, d, e, f) {
          void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === e && (e = this.width), void 0 === f && (f = this.height);
          for (var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; l < h; l++) for (var m = c; m < g; m++) (i = this.getPixel32(m, l)), (j = a.call(b, i, m, l)), j !== i && ((this.pixels[l * this.width + m] = j), (k = !0));
          return k && (this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0)), this;
        },
        replaceRGB: function (a, b, d, e, f, g, h, i, j) {
          var k = 0,
            l = 0,
            m = this.width,
            n = this.height,
            o = c.Color.packPixel(a, b, d, e);
          void 0 !== j && j instanceof c.Rectangle && ((k = j.x), (l = j.y), (m = j.width), (n = j.height));
          for (var p = 0; p < n; p++) for (var q = 0; q < m; q++) this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
          return this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0), this;
        },
        setHSL: function (a, b, d, e) {
          var f = a || 0 === a,
            g = b || 0 === b,
            h = d || 0 === d;
          if (f || g || h) {
            void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
            for (var i = c.Color.createColor(), j = e.y; j < e.bottom; j++)
              for (var k = e.x; k < e.right; k++) c.Color.unpackPixel(this.getPixel32(k, j), i, !0), f && (i.h = a), g && (i.s = b), h && (i.l = d), c.Color.HSLtoRGB(i.h, i.s, i.l, i), this.setPixel32(k, j, i.r, i.g, i.b, i.a, !1);
            return this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0), this;
          }
        },
        shiftHSL: function (a, b, d, e) {
          if (((void 0 !== a && null !== a) || (a = !1), (void 0 !== b && null !== b) || (b = !1), (void 0 !== d && null !== d) || (d = !1), a || b || d)) {
            void 0 === e && (e = new c.Rectangle(0, 0, this.width, this.height));
            for (var f = c.Color.createColor(), g = e.y; g < e.bottom; g++)
              for (var h = e.x; h < e.right; h++)
                c.Color.unpackPixel(this.getPixel32(h, g), f, !0),
                  a && (f.h = this.game.math.wrap(f.h + a, 0, 1)),
                  b && (f.s = this.game.math.clamp(f.s + b, 0, 1)),
                  d && (f.l = this.game.math.clamp(f.l + d, 0, 1)),
                  c.Color.HSLtoRGB(f.h, f.s, f.l, f),
                  this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
            return this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0), this;
          }
        },
        setPixel32: function (a, b, d, e, f, g, h) {
          return (
            void 0 === h && (h = !0),
            a >= 0 &&
              a <= this.width &&
              b >= 0 &&
              b <= this.height &&
              (c.Device.LITTLE_ENDIAN ? (this.pixels[b * this.width + a] = (g << 24) | (f << 16) | (e << 8) | d) : (this.pixels[b * this.width + a] = (d << 24) | (e << 16) | (f << 8) | g),
              h && (this.context.putImageData(this.imageData, 0, 0), (this.dirty = !0))),
            this
          );
        },
        setPixel: function (a, b, c, d, e, f) {
          return this.setPixel32(a, b, c, d, e, 255, f);
        },
        getPixel: function (a, b, d) {
          d || (d = c.Color.createColor());
          var e = ~~(a + b * this.width);
          return (e *= 4), (d.r = this.data[e]), (d.g = this.data[++e]), (d.b = this.data[++e]), (d.a = this.data[++e]), d;
        },
        getPixel32: function (a, b) {
          if (a >= 0 && a <= this.width && b >= 0 && b <= this.height) return this.pixels[b * this.width + a];
        },
        getPixelRGB: function (a, b, d, e, f) {
          return c.Color.unpackPixel(this.getPixel32(a, b), d, e, f);
        },
        getPixels: function (a) {
          return this.context.getImageData(a.x, a.y, a.width, a.height);
        },
        getFirstPixel: function (a) {
          void 0 === a && (a = 0);
          var b = c.Color.createColor(),
            d = 0,
            e = 0,
            f = 1,
            g = !1;
          1 === a ? ((f = -1), (e = this.height)) : 3 === a && ((f = -1), (d = this.width));
          do
            c.Color.unpackPixel(this.getPixel32(d, e), b),
              0 === a || 1 === a ? (d++, d === this.width && ((d = 0), (e += f), (e >= this.height || e <= 0) && (g = !0))) : (2 !== a && 3 !== a) || (e++, e === this.height && ((e = 0), (d += f), (d >= this.width || d <= 0) && (g = !0)));
          while (0 === b.a && !g);
          return (b.x = d), (b.y = e), b;
        },
        getBounds: function (a) {
          return (
            void 0 === a && (a = new c.Rectangle()),
            (a.x = this.getFirstPixel(2).x),
            a.x === this.width ? a.setTo(0, 0, 0, 0) : ((a.y = this.getFirstPixel(0).y), (a.width = this.getFirstPixel(3).x - a.x + 1), (a.height = this.getFirstPixel(1).y - a.y + 1), a)
          );
        },
        addToWorld: function (a, b, c, d, e, f) {
          (e = e || 1), (f = f || 1);
          var g = this.game.add.image(a, b, this);
          return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        copy: function (a, b, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
          if (
            ((void 0 !== a && null !== a) || (a = this),
            (a instanceof c.RenderTexture || a instanceof PIXI.RenderTexture) && (a = a.getCanvas()),
            (this._image = a),
            a instanceof c.Sprite || a instanceof c.Image || a instanceof c.Text || a instanceof PIXI.Sprite)
          )
            this._pos.set(a.texture.crop.x, a.texture.crop.y),
              this._size.set(a.texture.crop.width, a.texture.crop.height),
              this._scale.set(a.scale.x, a.scale.y),
              this._anchor.set(a.anchor.x, a.anchor.y),
              (this._rotate = a.rotation),
              (this._alpha.current = a.alpha),
              a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? (this._image = a.texture.getCanvas()) : (this._image = a.texture.baseTexture.source),
              (void 0 !== g && null !== g) || (g = a.x),
              (void 0 !== h && null !== h) || (h = a.y),
              a.texture.trim && ((g += a.texture.trim.x - a.anchor.x * a.texture.trim.width), (h += a.texture.trim.y - a.anchor.y * a.texture.trim.height)),
              16777215 !== a.tint && (a.cachedTint !== a.tint && ((a.cachedTint = a.tint), (a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint))), (this._image = a.tintedTexture), this._pos.set(0));
          else {
            if ((this._pos.set(0), this._scale.set(1), this._anchor.set(0), (this._rotate = 0), (this._alpha.current = 1), a instanceof c.BitmapData)) this._image = a.canvas;
            else if ("string" == typeof a) {
              if (((a = this.game.cache.getImage(a)), null === a)) return;
              this._image = a;
            }
            this._size.set(this._image.width, this._image.height);
          }
          if (
            ((void 0 !== b && null !== b) || (b = 0),
            (void 0 !== d && null !== d) || (d = 0),
            e && (this._size.x = e),
            f && (this._size.y = f),
            (void 0 !== g && null !== g) || (g = b),
            (void 0 !== h && null !== h) || (h = d),
            (void 0 !== i && null !== i) || (i = this._size.x),
            (void 0 !== j && null !== j) || (j = this._size.y),
            "number" == typeof k && (this._rotate = k),
            "number" == typeof l && (this._anchor.x = l),
            "number" == typeof m && (this._anchor.y = m),
            "number" == typeof n && (this._scale.x = n),
            "number" == typeof o && (this._scale.y = o),
            "number" == typeof p && (this._alpha.current = p),
            void 0 === q && (q = null),
            void 0 === r && (r = !1),
            !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y))
          ) {
            var s = this.context;
            return (
              (this._alpha.prev = s.globalAlpha),
              s.save(),
              (s.globalAlpha = this._alpha.current),
              q && (this.op = q),
              r && ((g |= 0), (h |= 0)),
              s.translate(g, h),
              s.scale(this._scale.x, this._scale.y),
              s.rotate(this._rotate),
              s.drawImage(this._image, this._pos.x + b, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j),
              s.restore(),
              (s.globalAlpha = this._alpha.prev),
              (this.dirty = !0),
              this
            );
          }
        },
        copyTransform: function (a, b, d) {
          if ((void 0 === b && (b = null), void 0 === d && (d = !1), !a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha)) return this;
          var e = a.worldTransform;
          if ((this._pos.set(a.texture.crop.x, a.texture.crop.y), this._size.set(a.texture.crop.width, a.texture.crop.height), 0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y)) return this;
          a.texture instanceof c.RenderTexture || a.texture instanceof PIXI.RenderTexture ? (this._image = a.texture.getCanvas()) : (this._image = a.texture.baseTexture.source);
          var f = e.tx,
            g = e.ty;
          a.texture.trim && ((f += a.texture.trim.x - a.anchor.x * a.texture.trim.width), (g += a.texture.trim.y - a.anchor.y * a.texture.trim.height)),
            16777215 !== a.tint && (a.cachedTint !== a.tint && ((a.cachedTint = a.tint), (a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint))), (this._image = a.tintedTexture), this._pos.set(0)),
            d && ((f |= 0), (g |= 0));
          var h = this.context;
          return (
            (this._alpha.prev = h.globalAlpha),
            h.save(),
            (h.globalAlpha = this._alpha.current),
            b && (this.op = b),
            (h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR),
            h.setTransform(e.a, e.b, e.c, e.d, f, g),
            h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y),
            h.restore(),
            (h.globalAlpha = this._alpha.prev),
            (this.dirty = !0),
            this
          );
        },
        copyRect: function (a, b, c, d, e, f, g) {
          return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g);
        },
        draw: function (a, b, c, d, e, f, g) {
          return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g);
        },
        drawGroup: function (a, b, c) {
          return a.total > 0 && a.forEachExists(this.drawGroupProxy, this, b, c), this;
        },
        drawGroupProxy: function (a, b, d) {
          if ((a.hasOwnProperty("texture") && this.copyTransform(a, b, d), a.type === c.GROUP && a.exists)) this.drawGroup(a, b, d);
          else if (a.hasOwnProperty("children") && a.children.length > 0) for (var e = 0; e < a.children.length; e++) a.children[e].exists && this.copyTransform(a.children[e], b, d);
        },
        drawFull: function (a, b, d) {
          if (a.worldVisible === !1 || 0 === a.worldAlpha || (a.hasOwnProperty("exists") && a.exists === !1)) return this;
          if (a.type !== c.GROUP && a.type !== c.EMITTER && a.type !== c.BITMAPTEXT)
            if (a.type === c.GRAPHICS) {
              var e = a.getBounds();
              this.ctx.save(), this.ctx.translate(e.x, e.y), PIXI.CanvasGraphics.renderGraphics(a, this.ctx), this.ctx.restore();
            } else this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, b, d);
          if (a.children) for (var f = 0; f < a.children.length; f++) this.drawFull(a.children[f], b, d);
          return this;
        },
        shadow: function (a, b, c, d) {
          var e = this.context;
          return void 0 === a || null === a ? (e.shadowColor = "rgba(0,0,0,0)") : ((e.shadowColor = a), (e.shadowBlur = b || 5), (e.shadowOffsetX = c || 10), (e.shadowOffsetY = d || 10)), this;
        },
        alphaMask: function (a, b, c, d) {
          return (
            void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(),
            void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(),
            this
          );
        },
        extract: function (a, b, c, d, e, f, g, h, i) {
          return (
            void 0 === e && (e = 255),
            void 0 === f && (f = !1),
            void 0 === g && (g = b),
            void 0 === h && (h = c),
            void 0 === i && (i = d),
            f && a.resize(this.width, this.height),
            this.processPixelRGB(function (f, j, k) {
              return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1), !1;
            }, this),
            a.context.putImageData(a.imageData, 0, 0),
            (a.dirty = !0),
            a
          );
        },
        rect: function (a, b, c, d, e) {
          return "undefined" != typeof e && (this.context.fillStyle = e), this.context.fillRect(a, b, c, d), this;
        },
        text: function (a, b, c, d, e, f) {
          void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = "14px Courier"), void 0 === e && (e = "rgb(255,255,255)"), void 0 === f && (f = !0);
          var g = this.context,
            h = g.font;
          return (g.font = d), f && ((g.fillStyle = "rgb(0,0,0)"), g.fillText(a, b + 1, c + 1)), (g.fillStyle = e), g.fillText(a, b, c), (g.font = h), this;
        },
        circle: function (a, b, c, d) {
          var e = this.context;
          return void 0 !== d && (e.fillStyle = d), e.beginPath(), e.arc(a, b, c, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), this;
        },
        line: function (a, b, c, d, e, f) {
          void 0 === e && (e = "#fff"), void 0 === f && (f = 1);
          var g = this.context;
          return g.beginPath(), g.moveTo(a, b), g.lineTo(c, d), (g.lineWidth = f), (g.strokeStyle = e), g.stroke(), g.closePath(), this;
        },
        textureLine: function (a, b, d) {
          if ((void 0 === d && (d = "repeat-x"), "string" != typeof b || (b = this.game.cache.getImage(b)))) {
            var e = a.length;
            "no-repeat" === d && e > b.width && (e = b.width);
            var f = this.context;
            return (
              (f.fillStyle = f.createPattern(b, d)),
              (this._circle = new c.Circle(a.start.x, a.start.y, b.height)),
              this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos),
              f.save(),
              f.translate(this._pos.x, this._pos.y),
              f.rotate(a.angle),
              f.fillRect(0, 0, e, b.height),
              f.restore(),
              (this.dirty = !0),
              this
            );
          }
        },
        render: function () {
          return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), (this.dirty = !1)), this;
        },
        destroy: function () {
          this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this);
        },
        blendReset: function () {
          return (this.op = "source-over"), this;
        },
        blendSourceOver: function () {
          return (this.op = "source-over"), this;
        },
        blendSourceIn: function () {
          return (this.op = "source-in"), this;
        },
        blendSourceOut: function () {
          return (this.op = "source-out"), this;
        },
        blendSourceAtop: function () {
          return (this.op = "source-atop"), this;
        },
        blendDestinationOver: function () {
          return (this.op = "destination-over"), this;
        },
        blendDestinationIn: function () {
          return (this.op = "destination-in"), this;
        },
        blendDestinationOut: function () {
          return (this.op = "destination-out"), this;
        },
        blendDestinationAtop: function () {
          return (this.op = "destination-atop"), this;
        },
        blendXor: function () {
          return (this.op = "xor"), this;
        },
        blendAdd: function () {
          return (this.op = "lighter"), this;
        },
        blendMultiply: function () {
          return (this.op = "multiply"), this;
        },
        blendScreen: function () {
          return (this.op = "screen"), this;
        },
        blendOverlay: function () {
          return (this.op = "overlay"), this;
        },
        blendDarken: function () {
          return (this.op = "darken"), this;
        },
        blendLighten: function () {
          return (this.op = "lighten"), this;
        },
        blendColorDodge: function () {
          return (this.op = "color-dodge"), this;
        },
        blendColorBurn: function () {
          return (this.op = "color-burn"), this;
        },
        blendHardLight: function () {
          return (this.op = "hard-light"), this;
        },
        blendSoftLight: function () {
          return (this.op = "soft-light"), this;
        },
        blendDifference: function () {
          return (this.op = "difference"), this;
        },
        blendExclusion: function () {
          return (this.op = "exclusion"), this;
        },
        blendHue: function () {
          return (this.op = "hue"), this;
        },
        blendSaturation: function () {
          return (this.op = "saturation"), this;
        },
        blendColor: function () {
          return (this.op = "color"), this;
        },
        blendLuminosity: function () {
          return (this.op = "luminosity"), this;
        },
      }),
      Object.defineProperty(c.BitmapData.prototype, "smoothed", {
        get: function () {
          c.Canvas.getSmoothingEnabled(this.context);
        },
        set: function (a) {
          c.Canvas.setSmoothingEnabled(this.context, a);
        },
      }),
      Object.defineProperty(c.BitmapData.prototype, "op", {
        get: function () {
          return this.context.globalCompositeOperation;
        },
        set: function (a) {
          this.context.globalCompositeOperation = a;
        },
      }),
      (c.BitmapData.getTransform = function (a, b, c, d, e, f) {
        return (
          "number" != typeof a && (a = 0),
          "number" != typeof b && (b = 0),
          "number" != typeof c && (c = 1),
          "number" != typeof d && (d = 1),
          "number" != typeof e && (e = 0),
          "number" != typeof f && (f = 0),
          { sx: c, sy: d, scaleX: c, scaleY: d, skewX: e, skewY: f, translateX: a, translateY: b, tx: a, ty: b }
        );
      }),
      (c.BitmapData.prototype.constructor = c.BitmapData),
      (PIXI.Graphics = function () {
        PIXI.DisplayObjectContainer.call(this),
          (this.renderable = !0),
          (this.fillAlpha = 1),
          (this.lineWidth = 0),
          (this.lineColor = 0),
          (this.graphicsData = []),
          (this.tint = 16777215),
          (this.blendMode = PIXI.blendModes.NORMAL),
          (this.currentPath = null),
          (this._webGL = []),
          (this.isMask = !1),
          (this.boundsPadding = 0),
          (this._localBounds = new PIXI.Rectangle(0, 0, 1, 1)),
          (this.dirty = !0),
          (this._boundsDirty = !1),
          (this.webGLDirty = !1),
          (this.cachedSpriteDirty = !1);
      }),
      (PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype)),
      (PIXI.Graphics.prototype.constructor = PIXI.Graphics),
      (PIXI.Graphics.prototype.lineStyle = function (a, b, c) {
        return (
          (this.lineWidth = a || 0),
          (this.lineColor = b || 0),
          (this.lineAlpha = void 0 === c ? 1 : c),
          this.currentPath &&
            (this.currentPath.shape.points.length
              ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2)))
              : ((this.currentPath.lineWidth = this.lineWidth), (this.currentPath.lineColor = this.lineColor), (this.currentPath.lineAlpha = this.lineAlpha))),
          this
        );
      }),
      (PIXI.Graphics.prototype.moveTo = function (a, b) {
        return this.drawShape(new PIXI.Polygon([a, b])), this;
      }),
      (PIXI.Graphics.prototype.lineTo = function (a, b) {
        return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(a, b), (this.dirty = !0), (this._boundsDirty = !0), this;
      }),
      (PIXI.Graphics.prototype.quadraticCurveTo = function (a, b, c, d) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        var e,
          f,
          g = 20,
          h = this.currentPath.shape.points;
        0 === h.length && this.moveTo(0, 0);
        for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; l <= g; ++l) (k = l / g), (e = i + (a - i) * k), (f = j + (b - j) * k), h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
        return (this.dirty = !0), (this._boundsDirty = !0), this;
      }),
      (PIXI.Graphics.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        for (var g, h, i, j, k, l = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; q <= l; ++q)
          (p = q / l), (g = 1 - p), (h = g * g), (i = h * g), (j = p * p), (k = j * p), m.push(i * n + 3 * h * p * a + 3 * g * j * c + k * e, i * o + 3 * h * p * b + 3 * g * j * d + k * f);
        return (this.dirty = !0), (this._boundsDirty = !0), this;
      }),
      (PIXI.Graphics.prototype.arcTo = function (a, b, c, d, e) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
        var f = this.currentPath.shape.points,
          g = f[f.length - 2],
          h = f[f.length - 1],
          i = h - b,
          j = g - a,
          k = d - b,
          l = c - a,
          m = Math.abs(i * l - j * k);
        if (m < 1e-8 || 0 === e) (f[f.length - 2] === a && f[f.length - 1] === b) || f.push(a, b);
        else {
          var n = i * i + j * j,
            o = k * k + l * l,
            p = i * k + j * l,
            q = (e * Math.sqrt(n)) / m,
            r = (e * Math.sqrt(o)) / m,
            s = (q * p) / n,
            t = (r * p) / o,
            u = q * l + r * j,
            v = q * k + r * i,
            w = j * (r + s),
            x = i * (r + s),
            y = l * (q + t),
            z = k * (q + t),
            A = Math.atan2(x - v, w - u),
            B = Math.atan2(z - v, y - u);
          this.arc(u + a, v + b, e, A, B, j * k > l * i);
        }
        return (this.dirty = !0), (this._boundsDirty = !0), this;
      }),
      (PIXI.Graphics.prototype.arc = function (a, b, c, d, e, f, g) {
        if (d === e) return this;
        void 0 === f && (f = !1), void 0 === g && (g = 40), !f && e <= d ? (e += 2 * Math.PI) : f && d <= e && (d += 2 * Math.PI);
        var h = f ? (d - e) * -1 : e - d,
          i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
        if (0 === h) return this;
        var j = a + Math.cos(d) * c,
          k = b + Math.sin(d) * c;
        f && this.filling ? this.moveTo(a, b) : this.moveTo(j, k);
        for (var l = this.currentPath.shape.points, m = h / (2 * i), n = 2 * m, o = Math.cos(m), p = Math.sin(m), q = i - 1, r = (q % 1) / q, s = 0; s <= q; s++) {
          var t = s + r * s,
            u = m + d + n * t,
            v = Math.cos(u),
            w = -Math.sin(u);
          l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b);
        }
        return (this.dirty = !0), (this._boundsDirty = !0), this;
      }),
      (PIXI.Graphics.prototype.beginFill = function (a, b) {
        return (
          (this.filling = !0),
          (this.fillColor = a || 0),
          (this.fillAlpha = void 0 === b ? 1 : b),
          this.currentPath && this.currentPath.shape.points.length <= 2 && ((this.currentPath.fill = this.filling), (this.currentPath.fillColor = this.fillColor), (this.currentPath.fillAlpha = this.fillAlpha)),
          this
        );
      }),
      (PIXI.Graphics.prototype.endFill = function () {
        return (this.filling = !1), (this.fillColor = null), (this.fillAlpha = 1), this;
      }),
      (PIXI.Graphics.prototype.drawRect = function (a, b, c, d) {
        return this.drawShape(new PIXI.Rectangle(a, b, c, d)), this;
      }),
      (PIXI.Graphics.prototype.drawRoundedRect = function (a, b, c, d, e) {
        return this.drawShape(new PIXI.RoundedRectangle(a, b, c, d, e)), this;
      }),
      (PIXI.Graphics.prototype.drawCircle = function (a, b, c) {
        return this.drawShape(new PIXI.Circle(a, b, c)), this;
      }),
      (PIXI.Graphics.prototype.drawEllipse = function (a, b, c, d) {
        return this.drawShape(new PIXI.Ellipse(a, b, c, d)), this;
      }),
      (PIXI.Graphics.prototype.drawPolygon = function (a) {
        (a instanceof c.Polygon || a instanceof PIXI.Polygon) && (a = a.points);
        var b = a;
        if (!Array.isArray(b)) {
          b = new Array(arguments.length);
          for (var d = 0; d < b.length; ++d) b[d] = arguments[d];
        }
        return this.drawShape(new c.Polygon(b)), this;
      }),
      (PIXI.Graphics.prototype.clear = function () {
        return (this.lineWidth = 0), (this.filling = !1), (this.dirty = !0), (this._boundsDirty = !0), (this.clearDirty = !0), (this.graphicsData = []), this.updateLocalBounds(), this;
      }),
      (PIXI.Graphics.prototype.generateTexture = function (a, b, c) {
        void 0 === a && (a = 1), void 0 === b && (b = PIXI.scaleModes.DEFAULT), void 0 === c && (c = 0);
        var d = this.getBounds();
        (d.width += c), (d.height += c);
        var e = new PIXI.CanvasBuffer(d.width * a, d.height * a),
          f = PIXI.Texture.fromCanvas(e.canvas, b);
        return (f.baseTexture.resolution = a), e.context.scale(a, a), e.context.translate(-d.x, -d.y), PIXI.CanvasGraphics.renderGraphics(this, e.context), f;
      }),
      (PIXI.Graphics.prototype._renderWebGL = function (a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
          if (this._cacheAsBitmap)
            return (
              (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), (this.cachedSpriteDirty = !1), (this.dirty = !1)),
              (this._cachedSprite.worldAlpha = this.worldAlpha),
              void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a)
            );
          if (
            (a.spriteBatch.stop(),
            a.blendModeManager.setBlendMode(this.blendMode),
            this._mask && a.maskManager.pushMask(this._mask, a),
            this._filters && a.filterManager.pushFilter(this._filterBlock),
            this.blendMode !== a.spriteBatch.currentBlendMode)
          ) {
            a.spriteBatch.currentBlendMode = this.blendMode;
            var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
            a.spriteBatch.gl.blendFunc(b[0], b[1]);
          }
          if ((this.webGLDirty && ((this.dirty = !0), (this.webGLDirty = !1)), PIXI.WebGLGraphics.renderGraphics(this, a), this.children.length)) {
            a.spriteBatch.start();
            for (var c = 0; c < this.children.length; c++) this.children[c]._renderWebGL(a);
            a.spriteBatch.stop();
          }
          this._filters && a.filterManager.popFilter(), this._mask && a.maskManager.popMask(this.mask, a), a.drawCount++, a.spriteBatch.start();
        }
      }),
      (PIXI.Graphics.prototype._renderCanvas = function (a) {
        if (this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
          if ((this._prevTint !== this.tint && ((this.dirty = !0), (this._prevTint = this.tint)), this._cacheAsBitmap))
            return (
              (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), (this.cachedSpriteDirty = !1), (this.dirty = !1)),
              (this._cachedSprite.alpha = this.alpha),
              void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a)
            );
          var b = a.context,
            c = this.worldTransform;
          this.blendMode !== a.currentBlendMode && ((a.currentBlendMode = this.blendMode), (b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode])), this._mask && a.maskManager.pushMask(this._mask, a);
          var d = a.resolution,
            e = c.tx * a.resolution + a.shakeX,
            f = c.ty * a.resolution + a.shakeY;
          b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f), PIXI.CanvasGraphics.renderGraphics(this, b);
          for (var g = 0; g < this.children.length; g++) this.children[g]._renderCanvas(a);
          this._mask && a.maskManager.popMask(a);
        }
      }),
      (PIXI.Graphics.prototype.getBounds = function (a) {
        if (!this._currentBounds) {
          if (!this.renderable) return PIXI.EmptyRectangle;
          this.dirty && (this.updateLocalBounds(), (this.webGLDirty = !0), (this.cachedSpriteDirty = !0), (this.dirty = !1));
          var b = this._localBounds,
            c = b.x,
            d = b.width + b.x,
            e = b.y,
            f = b.height + b.y,
            g = a || this.worldTransform,
            h = g.a,
            i = g.b,
            j = g.c,
            k = g.d,
            l = g.tx,
            m = g.ty,
            n = h * d + j * f + l,
            o = k * f + i * d + m,
            p = h * c + j * f + l,
            q = k * f + i * c + m,
            r = h * c + j * e + l,
            s = k * e + i * c + m,
            t = h * d + j * e + l,
            u = k * e + i * d + m,
            v = n,
            w = o,
            x = n,
            y = o;
          (x = p < x ? p : x),
            (x = r < x ? r : x),
            (x = t < x ? t : x),
            (y = q < y ? q : y),
            (y = s < y ? s : y),
            (y = u < y ? u : y),
            (v = p > v ? p : v),
            (v = r > v ? r : v),
            (v = t > v ? t : v),
            (w = q > w ? q : w),
            (w = s > w ? s : w),
            (w = u > w ? u : w),
            (this._bounds.x = x),
            (this._bounds.width = v - x),
            (this._bounds.y = y),
            (this._bounds.height = w - y),
            (this._currentBounds = this._bounds);
        }
        return this._currentBounds;
      }),
      (PIXI.Graphics.prototype.getLocalBounds = function () {
        var a = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var b = 0; b < this.children.length; b++) this.children[b].updateTransform();
        var c = this.getBounds();
        for (this.worldTransform = a, b = 0; b < this.children.length; b++) this.children[b].updateTransform();
        return c;
      }),
      (PIXI.Graphics.prototype.containsPoint = function (a) {
        this.worldTransform.applyInverse(a, tempPoint);
        for (var b = this.graphicsData, c = 0; c < b.length; c++) {
          var d = b[c];
          if (d.fill && d.shape && d.shape.contains(tempPoint.x, tempPoint.y)) return !0;
        }
        return !1;
      }),
      (PIXI.Graphics.prototype.updateLocalBounds = function () {
        var a = 1 / 0,
          b = -(1 / 0),
          d = 1 / 0,
          e = -(1 / 0);
        if (this.graphicsData.length)
          for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
            var m = this.graphicsData[l],
              n = m.type,
              o = m.lineWidth;
            if (((f = m.shape), n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC))
              (h = f.x - o / 2), (i = f.y - o / 2), (j = f.width + o), (k = f.height + o), (a = h < a ? h : a), (b = h + j > b ? h + j : b), (d = i < d ? i : d), (e = i + k > e ? i + k : e);
            else if (n === PIXI.Graphics.CIRC) (h = f.x), (i = f.y), (j = f.radius + o / 2), (k = f.radius + o / 2), (a = h - j < a ? h - j : a), (b = h + j > b ? h + j : b), (d = i - k < d ? i - k : d), (e = i + k > e ? i + k : e);
            else if (n === PIXI.Graphics.ELIP) (h = f.x), (i = f.y), (j = f.width + o / 2), (k = f.height + o / 2), (a = h - j < a ? h - j : a), (b = h + j > b ? h + j : b), (d = i - k < d ? i - k : d), (e = i + k > e ? i + k : e);
            else {
              g = f.points;
              for (var p = 0; p < g.length; p++)
                g[p] instanceof c.Point ? ((h = g[p].x), (i = g[p].y)) : ((h = g[p]), (i = g[p + 1]), p < g.length - 1 && p++),
                  (a = h - o < a ? h - o : a),
                  (b = h + o > b ? h + o : b),
                  (d = i - o < d ? i - o : d),
                  (e = i + o > e ? i + o : e);
            }
          }
        else (a = 0), (b = 0), (d = 0), (e = 0);
        var q = this.boundsPadding;
        (this._localBounds.x = a - q), (this._localBounds.width = b - a + 2 * q), (this._localBounds.y = d - q), (this._localBounds.height = e - d + 2 * q);
      }),
      (PIXI.Graphics.prototype._generateCachedSprite = function () {
        var a = this.getLocalBounds();
        if (this._cachedSprite) this._cachedSprite.buffer.resize(a.width, a.height);
        else {
          var b = new PIXI.CanvasBuffer(a.width, a.height),
            c = PIXI.Texture.fromCanvas(b.canvas);
          (this._cachedSprite = new PIXI.Sprite(c)), (this._cachedSprite.buffer = b), (this._cachedSprite.worldTransform = this.worldTransform);
        }
        (this._cachedSprite.anchor.x = -(a.x / a.width)),
          (this._cachedSprite.anchor.y = -(a.y / a.height)),
          this._cachedSprite.buffer.context.translate(-a.x, -a.y),
          (this.worldAlpha = 1),
          PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context),
          (this._cachedSprite.alpha = this.alpha);
      }),
      (PIXI.Graphics.prototype.updateCachedSpriteTexture = function () {
        var a = this._cachedSprite,
          b = a.texture,
          c = a.buffer.canvas;
        (b.baseTexture.width = c.width), (b.baseTexture.height = c.height), (b.crop.width = b.frame.width = c.width), (b.crop.height = b.frame.height = c.height), (a._width = c.width), (a._height = c.height), b.baseTexture.dirty();
      }),
      (PIXI.Graphics.prototype.destroyCachedSprite = function () {
        this._cachedSprite.texture.destroy(!0), (this._cachedSprite = null);
      }),
      (PIXI.Graphics.prototype.drawShape = function (a) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), (this.currentPath = null), a instanceof c.Polygon && ((a = a.clone()), a.flatten());
        var b = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
        return this.graphicsData.push(b), b.type === PIXI.Graphics.POLY && ((b.shape.closed = this.filling), (this.currentPath = b)), (this.dirty = !0), (this._boundsDirty = !0), b;
      }),
      Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function () {
          return this._cacheAsBitmap;
        },
        set: function (a) {
          (this._cacheAsBitmap = a), this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), (this.dirty = !0), (this.webGLDirty = !0);
        },
      }),
      (PIXI.GraphicsData = function (a, b, c, d, e, f, g) {
        (this.lineWidth = a), (this.lineColor = b), (this.lineAlpha = c), (this._lineTint = b), (this.fillColor = d), (this.fillAlpha = e), (this._fillTint = d), (this.fill = f), (this.shape = g), (this.type = g.type);
      }),
      (PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData),
      (PIXI.GraphicsData.prototype.clone = function () {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
      }),
      (PIXI.EarCut = {}),
      (PIXI.EarCut.Triangulate = function (a, b, c) {
        c = c || 2;
        var d = b && b.length,
          e = d ? b[0] * c : a.length,
          f = PIXI.EarCut.linkedList(a, 0, e, c, !0),
          g = [];
        if (!f) return g;
        var h, i, j, k, l, m, n;
        if ((d && (f = PIXI.EarCut.eliminateHoles(a, b, f, c)), a.length > 80 * c)) {
          (h = j = a[0]), (i = k = a[1]);
          for (var o = c; o < e; o += c) (l = a[o]), (m = a[o + 1]), l < h && (h = l), m < i && (i = m), l > j && (j = l), m > k && (k = m);
          n = Math.max(j - h, k - i);
        }
        return PIXI.EarCut.earcutLinked(f, g, c, h, i, n), g;
      }),
      (PIXI.EarCut.linkedList = function (a, b, c, d, e) {
        var f,
          g,
          h,
          i = 0;
        for (f = b, g = c - d; f < c; f += d) (i += (a[g] - a[f]) * (a[f + 1] + a[g + 1])), (g = f);
        if (e === i > 0) for (f = b; f < c; f += d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
        else for (f = c - d; f >= b; f -= d) h = PIXI.EarCut.insertNode(f, a[f], a[f + 1], h);
        return h;
      }),
      (PIXI.EarCut.filterPoints = function (a, b) {
        if (!a) return a;
        b || (b = a);
        var c,
          d = a;
        do
          if (((c = !1), d.steiner || (!PIXI.EarCut.equals(d, d.next) && 0 !== PIXI.EarCut.area(d.prev, d, d.next)))) d = d.next;
          else {
            if ((PIXI.EarCut.removeNode(d), (d = b = d.prev), d === d.next)) return null;
            c = !0;
          }
        while (c || d !== b);
        return b;
      }),
      (PIXI.EarCut.earcutLinked = function (a, b, c, d, e, f, g) {
        if (a) {
          !g && f && PIXI.EarCut.indexCurve(a, d, e, f);
          for (var h, i, j = a; a.prev !== a.next; )
            if (((h = a.prev), (i = a.next), f ? PIXI.EarCut.isEarHashed(a, d, e, f) : PIXI.EarCut.isEar(a))) b.push(h.i / c), b.push(a.i / c), b.push(i.i / c), PIXI.EarCut.removeNode(a), (a = i.next), (j = i.next);
            else if (((a = i), a === j)) {
              g
                ? 1 === g
                  ? ((a = PIXI.EarCut.cureLocalIntersections(a, b, c)), PIXI.EarCut.earcutLinked(a, b, c, d, e, f, 2))
                  : 2 === g && PIXI.EarCut.splitEarcut(a, b, c, d, e, f)
                : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(a), b, c, d, e, f, 1);
              break;
            }
        }
      }),
      (PIXI.EarCut.isEar = function (a) {
        var b = a.prev,
          c = a,
          d = a.next;
        if (PIXI.EarCut.area(b, c, d) >= 0) return !1;
        for (var e = a.next.next; e !== a.prev; ) {
          if (PIXI.EarCut.pointInTriangle(b.x, b.y, c.x, c.y, d.x, d.y, e.x, e.y) && PIXI.EarCut.area(e.prev, e, e.next) >= 0) return !1;
          e = e.next;
        }
        return !0;
      }),
      (PIXI.EarCut.isEarHashed = function (a, b, c, d) {
        var e = a.prev,
          f = a,
          g = a.next;
        if (PIXI.EarCut.area(e, f, g) >= 0) return !1;
        for (
          var h = e.x < f.x ? (e.x < g.x ? e.x : g.x) : f.x < g.x ? f.x : g.x,
            i = e.y < f.y ? (e.y < g.y ? e.y : g.y) : f.y < g.y ? f.y : g.y,
            j = e.x > f.x ? (e.x > g.x ? e.x : g.x) : f.x > g.x ? f.x : g.x,
            k = e.y > f.y ? (e.y > g.y ? e.y : g.y) : f.y > g.y ? f.y : g.y,
            l = PIXI.EarCut.zOrder(h, i, b, c, d),
            m = PIXI.EarCut.zOrder(j, k, b, c, d),
            n = a.nextZ;
          n && n.z <= m;

        ) {
          if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
          n = n.nextZ;
        }
        for (n = a.prevZ; n && n.z >= l; ) {
          if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
          n = n.prevZ;
        }
        return !0;
      }),
      (PIXI.EarCut.cureLocalIntersections = function (a, b, c) {
        var d = a;
        do {
          var e = d.prev,
            f = d.next.next;
          PIXI.EarCut.intersects(e, d, d.next, f) &&
            PIXI.EarCut.locallyInside(e, f) &&
            PIXI.EarCut.locallyInside(f, e) &&
            (b.push(e.i / c), b.push(d.i / c), b.push(f.i / c), PIXI.EarCut.removeNode(d), PIXI.EarCut.removeNode(d.next), (d = a = f)),
            (d = d.next);
        } while (d !== a);
        return d;
      }),
      (PIXI.EarCut.splitEarcut = function (a, b, c, d, e, f) {
        var g = a;
        do {
          for (var h = g.next.next; h !== g.prev; ) {
            if (g.i !== h.i && PIXI.EarCut.isValidDiagonal(g, h)) {
              var i = PIXI.EarCut.splitPolygon(g, h);
              return (g = PIXI.EarCut.filterPoints(g, g.next)), (i = PIXI.EarCut.filterPoints(i, i.next)), PIXI.EarCut.earcutLinked(g, b, c, d, e, f), void PIXI.EarCut.earcutLinked(i, b, c, d, e, f);
            }
            h = h.next;
          }
          g = g.next;
        } while (g !== a);
      }),
      (PIXI.EarCut.eliminateHoles = function (a, b, c, d) {
        var e,
          f,
          g,
          h,
          i,
          j = [];
        for (e = 0, f = b.length; e < f; e++) (g = b[e] * d), (h = e < f - 1 ? b[e + 1] * d : a.length), (i = PIXI.EarCut.linkedList(a, g, h, d, !1)), i === i.next && (i.steiner = !0), j.push(PIXI.EarCut.getLeftmost(i));
        for (j.sort(compareX), e = 0; e < j.length; e++) PIXI.EarCut.eliminateHole(j[e], c), (c = PIXI.EarCut.filterPoints(c, c.next));
        return c;
      }),
      (PIXI.EarCut.compareX = function (a, b) {
        return a.x - b.x;
      }),
      (PIXI.EarCut.eliminateHole = function (a, b) {
        if ((b = PIXI.EarCut.findHoleBridge(a, b))) {
          var c = PIXI.EarCut.splitPolygon(b, a);
          PIXI.EarCut.filterPoints(c, c.next);
        }
      }),
      (PIXI.EarCut.findHoleBridge = function (a, b) {
        var c,
          d = b,
          e = a.x,
          f = a.y,
          g = -(1 / 0);
        do {
          if (f <= d.y && f >= d.next.y) {
            var h = d.x + ((f - d.y) * (d.next.x - d.x)) / (d.next.y - d.y);
            h <= e && h > g && ((g = h), (c = d.x < d.next.x ? d : d.next));
          }
          d = d.next;
        } while (d !== b);
        if (!c) return null;
        if (a.x === c.x) return c.prev;
        var i,
          j = c,
          k = 1 / 0;
        for (d = c.next; d !== j; )
          e >= d.x &&
            d.x >= c.x &&
            PIXI.EarCut.pointInTriangle(f < c.y ? e : g, f, c.x, c.y, f < c.y ? g : e, f, d.x, d.y) &&
            ((i = Math.abs(f - d.y) / (e - d.x)), (i < k || (i === k && d.x > c.x)) && PIXI.EarCut.locallyInside(d, a) && ((c = d), (k = i))),
            (d = d.next);
        return c;
      }),
      (PIXI.EarCut.indexCurve = function (a, b, c, d) {
        var e = a;
        do null === e.z && (e.z = PIXI.EarCut.zOrder(e.x, e.y, b, c, d)), (e.prevZ = e.prev), (e.nextZ = e.next), (e = e.next);
        while (e !== a);
        (e.prevZ.nextZ = null), (e.prevZ = null), PIXI.EarCut.sortLinked(e);
      }),
      (PIXI.EarCut.sortLinked = function (a) {
        var b,
          c,
          d,
          e,
          f,
          g,
          h,
          i,
          j = 1;
        do {
          for (c = a, a = null, f = null, g = 0; c; ) {
            for (g++, d = c, h = 0, b = 0; b < j && (h++, (d = d.nextZ)); b++);
            for (i = j; h > 0 || (i > 0 && d); )
              0 === h ? ((e = d), (d = d.nextZ), i--) : 0 !== i && d ? (c.z <= d.z ? ((e = c), (c = c.nextZ), h--) : ((e = d), (d = d.nextZ), i--)) : ((e = c), (c = c.nextZ), h--), f ? (f.nextZ = e) : (a = e), (e.prevZ = f), (f = e);
            c = d;
          }
          (f.nextZ = null), (j *= 2);
        } while (g > 1);
        return a;
      }),
      (PIXI.EarCut.zOrder = function (a, b, c, d, e) {
        return (
          (a = (32767 * (a - c)) / e),
          (b = (32767 * (b - d)) / e),
          (a = 16711935 & (a | (a << 8))),
          (a = 252645135 & (a | (a << 4))),
          (a = 858993459 & (a | (a << 2))),
          (a = 1431655765 & (a | (a << 1))),
          (b = 16711935 & (b | (b << 8))),
          (b = 252645135 & (b | (b << 4))),
          (b = 858993459 & (b | (b << 2))),
          (b = 1431655765 & (b | (b << 1))),
          a | (b << 1)
        );
      }),
      (PIXI.EarCut.getLeftmost = function (a) {
        var b = a,
          c = a;
        do b.x < c.x && (c = b), (b = b.next);
        while (b !== a);
        return c;
      }),
      (PIXI.EarCut.pointInTriangle = function (a, b, c, d, e, f, g, h) {
        return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0;
      }),
      (PIXI.EarCut.isValidDiagonal = function (a, b) {
        return PIXI.EarCut.equals(a, b) || (a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b));
      }),
      (PIXI.EarCut.area = function (a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
      }),
      (PIXI.EarCut.equals = function (a, b) {
        return a.x === b.x && a.y === b.y;
      }),
      (PIXI.EarCut.intersects = function (a, b, c, d) {
        return PIXI.EarCut.area(a, b, c) > 0 != PIXI.EarCut.area(a, b, d) > 0 && PIXI.EarCut.area(c, d, a) > 0 != PIXI.EarCut.area(c, d, b) > 0;
      }),
      (PIXI.EarCut.intersectsPolygon = function (a, b) {
        var c = a;
        do {
          if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && PIXI.EarCut.intersects(c, c.next, a, b)) return !0;
          c = c.next;
        } while (c !== a);
        return !1;
      }),
      (PIXI.EarCut.locallyInside = function (a, b) {
        return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0;
      }),
      (PIXI.EarCut.middleInside = function (a, b) {
        var c = a,
          d = !1,
          e = (a.x + b.x) / 2,
          f = (a.y + b.y) / 2;
        do c.y > f != c.next.y > f && e < ((c.next.x - c.x) * (f - c.y)) / (c.next.y - c.y) + c.x && (d = !d), (c = c.next);
        while (c !== a);
        return d;
      }),
      (PIXI.EarCut.splitPolygon = function (a, b) {
        var c = new PIXI.EarCut.Node(a.i, a.x, a.y),
          d = new PIXI.EarCut.Node(b.i, b.x, b.y),
          e = a.next,
          f = b.prev;
        return (a.next = b), (b.prev = a), (c.next = e), (e.prev = c), (d.next = c), (c.prev = d), (f.next = d), (d.prev = f), d;
      }),
      (PIXI.EarCut.insertNode = function (a, b, c, d) {
        var e = new PIXI.EarCut.Node(a, b, c);
        return d ? ((e.next = d.next), (e.prev = d), (d.next.prev = e), (d.next = e)) : ((e.prev = e), (e.next = e)), e;
      }),
      (PIXI.EarCut.removeNode = function (a) {
        (a.next.prev = a.prev), (a.prev.next = a.next), a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
      }),
      (PIXI.EarCut.Node = function (a, b, c) {
        (this.i = a), (this.x = b), (this.y = c), (this.prev = null), (this.next = null), (this.z = null), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
      }),
      (PIXI.WebGLGraphics = function () {}),
      (PIXI.WebGLGraphics.stencilBufferLimit = 6),
      (PIXI.WebGLGraphics.renderGraphics = function (a, b) {
        var c,
          d = b.gl,
          e = b.projection,
          f = b.offset,
          g = b.shaderManager.primitiveShader;
        a.dirty && PIXI.WebGLGraphics.updateGraphics(a, d);
        for (var h = a._webGL[d.id], i = 0; i < h.data.length; i++)
          1 === h.data[i].mode
            ? ((c = h.data[i]), b.stencilManager.pushStencil(a, c, b), d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (c.indices.length - 4)), b.stencilManager.popStencil(a, c, b))
            : ((c = h.data[i]),
              b.shaderManager.setShader(g),
              (g = b.shaderManager.primitiveShader),
              d.uniformMatrix3fv(g.translationMatrix, !1, a.worldTransform.toArray(!0)),
              d.uniform1f(g.flipY, 1),
              d.uniform2f(g.projectionVector, e.x, -e.y),
              d.uniform2f(g.offsetVector, -f.x, -f.y),
              d.uniform3fv(g.tintColor, PIXI.hex2rgb(a.tint)),
              d.uniform1f(g.alpha, a.worldAlpha),
              d.bindBuffer(d.ARRAY_BUFFER, c.buffer),
              d.vertexAttribPointer(g.aVertexPosition, 2, d.FLOAT, !1, 24, 0),
              d.vertexAttribPointer(g.colorAttribute, 4, d.FLOAT, !1, 24, 8),
              d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c.indexBuffer),
              d.drawElements(d.TRIANGLE_STRIP, c.indices.length, d.UNSIGNED_SHORT, 0));
      }),
      (PIXI.WebGLGraphics.updateGraphics = function (a, b) {
        var c = a._webGL[b.id];
        c || (c = a._webGL[b.id] = { lastIndex: 0, data: [], gl: b }), (a.dirty = !1);
        var d;
        if (a.clearDirty) {
          for (a.clearDirty = !1, d = 0; d < c.data.length; d++) {
            var e = c.data[d];
            e.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(e);
          }
          (c.data = []), (c.lastIndex = 0);
        }
        var f;
        for (d = c.lastIndex; d < a.graphicsData.length; d++) {
          var g = a.graphicsData[d];
          if (g.type === PIXI.Graphics.POLY) {
            if (
              ((g.points = g.shape.points.slice()),
              g.shape.closed && ((g.points[0] === g.points[g.points.length - 2] && g.points[1] === g.points[g.points.length - 1]) || g.points.push(g.points[0], g.points[1])),
              g.fill && g.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
            )
              if (g.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                f = PIXI.WebGLGraphics.switchMode(c, 0);
                var h = PIXI.WebGLGraphics.buildPoly(g, f);
                h || ((f = PIXI.WebGLGraphics.switchMode(c, 1)), PIXI.WebGLGraphics.buildComplexPoly(g, f));
              } else (f = PIXI.WebGLGraphics.switchMode(c, 1)), PIXI.WebGLGraphics.buildComplexPoly(g, f);
            g.lineWidth > 0 && ((f = PIXI.WebGLGraphics.switchMode(c, 0)), PIXI.WebGLGraphics.buildLine(g, f));
          } else
            (f = PIXI.WebGLGraphics.switchMode(c, 0)),
              g.type === PIXI.Graphics.RECT
                ? PIXI.WebGLGraphics.buildRectangle(g, f)
                : g.type === PIXI.Graphics.CIRC || g.type === PIXI.Graphics.ELIP
                ? PIXI.WebGLGraphics.buildCircle(g, f)
                : g.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(g, f);
          c.lastIndex++;
        }
        for (d = 0; d < c.data.length; d++) (f = c.data[d]), f.dirty && f.upload();
      }),
      (PIXI.WebGLGraphics.switchMode = function (a, b) {
        var c;
        return (
          a.data.length
            ? ((c = a.data[a.data.length - 1]), (c.mode === b && 1 !== b) || ((c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl)), (c.mode = b), a.data.push(c)))
            : ((c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl)), (c.mode = b), a.data.push(c)),
          (c.dirty = !0),
          c
        );
      }),
      (PIXI.WebGLGraphics.buildRectangle = function (a, b) {
        var c = a.shape,
          d = c.x,
          e = c.y,
          f = c.width,
          g = c.height;
        if (a.fill) {
          var h = PIXI.hex2rgb(a.fillColor),
            i = a.fillAlpha,
            j = h[0] * i,
            k = h[1] * i,
            l = h[2] * i,
            m = b.points,
            n = b.indices,
            o = m.length / 6;
          m.push(d, e), m.push(j, k, l, i), m.push(d + f, e), m.push(j, k, l, i), m.push(d, e + g), m.push(j, k, l, i), m.push(d + f, e + g), m.push(j, k, l, i), n.push(o, o, o + 1, o + 2, o + 3, o + 3);
        }
        if (a.lineWidth) {
          var p = a.points;
          (a.points = [d, e, d + f, e, d + f, e + g, d, e + g, d, e]), PIXI.WebGLGraphics.buildLine(a, b), (a.points = p);
        }
      }),
      (PIXI.WebGLGraphics.buildRoundedRectangle = function (a, b) {
        var c = a.shape,
          d = c.x,
          e = c.y,
          f = c.width,
          g = c.height,
          h = c.radius,
          i = [];
        if (
          (i.push(d, e + h),
          (i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d, e + g - h, d, e + g, d + h, e + g))),
          (i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f - h, e + g, d + f, e + g, d + f, e + g - h))),
          (i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f, e + h, d + f, e, d + f - h, e))),
          (i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + h, e, d, e, d, e + h))),
          a.fill)
        ) {
          var j = PIXI.hex2rgb(a.fillColor),
            k = a.fillAlpha,
            l = j[0] * k,
            m = j[1] * k,
            n = j[2] * k,
            o = b.points,
            p = b.indices,
            q = o.length / 6,
            r = PIXI.EarCut.Triangulate(i, null, 2),
            s = 0;
          for (s = 0; s < r.length; s += 3) p.push(r[s] + q), p.push(r[s] + q), p.push(r[s + 1] + q), p.push(r[s + 2] + q), p.push(r[s + 2] + q);
          for (s = 0; s < i.length; s++) o.push(i[s], i[++s], l, m, n, k);
        }
        if (a.lineWidth) {
          var t = a.points;
          (a.points = i), PIXI.WebGLGraphics.buildLine(a, b), (a.points = t);
        }
      }),
      (PIXI.WebGLGraphics.quadraticBezierCurve = function (a, b, c, d, e, f) {
        function g(a, b, c) {
          var d = b - a;
          return a + d * c;
        }
        for (var h, i, j, k, l, m, n = 20, o = [], p = 0, q = 0; q <= n; q++) (p = q / n), (h = g(a, c, p)), (i = g(b, d, p)), (j = g(c, e, p)), (k = g(d, f, p)), (l = g(h, j, p)), (m = g(i, k, p)), o.push(l, m);
        return o;
      }),
      (PIXI.WebGLGraphics.buildCircle = function (a, b) {
        var c,
          d,
          e = a.shape,
          f = e.x,
          g = e.y;
        a.type === PIXI.Graphics.CIRC ? ((c = e.radius), (d = e.radius)) : ((c = e.width), (d = e.height));
        var h = 40,
          i = (2 * Math.PI) / h,
          j = 0;
        if (a.fill) {
          var k = PIXI.hex2rgb(a.fillColor),
            l = a.fillAlpha,
            m = k[0] * l,
            n = k[1] * l,
            o = k[2] * l,
            p = b.points,
            q = b.indices,
            r = p.length / 6;
          for (q.push(r), j = 0; j < h + 1; j++) p.push(f, g, m, n, o, l), p.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d, m, n, o, l), q.push(r++, r++);
          q.push(r - 1);
        }
        if (a.lineWidth) {
          var s = a.points;
          for (a.points = [], j = 0; j < h + 1; j++) a.points.push(f + Math.sin(i * j) * c, g + Math.cos(i * j) * d);
          PIXI.WebGLGraphics.buildLine(a, b), (a.points = s);
        }
      }),
      (PIXI.WebGLGraphics.buildLine = function (a, b) {
        var c = 0,
          d = a.points;
        if (0 !== d.length) {
          if (a.lineWidth % 2) for (c = 0; c < d.length; c++) d[c] += 0.5;
          var e = new PIXI.Point(d[0], d[1]),
            f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
          if (e.x === f.x && e.y === f.y) {
            (d = d.slice()), d.pop(), d.pop(), (f = new PIXI.Point(d[d.length - 2], d[d.length - 1]));
            var g = f.x + 0.5 * (e.x - f.x),
              h = f.y + 0.5 * (e.y - f.y);
            d.unshift(g, h), d.push(g, h);
          }
          var i,
            j,
            k,
            l,
            m,
            n,
            o,
            p,
            q,
            r,
            s,
            t,
            u,
            v,
            w,
            x,
            y,
            z,
            A,
            B,
            C,
            D,
            E,
            F = b.points,
            G = b.indices,
            H = d.length / 2,
            I = d.length,
            J = F.length / 6,
            K = a.lineWidth / 2,
            L = PIXI.hex2rgb(a.lineColor),
            M = a.lineAlpha,
            N = L[0] * M,
            O = L[1] * M,
            P = L[2] * M;
          for (k = d[0], l = d[1], m = d[2], n = d[3], q = -(l - n), r = k - m, E = Math.sqrt(q * q + r * r), q /= E, r /= E, q *= K, r *= K, F.push(k - q, l - r, N, O, P, M), F.push(k + q, l + r, N, O, P, M), c = 1; c < H - 1; c++)
            (k = d[2 * (c - 1)]),
              (l = d[2 * (c - 1) + 1]),
              (m = d[2 * c]),
              (n = d[2 * c + 1]),
              (o = d[2 * (c + 1)]),
              (p = d[2 * (c + 1) + 1]),
              (q = -(l - n)),
              (r = k - m),
              (E = Math.sqrt(q * q + r * r)),
              (q /= E),
              (r /= E),
              (q *= K),
              (r *= K),
              (s = -(n - p)),
              (t = m - o),
              (E = Math.sqrt(s * s + t * t)),
              (s /= E),
              (t /= E),
              (s *= K),
              (t *= K),
              (w = -r + l - (-r + n)),
              (x = -q + m - (-q + k)),
              (y = (-q + k) * (-r + n) - (-q + m) * (-r + l)),
              (z = -t + p - (-t + n)),
              (A = -s + m - (-s + o)),
              (B = (-s + o) * (-t + n) - (-s + m) * (-t + p)),
              (C = w * A - z * x),
              Math.abs(C) < 0.1
                ? ((C += 10.1), F.push(m - q, n - r, N, O, P, M), F.push(m + q, n + r, N, O, P, M))
                : ((i = (x * B - A * y) / C),
                  (j = (z * y - w * B) / C),
                  (D = (i - m) * (i - m) + (j - n) + (j - n)),
                  D > 19600
                    ? ((u = q - s),
                      (v = r - t),
                      (E = Math.sqrt(u * u + v * v)),
                      (u /= E),
                      (v /= E),
                      (u *= K),
                      (v *= K),
                      F.push(m - u, n - v),
                      F.push(N, O, P, M),
                      F.push(m + u, n + v),
                      F.push(N, O, P, M),
                      F.push(m - u, n - v),
                      F.push(N, O, P, M),
                      I++)
                    : (F.push(i, j), F.push(N, O, P, M), F.push(m - (i - m), n - (j - n)), F.push(N, O, P, M)));
          for (
            k = d[2 * (H - 2)],
              l = d[2 * (H - 2) + 1],
              m = d[2 * (H - 1)],
              n = d[2 * (H - 1) + 1],
              q = -(l - n),
              r = k - m,
              E = Math.sqrt(q * q + r * r),
              q /= E,
              r /= E,
              q *= K,
              r *= K,
              F.push(m - q, n - r),
              F.push(N, O, P, M),
              F.push(m + q, n + r),
              F.push(N, O, P, M),
              G.push(J),
              c = 0;
            c < I;
            c++
          )
            G.push(J++);
          G.push(J - 1);
        }
      }),
      (PIXI.WebGLGraphics.buildComplexPoly = function (a, b) {
        var c = a.points.slice();
        if (!(c.length < 6)) {
          var d = b.indices;
          (b.points = c), (b.alpha = a.fillAlpha), (b.color = PIXI.hex2rgb(a.fillColor));
          for (var e, f, g = 1 / 0, h = -(1 / 0), i = 1 / 0, j = -(1 / 0), k = 0; k < c.length; k += 2) (e = c[k]), (f = c[k + 1]), (g = e < g ? e : g), (h = e > h ? e : h), (i = f < i ? f : i), (j = f > j ? f : j);
          c.push(g, i, h, i, h, j, g, j);
          var l = c.length / 2;
          for (k = 0; k < l; k++) d.push(k);
        }
      }),
      (PIXI.WebGLGraphics.buildPoly = function (a, b) {
        var c = a.points;
        if (!(c.length < 6)) {
          var d = b.points,
            e = b.indices,
            f = c.length / 2,
            g = PIXI.hex2rgb(a.fillColor),
            h = a.fillAlpha,
            i = g[0] * h,
            j = g[1] * h,
            k = g[2] * h,
            l = PIXI.EarCut.Triangulate(c, null, 2);
          if (!l) return !1;
          var m = d.length / 6,
            n = 0;
          for (n = 0; n < l.length; n += 3) e.push(l[n] + m), e.push(l[n] + m), e.push(l[n + 1] + m), e.push(l[n + 2] + m), e.push(l[n + 2] + m);
          for (n = 0; n < f; n++) d.push(c[2 * n], c[2 * n + 1], i, j, k, h);
          return !0;
        }
      }),
      (PIXI.WebGLGraphics.graphicsDataPool = []),
      (PIXI.WebGLGraphicsData = function (a) {
        (this.gl = a), (this.color = [0, 0, 0]), (this.points = []), (this.indices = []), (this.buffer = a.createBuffer()), (this.indexBuffer = a.createBuffer()), (this.mode = 1), (this.alpha = 1), (this.dirty = !0);
      }),
      (PIXI.WebGLGraphicsData.prototype.reset = function () {
        (this.points = []), (this.indices = []);
      }),
      (PIXI.WebGLGraphicsData.prototype.upload = function () {
        var a = this.gl;
        (this.glPoints = new PIXI.Float32Array(this.points)),
          a.bindBuffer(a.ARRAY_BUFFER, this.buffer),
          a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW),
          (this.glIndicies = new PIXI.Uint16Array(this.indices)),
          a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
          a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW),
          (this.dirty = !1);
      }),
      (PIXI.CanvasGraphics = function () {}),
      (PIXI.CanvasGraphics.renderGraphics = function (a, b) {
        var c = a.worldAlpha;
        a.dirty && (this.updateGraphicsTint(a), (a.dirty = !1));
        for (var d = 0; d < a.graphicsData.length; d++) {
          var e = a.graphicsData[d],
            f = e.shape,
            g = e._fillTint,
            h = e._lineTint;
          if (((b.lineWidth = e.lineWidth), e.type === PIXI.Graphics.POLY)) {
            b.beginPath();
            var i = f.points;
            b.moveTo(i[0], i[1]);
            for (var j = 1; j < i.length / 2; j++) b.lineTo(i[2 * j], i[2 * j + 1]);
            f.closed && b.lineTo(i[0], i[1]),
              i[0] === i[i.length - 2] && i[1] === i[i.length - 1] && b.closePath(),
              e.fill && ((b.globalAlpha = e.fillAlpha * c), (b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6)), b.fill()),
              e.lineWidth && ((b.globalAlpha = e.lineAlpha * c), (b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6)), b.stroke());
          } else if (e.type === PIXI.Graphics.RECT)
            (e.fillColor || 0 === e.fillColor) && ((b.globalAlpha = e.fillAlpha * c), (b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6)), b.fillRect(f.x, f.y, f.width, f.height)),
              e.lineWidth && ((b.globalAlpha = e.lineAlpha * c), (b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6)), b.strokeRect(f.x, f.y, f.width, f.height));
          else if (e.type === PIXI.Graphics.CIRC)
            b.beginPath(),
              b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI),
              b.closePath(),
              e.fill && ((b.globalAlpha = e.fillAlpha * c), (b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6)), b.fill()),
              e.lineWidth && ((b.globalAlpha = e.lineAlpha * c), (b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6)), b.stroke());
          else if (e.type === PIXI.Graphics.ELIP) {
            var k = 2 * f.width,
              l = 2 * f.height,
              m = f.x - k / 2,
              n = f.y - l / 2;
            b.beginPath();
            var o = 0.5522848,
              p = (k / 2) * o,
              q = (l / 2) * o,
              r = m + k,
              s = n + l,
              t = m + k / 2,
              u = n + l / 2;
            b.moveTo(m, u),
              b.bezierCurveTo(m, u - q, t - p, n, t, n),
              b.bezierCurveTo(t + p, n, r, u - q, r, u),
              b.bezierCurveTo(r, u + q, t + p, s, t, s),
              b.bezierCurveTo(t - p, s, m, u + q, m, u),
              b.closePath(),
              e.fill && ((b.globalAlpha = e.fillAlpha * c), (b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6)), b.fill()),
              e.lineWidth && ((b.globalAlpha = e.lineAlpha * c), (b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6)), b.stroke());
          } else if (e.type === PIXI.Graphics.RREC) {
            var v = f.x,
              w = f.y,
              x = f.width,
              y = f.height,
              z = f.radius,
              A = (Math.min(x, y) / 2) | 0;
            (z = z > A ? A : z),
              b.beginPath(),
              b.moveTo(v, w + z),
              b.lineTo(v, w + y - z),
              b.quadraticCurveTo(v, w + y, v + z, w + y),
              b.lineTo(v + x - z, w + y),
              b.quadraticCurveTo(v + x, w + y, v + x, w + y - z),
              b.lineTo(v + x, w + z),
              b.quadraticCurveTo(v + x, w, v + x - z, w),
              b.lineTo(v + z, w),
              b.quadraticCurveTo(v, w, v, w + z),
              b.closePath(),
              (e.fillColor || 0 === e.fillColor) && ((b.globalAlpha = e.fillAlpha * c), (b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6)), b.fill()),
              e.lineWidth && ((b.globalAlpha = e.lineAlpha * c), (b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6)), b.stroke());
          }
        }
      }),
      (PIXI.CanvasGraphics.renderGraphicsMask = function (a, b) {
        var c = a.graphicsData.length;
        if (0 !== c) {
          b.beginPath();
          for (var d = 0; d < c; d++) {
            var e = a.graphicsData[d],
              f = e.shape;
            if (e.type === PIXI.Graphics.POLY) {
              var g = f.points;
              b.moveTo(g[0], g[1]);
              for (var h = 1; h < g.length / 2; h++) b.lineTo(g[2 * h], g[2 * h + 1]);
              g[0] === g[g.length - 2] && g[1] === g[g.length - 1] && b.closePath();
            } else if (e.type === PIXI.Graphics.RECT) b.rect(f.x, f.y, f.width, f.height), b.closePath();
            else if (e.type === PIXI.Graphics.CIRC) b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI), b.closePath();
            else if (e.type === PIXI.Graphics.ELIP) {
              var i = 2 * f.width,
                j = 2 * f.height,
                k = f.x - i / 2,
                l = f.y - j / 2,
                m = 0.5522848,
                n = (i / 2) * m,
                o = (j / 2) * m,
                p = k + i,
                q = l + j,
                r = k + i / 2,
                s = l + j / 2;
              b.moveTo(k, s), b.bezierCurveTo(k, s - o, r - n, l, r, l), b.bezierCurveTo(r + n, l, p, s - o, p, s), b.bezierCurveTo(p, s + o, r + n, q, r, q), b.bezierCurveTo(r - n, q, k, s + o, k, s), b.closePath();
            } else if (e.type === PIXI.Graphics.RREC) {
              var t = f.x,
                u = f.y,
                v = f.width,
                w = f.height,
                x = f.radius,
                y = (Math.min(v, w) / 2) | 0;
              (x = x > y ? y : x),
                b.moveTo(t, u + x),
                b.lineTo(t, u + w - x),
                b.quadraticCurveTo(t, u + w, t + x, u + w),
                b.lineTo(t + v - x, u + w),
                b.quadraticCurveTo(t + v, u + w, t + v, u + w - x),
                b.lineTo(t + v, u + x),
                b.quadraticCurveTo(t + v, u, t + v - x, u),
                b.lineTo(t + x, u),
                b.quadraticCurveTo(t, u, t, u + x),
                b.closePath();
            }
          }
        }
      }),
      (PIXI.CanvasGraphics.updateGraphicsTint = function (a) {
        if (16777215 !== a.tint)
          for (var b = ((a.tint >> 16) & 255) / 255, c = ((a.tint >> 8) & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
            var f = a.graphicsData[e],
              g = 0 | f.fillColor,
              h = 0 | f.lineColor;
            (f._fillTint = (((((g >> 16) & 255) / 255) * b * 255) << 16) + (((((g >> 8) & 255) / 255) * c * 255) << 8) + ((255 & g) / 255) * d * 255),
              (f._lineTint = (((((h >> 16) & 255) / 255) * b * 255) << 16) + (((((h >> 8) & 255) / 255) * c * 255) << 8) + ((255 & h) / 255) * d * 255);
          }
      }),
      (c.Graphics = function (a, b, d) {
        void 0 === b && (b = 0), void 0 === d && (d = 0), (this.type = c.GRAPHICS), (this.physicsType = c.SPRITE), (this.anchor = new c.Point()), PIXI.Graphics.call(this), c.Component.Core.init.call(this, a, b, d, "", null);
      }),
      (c.Graphics.prototype = Object.create(PIXI.Graphics.prototype)),
      (c.Graphics.prototype.constructor = c.Graphics),
      c.Component.Core.install.call(c.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
      (c.Graphics.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate),
      (c.Graphics.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate),
      (c.Graphics.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.Graphics.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.Graphics.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
      }),
      (c.Graphics.prototype.postUpdate = function () {
        c.Component.PhysicsBody.postUpdate.call(this), c.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), (this._boundsDirty = !1));
        for (var a = 0; a < this.children.length; a++) this.children[a].postUpdate();
      }),
      (c.Graphics.prototype.destroy = function (a) {
        this.clear(), c.Component.Destroy.prototype.destroy.call(this, a);
      }),
      (c.Graphics.prototype.drawTriangle = function (a, b) {
        void 0 === b && (b = !1);
        var d = new c.Polygon(a);
        if (b) {
          var e = new c.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y),
            f = new c.Point(a[1].x - a[0].x, a[1].y - a[0].y),
            g = new c.Point(a[1].x - a[2].x, a[1].y - a[2].y),
            h = g.cross(f);
          e.dot(h) > 0 && this.drawPolygon(d);
        } else this.drawPolygon(d);
      }),
      (c.Graphics.prototype.drawTriangles = function (a, b, d) {
        void 0 === d && (d = !1);
        var e,
          f = new c.Point(),
          g = new c.Point(),
          h = new c.Point(),
          i = [];
        if (b)
          if (a[0] instanceof c.Point) for (e = 0; e < b.length / 3; e++) i.push(a[b[3 * e]]), i.push(a[b[3 * e + 1]]), i.push(a[b[3 * e + 2]]), 3 === i.length && (this.drawTriangle(i, d), (i = []));
          else for (e = 0; e < b.length; e++) (f.x = a[2 * b[e]]), (f.y = a[2 * b[e] + 1]), i.push(f.copyTo({})), 3 === i.length && (this.drawTriangle(i, d), (i = []));
        else if (a[0] instanceof c.Point) for (e = 0; e < a.length / 3; e++) this.drawTriangle([a[3 * e], a[3 * e + 1], a[3 * e + 2]], d);
        else for (e = 0; e < a.length / 6; e++) (f.x = a[6 * e + 0]), (f.y = a[6 * e + 1]), (g.x = a[6 * e + 2]), (g.y = a[6 * e + 3]), (h.x = a[6 * e + 4]), (h.y = a[6 * e + 5]), this.drawTriangle([f, g, h], d);
      }),
      (c.RenderTexture = function (a, b, d, e, f, g) {
        void 0 === e && (e = ""),
          void 0 === f && (f = c.scaleModes.DEFAULT),
          void 0 === g && (g = 1),
          (this.game = a),
          (this.key = e),
          (this.type = c.RENDERTEXTURE),
          (this._tempMatrix = new PIXI.Matrix()),
          PIXI.RenderTexture.call(this, b, d, this.game.renderer, f, g),
          (this.render = c.RenderTexture.prototype.render);
      }),
      (c.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype)),
      (c.RenderTexture.prototype.constructor = c.RenderTexture),
      (c.RenderTexture.prototype.renderXY = function (a, b, c, d) {
        a.updateTransform(),
          this._tempMatrix.copyFrom(a.worldTransform),
          (this._tempMatrix.tx = b),
          (this._tempMatrix.ty = c),
          this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d);
      }),
      (c.RenderTexture.prototype.renderRawXY = function (a, b, c, d) {
        this._tempMatrix.identity().translate(b, c), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d);
      }),
      (c.RenderTexture.prototype.render = function (a, b, c) {
        void 0 === b || null === b ? this._tempMatrix.copyFrom(a.worldTransform) : this._tempMatrix.copyFrom(b),
          this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, c) : this.renderCanvas(a, this._tempMatrix, c);
      }),
      (c.Text = function (a, b, d, e, f) {
        (b = b || 0),
          (d = d || 0),
          (e = void 0 === e || null === e ? "" : e.toString()),
          (f = c.Utils.extend({}, f)),
          (this.type = c.TEXT),
          (this.physicsType = c.SPRITE),
          (this.padding = new c.Point()),
          (this.textBounds = null),
          (this.canvas = PIXI.CanvasPool.create(this)),
          (this.context = this.canvas.getContext("2d")),
          (this.colors = []),
          (this.strokeColors = []),
          (this.fontStyles = []),
          (this.fontWeights = []),
          (this.autoRound = !1),
          (this.useAdvancedWrap = !1),
          (this._res = a.renderer.resolution),
          (this._text = e),
          (this._fontComponents = null),
          (this._lineSpacing = 0),
          (this._charCount = 0),
          (this._width = 0),
          (this._height = 0),
          c.Sprite.call(this, a, b, d, PIXI.Texture.fromCanvas(this.canvas)),
          this.setStyle(f),
          "" !== e && this.updateText();
      }),
      (c.Text.prototype = Object.create(c.Sprite.prototype)),
      (c.Text.prototype.constructor = c.Text),
      (c.Text.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
      }),
      (c.Text.prototype.update = function () {}),
      (c.Text.prototype.destroy = function (a) {
        this.texture.destroy(!0), c.Component.Destroy.prototype.destroy.call(this, a);
      }),
      (c.Text.prototype.setShadow = function (a, b, c, d, e, f) {
        return (
          void 0 === a && (a = 0),
          void 0 === b && (b = 0),
          void 0 === c && (c = "rgba(0, 0, 0, 1)"),
          void 0 === d && (d = 0),
          void 0 === e && (e = !0),
          void 0 === f && (f = !0),
          (this.style.shadowOffsetX = a),
          (this.style.shadowOffsetY = b),
          (this.style.shadowColor = c),
          (this.style.shadowBlur = d),
          (this.style.shadowStroke = e),
          (this.style.shadowFill = f),
          (this.dirty = !0),
          this
        );
      }),
      (c.Text.prototype.setStyle = function (a, b) {
        void 0 === b && (b = !1),
          (a = a || {}),
          (a.font = a.font || "bold 20pt Arial"),
          (a.backgroundColor = a.backgroundColor || null),
          (a.fill = a.fill || "black"),
          (a.align = a.align || "left"),
          (a.boundsAlignH = a.boundsAlignH || "left"),
          (a.boundsAlignV = a.boundsAlignV || "top"),
          (a.stroke = a.stroke || "black"),
          (a.strokeThickness = a.strokeThickness || 0),
          (a.wordWrap = a.wordWrap || !1),
          (a.wordWrapWidth = a.wordWrapWidth || 100),
          (a.maxLines = a.maxLines || 0),
          (a.shadowOffsetX = a.shadowOffsetX || 0),
          (a.shadowOffsetY = a.shadowOffsetY || 0),
          (a.shadowColor = a.shadowColor || "rgba(0,0,0,0)"),
          (a.shadowBlur = a.shadowBlur || 0),
          (a.tabs = a.tabs || 0);
        var c = this.fontToComponents(a.font);
        return (
          a.fontStyle && (c.fontStyle = a.fontStyle),
          a.fontVariant && (c.fontVariant = a.fontVariant),
          a.fontWeight && (c.fontWeight = a.fontWeight),
          a.fontSize && ("number" == typeof a.fontSize && (a.fontSize = a.fontSize + "px"), (c.fontSize = a.fontSize)),
          (this._fontComponents = c),
          (a.font = this.componentsToFont(this._fontComponents)),
          (this.style = a),
          (this.dirty = !0),
          b && this.updateText(),
          this
        );
      }),
      (c.Text.prototype.updateText = function () {
        (this.texture.baseTexture.resolution = this._res), (this.context.font = this.style.font);
        var a = this.text;
        this.style.wordWrap && (a = this.runWordWrap(this.text));
        var b = a.split(/(?:\r\n|\r|\n)/),
          c = this.style.tabs,
          d = [],
          e = 0,
          f = this.determineFontProperties(this.style.font),
          g = b.length;
        this.style.maxLines > 0 && this.style.maxLines < b.length && (g = this.style.maxLines), (this._charCount = 0);
        for (var h = 0; h < g; h++) {
          if (0 === c) {
            var i = this.style.strokeThickness + this.padding.x;
            (i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(b[h]) : this.context.measureText(b[h]).width),
              this.style.wordWrap && (i -= this.context.measureText(" ").width);
          } else {
            var j = b[h].split(/(?:\t)/),
              i = this.padding.x + this.style.strokeThickness;
            if (Array.isArray(c))
              for (var k = 0, l = 0; l < j.length; l++) {
                var m = 0;
                (m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width)),
                  l > 0 && (k += c[l - 1]),
                  (i = k + m);
              }
            else
              for (var l = 0; l < j.length; l++) {
                i += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width);
                var n = this.game.math.snapToCeil(i, c) - i;
                i += n;
              }
          }
          (d[h] = Math.ceil(i)), (e = Math.max(e, d[h]));
        }
        this.canvas.width = e * this._res;
        var o = f.fontSize + this.style.strokeThickness + this.padding.y,
          p = o * g,
          q = this._lineSpacing;
        q < 0 && Math.abs(q) > o && (q = -o),
          0 !== q && (p += q > 0 ? q * b.length : q * (b.length - 1)),
          (this.canvas.height = p * this._res),
          this.context.scale(this._res, this._res),
          navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height),
          this.style.backgroundColor && ((this.context.fillStyle = this.style.backgroundColor), this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)),
          (this.context.fillStyle = this.style.fill),
          (this.context.font = this.style.font),
          (this.context.strokeStyle = this.style.stroke),
          (this.context.textBaseline = "alphabetic"),
          (this.context.lineWidth = this.style.strokeThickness),
          (this.context.lineCap = "round"),
          (this.context.lineJoin = "round");
        var r, s;
        for (this._charCount = 0, h = 0; h < g; h++)
          (r = this.style.strokeThickness / 2),
            (s = this.style.strokeThickness / 2 + h * o + f.ascent),
            h > 0 && (s += q * h),
            "right" === this.style.align ? (r += e - d[h]) : "center" === this.style.align && (r += (e - d[h]) / 2),
            this.autoRound && ((r = Math.round(r)), (s = Math.round(s))),
            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0
              ? this.updateLine(b[h], r, s)
              : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === c ? this.context.strokeText(b[h], r, s) : this.renderTabLine(b[h], r, s, !1)),
                this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[h], r, s) : this.renderTabLine(b[h], r, s, !0)));
        this.updateTexture(), (this.dirty = !1);
      }),
      (c.Text.prototype.renderTabLine = function (a, b, c, d) {
        var e = a.split(/(?:\t)/),
          f = this.style.tabs,
          g = 0;
        if (Array.isArray(f)) for (var h = 0, i = 0; i < e.length; i++) i > 0 && (h += f[i - 1]), (g = b + h), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c);
        else
          for (var i = 0; i < e.length; i++) {
            var j = Math.ceil(this.context.measureText(e[i]).width);
            (g = this.game.math.snapToCeil(b, f)), d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c), (b = g + j);
          }
      }),
      (c.Text.prototype.updateShadow = function (a) {
        a
          ? ((this.context.shadowOffsetX = this.style.shadowOffsetX), (this.context.shadowOffsetY = this.style.shadowOffsetY), (this.context.shadowColor = this.style.shadowColor), (this.context.shadowBlur = this.style.shadowBlur))
          : ((this.context.shadowOffsetX = 0), (this.context.shadowOffsetY = 0), (this.context.shadowColor = 0), (this.context.shadowBlur = 0));
      }),
      (c.Text.prototype.measureLine = function (a) {
        for (var b = 0, c = 0; c < a.length; c++) {
          var d = a[c];
          if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
            var e = this.fontToComponents(this.context.font);
            this.fontStyles[this._charCount] && (e.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (e.fontWeight = this.fontWeights[this._charCount]), (this.context.font = this.componentsToFont(e));
          }
          this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)),
            (b += this.context.measureText(d).width),
            this._charCount++;
        }
        return Math.ceil(b);
      }),
      (c.Text.prototype.updateLine = function (a, b, c) {
        for (var d = 0; d < a.length; d++) {
          var e = a[d];
          if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
            var f = this.fontToComponents(this.context.font);
            this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]), (this.context.font = this.componentsToFont(f));
          }
          this.style.stroke &&
            this.style.strokeThickness &&
            (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(e, b, c)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(e, b, c)),
            (b += this.context.measureText(e).width),
            this._charCount++;
        }
      }),
      (c.Text.prototype.clearColors = function () {
        return (this.colors = []), (this.strokeColors = []), (this.dirty = !0), this;
      }),
      (c.Text.prototype.clearFontValues = function () {
        return (this.fontStyles = []), (this.fontWeights = []), (this.dirty = !0), this;
      }),
      (c.Text.prototype.addColor = function (a, b) {
        return (this.colors[b] = a), (this.dirty = !0), this;
      }),
      (c.Text.prototype.addStrokeColor = function (a, b) {
        return (this.strokeColors[b] = a), (this.dirty = !0), this;
      }),
      (c.Text.prototype.addFontStyle = function (a, b) {
        return (this.fontStyles[b] = a), (this.dirty = !0), this;
      }),
      (c.Text.prototype.addFontWeight = function (a, b) {
        return (this.fontWeights[b] = a), (this.dirty = !0), this;
      }),
      (c.Text.prototype.precalculateWordWrap = function (a) {
        (this.texture.baseTexture.resolution = this._res), (this.context.font = this.style.font);
        var b = this.runWordWrap(a);
        return b.split(/(?:\r\n|\r|\n)/);
      }),
      (c.Text.prototype.runWordWrap = function (a) {
        return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a);
      }),
      (c.Text.prototype.advancedWordWrap = function (a) {
        for (var b = this.context, c = this.style.wordWrapWidth, d = "", e = a.replace(/ +/gi, " ").split(/\r?\n/gi), f = e.length, g = 0; g < f; g++) {
          var h = e[g],
            i = "";
          h = h.replace(/^ *|\s*$/gi, "");
          var j = b.measureText(h).width;
          if (j < c) d += h + "\n";
          else {
            for (var k = c, l = h.split(" "), m = 0; m < l.length; m++) {
              var n = l[m],
                o = n + " ",
                p = b.measureText(o).width;
              if (p > k) {
                if (0 === m) {
                  for (var q = o; q.length && ((q = q.slice(0, -1)), (p = b.measureText(q).width), !(p <= k)); );
                  if (!q.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                  var r = n.substr(q.length);
                  (l[m] = r), (i += q);
                }
                var s = l[m].length ? m : m + 1,
                  t = l
                    .slice(s)
                    .join(" ")
                    .replace(/[ \n]*$/gi, "");
                (e[g + 1] = t + " " + (e[g + 1] || "")), (f = e.length);
                break;
              }
              (i += o), (k -= p);
            }
            d += i.replace(/[ \n]*$/gi, "") + "\n";
          }
        }
        return (d = d.replace(/[\s|\n]*$/gi, ""));
      }),
      (c.Text.prototype.basicWordWrap = function (a) {
        for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
          for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
            var h = this.context.measureText(f[g]).width,
              i = h + this.context.measureText(" ").width;
            i > e ? (g > 0 && (b += "\n"), (b += f[g] + " "), (e = this.style.wordWrapWidth - h)) : ((e -= i), (b += f[g] + " "));
          }
          d < c.length - 1 && (b += "\n");
        }
        return b;
      }),
      (c.Text.prototype.updateFont = function (a) {
        var b = this.componentsToFont(a);
        this.style.font !== b && ((this.style.font = b), (this.dirty = !0), this.parent && this.updateTransform());
      }),
      (c.Text.prototype.fontToComponents = function (a) {
        var b = a.match(
          /^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/
        );
        if (b) {
          var c = b[5].trim();
          return (
            /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c) || (c = "'" + c + "'"),
            { font: a, fontStyle: b[1] || "normal", fontVariant: b[2] || "normal", fontWeight: b[3] || "normal", fontSize: b[4] || "medium", fontFamily: c }
          );
        }
        return { font: a };
      }),
      (c.Text.prototype.componentsToFont = function (a) {
        var b,
          c = [];
        return (
          (b = a.fontStyle),
          b && "normal" !== b && c.push(b),
          (b = a.fontVariant),
          b && "normal" !== b && c.push(b),
          (b = a.fontWeight),
          b && "normal" !== b && c.push(b),
          (b = a.fontSize),
          b && "medium" !== b && c.push(b),
          (b = a.fontFamily),
          b && c.push(b),
          c.length || c.push(a.font),
          c.join(" ")
        );
      }),
      (c.Text.prototype.setText = function (a, b) {
        return void 0 === b && (b = !1), (this.text = a.toString() || ""), b ? this.updateText() : (this.dirty = !0), this;
      }),
      (c.Text.prototype.parseList = function (a) {
        if (!Array.isArray(a)) return this;
        for (var b = "", c = 0; c < a.length; c++) Array.isArray(a[c]) ? ((b += a[c].join("\t")), c < a.length - 1 && (b += "\n")) : ((b += a[c]), c < a.length - 1 && (b += "\t"));
        return (this.text = b), (this.dirty = !0), this;
      }),
      (c.Text.prototype.setTextBounds = function (a, b, d, e) {
        return (
          void 0 === a ? (this.textBounds = null) : (this.textBounds ? this.textBounds.setTo(a, b, d, e) : (this.textBounds = new c.Rectangle(a, b, d, e)), this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)),
          this.updateTexture(),
          this
        );
      }),
      (c.Text.prototype.updateTexture = function () {
        var a = this.texture.baseTexture,
          b = this.texture.crop,
          c = this.texture.frame,
          d = this.canvas.width,
          e = this.canvas.height;
        if (((a.width = d), (a.height = e), (b.width = d), (b.height = e), (c.width = d), (c.height = e), (this.texture.width = d), (this.texture.height = e), (this._width = d), (this._height = e), this.textBounds)) {
          var f = this.textBounds.x,
            g = this.textBounds.y;
          "right" === this.style.boundsAlignH ? (f += this.textBounds.width - this.canvas.width / this.resolution) : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2),
            "bottom" === this.style.boundsAlignV ? (g += this.textBounds.height - this.canvas.height / this.resolution) : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2),
            (this.pivot.x = -f),
            (this.pivot.y = -g);
        }
        (this.renderable = 0 !== d && 0 !== e), (this.texture.requiresReTint = !0), this.texture.baseTexture.dirty();
      }),
      (c.Text.prototype._renderWebGL = function (a) {
        this.dirty && (this.updateText(), (this.dirty = !1)), PIXI.Sprite.prototype._renderWebGL.call(this, a);
      }),
      (c.Text.prototype._renderCanvas = function (a) {
        this.dirty && (this.updateText(), (this.dirty = !1)), PIXI.Sprite.prototype._renderCanvas.call(this, a);
      }),
      (c.Text.prototype.determineFontProperties = function (a) {
        var b = c.Text.fontPropertiesCache[a];
        if (!b) {
          b = {};
          var d = c.Text.fontPropertiesCanvas,
            e = c.Text.fontPropertiesContext;
          e.font = a;
          var f = Math.ceil(e.measureText("|MÉq").width),
            g = Math.ceil(e.measureText("|MÉq").width),
            h = 2 * g;
          if (
            ((g = (1.4 * g) | 0), (d.width = f), (d.height = h), (e.fillStyle = "#f00"), e.fillRect(0, 0, f, h), (e.font = a), (e.textBaseline = "alphabetic"), (e.fillStyle = "#000"), e.fillText("|MÉq", 0, g), !e.getImageData(0, 0, f, h))
          )
            return (b.ascent = g), (b.descent = g + 6), (b.fontSize = b.ascent + b.descent), (c.Text.fontPropertiesCache[a] = b), b;
          var i,
            j,
            k = e.getImageData(0, 0, f, h).data,
            l = k.length,
            m = 4 * f,
            n = 0,
            o = !1;
          for (i = 0; i < g; i++) {
            for (j = 0; j < m; j += 4)
              if (255 !== k[n + j]) {
                o = !0;
                break;
              }
            if (o) break;
            n += m;
          }
          for (b.ascent = g - i, n = l - m, o = !1, i = h; i > g; i--) {
            for (j = 0; j < m; j += 4)
              if (255 !== k[n + j]) {
                o = !0;
                break;
              }
            if (o) break;
            n -= m;
          }
          (b.descent = i - g), (b.descent += 6), (b.fontSize = b.ascent + b.descent), (c.Text.fontPropertiesCache[a] = b);
        }
        return b;
      }),
      (c.Text.prototype.getBounds = function (a) {
        return this.dirty && (this.updateText(), (this.dirty = !1)), PIXI.Sprite.prototype.getBounds.call(this, a);
      }),
      Object.defineProperty(c.Text.prototype, "text", {
        get: function () {
          return this._text;
        },
        set: function (a) {
          a !== this._text && ((this._text = a.toString() || ""), (this.dirty = !0), this.parent && this.updateTransform());
        },
      }),
      Object.defineProperty(c.Text.prototype, "cssFont", {
        get: function () {
          return this.componentsToFont(this._fontComponents);
        },
        set: function (a) {
          (a = a || "bold 20pt Arial"), (this._fontComponents = this.fontToComponents(a)), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "font", {
        get: function () {
          return this._fontComponents.fontFamily;
        },
        set: function (a) {
          (a = a || "Arial"), (a = a.trim()), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"), (this._fontComponents.fontFamily = a), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "fontSize", {
        get: function () {
          var a = this._fontComponents.fontSize;
          return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a;
        },
        set: function (a) {
          (a = a || "0"), "number" == typeof a && (a += "px"), (this._fontComponents.fontSize = a), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "fontWeight", {
        get: function () {
          return this._fontComponents.fontWeight || "normal";
        },
        set: function (a) {
          (a = a || "normal"), (this._fontComponents.fontWeight = a), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "fontStyle", {
        get: function () {
          return this._fontComponents.fontStyle || "normal";
        },
        set: function (a) {
          (a = a || "normal"), (this._fontComponents.fontStyle = a), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "fontVariant", {
        get: function () {
          return this._fontComponents.fontVariant || "normal";
        },
        set: function (a) {
          (a = a || "normal"), (this._fontComponents.fontVariant = a), this.updateFont(this._fontComponents);
        },
      }),
      Object.defineProperty(c.Text.prototype, "fill", {
        get: function () {
          return this.style.fill;
        },
        set: function (a) {
          a !== this.style.fill && ((this.style.fill = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "align", {
        get: function () {
          return this.style.align;
        },
        set: function (a) {
          a !== this.style.align && ((this.style.align = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "resolution", {
        get: function () {
          return this._res;
        },
        set: function (a) {
          a !== this._res && ((this._res = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "tabs", {
        get: function () {
          return this.style.tabs;
        },
        set: function (a) {
          a !== this.style.tabs && ((this.style.tabs = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "boundsAlignH", {
        get: function () {
          return this.style.boundsAlignH;
        },
        set: function (a) {
          a !== this.style.boundsAlignH && ((this.style.boundsAlignH = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "boundsAlignV", {
        get: function () {
          return this.style.boundsAlignV;
        },
        set: function (a) {
          a !== this.style.boundsAlignV && ((this.style.boundsAlignV = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "stroke", {
        get: function () {
          return this.style.stroke;
        },
        set: function (a) {
          a !== this.style.stroke && ((this.style.stroke = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "strokeThickness", {
        get: function () {
          return this.style.strokeThickness;
        },
        set: function (a) {
          a !== this.style.strokeThickness && ((this.style.strokeThickness = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "wordWrap", {
        get: function () {
          return this.style.wordWrap;
        },
        set: function (a) {
          a !== this.style.wordWrap && ((this.style.wordWrap = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "wordWrapWidth", {
        get: function () {
          return this.style.wordWrapWidth;
        },
        set: function (a) {
          a !== this.style.wordWrapWidth && ((this.style.wordWrapWidth = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "lineSpacing", {
        get: function () {
          return this._lineSpacing;
        },
        set: function (a) {
          a !== this._lineSpacing && ((this._lineSpacing = parseFloat(a)), (this.dirty = !0), this.parent && this.updateTransform());
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowOffsetX", {
        get: function () {
          return this.style.shadowOffsetX;
        },
        set: function (a) {
          a !== this.style.shadowOffsetX && ((this.style.shadowOffsetX = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowOffsetY", {
        get: function () {
          return this.style.shadowOffsetY;
        },
        set: function (a) {
          a !== this.style.shadowOffsetY && ((this.style.shadowOffsetY = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowColor", {
        get: function () {
          return this.style.shadowColor;
        },
        set: function (a) {
          a !== this.style.shadowColor && ((this.style.shadowColor = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowBlur", {
        get: function () {
          return this.style.shadowBlur;
        },
        set: function (a) {
          a !== this.style.shadowBlur && ((this.style.shadowBlur = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowStroke", {
        get: function () {
          return this.style.shadowStroke;
        },
        set: function (a) {
          a !== this.style.shadowStroke && ((this.style.shadowStroke = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "shadowFill", {
        get: function () {
          return this.style.shadowFill;
        },
        set: function (a) {
          a !== this.style.shadowFill && ((this.style.shadowFill = a), (this.dirty = !0));
        },
      }),
      Object.defineProperty(c.Text.prototype, "width", {
        get: function () {
          return this.dirty && (this.updateText(), (this.dirty = !1)), this.scale.x * this.texture.frame.width;
        },
        set: function (a) {
          (this.scale.x = a / this.texture.frame.width), (this._width = a);
        },
      }),
      Object.defineProperty(c.Text.prototype, "height", {
        get: function () {
          return this.dirty && (this.updateText(), (this.dirty = !1)), this.scale.y * this.texture.frame.height;
        },
        set: function (a) {
          (this.scale.y = a / this.texture.frame.height), (this._height = a);
        },
      }),
      (c.Text.fontPropertiesCache = {}),
      (c.Text.fontPropertiesCanvas = document.createElement("canvas")),
      (c.Text.fontPropertiesContext = c.Text.fontPropertiesCanvas.getContext("2d")),
      (c.BitmapText = function (a, b, d, e, f, g, h) {
        (b = b || 0),
          (d = d || 0),
          (e = e || ""),
          (f = f || ""),
          (g = g || 32),
          (h = h || "left"),
          PIXI.DisplayObjectContainer.call(this),
          (this.type = c.BITMAPTEXT),
          (this.physicsType = c.SPRITE),
          (this.textWidth = 0),
          (this.textHeight = 0),
          (this.anchor = new c.Point()),
          (this._prevAnchor = new c.Point()),
          (this._glyphs = []),
          (this._maxWidth = 0),
          (this._text = f.toString() || ""),
          (this._data = a.cache.getBitmapFont(e)),
          (this._font = e),
          (this._fontSize = g),
          (this._align = h),
          (this._tint = 16777215),
          this.updateText(),
          (this.dirty = !1),
          c.Component.Core.init.call(this, a, b, d, "", null);
      }),
      (c.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype)),
      (c.BitmapText.prototype.constructor = c.BitmapText),
      c.Component.Core.install.call(c.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
      (c.BitmapText.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate),
      (c.BitmapText.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate),
      (c.BitmapText.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.BitmapText.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.BitmapText.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
      }),
      (c.BitmapText.prototype.postUpdate = function () {
        c.Component.PhysicsBody.postUpdate.call(this),
          c.Component.FixedToCamera.postUpdate.call(this),
          this.body && this.body.type === c.Physics.ARCADE && ((this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight) || this.body.setSize(this.textWidth, this.textHeight));
      }),
      (c.BitmapText.prototype.setText = function (a) {
        this.text = a;
      }),
      (c.BitmapText.prototype.scanLine = function (a, b, c) {
        for (var d = 0, e = 0, f = -1, g = 0, h = null, i = this._maxWidth > 0 ? this._maxWidth : null, j = [], k = 0; k < c.length; k++) {
          var l = k === c.length - 1;
          if (/(?:\r\n|\r|\n)/.test(c.charAt(k))) return { width: e, text: c.substr(0, k), end: l, chars: j };
          var m = c.charCodeAt(k),
            n = a.chars[m],
            o = 0;
          void 0 === n && ((m = 32), (n = a.chars[m]));
          var p = h && n.kerning[h] ? n.kerning[h] : 0;
          if ((/(\s)/.test(c.charAt(k)) && ((f = k), (g = e)), (o = (p + n.texture.width + n.xOffset) * b), i && e + o >= i && f > -1)) return { width: g || e, text: c.substr(0, k - (k - f)), end: l, chars: j };
          (e += (n.xAdvance + p) * b), j.push(d + (n.xOffset + p) * b), (d += (n.xAdvance + p) * b), (h = m);
        }
        return { width: e, text: c, end: l, chars: j };
      }),
      (c.BitmapText.prototype.cleanText = function (a, b) {
        void 0 === b && (b = "");
        var c = this._data.font;
        if (!c) return "";
        for (var d = /\r\n|\n\r|\n|\r/g, e = a.replace(d, "\n").split("\n"), f = 0; f < e.length; f++) {
          for (var g = "", h = e[f], i = 0; i < h.length; i++) g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
          e[f] = g;
        }
        return e.join("\n");
      }),
      (c.BitmapText.prototype.updateText = function () {
        var a = this._data.font;
        if (a) {
          var b = this.text,
            c = this._fontSize / a.size,
            d = [],
            e = 0;
          this.textWidth = 0;
          do {
            var f = this.scanLine(a, c, b);
            (f.y = e), d.push(f), f.width > this.textWidth && (this.textWidth = f.width), (e += a.lineHeight * c), (b = b.substr(f.text.length + 1));
          } while (f.end === !1);
          this.textHeight = e;
          for (var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++) {
            var f = d[k];
            "right" === this._align ? (h = this.textWidth - f.width) : "center" === this._align && (h = (this.textWidth - f.width) / 2);
            for (var l = 0; l < f.text.length; l++) {
              var m = f.text.charCodeAt(l),
                n = a.chars[m];
              void 0 === n && ((m = 32), (n = a.chars[m]));
              var o = this._glyphs[g];
              o ? (o.texture = n.texture) : ((o = new PIXI.Sprite(n.texture)), (o.name = f.text[l]), this._glyphs.push(o)),
                (o.position.x = f.chars[l] + h - i),
                (o.position.y = f.y + n.yOffset * c - j),
                o.scale.set(c),
                (o.tint = this.tint),
                (o.texture.requiresReTint = !0),
                o.parent || this.addChild(o),
                g++;
            }
          }
          for (k = g; k < this._glyphs.length; k++) this.removeChild(this._glyphs[k]);
        }
      }),
      (c.BitmapText.prototype.purgeGlyphs = function () {
        for (var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++) this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]);
        return (this._glyphs = []), (this._glyphs = b), this.updateText(), a - b.length;
      }),
      (c.BitmapText.prototype.updateTransform = function () {
        (!this.dirty && this.anchor.equals(this._prevAnchor)) || (this.updateText(), (this.dirty = !1), this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
      }),
      Object.defineProperty(c.BitmapText.prototype, "align", {
        get: function () {
          return this._align;
        },
        set: function (a) {
          a === this._align || ("left" !== a && "center" !== a && "right" !== a) || ((this._align = a), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "tint", {
        get: function () {
          return this._tint;
        },
        set: function (a) {
          a !== this._tint && ((this._tint = a), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "font", {
        get: function () {
          return this._font;
        },
        set: function (a) {
          a !== this._font && ((this._font = a.trim()), (this._data = this.game.cache.getBitmapFont(this._font)), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "fontSize", {
        get: function () {
          return this._fontSize;
        },
        set: function (a) {
          (a = parseInt(a, 10)), a !== this._fontSize && a > 0 && ((this._fontSize = a), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "text", {
        get: function () {
          return this._text;
        },
        set: function (a) {
          a !== this._text && ((this._text = a.toString() || ""), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "maxWidth", {
        get: function () {
          return this._maxWidth;
        },
        set: function (a) {
          a !== this._maxWidth && ((this._maxWidth = a), this.updateText());
        },
      }),
      Object.defineProperty(c.BitmapText.prototype, "smoothed", {
        get: function () {
          return !this._data.base.scaleMode;
        },
        set: function (a) {
          a ? (this._data.base.scaleMode = 0) : (this._data.base.scaleMode = 1);
        },
      }),
      (c.RetroFont = function (a, b, d, e, f, g, h, i, j, k) {
        if (!a.cache.checkImageKey(b)) return !1;
        (void 0 !== g && null !== g) || (g = a.cache.getImage(b).width / d),
          (this.characterWidth = d),
          (this.characterHeight = e),
          (this.characterSpacingX = h || 0),
          (this.characterSpacingY = i || 0),
          (this.characterPerRow = g),
          (this.offsetX = j || 0),
          (this.offsetY = k || 0),
          (this.align = "left"),
          (this.multiLine = !1),
          (this.autoUpperCase = !0),
          (this.customSpacingX = 0),
          (this.customSpacingY = 0),
          (this.fixedWidth = 0),
          (this.fontSet = a.cache.getImage(b)),
          (this._text = ""),
          (this.grabData = []),
          (this.frameData = new c.FrameData());
        for (var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++) {
          var p = this.frameData.addFrame(new c.Frame(o, l, m, this.characterWidth, this.characterHeight));
          (this.grabData[f.charCodeAt(o)] = p.index), n++, n === this.characterPerRow ? ((n = 0), (l = this.offsetX), (m += this.characterHeight + this.characterSpacingY)) : (l += this.characterWidth + this.characterSpacingX);
        }
        a.cache.updateFrameData(b, this.frameData), (this.stamp = new c.Image(a, 0, 0, b, 0)), c.RenderTexture.call(this, a, 100, 100, "", c.scaleModes.NEAREST), (this.type = c.RETROFONT);
      }),
      (c.RetroFont.prototype = Object.create(c.RenderTexture.prototype)),
      (c.RetroFont.prototype.constructor = c.RetroFont),
      (c.RetroFont.ALIGN_LEFT = "left"),
      (c.RetroFont.ALIGN_RIGHT = "right"),
      (c.RetroFont.ALIGN_CENTER = "center"),
      (c.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"),
      (c.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
      (c.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 "),
      (c.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789"),
      (c.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789"),
      (c.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' "),
      (c.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39"),
      (c.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
      (c.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!"),
      (c.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
      (c.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789"),
      (c.RetroFont.prototype.setFixedWidth = function (a, b) {
        void 0 === b && (b = "left"), (this.fixedWidth = a), (this.align = b);
      }),
      (c.RetroFont.prototype.setText = function (a, b, c, d, e, f) {
        (this.multiLine = b || !1), (this.customSpacingX = c || 0), (this.customSpacingY = d || 0), (this.align = e || "left"), f ? (this.autoUpperCase = !1) : (this.autoUpperCase = !0), a.length > 0 && (this.text = a);
      }),
      (c.RetroFont.prototype.buildRetroFontText = function () {
        var a = 0,
          b = 0;
        if ((this.clear(), this.multiLine)) {
          var d = this._text.split("\n");
          this.fixedWidth > 0
            ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0)
            : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
          for (var e = 0; e < d.length; e++)
            (a = 0),
              this.align === c.RetroFont.ALIGN_RIGHT
                ? (a = this.width - d[e].length * (this.characterWidth + this.customSpacingX))
                : this.align === c.RetroFont.ALIGN_CENTER && ((a = this.width / 2 - (d[e].length * (this.characterWidth + this.customSpacingX)) / 2), (a += this.customSpacingX / 2)),
              a < 0 && (a = 0),
              this.pasteLine(d[e], a, b, this.customSpacingX),
              (b += this.characterHeight + this.customSpacingY);
        } else
          this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0),
            (a = 0),
            this.align === c.RetroFont.ALIGN_RIGHT
              ? (a = this.width - this._text.length * (this.characterWidth + this.customSpacingX))
              : this.align === c.RetroFont.ALIGN_CENTER && ((a = this.width / 2 - (this._text.length * (this.characterWidth + this.customSpacingX)) / 2), (a += this.customSpacingX / 2)),
            a < 0 && (a = 0),
            this.pasteLine(this._text, a, 0, this.customSpacingX);
        this.requiresReTint = !0;
      }),
      (c.RetroFont.prototype.pasteLine = function (a, b, c, d) {
        for (var e = 0; e < a.length; e++)
          if (" " === a.charAt(e)) b += this.characterWidth + d;
          else if (this.grabData[a.charCodeAt(e)] >= 0 && ((this.stamp.frame = this.grabData[a.charCodeAt(e)]), this.renderXY(this.stamp, b, c, !1), (b += this.characterWidth + d), b > this.width)) break;
      }),
      (c.RetroFont.prototype.getLongestLine = function () {
        var a = 0;
        if (this._text.length > 0) for (var b = this._text.split("\n"), c = 0; c < b.length; c++) b[c].length > a && (a = b[c].length);
        return a;
      }),
      (c.RetroFont.prototype.removeUnsupportedCharacters = function (a) {
        for (var b = "", c = 0; c < this._text.length; c++) {
          var d = this._text[c],
            e = d.charCodeAt(0);
          (this.grabData[e] >= 0 || (!a && "\n" === d)) && (b = b.concat(d));
        }
        return b;
      }),
      (c.RetroFont.prototype.updateOffset = function (a, b) {
        if (this.offsetX !== a || this.offsetY !== b) {
          for (var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--; ) (e[f].x += c), (e[f].y += d);
          this.buildRetroFontText();
        }
      }),
      Object.defineProperty(c.RetroFont.prototype, "text", {
        get: function () {
          return this._text;
        },
        set: function (a) {
          var b;
          (b = this.autoUpperCase ? a.toUpperCase() : a), b !== this._text && ((this._text = b), this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText());
        },
      }),
      Object.defineProperty(c.RetroFont.prototype, "smoothed", {
        get: function () {
          return this.stamp.smoothed;
        },
        set: function (a) {
          (this.stamp.smoothed = a), this.buildRetroFontText();
        },
      }),
      (c.Rope = function (a, b, d, e, f, g) {
        (this.points = []),
          (this.points = g),
          (this._hasUpdateAnimation = !1),
          (this._updateAnimationCallback = null),
          (b = b || 0),
          (d = d || 0),
          (e = e || null),
          (f = f || null),
          (this.type = c.ROPE),
          PIXI.Rope.call(this, c.Cache.DEFAULT, this.points),
          c.Component.Core.init.call(this, a, b, d, e, f);
      }),
      (c.Rope.prototype = Object.create(PIXI.Rope.prototype)),
      (c.Rope.prototype.constructor = c.Rope),
      c.Component.Core.install.call(c.Rope.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Crop",
        "Delta",
        "Destroy",
        "FixedToCamera",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "ScaleMinMax",
        "Smoothed",
      ]),
      (c.Rope.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate),
      (c.Rope.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate),
      (c.Rope.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.Rope.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.Rope.prototype.preUpdate = function () {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
      }),
      (c.Rope.prototype.update = function () {
        this._hasUpdateAnimation && this.updateAnimation.call(this);
      }),
      (c.Rope.prototype.reset = function (a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), this;
      }),
      Object.defineProperty(c.Rope.prototype, "updateAnimation", {
        get: function () {
          return this._updateAnimation;
        },
        set: function (a) {
          a && "function" == typeof a ? ((this._hasUpdateAnimation = !0), (this._updateAnimation = a)) : ((this._hasUpdateAnimation = !1), (this._updateAnimation = null));
        },
      }),
      Object.defineProperty(c.Rope.prototype, "segments", {
        get: function () {
          for (var a, b, d, e, f, g, h, i, j = [], k = 0; k < this.points.length; k++)
            (a = 4 * k),
              (b = this.vertices[a] * this.scale.x),
              (d = this.vertices[a + 1] * this.scale.y),
              (e = this.vertices[a + 4] * this.scale.x),
              (f = this.vertices[a + 3] * this.scale.y),
              (g = c.Math.difference(b, e)),
              (h = c.Math.difference(d, f)),
              (b += this.world.x),
              (d += this.world.y),
              (i = new c.Rectangle(b, d, g, h)),
              j.push(i);
          return j;
        },
      }),
      (c.TileSprite = function (a, b, d, e, f, g, h) {
        (b = b || 0), (d = d || 0), (e = e || 256), (f = f || 256), (g = g || null), (h = h || null), (this.type = c.TILESPRITE), (this.physicsType = c.SPRITE), (this._scroll = new c.Point());
        var i = a.cache.getImage("__default", !0);
        PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f), c.Component.Core.init.call(this, a, b, d, g, h);
      }),
      (c.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype)),
      (c.TileSprite.prototype.constructor = c.TileSprite),
      c.Component.Core.install.call(c.TileSprite.prototype, [
        "Angle",
        "Animation",
        "AutoCull",
        "Bounds",
        "BringToTop",
        "Destroy",
        "FixedToCamera",
        "Health",
        "InCamera",
        "InputEnabled",
        "InWorld",
        "LifeSpan",
        "LoadTexture",
        "Overlap",
        "PhysicsBody",
        "Reset",
        "Smoothed",
      ]),
      (c.TileSprite.prototype.preUpdatePhysics = c.Component.PhysicsBody.preUpdate),
      (c.TileSprite.prototype.preUpdateLifeSpan = c.Component.LifeSpan.preUpdate),
      (c.TileSprite.prototype.preUpdateInWorld = c.Component.InWorld.preUpdate),
      (c.TileSprite.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.TileSprite.prototype.preUpdate = function () {
        return (
          0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed),
          0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed),
          !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        );
      }),
      (c.TileSprite.prototype.autoScroll = function (a, b) {
        this._scroll.set(a, b);
      }),
      (c.TileSprite.prototype.stopScroll = function () {
        this._scroll.set(0, 0);
      }),
      (c.TileSprite.prototype.destroy = function (a) {
        c.Component.Destroy.prototype.destroy.call(this, a), PIXI.TilingSprite.prototype.destroy.call(this);
      }),
      (c.TileSprite.prototype.reset = function (a, b) {
        return c.Component.Reset.prototype.reset.call(this, a, b), (this.tilePosition.x = 0), (this.tilePosition.y = 0), this;
      }),
      (c.Device = function () {
        (this.deviceReadyAt = 0),
          (this.initialized = !1),
          (this.desktop = !1),
          (this.iOS = !1),
          (this.iOSVersion = 0),
          (this.cocoonJS = !1),
          (this.cocoonJSApp = !1),
          (this.cordova = !1),
          (this.node = !1),
          (this.nodeWebkit = !1),
          (this.electron = !1),
          (this.ejecta = !1),
          (this.crosswalk = !1),
          (this.android = !1),
          (this.chromeOS = !1),
          (this.linux = !1),
          (this.macOS = !1),
          (this.windows = !1),
          (this.windowsPhone = !1),
          (this.canvas = !1),
          (this.canvasBitBltShift = null),
          (this.webGL = !1),
          (this.file = !1),
          (this.fileSystem = !1),
          (this.localStorage = !1),
          (this.worker = !1),
          (this.css3D = !1),
          (this.pointerLock = !1),
          (this.typedArray = !1),
          (this.vibration = !1),
          (this.getUserMedia = !0),
          (this.quirksMode = !1),
          (this.touch = !1),
          (this.mspointer = !1),
          (this.wheelEvent = null),
          (this.arora = !1),
          (this.chrome = !1),
          (this.chromeVersion = 0),
          (this.epiphany = !1),
          (this.firefox = !1),
          (this.firefoxVersion = 0),
          (this.ie = !1),
          (this.ieVersion = 0),
          (this.trident = !1),
          (this.tridentVersion = 0),
          (this.edge = !1),
          (this.mobileSafari = !1),
          (this.midori = !1),
          (this.opera = !1),
          (this.safari = !1),
          (this.safariVersion = 0),
          (this.webApp = !1),
          (this.silk = !1),
          (this.audioData = !1),
          (this.webAudio = !1),
          (this.ogg = !1),
          (this.opus = !1),
          (this.mp3 = !1),
          (this.wav = !1),
          (this.m4a = !1),
          (this.webm = !1),
          (this.dolby = !1),
          (this.oggVideo = !1),
          (this.h264Video = !1),
          (this.mp4Video = !1),
          (this.webmVideo = !1),
          (this.vp9Video = !1),
          (this.hlsVideo = !1),
          (this.iPhone = !1),
          (this.iPhone4 = !1),
          (this.iPad = !1),
          (this.pixelRatio = 0),
          (this.littleEndian = !1),
          (this.LITTLE_ENDIAN = !1),
          (this.support32bit = !1),
          (this.fullscreen = !1),
          (this.requestFullscreen = ""),
          (this.cancelFullscreen = ""),
          (this.fullscreenKeyboard = !1);
      }),
      (c.Device = new c.Device()),
      (c.Device.onInitialized = new c.Signal()),
      (c.Device.whenReady = function (a, b, c) {
        var d = this._readyCheck;
        if (this.deviceReadyAt || !d) a.call(b, this);
        else if (d._monitor || c) (d._queue = d._queue || []), d._queue.push([a, b]);
        else {
          (d._monitor = d.bind(this)), (d._queue = d._queue || []), d._queue.push([a, b]);
          var e = "undefined" != typeof window.cordova,
            f = navigator.isCocoonJS;
          "complete" === document.readyState || "interactive" === document.readyState
            ? window.setTimeout(d._monitor, 0)
            : e && !f
            ? document.addEventListener("deviceready", d._monitor, !1)
            : (document.addEventListener("DOMContentLoaded", d._monitor, !1), window.addEventListener("load", d._monitor, !1));
        }
      }),
      (c.Device._readyCheck = function () {
        var a = this._readyCheck;
        if (document.body) {
          if (!this.deviceReadyAt) {
            (this.deviceReadyAt = Date.now()),
              document.removeEventListener("deviceready", a._monitor),
              document.removeEventListener("DOMContentLoaded", a._monitor),
              window.removeEventListener("load", a._monitor),
              this._initialize(),
              (this.initialized = !0),
              this.onInitialized.dispatch(this);
            for (var b; (b = a._queue.shift()); ) {
              var c = b[0],
                d = b[1];
              c.call(d, this);
            }
            (this._readyCheck = null), (this._initialize = null), (this.onInitialized = null);
          }
        } else window.setTimeout(a._monitor, 20);
      }),
      (c.Device._initialize = function () {
        function a() {
          var a = navigator.userAgent;
          /Playstation Vita/.test(a)
            ? (l.vita = !0)
            : /Kindle/.test(a) || /\bKF[A-Z][A-Z]+/.test(a) || /Silk.*Mobile Safari/.test(a)
            ? (l.kindle = !0)
            : /Android/.test(a)
            ? (l.android = !0)
            : /CrOS/.test(a)
            ? (l.chromeOS = !0)
            : /iP[ao]d|iPhone/i.test(a)
            ? ((l.iOS = !0), navigator.appVersion.match(/OS (\d+)/), (l.iOSVersion = parseInt(RegExp.$1, 10)))
            : /Linux/.test(a)
            ? (l.linux = !0)
            : /Mac OS/.test(a)
            ? (l.macOS = !0)
            : /Windows/.test(a) && (l.windows = !0),
            (/Windows Phone/i.test(a) || /IEMobile/i.test(a)) && ((l.android = !1), (l.iOS = !1), (l.macOS = !1), (l.windows = !0), (l.windowsPhone = !0));
          var b = /Silk/.test(a);
          (l.windows || l.macOS || (l.linux && !b) || l.chromeOS) && (l.desktop = !0), (l.windowsPhone || (/Windows NT/i.test(a) && /Touch/i.test(a))) && (l.desktop = !1);
        }
        function b() {
          l.canvas = !!window.CanvasRenderingContext2D || l.cocoonJS;
          try {
            l.localStorage = !!localStorage.getItem;
          } catch (a) {
            l.localStorage = !1;
          }
          (l.file = !!(window.File && window.FileReader && window.FileList && window.Blob)),
            (l.fileSystem = !!window.requestFileSystem),
            (l.webGL = (function () {
              try {
                var a = document.createElement("canvas");
                return (a.screencanvas = !1), !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
              } catch (a) {
                return !1;
              }
            })()),
            (l.webGL = !!l.webGL),
            (l.worker = !!window.Worker),
            (l.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document),
            (l.quirksMode = "CSS1Compat" !== document.compatMode),
            (navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia),
            (window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL),
            (l.getUserMedia = l.getUserMedia && !!navigator.getUserMedia && !!window.URL),
            l.firefox && l.firefoxVersion < 21 && (l.getUserMedia = !1),
            !l.iOS && (l.ie || l.firefox || l.chrome) && (l.canvasBitBltShift = !0),
            (l.safari || l.mobileSafari) && (l.canvasBitBltShift = !1);
        }
        function c() {
          ("ontouchstart" in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1)) && (l.touch = !0),
            (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (l.mspointer = !0),
            l.cocoonJS ||
              ("onwheel" in window || (l.ie && "WheelEvent" in window) ? (l.wheelEvent = "wheel") : "onmousewheel" in window ? (l.wheelEvent = "mousewheel") : l.firefox && "MouseScrollEvent" in window && (l.wheelEvent = "DOMMouseScroll"));
        }
        function d() {
          for (
            var a = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"],
              b = document.createElement("div"),
              c = 0;
            c < a.length;
            c++
          )
            if (b[a[c]]) {
              (l.fullscreen = !0), (l.requestFullscreen = a[c]);
              break;
            }
          var d = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
          if (l.fullscreen)
            for (var c = 0; c < d.length; c++)
              if (document[d[c]]) {
                l.cancelFullscreen = d[c];
                break;
              }
          window.Element && Element.ALLOW_KEYBOARD_INPUT && (l.fullscreenKeyboard = !0);
        }
        function e() {
          var a = navigator.userAgent;
          if (
            (/Arora/.test(a)
              ? (l.arora = !0)
              : /Edge\/\d+/.test(a)
              ? (l.edge = !0)
              : /Chrome\/(\d+)/.test(a) && !l.windowsPhone
              ? ((l.chrome = !0), (l.chromeVersion = parseInt(RegExp.$1, 10)))
              : /Epiphany/.test(a)
              ? (l.epiphany = !0)
              : /Firefox\D+(\d+)/.test(a)
              ? ((l.firefox = !0), (l.firefoxVersion = parseInt(RegExp.$1, 10)))
              : /AppleWebKit/.test(a) && l.iOS
              ? (l.mobileSafari = !0)
              : /MSIE (\d+\.\d+);/.test(a)
              ? ((l.ie = !0), (l.ieVersion = parseInt(RegExp.$1, 10)))
              : /Midori/.test(a)
              ? (l.midori = !0)
              : /Opera/.test(a)
              ? (l.opera = !0)
              : /Safari\/(\d+)/.test(a) && !l.windowsPhone
              ? ((l.safari = !0), /Version\/(\d+)\./.test(a) && (l.safariVersion = parseInt(RegExp.$1, 10)))
              : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(a) && ((l.ie = !0), (l.trident = !0), (l.tridentVersion = parseInt(RegExp.$1, 10)), (l.ieVersion = parseInt(RegExp.$3, 10))),
            /Silk/.test(a) && (l.silk = !0),
            navigator.standalone && (l.webApp = !0),
            "undefined" != typeof window.cordova && (l.cordova = !0),
            "undefined" != typeof process && "undefined" != typeof require && (l.node = !0),
            l.node && "object" == typeof process.versions && ((l.nodeWebkit = !!process.versions["node-webkit"]), (l.electron = !!process.versions.electron)),
            navigator.isCocoonJS && (l.cocoonJS = !0),
            l.cocoonJS)
          )
            try {
              l.cocoonJSApp = "undefined" != typeof CocoonJS;
            } catch (a) {
              l.cocoonJSApp = !1;
            }
          "undefined" != typeof window.ejecta && (l.ejecta = !0), /Crosswalk/.test(a) && (l.crosswalk = !0);
        }
        function f() {
          var a = document.createElement("video"),
            b = !1;
          try {
            (b = !!a.canPlayType) &&
              (a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (l.oggVideo = !0),
              a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && ((l.h264Video = !0), (l.mp4Video = !0)),
              a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (l.webmVideo = !0),
              a.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (l.vp9Video = !0),
              a.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (l.hlsVideo = !0));
          } catch (a) {}
        }
        function g() {
          (l.audioData = !!window.Audio), (l.webAudio = !(!window.AudioContext && !window.webkitAudioContext));
          var a = document.createElement("audio"),
            b = !1;
          try {
            if (
              (b = !!a.canPlayType) &&
              (a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (l.ogg = !0),
              (a.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || a.canPlayType("audio/opus;").replace(/^no$/, "")) && (l.opus = !0),
              a.canPlayType("audio/mpeg;").replace(/^no$/, "") && (l.mp3 = !0),
              a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (l.wav = !0),
              (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;").replace(/^no$/, "")) && (l.m4a = !0),
              a.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (l.webm = !0),
              "" !== a.canPlayType('audio/mp4;codecs="ec-3"'))
            )
              if (l.edge) l.dolby = !0;
              else if (l.safari && l.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                var c = parseInt(RegExp.$1, 10),
                  d = parseInt(RegExp.$2, 10);
                ((10 === c && d >= 11) || c > 10) && (l.dolby = !0);
              }
          } catch (a) {}
        }
        function h() {
          var a = new ArrayBuffer(4),
            b = new Uint8Array(a),
            c = new Uint32Array(a);
          return (b[0] = 161), (b[1] = 178), (b[2] = 195), (b[3] = 212), 3569595041 === c[0] || (2712847316 !== c[0] && null);
        }
        function i() {
          if (void 0 === Uint8ClampedArray) return !1;
          var a = PIXI.CanvasPool.create(this, 1, 1),
            b = a.getContext("2d");
          if (!b) return !1;
          var c = b.createImageData(1, 1);
          return PIXI.CanvasPool.remove(this), c.data instanceof Uint8ClampedArray;
        }
        function j() {
          (l.pixelRatio = window.devicePixelRatio || 1),
            (l.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") !== -1),
            (l.iPhone4 = 2 === l.pixelRatio && l.iPhone),
            (l.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") !== -1),
            "undefined" != typeof Int8Array ? (l.typedArray = !0) : (l.typedArray = !1),
            "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && ((l.littleEndian = h()), (l.LITTLE_ENDIAN = l.littleEndian)),
            (l.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== l.littleEndian && i()),
            (navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate),
            navigator.vibrate && (l.vibration = !0);
        }
        function k() {
          var a,
            b = document.createElement("p"),
            c = { webkitTransform: "-webkit-transform", OTransform: "-o-transform", msTransform: "-ms-transform", MozTransform: "-moz-transform", transform: "transform" };
          document.body.insertBefore(b, null);
          for (var d in c) void 0 !== b.style[d] && ((b.style[d] = "translate3d(1px,1px,1px)"), (a = window.getComputedStyle(b).getPropertyValue(c[d])));
          document.body.removeChild(b), (l.css3D = void 0 !== a && a.length > 0 && "none" !== a);
        }
        var l = this;
        a(), e(), g(), f(), k(), j(), b(), d(), c();
      }),
      (c.Device.canPlayAudio = function (a) {
        return !!(("mp3" === a && this.mp3) || ("ogg" === a && (this.ogg || this.opus)) || ("m4a" === a && this.m4a) || ("opus" === a && this.opus) || ("wav" === a && this.wav) || ("webm" === a && this.webm) || ("mp4" === a && this.dolby));
      }),
      (c.Device.canPlayVideo = function (a) {
        return !!(("webm" === a && (this.webmVideo || this.vp9Video)) || ("mp4" === a && (this.mp4Video || this.h264Video)) || (("ogg" === a || "ogv" === a) && this.oggVideo) || ("mpeg" === a && this.hlsVideo));
      }),
      (c.Device.isConsoleOpen = function () {
        return !(!window.console || !window.console.firebug) || (!(!window.console || (console.clear && void 0, !console.profiles)) && console.profiles.length > 0);
      }),
      (c.Device.isAndroidStockBrowser = function () {
        var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return a && a[1] < 537;
      }),
      (c.Canvas = {
        create: function (a, b, c, d, e) {
          (b = b || 256), (c = c || 256);
          var f = e ? document.createElement("canvas") : PIXI.CanvasPool.create(a, b, c);
          return "string" == typeof d && "" !== d && (f.id = d), (f.width = b), (f.height = c), (f.style.display = "block"), f;
        },
        setBackgroundColor: function (a, b) {
          return (b = b || "rgb(0,0,0)"), (a.style.backgroundColor = b), a;
        },
        setTouchAction: function (a, b) {
          return (b = b || "none"), (a.style.msTouchAction = b), (a.style["ms-touch-action"] = b), (a.style["touch-action"] = b), a;
        },
        setUserSelect: function (a, b) {
          return (
            (b = b || "none"),
            (a.style["-webkit-touch-callout"] = b),
            (a.style["-webkit-user-select"] = b),
            (a.style["-khtml-user-select"] = b),
            (a.style["-moz-user-select"] = b),
            (a.style["-ms-user-select"] = b),
            (a.style["user-select"] = b),
            (a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)"),
            a
          );
        },
        addToDOM: function (a, b, c) {
          var d;
          return (
            void 0 === c && (c = !0),
            b && ("string" == typeof b ? (d = document.getElementById(b)) : "object" == typeof b && 1 === b.nodeType && (d = b)),
            d || (d = document.body),
            c && d.style && (d.style.overflow = "hidden"),
            d.appendChild(a),
            a
          );
        },
        removeFromDOM: function (a) {
          a.parentNode && a.parentNode.removeChild(a);
        },
        setTransform: function (a, b, c, d, e, f, g) {
          return a.setTransform(d, f, g, e, b, c), a;
        },
        setSmoothingEnabled: function (a, b) {
          var d = c.Canvas.getSmoothingPrefix(a);
          return d && (a[d] = b), a;
        },
        getSmoothingPrefix: function (a) {
          var b = ["i", "webkitI", "msI", "mozI", "oI"];
          for (var c in b) {
            var d = b[c] + "mageSmoothingEnabled";
            if (d in a) return d;
          }
          return null;
        },
        getSmoothingEnabled: function (a) {
          var b = c.Canvas.getSmoothingPrefix(a);
          if (b) return a[b];
        },
        setImageRenderingCrisp: function (a) {
          for (var b = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], c = 0; c < b.length; c++) a.style["image-rendering"] = b[c];
          return (a.style.msInterpolationMode = "nearest-neighbor"), a;
        },
        setImageRenderingBicubic: function (a) {
          return (a.style["image-rendering"] = "auto"), (a.style.msInterpolationMode = "bicubic"), a;
        },
      }),
      (c.RequestAnimationFrame = function (a, b) {
        void 0 === b && (b = !1), (this.game = a), (this.isRunning = !1), (this.forceSetTimeOut = b);
        for (var c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !window.requestAnimationFrame; d++)
          (window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"]), (window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"]);
        (this._isSetTimeOut = !1), (this._onLoop = null), (this._timeOutID = null);
      }),
      (c.RequestAnimationFrame.prototype = {
        start: function () {
          this.isRunning = !0;
          var a = this;
          !window.requestAnimationFrame || this.forceSetTimeOut
            ? ((this._isSetTimeOut = !0),
              (this._onLoop = function () {
                return a.updateSetTimeout();
              }),
              (this._timeOutID = window.setTimeout(this._onLoop, 0)))
            : ((this._isSetTimeOut = !1),
              (this._onLoop = function (b) {
                return a.updateRAF(b);
              }),
              (this._timeOutID = window.requestAnimationFrame(this._onLoop)));
        },
        updateRAF: function (a) {
          this.isRunning && (this.game.update(Math.floor(a)), (this._timeOutID = window.requestAnimationFrame(this._onLoop)));
        },
        updateSetTimeout: function () {
          this.isRunning && (this.game.update(Date.now()), (this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)));
        },
        stop: function () {
          this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), (this.isRunning = !1);
        },
        isSetTimeOut: function () {
          return this._isSetTimeOut;
        },
        isRAF: function () {
          return this._isSetTimeOut === !1;
        },
      }),
      (c.RequestAnimationFrame.prototype.constructor = c.RequestAnimationFrame),
      (c.Math = {
        PI2: 2 * Math.PI,
        between: function (a, b) {
          return Math.floor(Math.random() * (b - a + 1) + a);
        },
        fuzzyEqual: function (a, b, c) {
          return void 0 === c && (c = 1e-4), Math.abs(a - b) < c;
        },
        fuzzyLessThan: function (a, b, c) {
          return void 0 === c && (c = 1e-4), a < b + c;
        },
        fuzzyGreaterThan: function (a, b, c) {
          return void 0 === c && (c = 1e-4), a > b - c;
        },
        fuzzyCeil: function (a, b) {
          return void 0 === b && (b = 1e-4), Math.ceil(a - b);
        },
        fuzzyFloor: function (a, b) {
          return void 0 === b && (b = 1e-4), Math.floor(a + b);
        },
        average: function () {
          for (var a = 0, b = arguments.length, c = 0; c < b; c++) a += +arguments[c];
          return a / b;
        },
        shear: function (a) {
          return a % 1;
        },
        snapTo: function (a, b, c) {
          return void 0 === c && (c = 0), 0 === b ? a : ((a -= c), (a = b * Math.round(a / b)), c + a);
        },
        snapToFloor: function (a, b, c) {
          return void 0 === c && (c = 0), 0 === b ? a : ((a -= c), (a = b * Math.floor(a / b)), c + a);
        },
        snapToCeil: function (a, b, c) {
          return void 0 === c && (c = 0), 0 === b ? a : ((a -= c), (a = b * Math.ceil(a / b)), c + a);
        },
        roundTo: function (a, b, c) {
          void 0 === b && (b = 0), void 0 === c && (c = 10);
          var d = Math.pow(c, -b);
          return Math.round(a * d) / d;
        },
        floorTo: function (a, b, c) {
          void 0 === b && (b = 0), void 0 === c && (c = 10);
          var d = Math.pow(c, -b);
          return Math.floor(a * d) / d;
        },
        ceilTo: function (a, b, c) {
          void 0 === b && (b = 0), void 0 === c && (c = 10);
          var d = Math.pow(c, -b);
          return Math.ceil(a * d) / d;
        },
        rotateToAngle: function (a, b, d) {
          return (
            void 0 === d && (d = 0.05),
            a === b ? a : (Math.abs(b - a) <= d || Math.abs(b - a) >= c.Math.PI2 - d ? (a = b) : (Math.abs(b - a) > Math.PI && (b < a ? (b += c.Math.PI2) : (b -= c.Math.PI2)), b > a ? (a += d) : b < a && (a -= d)), a)
          );
        },
        getShortestAngle: function (a, b) {
          var c = b - a;
          if (0 === c) return 0;
          var d = Math.floor((c - -180) / 360);
          return c - 360 * d;
        },
        angleBetween: function (a, b, c, d) {
          return Math.atan2(d - b, c - a);
        },
        angleBetweenY: function (a, b, c, d) {
          return Math.atan2(c - a, d - b);
        },
        angleBetweenPoints: function (a, b) {
          return Math.atan2(b.y - a.y, b.x - a.x);
        },
        angleBetweenPointsY: function (a, b) {
          return Math.atan2(b.x - a.x, b.y - a.y);
        },
        reverseAngle: function (a) {
          return this.normalizeAngle(a + Math.PI, !0);
        },
        normalizeAngle: function (a) {
          return (a %= 2 * Math.PI), a >= 0 ? a : a + 2 * Math.PI;
        },
        maxAdd: function (a, b, c) {
          return Math.min(a + b, c);
        },
        minSub: function (a, b, c) {
          return Math.max(a - b, c);
        },
        wrap: function (a, b, c) {
          var d = c - b;
          if (d <= 0) return 0;
          var e = (a - b) % d;
          return e < 0 && (e += d), e + b;
        },
        wrapValue: function (a, b, c) {
          var d;
          return (a = Math.abs(a)), (b = Math.abs(b)), (c = Math.abs(c)), (d = (a + b) % c);
        },
        isOdd: function (a) {
          return !!(1 & a);
        },
        isEven: function (a) {
          return !(1 & a);
        },
        min: function () {
          if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
          else var a = arguments;
          for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] < a[c] && (c = b);
          return a[c];
        },
        max: function () {
          if (1 === arguments.length && "object" == typeof arguments[0]) var a = arguments[0];
          else var a = arguments;
          for (var b = 1, c = 0, d = a.length; b < d; b++) a[b] > a[c] && (c = b);
          return a[c];
        },
        minProperty: function (a) {
          if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
          else var b = arguments.slice(1);
          for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] < b[d][a] && (d = c);
          return b[d][a];
        },
        maxProperty: function (a) {
          if (2 === arguments.length && "object" == typeof arguments[1]) var b = arguments[1];
          else var b = arguments.slice(1);
          for (var c = 1, d = 0, e = b.length; c < e; c++) b[c][a] > b[d][a] && (d = c);
          return b[d][a];
        },
        wrapAngle: function (a, b) {
          return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180);
        },
        linearInterpolation: function (a, b) {
          var c = a.length - 1,
            d = c * b,
            e = Math.floor(d);
          return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e);
        },
        bezierInterpolation: function (a, b) {
          for (var c = 0, d = a.length - 1, e = 0; e <= d; e++) c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
          return c;
        },
        catmullRomInterpolation: function (a, b) {
          var c = a.length - 1,
            d = c * b,
            e = Math.floor(d);
          return a[0] === a[c]
            ? (b < 0 && (e = Math.floor((d = c * (1 + b)))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e))
            : b < 0
            ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0])
            : b > 1
            ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c])
            : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e);
        },
        linear: function (a, b, c) {
          return (b - a) * c + a;
        },
        bernstein: function (a, b) {
          return this.factorial(a) / this.factorial(b) / this.factorial(a - b);
        },
        factorial: function (a) {
          if (0 === a) return 1;
          for (var b = a; --a; ) b *= a;
          return b;
        },
        catmullRom: function (a, b, c, d, e) {
          var f = 0.5 * (c - a),
            g = 0.5 * (d - b),
            h = e * e,
            i = e * h;
          return (2 * b - 2 * c + f + g) * i + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b;
        },
        difference: function (a, b) {
          return Math.abs(a - b);
        },
        roundAwayFromZero: function (a) {
          return a > 0 ? Math.ceil(a) : Math.floor(a);
        },
        sinCosGenerator: function (a, b, c, d) {
          void 0 === b && (b = 1), void 0 === c && (c = 1), void 0 === d && (d = 1);
          for (var e = b, f = c, g = (d * Math.PI) / a, h = [], i = [], j = 0; j < a; j++) (f -= e * g), (e += f * g), (h[j] = f), (i[j] = e);
          return { sin: i, cos: h, length: a };
        },
        distance: function (a, b, c, d) {
          var e = a - c,
            f = b - d;
          return Math.sqrt(e * e + f * f);
        },
        distanceSq: function (a, b, c, d) {
          var e = a - c,
            f = b - d;
          return e * e + f * f;
        },
        distancePow: function (a, b, c, d, e) {
          return void 0 === e && (e = 2), Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e));
        },
        clamp: function (a, b, c) {
          return a < b ? b : c < a ? c : a;
        },
        clampBottom: function (a, b) {
          return a < b ? b : a;
        },
        within: function (a, b, c) {
          return Math.abs(a - b) <= c;
        },
        mapLinear: function (a, b, c, d, e) {
          return d + ((a - b) * (e - d)) / (c - b);
        },
        smoothstep: function (a, b, c) {
          return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))), a * a * (3 - 2 * a);
        },
        smootherstep: function (a, b, c) {
          return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))), a * a * a * (a * (6 * a - 15) + 10);
        },
        sign: function (a) {
          return a < 0 ? -1 : a > 0 ? 1 : 0;
        },
        percent: function (a, b, c) {
          return void 0 === c && (c = 0), a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b;
        },
      });
    var k = Math.PI / 180,
      l = 180 / Math.PI;
    return (
      (c.Math.degToRad = function (a) {
        return a * k;
      }),
      (c.Math.radToDeg = function (a) {
        return a * l;
      }),
      (c.RandomDataGenerator = function (a) {
        void 0 === a && (a = []), (this.c = 1), (this.s0 = 0), (this.s1 = 0), (this.s2 = 0), "string" == typeof a ? this.state(a) : this.sow(a);
      }),
      (c.RandomDataGenerator.prototype = {
        rnd: function () {
          var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
          return (this.c = 0 | a), (this.s0 = this.s1), (this.s1 = this.s2), (this.s2 = a - this.c), this.s2;
        },
        sow: function (a) {
          if (((this.s0 = this.hash(" ")), (this.s1 = this.hash(this.s0)), (this.s2 = this.hash(this.s1)), (this.c = 1), a))
            for (var b = 0; b < a.length && null != a[b]; b++) {
              var c = a[b];
              (this.s0 -= this.hash(c)), (this.s0 += ~~(this.s0 < 0)), (this.s1 -= this.hash(c)), (this.s1 += ~~(this.s1 < 0)), (this.s2 -= this.hash(c)), (this.s2 += ~~(this.s2 < 0));
            }
        },
        hash: function (a) {
          var b, c, d;
          for (d = 4022871197, a = a.toString(), c = 0; c < a.length; c++) (d += a.charCodeAt(c)), (b = 0.02519603282416938 * d), (d = b >>> 0), (b -= d), (b *= d), (d = b >>> 0), (b -= d), (d += 4294967296 * b);
          return 2.3283064365386963e-10 * (d >>> 0);
        },
        integer: function () {
          return 4294967296 * this.rnd.apply(this);
        },
        frac: function () {
          return this.rnd.apply(this) + 1.1102230246251565e-16 * ((2097152 * this.rnd.apply(this)) | 0);
        },
        real: function () {
          return this.integer() + this.frac();
        },
        integerInRange: function (a, b) {
          return Math.floor(this.realInRange(0, b - a + 1) + a);
        },
        between: function (a, b) {
          return this.integerInRange(a, b);
        },
        realInRange: function (a, b) {
          return this.frac() * (b - a) + a;
        },
        normal: function () {
          return 1 - 2 * this.frac();
        },
        uuid: function () {
          var a = "",
            b = "";
          for (b = a = ""; a++ < 36; b += ~a % 5 | ((3 * a) & 4) ? (15 ^ a ? 8 ^ (this.frac() * (20 ^ a ? 16 : 4)) : 4).toString(16) : "-");
          return b;
        },
        pick: function (a) {
          return a[this.integerInRange(0, a.length - 1)];
        },
        sign: function () {
          return this.pick([-1, 1]);
        },
        weightedPick: function (a) {
          return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + 0.5)];
        },
        timestamp: function (a, b) {
          return this.realInRange(a || 9466848e5, b || 1577862e6);
        },
        angle: function () {
          return this.integerInRange(-180, 180);
        },
        state: function (a) {
          return (
            "string" == typeof a && a.match(/^!rnd/) && ((a = a.split(",")), (this.c = parseFloat(a[1])), (this.s0 = parseFloat(a[2])), (this.s1 = parseFloat(a[3])), (this.s2 = parseFloat(a[4]))),
            ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
          );
        },
      }),
      (c.RandomDataGenerator.prototype.constructor = c.RandomDataGenerator),
      (c.QuadTree = function (a, b, c, d, e, f, g) {
        (this.maxObjects = 10), (this.maxLevels = 4), (this.level = 0), (this.bounds = {}), (this.objects = []), (this.nodes = []), (this._empty = []), this.reset(a, b, c, d, e, f, g);
      }),
      (c.QuadTree.prototype = {
        reset: function (a, b, c, d, e, f, g) {
          (this.maxObjects = e || 10),
            (this.maxLevels = f || 4),
            (this.level = g || 0),
            (this.bounds = { x: Math.round(a), y: Math.round(b), width: c, height: d, subWidth: Math.floor(c / 2), subHeight: Math.floor(d / 2), right: Math.round(a) + Math.floor(c / 2), bottom: Math.round(b) + Math.floor(d / 2) }),
            (this.objects.length = 0),
            (this.nodes.length = 0);
        },
        populate: function (a) {
          a.forEach(this.populateHandler, this, !0);
        },
        populateHandler: function (a) {
          a.body && a.exists && this.insert(a.body);
        },
        split: function () {
          (this.nodes[0] = new c.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)),
            (this.nodes[1] = new c.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)),
            (this.nodes[2] = new c.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)),
            (this.nodes[3] = new c.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1));
        },
        insert: function (a) {
          var b,
            c = 0;
          if (null != this.nodes[0] && ((b = this.getIndex(a)), b !== -1)) return void this.nodes[b].insert(a);
          if ((this.objects.push(a), this.objects.length > this.maxObjects && this.level < this.maxLevels))
            for (null == this.nodes[0] && this.split(); c < this.objects.length; ) (b = this.getIndex(this.objects[c])), b !== -1 ? this.nodes[b].insert(this.objects.splice(c, 1)[0]) : c++;
        },
        getIndex: function (a) {
          var b = -1;
          return (
            a.x < this.bounds.right && a.right < this.bounds.right
              ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom
                ? (b = 1)
                : a.y > this.bounds.bottom && (b = 2)
              : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? (b = 0) : a.y > this.bounds.bottom && (b = 3)),
            b
          );
        },
        retrieve: function (a) {
          if (a instanceof c.Rectangle)
            var b = this.objects,
              d = this.getIndex(a);
          else {
            if (!a.body) return this._empty;
            var b = this.objects,
              d = this.getIndex(a.body);
          }
          return (
            this.nodes[0] &&
              (d !== -1
                ? (b = b.concat(this.nodes[d].retrieve(a)))
                : ((b = b.concat(this.nodes[0].retrieve(a))), (b = b.concat(this.nodes[1].retrieve(a))), (b = b.concat(this.nodes[2].retrieve(a))), (b = b.concat(this.nodes[3].retrieve(a))))),
            b
          );
        },
        clear: function () {
          this.objects.length = 0;
          for (var a = this.nodes.length; a--; ) this.nodes[a].clear(), this.nodes.splice(a, 1);
          this.nodes.length = 0;
        },
      }),
      (c.QuadTree.prototype.constructor = c.QuadTree),
      (c.Net = function (a) {
        this.game = a;
      }),
      (c.Net.prototype = {
        getHostName: function () {
          return window.location && window.location.hostname ? window.location.hostname : null;
        },
        checkDomainName: function (a) {
          return window.location.hostname.indexOf(a) !== -1;
        },
        updateQueryString: function (a, b, c, d) {
          void 0 === c && (c = !1), (void 0 !== d && "" !== d) || (d = window.location.href);
          var e = "",
            f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
          if (f.test(d)) e = "undefined" != typeof b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
          else if ("undefined" != typeof b && null !== b) {
            var g = d.indexOf("?") !== -1 ? "&" : "?",
              h = d.split("#");
            (d = h[0] + g + a + "=" + b), h[1] && (d += "#" + h[1]), (e = d);
          } else e = d;
          return c ? void (window.location.href = e) : e;
        },
        getQueryString: function (a) {
          void 0 === a && (a = "");
          var b = {},
            c = location.search.substring(1).split("&");
          for (var d in c) {
            var e = c[d].split("=");
            if (e.length > 1) {
              if (a && a === this.decodeURI(e[0])) return this.decodeURI(e[1]);
              b[this.decodeURI(e[0])] = this.decodeURI(e[1]);
            }
          }
          return b;
        },
        decodeURI: function (a) {
          return decodeURIComponent(a.replace(/\+/g, " "));
        },
      }),
      (c.Net.prototype.constructor = c.Net),
      (c.TweenManager = function (a) {
        (this.game = a),
          (this.frameBased = !1),
          (this._tweens = []),
          (this._add = []),
          (this.easeMap = {
            Power0: c.Easing.Power0,
            Power1: c.Easing.Power1,
            Power2: c.Easing.Power2,
            Power3: c.Easing.Power3,
            Power4: c.Easing.Power4,
            Linear: c.Easing.Linear.None,
            Quad: c.Easing.Quadratic.Out,
            Cubic: c.Easing.Cubic.Out,
            Quart: c.Easing.Quartic.Out,
            Quint: c.Easing.Quintic.Out,
            Sine: c.Easing.Sinusoidal.Out,
            Expo: c.Easing.Exponential.Out,
            Circ: c.Easing.Circular.Out,
            Elastic: c.Easing.Elastic.Out,
            Back: c.Easing.Back.Out,
            Bounce: c.Easing.Bounce.Out,
            "Quad.easeIn": c.Easing.Quadratic.In,
            "Cubic.easeIn": c.Easing.Cubic.In,
            "Quart.easeIn": c.Easing.Quartic.In,
            "Quint.easeIn": c.Easing.Quintic.In,
            "Sine.easeIn": c.Easing.Sinusoidal.In,
            "Expo.easeIn": c.Easing.Exponential.In,
            "Circ.easeIn": c.Easing.Circular.In,
            "Elastic.easeIn": c.Easing.Elastic.In,
            "Back.easeIn": c.Easing.Back.In,
            "Bounce.easeIn": c.Easing.Bounce.In,
            "Quad.easeOut": c.Easing.Quadratic.Out,
            "Cubic.easeOut": c.Easing.Cubic.Out,
            "Quart.easeOut": c.Easing.Quartic.Out,
            "Quint.easeOut": c.Easing.Quintic.Out,
            "Sine.easeOut": c.Easing.Sinusoidal.Out,
            "Expo.easeOut": c.Easing.Exponential.Out,
            "Circ.easeOut": c.Easing.Circular.Out,
            "Elastic.easeOut": c.Easing.Elastic.Out,
            "Back.easeOut": c.Easing.Back.Out,
            "Bounce.easeOut": c.Easing.Bounce.Out,
            "Quad.easeInOut": c.Easing.Quadratic.InOut,
            "Cubic.easeInOut": c.Easing.Cubic.InOut,
            "Quart.easeInOut": c.Easing.Quartic.InOut,
            "Quint.easeInOut": c.Easing.Quintic.InOut,
            "Sine.easeInOut": c.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": c.Easing.Exponential.InOut,
            "Circ.easeInOut": c.Easing.Circular.InOut,
            "Elastic.easeInOut": c.Easing.Elastic.InOut,
            "Back.easeInOut": c.Easing.Back.InOut,
            "Bounce.easeInOut": c.Easing.Bounce.InOut,
          }),
          this.game.onPause.add(this._pauseAll, this),
          this.game.onResume.add(this._resumeAll, this);
      }),
      (c.TweenManager.prototype = {
        getAll: function () {
          return this._tweens;
        },
        removeAll: function () {
          for (var a = 0; a < this._tweens.length; a++) this._tweens[a].pendingDelete = !0;
          this._add = [];
        },
        removeFrom: function (a, b) {
          void 0 === b && (b = !0);
          var d, e;
          if (Array.isArray(a)) for (d = 0, e = a.length; d < e; d++) this.removeFrom(a[d]);
          else if (a.type === c.GROUP && b) for (var d = 0, e = a.children.length; d < e; d++) this.removeFrom(a.children[d]);
          else {
            for (d = 0, e = this._tweens.length; d < e; d++) a === this._tweens[d].target && this.remove(this._tweens[d]);
            for (d = 0, e = this._add.length; d < e; d++) a === this._add[d].target && this.remove(this._add[d]);
          }
        },
        add: function (a) {
          (a._manager = this), this._add.push(a);
        },
        create: function (a) {
          return new c.Tween(a, this.game, this);
        },
        remove: function (a) {
          var b = this._tweens.indexOf(a);
          b !== -1 ? (this._tweens[b].pendingDelete = !0) : ((b = this._add.indexOf(a)), b !== -1 && (this._add[b].pendingDelete = !0));
        },
        update: function () {
          var a = this._add.length,
            b = this._tweens.length;
          if (0 === b && 0 === a) return !1;
          for (var c = 0; c < b; ) this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1), b--);
          return a > 0 && ((this._tweens = this._tweens.concat(this._add)), (this._add.length = 0)), !0;
        },
        isTweening: function (a) {
          return this._tweens.some(function (b) {
            return b.target === a;
          });
        },
        _pauseAll: function () {
          for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._pause();
        },
        _resumeAll: function () {
          for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a]._resume();
        },
        pauseAll: function () {
          for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].pause();
        },
        resumeAll: function () {
          for (var a = this._tweens.length - 1; a >= 0; a--) this._tweens[a].resume(!0);
        },
      }),
      (c.TweenManager.prototype.constructor = c.TweenManager),
      (c.Tween = function (a, b, d) {
        (this.game = b),
          (this.target = a),
          (this.manager = d),
          (this.timeline = []),
          (this.reverse = !1),
          (this.timeScale = 1),
          (this.repeatCounter = 0),
          (this.pendingDelete = !1),
          (this.onStart = new c.Signal()),
          (this.onLoop = new c.Signal()),
          (this.onRepeat = new c.Signal()),
          (this.onChildComplete = new c.Signal()),
          (this.onComplete = new c.Signal()),
          (this.isRunning = !1),
          (this.current = 0),
          (this.properties = {}),
          (this.chainedTween = null),
          (this.isPaused = !1),
          (this.frameBased = d.frameBased),
          (this._onUpdateCallback = null),
          (this._onUpdateCallbackContext = null),
          (this._pausedTime = 0),
          (this._codePaused = !1),
          (this._hasStarted = !1);
      }),
      (c.Tween.prototype = {
        to: function (a, b, d, e, f, g, h) {
          return (
            (void 0 === b || b <= 0) && (b = 1e3),
            (void 0 !== d && null !== d) || (d = c.Easing.Default),
            void 0 === e && (e = !1),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            void 0 === h && (h = !1),
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]),
            this.isRunning ? this : (this.timeline.push(new c.TweenData(this).to(a, b, d, f, g, h)), e && this.start(), this)
          );
        },
        from: function (a, b, d, e, f, g, h) {
          return (
            void 0 === b && (b = 1e3),
            (void 0 !== d && null !== d) || (d = c.Easing.Default),
            void 0 === e && (e = !1),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            void 0 === h && (h = !1),
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]),
            this.isRunning ? this : (this.timeline.push(new c.TweenData(this).from(a, b, d, f, g, h)), e && this.start(), this)
          );
        },
        start: function (a) {
          if ((void 0 === a && (a = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning)) return this;
          for (var b = 0; b < this.timeline.length; b++) for (var c in this.timeline[b].vEnd) (this.properties[c] = this.target[c] || 0), Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
          for (var b = 0; b < this.timeline.length; b++) this.timeline[b].loadValues();
          return this.manager.add(this), (this.isRunning = !0), (a < 0 || a > this.timeline.length - 1) && (a = 0), (this.current = a), this.timeline[this.current].start(), this;
        },
        stop: function (a) {
          return (
            void 0 === a && (a = !1),
            (this.isRunning = !1),
            (this._onUpdateCallback = null),
            (this._onUpdateCallbackContext = null),
            a && (this.onComplete.dispatch(this.target, this), (this._hasStarted = !1), this.chainedTween && this.chainedTween.start()),
            this.manager.remove(this),
            this
          );
        },
        updateTweenData: function (a, b, c) {
          if (0 === this.timeline.length) return this;
          if ((void 0 === c && (c = 0), c === -1)) for (var d = 0; d < this.timeline.length; d++) this.timeline[d][a] = b;
          else this.timeline[c][a] = b;
          return this;
        },
        delay: function (a, b) {
          return this.updateTweenData("delay", a, b);
        },
        repeat: function (a, b, c) {
          return void 0 === b && (b = 0), this.updateTweenData("repeatCounter", a, c), this.updateTweenData("repeatDelay", b, c);
        },
        repeatDelay: function (a, b) {
          return this.updateTweenData("repeatDelay", a, b);
        },
        yoyo: function (a, b, c) {
          return void 0 === b && (b = 0), this.updateTweenData("yoyo", a, c), this.updateTweenData("yoyoDelay", b, c);
        },
        yoyoDelay: function (a, b) {
          return this.updateTweenData("yoyoDelay", a, b);
        },
        easing: function (a, b) {
          return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]), this.updateTweenData("easingFunction", a, b);
        },
        interpolation: function (a, b, d) {
          return void 0 === b && (b = c.Math), this.updateTweenData("interpolationFunction", a, d), this.updateTweenData("interpolationContext", b, d);
        },
        repeatAll: function (a) {
          return void 0 === a && (a = 0), (this.repeatCounter = a), this;
        },
        chain: function () {
          for (var a = arguments.length; a--; ) a > 0 ? (arguments[a - 1].chainedTween = arguments[a]) : (this.chainedTween = arguments[a]);
          return this;
        },
        loop: function (a) {
          return void 0 === a && (a = !0), (this.repeatCounter = a ? -1 : 0), this;
        },
        onUpdateCallback: function (a, b) {
          return (this._onUpdateCallback = a), (this._onUpdateCallbackContext = b), this;
        },
        pause: function () {
          (this.isPaused = !0), (this._codePaused = !0), (this._pausedTime = this.game.time.time);
        },
        _pause: function () {
          this._codePaused || ((this.isPaused = !0), (this._pausedTime = this.game.time.time));
        },
        resume: function () {
          if (this.isPaused) {
            (this.isPaused = !1), (this._codePaused = !1);
            for (var a = 0; a < this.timeline.length; a++) this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime);
          }
        },
        _resume: function () {
          this._codePaused || this.resume();
        },
        update: function (a) {
          if (this.pendingDelete || !this.target) return !1;
          if (this.isPaused) return !0;
          var b = this.timeline[this.current].update(a);
          if (b === c.TweenData.PENDING) return !0;
          if (b === c.TweenData.RUNNING)
            return (
              this._hasStarted || (this.onStart.dispatch(this.target, this), (this._hasStarted = !0)),
              null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]),
              this.isRunning
            );
          if (b === c.TweenData.LOOPED) return this.timeline[this.current].repeatCounter === -1 ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
          if (b === c.TweenData.COMPLETE) {
            var d = !1;
            return (
              this.reverse ? (this.current--, this.current < 0 && ((this.current = this.timeline.length - 1), (d = !0))) : (this.current++, this.current === this.timeline.length && ((this.current = 0), (d = !0))),
              d
                ? this.repeatCounter === -1
                  ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0)
                  : this.repeatCounter > 0
                  ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0)
                  : ((this.isRunning = !1), this.onComplete.dispatch(this.target, this), (this._hasStarted = !1), this.chainedTween && this.chainedTween.start(), !1)
                : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
            );
          }
        },
        generateData: function (a, b) {
          if (null === this.game || null === this.target) return null;
          void 0 === a && (a = 60), void 0 === b && (b = []);
          for (var c = 0; c < this.timeline.length; c++) for (var d in this.timeline[c].vEnd) (this.properties[d] = this.target[d] || 0), Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
          for (var c = 0; c < this.timeline.length; c++) this.timeline[c].loadValues();
          for (var c = 0; c < this.timeline.length; c++) b = b.concat(this.timeline[c].generateData(a));
          return b;
        },
      }),
      Object.defineProperty(c.Tween.prototype, "totalDuration", {
        get: function () {
          for (var a = 0, b = 0; b < this.timeline.length; b++) a += this.timeline[b].duration;
          return a;
        },
      }),
      (c.Tween.prototype.constructor = c.Tween),
      (c.TweenData = function (a) {
        (this.parent = a),
          (this.game = a.game),
          (this.vStart = {}),
          (this.vStartCache = {}),
          (this.vEnd = {}),
          (this.vEndCache = {}),
          (this.duration = 1e3),
          (this.percent = 0),
          (this.value = 0),
          (this.repeatCounter = 0),
          (this.repeatDelay = 0),
          (this.repeatTotal = 0),
          (this.interpolate = !1),
          (this.yoyo = !1),
          (this.yoyoDelay = 0),
          (this.inReverse = !1),
          (this.delay = 0),
          (this.dt = 0),
          (this.startTime = null),
          (this.easingFunction = c.Easing.Default),
          (this.interpolationFunction = c.Math.linearInterpolation),
          (this.interpolationContext = c.Math),
          (this.isRunning = !1),
          (this.isFrom = !1);
      }),
      (c.TweenData.PENDING = 0),
      (c.TweenData.RUNNING = 1),
      (c.TweenData.LOOPED = 2),
      (c.TweenData.COMPLETE = 3),
      (c.TweenData.prototype = {
        to: function (a, b, c, d, e, f) {
          return (this.vEnd = a), (this.duration = b), (this.easingFunction = c), (this.delay = d), (this.repeatTotal = e), (this.yoyo = f), (this.isFrom = !1), this;
        },
        from: function (a, b, c, d, e, f) {
          return (this.vEnd = a), (this.duration = b), (this.easingFunction = c), (this.delay = d), (this.repeatTotal = e), (this.yoyo = f), (this.isFrom = !0), this;
        },
        start: function () {
          if (((this.startTime = this.game.time.time + this.delay), this.parent.reverse ? (this.dt = this.duration) : (this.dt = 0), this.delay > 0 ? (this.isRunning = !1) : (this.isRunning = !0), this.isFrom))
            for (var a in this.vStartCache) (this.vStart[a] = this.vEndCache[a]), (this.vEnd[a] = this.vStartCache[a]), (this.parent.target[a] = this.vStart[a]);
          return (this.value = 0), (this.yoyoCounter = 0), (this.repeatCounter = this.repeatTotal), this;
        },
        loadValues: function () {
          for (var a in this.parent.properties) {
            if (((this.vStart[a] = this.parent.properties[a]), Array.isArray(this.vEnd[a]))) {
              if (0 === this.vEnd[a].length) continue;
              0 === this.percent && (this.vEnd[a] = [this.vStart[a]].concat(this.vEnd[a]));
            }
            "undefined" != typeof this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)), (this.parent.properties[a] = this.vEnd[a])) : (this.vEnd[a] = this.vStart[a]),
              (this.vStartCache[a] = this.vStart[a]),
              (this.vEndCache[a] = this.vEnd[a]);
          }
          return this;
        },
        update: function (a) {
          if (this.isRunning) {
            if (a < this.startTime) return c.TweenData.RUNNING;
          } else {
            if (!(a >= this.startTime)) return c.TweenData.PENDING;
            this.isRunning = !0;
          }
          var b = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
          this.parent.reverse ? ((this.dt -= b * this.parent.timeScale), (this.dt = Math.max(this.dt, 0))) : ((this.dt += b * this.parent.timeScale), (this.dt = Math.min(this.dt, this.duration))),
            (this.percent = this.dt / this.duration),
            (this.value = this.easingFunction(this.percent));
          for (var d in this.vEnd) {
            var e = this.vStart[d],
              f = this.vEnd[d];
            Array.isArray(f) ? (this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value)) : (this.parent.target[d] = e + (f - e) * this.value);
          }
          return (!this.parent.reverse && 1 === this.percent) || (this.parent.reverse && 0 === this.percent) ? this.repeat() : c.TweenData.RUNNING;
        },
        generateData: function (a) {
          this.parent.reverse ? (this.dt = this.duration) : (this.dt = 0);
          var b = [],
            c = !1,
            d = (1 / a) * 1e3;
          do {
            this.parent.reverse ? ((this.dt -= d), (this.dt = Math.max(this.dt, 0))) : ((this.dt += d), (this.dt = Math.min(this.dt, this.duration))),
              (this.percent = this.dt / this.duration),
              (this.value = this.easingFunction(this.percent));
            var e = {};
            for (var f in this.vEnd) {
              var g = this.vStart[f],
                h = this.vEnd[f];
              Array.isArray(h) ? (e[f] = this.interpolationFunction(h, this.value)) : (e[f] = g + (h - g) * this.value);
            }
            b.push(e), ((!this.parent.reverse && 1 === this.percent) || (this.parent.reverse && 0 === this.percent)) && (c = !0);
          } while (!c);
          if (this.yoyo) {
            var i = b.slice();
            i.reverse(), (b = b.concat(i));
          }
          return b;
        },
        repeat: function () {
          if (this.yoyo) {
            if (this.inReverse && 0 === this.repeatCounter) {
              for (var a in this.vStartCache) (this.vStart[a] = this.vStartCache[a]), (this.vEnd[a] = this.vEndCache[a]);
              return (this.inReverse = !1), c.TweenData.COMPLETE;
            }
            this.inReverse = !this.inReverse;
          } else if (0 === this.repeatCounter) return c.TweenData.COMPLETE;
          if (this.inReverse) for (var a in this.vStartCache) (this.vStart[a] = this.vEndCache[a]), (this.vEnd[a] = this.vStartCache[a]);
          else {
            for (var a in this.vStartCache) (this.vStart[a] = this.vStartCache[a]), (this.vEnd[a] = this.vEndCache[a]);
            this.repeatCounter > 0 && this.repeatCounter--;
          }
          return (
            (this.startTime = this.game.time.time),
            this.yoyo && this.inReverse ? (this.startTime += this.yoyoDelay) : this.inReverse || (this.startTime += this.repeatDelay),
            this.parent.reverse ? (this.dt = this.duration) : (this.dt = 0),
            c.TweenData.LOOPED
          );
        },
      }),
      (c.TweenData.prototype.constructor = c.TweenData),
      (c.Easing = {
        Linear: {
          None: function (a) {
            return a;
          },
        },
        Quadratic: {
          In: function (a) {
            return a * a;
          },
          Out: function (a) {
            return a * (2 - a);
          },
          InOut: function (a) {
            return (a *= 2) < 1 ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
          },
        },
        Cubic: {
          In: function (a) {
            return a * a * a;
          },
          Out: function (a) {
            return --a * a * a + 1;
          },
          InOut: function (a) {
            return (a *= 2) < 1 ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
          },
        },
        Quartic: {
          In: function (a) {
            return a * a * a * a;
          },
          Out: function (a) {
            return 1 - --a * a * a * a;
          },
          InOut: function (a) {
            return (a *= 2) < 1 ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
          },
        },
        Quintic: {
          In: function (a) {
            return a * a * a * a * a;
          },
          Out: function (a) {
            return --a * a * a * a * a + 1;
          },
          InOut: function (a) {
            return (a *= 2) < 1 ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
          },
        },
        Sinusoidal: {
          In: function (a) {
            return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos((a * Math.PI) / 2);
          },
          Out: function (a) {
            return 0 === a ? 0 : 1 === a ? 1 : Math.sin((a * Math.PI) / 2);
          },
          InOut: function (a) {
            return 0 === a ? 0 : 1 === a ? 1 : 0.5 * (1 - Math.cos(Math.PI * a));
          },
        },
        Exponential: {
          In: function (a) {
            return 0 === a ? 0 : Math.pow(1024, a - 1);
          },
          Out: function (a) {
            return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
          },
          InOut: function (a) {
            return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
          },
        },
        Circular: {
          In: function (a) {
            return 1 - Math.sqrt(1 - a * a);
          },
          Out: function (a) {
            return Math.sqrt(1 - --a * a);
          },
          InOut: function (a) {
            return (a *= 2) < 1 ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
          },
        },
        Elastic: {
          In: function (a) {
            var b,
              c = 0.1,
              d = 0.4;
            return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? ((c = 1), (b = d / 4)) : (b = (d * Math.asin(1 / c)) / (2 * Math.PI)), -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin(((a - b) * (2 * Math.PI)) / d)));
          },
          Out: function (a) {
            var b,
              c = 0.1,
              d = 0.4;
            return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? ((c = 1), (b = d / 4)) : (b = (d * Math.asin(1 / c)) / (2 * Math.PI)), c * Math.pow(2, -10 * a) * Math.sin(((a - b) * (2 * Math.PI)) / d) + 1);
          },
          InOut: function (a) {
            var b,
              c = 0.1,
              d = 0.4;
            return 0 === a
              ? 0
              : 1 === a
              ? 1
              : (!c || c < 1 ? ((c = 1), (b = d / 4)) : (b = (d * Math.asin(1 / c)) / (2 * Math.PI)),
                (a *= 2) < 1 ? -0.5 * (c * Math.pow(2, 10 * (a -= 1)) * Math.sin(((a - b) * (2 * Math.PI)) / d)) : c * Math.pow(2, -10 * (a -= 1)) * Math.sin(((a - b) * (2 * Math.PI)) / d) * 0.5 + 1);
          },
        },
        Back: {
          In: function (a) {
            var b = 1.70158;
            return a * a * ((b + 1) * a - b);
          },
          Out: function (a) {
            var b = 1.70158;
            return --a * a * ((b + 1) * a + b) + 1;
          },
          InOut: function (a) {
            var b = 2.5949095;
            return (a *= 2) < 1 ? 0.5 * (a * a * ((b + 1) * a - b)) : 0.5 * ((a -= 2) * a * ((b + 1) * a + b) + 2);
          },
        },
        Bounce: {
          In: function (a) {
            return 1 - c.Easing.Bounce.Out(1 - a);
          },
          Out: function (a) {
            return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
          },
          InOut: function (a) {
            return a < 0.5 ? 0.5 * c.Easing.Bounce.In(2 * a) : 0.5 * c.Easing.Bounce.Out(2 * a - 1) + 0.5;
          },
        },
      }),
      (c.Easing.Default = c.Easing.Linear.None),
      (c.Easing.Power0 = c.Easing.Linear.None),
      (c.Easing.Power1 = c.Easing.Quadratic.Out),
      (c.Easing.Power2 = c.Easing.Cubic.Out),
      (c.Easing.Power3 = c.Easing.Quartic.Out),
      (c.Easing.Power4 = c.Easing.Quintic.Out),
      (c.Time = function (a) {
        (this.game = a),
          (this.time = 0),
          (this.prevTime = 0),
          (this.now = 0),
          (this.elapsed = 0),
          (this.elapsedMS = 0),
          (this.physicsElapsed = 1 / 60),
          (this.physicsElapsedMS = (1 / 60) * 1e3),
          (this.desiredFpsMult = 1 / 60),
          (this._desiredFps = 60),
          (this.suggestedFps = this.desiredFps),
          (this.slowMotion = 1),
          (this.advancedTiming = !1),
          (this.frames = 0),
          (this.fps = 0),
          (this.fpsMin = 1e3),
          (this.fpsMax = 0),
          (this.msMin = 1e3),
          (this.msMax = 0),
          (this.pauseDuration = 0),
          (this.timeToCall = 0),
          (this.timeExpected = 0),
          (this.events = new c.Timer(this.game, !1)),
          (this._frameCount = 0),
          (this._elapsedAccumulator = 0),
          (this._started = 0),
          (this._timeLastSecond = 0),
          (this._pauseStarted = 0),
          (this._justResumed = !1),
          (this._timers = []);
      }),
      (c.Time.prototype = {
        boot: function () {
          (this._started = Date.now()), (this.time = Date.now()), this.events.start(), (this.timeExpected = this.time);
        },
        add: function (a) {
          return this._timers.push(a), a;
        },
        create: function (a) {
          void 0 === a && (a = !0);
          var b = new c.Timer(this.game, a);
          return this._timers.push(b), b;
        },
        removeAll: function () {
          for (var a = 0; a < this._timers.length; a++) this._timers[a].destroy();
          (this._timers = []), this.events.removeAll();
        },
        refresh: function () {
          var a = this.time;
          (this.time = Date.now()), (this.elapsedMS = this.time - a);
        },
        update: function (a) {
          var b = this.time;
          (this.time = Date.now()),
            (this.elapsedMS = this.time - b),
            (this.prevTime = this.now),
            (this.now = a),
            (this.elapsed = this.now - this.prevTime),
            this.game.raf._isSetTimeOut && ((this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - a)))), (this.timeExpected = a + this.timeToCall)),
            this.advancedTiming && this.updateAdvancedTiming(),
            this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers());
        },
        updateTimers: function () {
          for (var a = 0, b = this._timers.length; a < b; ) this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1), b--);
        },
        updateAdvancedTiming: function () {
          this._frameCount++,
            (this._elapsedAccumulator += this.elapsed),
            this._frameCount >= 2 * this._desiredFps && ((this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount))), (this._frameCount = 0), (this._elapsedAccumulator = 0)),
            (this.msMin = Math.min(this.msMin, this.elapsed)),
            (this.msMax = Math.max(this.msMax, this.elapsed)),
            this.frames++,
            this.now > this._timeLastSecond + 1e3 &&
              ((this.fps = Math.round((1e3 * this.frames) / (this.now - this._timeLastSecond))),
              (this.fpsMin = Math.min(this.fpsMin, this.fps)),
              (this.fpsMax = Math.max(this.fpsMax, this.fps)),
              (this._timeLastSecond = this.now),
              (this.frames = 0));
        },
        gamePaused: function () {
          (this._pauseStarted = Date.now()), this.events.pause();
          for (var a = this._timers.length; a--; ) this._timers[a]._pause();
        },
        gameResumed: function () {
          (this.time = Date.now()), (this.pauseDuration = this.time - this._pauseStarted), this.events.resume();
          for (var a = this._timers.length; a--; ) this._timers[a]._resume();
        },
        totalElapsedSeconds: function () {
          return 0.001 * (this.time - this._started);
        },
        elapsedSince: function (a) {
          return this.time - a;
        },
        elapsedSecondsSince: function (a) {
          return 0.001 * (this.time - a);
        },
        reset: function () {
          (this._started = this.time), this.removeAll();
        },
      }),
      Object.defineProperty(c.Time.prototype, "desiredFps", {
        get: function () {
          return this._desiredFps;
        },
        set: function (a) {
          (this._desiredFps = a), (this.physicsElapsed = 1 / a), (this.physicsElapsedMS = 1e3 * this.physicsElapsed), (this.desiredFpsMult = 1 / a);
        },
      }),
      (c.Time.prototype.constructor = c.Time),
      (c.Timer = function (a, b) {
        void 0 === b && (b = !0),
          (this.game = a),
          (this.running = !1),
          (this.autoDestroy = b),
          (this.expired = !1),
          (this.elapsed = 0),
          (this.events = []),
          (this.onComplete = new c.Signal()),
          (this.nextTick = 0),
          (this.timeCap = 1e3),
          (this.paused = !1),
          (this._codePaused = !1),
          (this._started = 0),
          (this._pauseStarted = 0),
          (this._pauseTotal = 0),
          (this._now = Date.now()),
          (this._len = 0),
          (this._marked = 0),
          (this._i = 0),
          (this._diff = 0),
          (this._newTick = 0);
      }),
      (c.Timer.MINUTE = 6e4),
      (c.Timer.SECOND = 1e3),
      (c.Timer.HALF = 500),
      (c.Timer.QUARTER = 250),
      (c.Timer.prototype = {
        create: function (a, b, d, e, f, g) {
          a = Math.round(a);
          var h = a;
          h += 0 === this._now ? this.game.time.time : this._now;
          var i = new c.TimerEvent(this, a, h, d, b, e, f, g);
          return this.events.push(i), this.order(), (this.expired = !1), i;
        },
        add: function (a, b, c) {
          return this.create(a, !1, 0, b, c, Array.prototype.slice.call(arguments, 3));
        },
        repeat: function (a, b, c, d) {
          return this.create(a, !1, b, c, d, Array.prototype.slice.call(arguments, 4));
        },
        loop: function (a, b, c) {
          return this.create(a, !0, 0, b, c, Array.prototype.slice.call(arguments, 3));
        },
        start: function (a) {
          if (!this.running) {
            (this._started = this.game.time.time + (a || 0)), (this.running = !0);
            for (var b = 0; b < this.events.length; b++) this.events[b].tick = this.events[b].delay + this._started;
          }
        },
        stop: function (a) {
          (this.running = !1), void 0 === a && (a = !0), a && (this.events.length = 0);
        },
        remove: function (a) {
          for (var b = 0; b < this.events.length; b++) if (this.events[b] === a) return (this.events[b].pendingDelete = !0), !0;
          return !1;
        },
        order: function () {
          this.events.length > 0 && (this.events.sort(this.sortHandler), (this.nextTick = this.events[0].tick));
        },
        sortHandler: function (a, b) {
          return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
        },
        clearPendingEvents: function () {
          for (this._i = this.events.length; this._i--; ) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
          (this._len = this.events.length), (this._i = 0);
        },
        update: function (a) {
          if (this.paused) return !0;
          if (
            ((this.elapsed = a - this._now), (this._now = a), this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed), (this._marked = 0), this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0)
          ) {
            for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete; )
              (this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick)),
                this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay),
                this.events[this._i].loop === !0
                  ? ((this.events[this._i].tick = this._newTick), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args))
                  : this.events[this._i].repeatCount > 0
                  ? (this.events[this._i].repeatCount--, (this.events[this._i].tick = this._newTick), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args))
                  : (this._marked++, (this.events[this._i].pendingDelete = !0), this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)),
                this._i++;
            this.events.length > this._marked ? this.order() : ((this.expired = !0), this.onComplete.dispatch(this));
          }
          return !this.expired || !this.autoDestroy;
        },
        pause: function () {
          this.running && ((this._codePaused = !0), this.paused || ((this._pauseStarted = this.game.time.time), (this.paused = !0)));
        },
        _pause: function () {
          !this.paused && this.running && ((this._pauseStarted = this.game.time.time), (this.paused = !0));
        },
        adjustEvents: function (a) {
          for (var b = 0; b < this.events.length; b++)
            if (!this.events[b].pendingDelete) {
              var c = this.events[b].tick - a;
              c < 0 && (c = 0), (this.events[b].tick = this._now + c);
            }
          var d = this.nextTick - a;
          d < 0 ? (this.nextTick = this._now) : (this.nextTick = this._now + d);
        },
        resume: function () {
          if (this.paused) {
            var a = this.game.time.time;
            (this._pauseTotal += a - this._now), (this._now = a), this.adjustEvents(this._pauseStarted), (this.paused = !1), (this._codePaused = !1);
          }
        },
        _resume: function () {
          this._codePaused || this.resume();
        },
        removeAll: function () {
          this.onComplete.removeAll(), (this.events.length = 0), (this._len = 0), (this._i = 0);
        },
        destroy: function () {
          this.onComplete.removeAll(), (this.running = !1), (this.events = []), (this._len = 0), (this._i = 0);
        },
      }),
      Object.defineProperty(c.Timer.prototype, "next", {
        get: function () {
          return this.nextTick;
        },
      }),
      Object.defineProperty(c.Timer.prototype, "duration", {
        get: function () {
          return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
        },
      }),
      Object.defineProperty(c.Timer.prototype, "length", {
        get: function () {
          return this.events.length;
        },
      }),
      Object.defineProperty(c.Timer.prototype, "ms", {
        get: function () {
          return this.running ? this._now - this._started - this._pauseTotal : 0;
        },
      }),
      Object.defineProperty(c.Timer.prototype, "seconds", {
        get: function () {
          return this.running ? 0.001 * this.ms : 0;
        },
      }),
      (c.Timer.prototype.constructor = c.Timer),
      (c.TimerEvent = function (a, b, c, d, e, f, g, h) {
        (this.timer = a), (this.delay = b), (this.tick = c), (this.repeatCount = d - 1), (this.loop = e), (this.callback = f), (this.callbackContext = g), (this.args = h), (this.pendingDelete = !1);
      }),
      (c.TimerEvent.prototype.constructor = c.TimerEvent),
      (c.AnimationManager = function (a) {
        (this.sprite = a), (this.game = a.game), (this.currentFrame = null), (this.currentAnim = null), (this.updateIfVisible = !0), (this.isLoaded = !1), (this._frameData = null), (this._anims = {}), (this._outputFrames = []);
      }),
      (c.AnimationManager.prototype = {
        loadFrameData: function (a, b) {
          if (void 0 === a) return !1;
          if (this.isLoaded) for (var c in this._anims) this._anims[c].updateFrameData(a);
          return (this._frameData = a), void 0 === b || null === b ? (this.frame = 0) : "string" == typeof b ? (this.frameName = b) : (this.frame = b), (this.isLoaded = !0), !0;
        },
        copyFrameData: function (a, b) {
          if (((this._frameData = a.clone()), this.isLoaded)) for (var c in this._anims) this._anims[c].updateFrameData(this._frameData);
          return void 0 === b || null === b ? (this.frame = 0) : "string" == typeof b ? (this.frameName = b) : (this.frame = b), (this.isLoaded = !0), !0;
        },
        add: function (a, b, d, e, f) {
          return (
            (b = b || []),
            (d = d || 60),
            void 0 === e && (e = !1),
            void 0 === f && (f = !(!b || "number" != typeof b[0])),
            (this._outputFrames = []),
            this._frameData.getFrameIndexes(b, f, this._outputFrames),
            (this._anims[a] = new c.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e)),
            (this.currentAnim = this._anims[a]),
            this.sprite.tilingTexture && (this.sprite.refreshTexture = !0),
            this._anims[a]
          );
        },
        validateFrames: function (a, b) {
          void 0 === b && (b = !0);
          for (var c = 0; c < a.length; c++)
            if (b === !0) {
              if (a[c] > this._frameData.total) return !1;
            } else if (this._frameData.checkFrameName(a[c]) === !1) return !1;
          return !0;
        },
        play: function (a, b, c, d) {
          if (this._anims[a])
            return this.currentAnim === this._anims[a]
              ? this.currentAnim.isPlaying === !1
                ? ((this.currentAnim.paused = !1), this.currentAnim.play(b, c, d))
                : this.currentAnim
              : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(),
                (this.currentAnim = this._anims[a]),
                (this.currentAnim.paused = !1),
                (this.currentFrame = this.currentAnim.currentFrame),
                this.currentAnim.play(b, c, d));
        },
        stop: function (a, b) {
          void 0 === b && (b = !1), !this.currentAnim || ("string" == typeof a && a !== this.currentAnim.name) || this.currentAnim.stop(b);
        },
        update: function () {
          return !((this.updateIfVisible && !this.sprite.visible) || !this.currentAnim || !this.currentAnim.update() || ((this.currentFrame = this.currentAnim.currentFrame), 0));
        },
        next: function (a) {
          this.currentAnim && (this.currentAnim.next(a), (this.currentFrame = this.currentAnim.currentFrame));
        },
        previous: function (a) {
          this.currentAnim && (this.currentAnim.previous(a), (this.currentFrame = this.currentAnim.currentFrame));
        },
        getAnimation: function (a) {
          return "string" == typeof a && this._anims[a] ? this._anims[a] : null;
        },
        refreshFrame: function () {},
        destroy: function () {
          var a = null;
          for (var a in this._anims) this._anims.hasOwnProperty(a) && this._anims[a].destroy();
          (this._anims = {}), (this._outputFrames = []), (this._frameData = null), (this.currentAnim = null), (this.currentFrame = null), (this.sprite = null), (this.game = null);
        },
      }),
      (c.AnimationManager.prototype.constructor = c.AnimationManager),
      Object.defineProperty(c.AnimationManager.prototype, "frameData", {
        get: function () {
          return this._frameData;
        },
      }),
      Object.defineProperty(c.AnimationManager.prototype, "frameTotal", {
        get: function () {
          return this._frameData.total;
        },
      }),
      Object.defineProperty(c.AnimationManager.prototype, "paused", {
        get: function () {
          return this.currentAnim.isPaused;
        },
        set: function (a) {
          this.currentAnim.paused = a;
        },
      }),
      Object.defineProperty(c.AnimationManager.prototype, "name", {
        get: function () {
          if (this.currentAnim) return this.currentAnim.name;
        },
      }),
      Object.defineProperty(c.AnimationManager.prototype, "frame", {
        get: function () {
          if (this.currentFrame) return this.currentFrame.index;
        },
        set: function (a) {
          "number" == typeof a && this._frameData && null !== this._frameData.getFrame(a) && ((this.currentFrame = this._frameData.getFrame(a)), this.currentFrame && this.sprite.setFrame(this.currentFrame));
        },
      }),
      Object.defineProperty(c.AnimationManager.prototype, "frameName", {
        get: function () {
          if (this.currentFrame) return this.currentFrame.name;
        },
        set: function (a) {
          "string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a)
            ? ((this.currentFrame = this._frameData.getFrameByName(a)), this.currentFrame && ((this._frameIndex = this.currentFrame.index), this.sprite.setFrame(this.currentFrame)))
            : void 0;
        },
      }),
      (c.Animation = function (a, b, d, e, f, g, h) {
        void 0 === h && (h = !1),
          (this.game = a),
          (this._parent = b),
          (this._frameData = e),
          (this.name = d),
          (this._frames = []),
          (this._frames = this._frames.concat(f)),
          (this.delay = 1e3 / g),
          (this.loop = h),
          (this.loopCount = 0),
          (this.killOnComplete = !1),
          (this.isFinished = !1),
          (this.isPlaying = !1),
          (this.isPaused = !1),
          (this._pauseStartTime = 0),
          (this._frameIndex = 0),
          (this._frameDiff = 0),
          (this._frameSkip = 1),
          (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])),
          (this.onStart = new c.Signal()),
          (this.onUpdate = null),
          (this.onComplete = new c.Signal()),
          (this.onLoop = new c.Signal()),
          (this.isReversed = !1),
          this.game.onPause.add(this.onPause, this),
          this.game.onResume.add(this.onResume, this);
      }),
      (c.Animation.prototype = {
        play: function (a, b, c) {
          return (
            "number" == typeof a && (this.delay = 1e3 / a),
            "boolean" == typeof b && (this.loop = b),
            "undefined" != typeof c && (this.killOnComplete = c),
            (this.isPlaying = !0),
            (this.isFinished = !1),
            (this.paused = !1),
            (this.loopCount = 0),
            (this._timeLastFrame = this.game.time.time),
            (this._timeNextFrame = this.game.time.time + this.delay),
            (this._frameIndex = this.isReversed ? this._frames.length - 1 : 0),
            this.updateCurrentFrame(!1, !0),
            this._parent.events.onAnimationStart$dispatch(this._parent, this),
            this.onStart.dispatch(this._parent, this),
            (this._parent.animations.currentAnim = this),
            (this._parent.animations.currentFrame = this.currentFrame),
            this
          );
        },
        restart: function () {
          (this.isPlaying = !0),
            (this.isFinished = !1),
            (this.paused = !1),
            (this.loopCount = 0),
            (this._timeLastFrame = this.game.time.time),
            (this._timeNextFrame = this.game.time.time + this.delay),
            (this._frameIndex = 0),
            (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])),
            this._parent.setFrame(this.currentFrame),
            (this._parent.animations.currentAnim = this),
            (this._parent.animations.currentFrame = this.currentFrame),
            this.onStart.dispatch(this._parent, this);
        },
        reverse: function () {
          return (this.reversed = !this.reversed), this;
        },
        reverseOnce: function () {
          return this.onComplete.addOnce(this.reverse, this), this.reverse();
        },
        setFrame: function (a, b) {
          var c;
          if ((void 0 === b && (b = !1), "string" == typeof a)) for (var d = 0; d < this._frames.length; d++) this._frameData.getFrame(this._frames[d]).name === a && (c = d);
          else if ("number" == typeof a)
            if (b) c = a;
            else for (var d = 0; d < this._frames.length; d++) this._frames[d] === a && (c = d);
          c && ((this._frameIndex = c - 1), (this._timeNextFrame = this.game.time.time), this.update());
        },
        stop: function (a, b) {
          void 0 === a && (a = !1),
            void 0 === b && (b = !1),
            (this.isPlaying = !1),
            (this.isFinished = !0),
            (this.paused = !1),
            a && ((this.currentFrame = this._frameData.getFrame(this._frames[0])), this._parent.setFrame(this.currentFrame)),
            b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this));
        },
        onPause: function () {
          this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time);
        },
        onResume: function () {
          this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff);
        },
        update: function () {
          return (
            !this.isPaused &&
            !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) &&
            ((this._frameSkip = 1),
            (this._frameDiff = this.game.time.time - this._timeNextFrame),
            (this._timeLastFrame = this.game.time.time),
            this._frameDiff > this.delay && ((this._frameSkip = Math.floor(this._frameDiff / this.delay)), (this._frameDiff -= this._frameSkip * this.delay)),
            (this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff)),
            this.isReversed ? (this._frameIndex -= this._frameSkip) : (this._frameIndex += this._frameSkip),
            (!this.isReversed && this._frameIndex >= this._frames.length) || (this.isReversed && this._frameIndex <= -1)
              ? this.loop
                ? ((this._frameIndex = Math.abs(this._frameIndex) % this._frames.length),
                  this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex),
                  (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])),
                  this.currentFrame && this._parent.setFrame(this.currentFrame),
                  this.loopCount++,
                  this._parent.events.onAnimationLoop$dispatch(this._parent, this),
                  this.onLoop.dispatch(this._parent, this),
                  !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData))
                : (this.complete(), !1)
              : this.updateCurrentFrame(!0))
          );
        },
        updateCurrentFrame: function (a, b) {
          if ((void 0 === b && (b = !1), !this._frameData)) return !1;
          var c = this.currentFrame.index;
          return (
            (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])),
            this.currentFrame && (b || (!b && c !== this.currentFrame.index)) && this._parent.setFrame(this.currentFrame),
            !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
          );
        },
        next: function (a) {
          void 0 === a && (a = 1);
          var b = this._frameIndex + a;
          b >= this._frames.length && (this.loop ? (b %= this._frames.length) : (b = this._frames.length - 1)), b !== this._frameIndex && ((this._frameIndex = b), this.updateCurrentFrame(!0));
        },
        previous: function (a) {
          void 0 === a && (a = 1);
          var b = this._frameIndex - a;
          b < 0 && (this.loop ? (b = this._frames.length + b) : b++), b !== this._frameIndex && ((this._frameIndex = b), this.updateCurrentFrame(!0));
        },
        updateFrameData: function (a) {
          (this._frameData = a), (this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null);
        },
        destroy: function () {
          this._frameData &&
            (this.game.onPause.remove(this.onPause, this),
            this.game.onResume.remove(this.onResume, this),
            (this.game = null),
            (this._parent = null),
            (this._frames = null),
            (this._frameData = null),
            (this.currentFrame = null),
            (this.isPlaying = !1),
            this.onStart.dispose(),
            this.onLoop.dispose(),
            this.onComplete.dispose(),
            this.onUpdate && this.onUpdate.dispose());
        },
        complete: function () {
          (this._frameIndex = this._frames.length - 1),
            (this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])),
            (this.isPlaying = !1),
            (this.isFinished = !0),
            (this.paused = !1),
            this._parent.events.onAnimationComplete$dispatch(this._parent, this),
            this.onComplete.dispatch(this._parent, this),
            this.killOnComplete && this._parent.kill();
        },
      }),
      (c.Animation.prototype.constructor = c.Animation),
      Object.defineProperty(c.Animation.prototype, "paused", {
        get: function () {
          return this.isPaused;
        },
        set: function (a) {
          (this.isPaused = a), a ? (this._pauseStartTime = this.game.time.time) : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay);
        },
      }),
      Object.defineProperty(c.Animation.prototype, "reversed", {
        get: function () {
          return this.isReversed;
        },
        set: function (a) {
          this.isReversed = a;
        },
      }),
      Object.defineProperty(c.Animation.prototype, "frameTotal", {
        get: function () {
          return this._frames.length;
        },
      }),
      Object.defineProperty(c.Animation.prototype, "frame", {
        get: function () {
          return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
        },
        set: function (a) {
          (this.currentFrame = this._frameData.getFrame(this._frames[a])), null !== this.currentFrame && ((this._frameIndex = a), this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame));
        },
      }),
      Object.defineProperty(c.Animation.prototype, "speed", {
        get: function () {
          return 1e3 / this.delay;
        },
        set: function (a) {
          a > 0 && (this.delay = 1e3 / a);
        },
      }),
      Object.defineProperty(c.Animation.prototype, "enableUpdate", {
        get: function () {
          return null !== this.onUpdate;
        },
        set: function (a) {
          a && null === this.onUpdate ? (this.onUpdate = new c.Signal()) : a || null === this.onUpdate || (this.onUpdate.dispose(), (this.onUpdate = null));
        },
      }),
      (c.Animation.generateFrameNames = function (a, b, d, e, f) {
        void 0 === e && (e = "");
        var g = [],
          h = "";
        if (b < d) for (var i = b; i <= d; i++) (h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString()), (h = a + h + e), g.push(h);
        else for (var i = b; i >= d; i--) (h = "number" == typeof f ? c.Utils.pad(i.toString(), f, "0", 1) : i.toString()), (h = a + h + e), g.push(h);
        return g;
      }),
      (c.Frame = function (a, b, d, e, f, g) {
        (this.index = a),
          (this.x = b),
          (this.y = d),
          (this.width = e),
          (this.height = f),
          (this.name = g),
          (this.centerX = Math.floor(e / 2)),
          (this.centerY = Math.floor(f / 2)),
          (this.distance = c.Math.distance(0, 0, e, f)),
          (this.rotated = !1),
          (this.rotationDirection = "cw"),
          (this.trimmed = !1),
          (this.sourceSizeW = e),
          (this.sourceSizeH = f),
          (this.spriteSourceSizeX = 0),
          (this.spriteSourceSizeY = 0),
          (this.spriteSourceSizeW = 0),
          (this.spriteSourceSizeH = 0),
          (this.right = this.x + this.width),
          (this.bottom = this.y + this.height);
      }),
      (c.Frame.prototype = {
        resize: function (a, b) {
          (this.width = a),
            (this.height = b),
            (this.centerX = Math.floor(a / 2)),
            (this.centerY = Math.floor(b / 2)),
            (this.distance = c.Math.distance(0, 0, a, b)),
            (this.sourceSizeW = a),
            (this.sourceSizeH = b),
            (this.right = this.x + a),
            (this.bottom = this.y + b);
        },
        setTrim: function (a, b, c, d, e, f, g) {
          (this.trimmed = a),
            a &&
              ((this.sourceSizeW = b),
              (this.sourceSizeH = c),
              (this.centerX = Math.floor(b / 2)),
              (this.centerY = Math.floor(c / 2)),
              (this.spriteSourceSizeX = d),
              (this.spriteSourceSizeY = e),
              (this.spriteSourceSizeW = f),
              (this.spriteSourceSizeH = g));
        },
        clone: function () {
          var a = new c.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
          for (var b in this) this.hasOwnProperty(b) && (a[b] = this[b]);
          return a;
        },
        getRect: function (a) {
          return void 0 === a ? (a = new c.Rectangle(this.x, this.y, this.width, this.height)) : a.setTo(this.x, this.y, this.width, this.height), a;
        },
      }),
      (c.Frame.prototype.constructor = c.Frame),
      (c.FrameData = function () {
        (this._frames = []), (this._frameNames = []);
      }),
      (c.FrameData.prototype = {
        addFrame: function (a) {
          return (a.index = this._frames.length), this._frames.push(a), "" !== a.name && (this._frameNames[a.name] = a.index), a;
        },
        getFrame: function (a) {
          return a >= this._frames.length && (a = 0), this._frames[a];
        },
        getFrameByName: function (a) {
          return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null;
        },
        checkFrameName: function (a) {
          return null != this._frameNames[a];
        },
        clone: function () {
          for (var a = new c.FrameData(), b = 0; b < this._frames.length; b++) a._frames.push(this._frames[b].clone());
          for (var d in this._frameNames) this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]);
          return a;
        },
        getFrameRange: function (a, b, c) {
          void 0 === c && (c = []);
          for (var d = a; d <= b; d++) c.push(this._frames[d]);
          return c;
        },
        getFrames: function (a, b, c) {
          if ((void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)) for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d]);
          else for (var d = 0; d < a.length; d++) b ? c.push(this.getFrame(a[d])) : c.push(this.getFrameByName(a[d]));
          return c;
        },
        getFrameIndexes: function (a, b, c) {
          if ((void 0 === b && (b = !0), void 0 === c && (c = []), void 0 === a || 0 === a.length)) for (var d = 0; d < this._frames.length; d++) c.push(this._frames[d].index);
          else for (var d = 0; d < a.length; d++) b && this._frames[a[d]] ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
          return c;
        },
        destroy: function () {
          (this._frames = null), (this._frameNames = null);
        },
      }),
      (c.FrameData.prototype.constructor = c.FrameData),
      Object.defineProperty(c.FrameData.prototype, "total", {
        get: function () {
          return this._frames.length;
        },
      }),
      (c.AnimationParser = {
        spriteSheet: function (a, b, d, e, f, g, h) {
          var i = b;
          if (("string" == typeof b && (i = a.cache.getImage(b)), null === i)) return null;
          var j = i.width,
            k = i.height;
          d <= 0 && (d = Math.floor(-j / Math.min(-1, d))), e <= 0 && (e = Math.floor(-k / Math.min(-1, e)));
          var l = Math.floor((j - g) / (d + h)),
            m = Math.floor((k - g) / (e + h)),
            n = l * m;
          if ((f !== -1 && (n = f), 0 === j || 0 === k || j < d || k < e || 0 === n)) return null;
          for (var o = new c.FrameData(), p = g, q = g, r = 0; r < n; r++) o.addFrame(new c.Frame(r, p, q, d, e, "")), (p += d + h), p + d > j && ((p = g), (q += e + h));
          return o;
        },
        JSONData: function (a, b) {
          if (b.frames) {
            for (var d, e = new c.FrameData(), f = b.frames, g = 0; g < f.length; g++)
              (d = e.addFrame(new c.Frame(g, f[g].frame.x, f[g].frame.y, f[g].frame.w, f[g].frame.h, f[g].filename))),
                f[g].trimmed && d.setTrim(f[g].trimmed, f[g].sourceSize.w, f[g].sourceSize.h, f[g].spriteSourceSize.x, f[g].spriteSourceSize.y, f[g].spriteSourceSize.w, f[g].spriteSourceSize.h);
            return e;
          }
        },
        JSONDataPyxel: function (a, b) {
          var d = ["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"];
          if (
            (d.forEach(function (a) {
              !b[a];
            }),
            1 === b.layers.length)
          ) {
            for (var e, f = new c.FrameData(), g = b.tileheight, h = b.tilewidth, i = b.layers[0].tiles, j = 0; j < i.length; j++) (e = f.addFrame(new c.Frame(j, i[j].x, i[j].y, h, g, "frame_" + j))), e.setTrim(!1);
            return f;
          }
        },
        JSONDataHash: function (a, b) {
          if (b.frames) {
            var d,
              e = new c.FrameData(),
              f = b.frames,
              g = 0;
            for (var h in f)
              (d = e.addFrame(new c.Frame(g, f[h].frame.x, f[h].frame.y, f[h].frame.w, f[h].frame.h, h))),
                f[h].trimmed && d.setTrim(f[h].trimmed, f[h].sourceSize.w, f[h].sourceSize.h, f[h].spriteSourceSize.x, f[h].spriteSourceSize.y, f[h].spriteSourceSize.w, f[h].spriteSourceSize.h),
                g++;
            return e;
          }
        },
        XMLData: function (a, b) {
          if (b.getElementsByTagName("TextureAtlas")) {
            for (var d, e, f, g, h, i, j, k, l, m, n, o = new c.FrameData(), p = b.getElementsByTagName("SubTexture"), q = 0; q < p.length; q++)
              (f = p[q].attributes),
                (e = f.name.value),
                (g = parseInt(f.x.value, 10)),
                (h = parseInt(f.y.value, 10)),
                (i = parseInt(f.width.value, 10)),
                (j = parseInt(f.height.value, 10)),
                (k = null),
                (l = null),
                f.frameX && ((k = Math.abs(parseInt(f.frameX.value, 10))), (l = Math.abs(parseInt(f.frameY.value, 10))), (m = parseInt(f.frameWidth.value, 10)), (n = parseInt(f.frameHeight.value, 10))),
                (d = o.addFrame(new c.Frame(q, g, h, i, j, e))),
                (null === k && null === l) || d.setTrim(!0, i, j, k, l, m, n);
            return o;
          }
        },
      }),
      (c.Cache = function (a) {
        (this.game = a),
          (this.autoResolveURL = !1),
          (this._cache = { canvas: {}, image: {}, texture: {}, sound: {}, video: {}, text: {}, json: {}, xml: {}, physics: {}, tilemap: {}, binary: {}, bitmapData: {}, bitmapFont: {}, shader: {}, renderTexture: {} }),
          (this._urlMap = {}),
          (this._urlResolver = new Image()),
          (this._urlTemp = null),
          (this.onSoundUnlock = new c.Signal()),
          (this._cacheMap = []),
          (this._cacheMap[c.Cache.CANVAS] = this._cache.canvas),
          (this._cacheMap[c.Cache.IMAGE] = this._cache.image),
          (this._cacheMap[c.Cache.TEXTURE] = this._cache.texture),
          (this._cacheMap[c.Cache.SOUND] = this._cache.sound),
          (this._cacheMap[c.Cache.TEXT] = this._cache.text),
          (this._cacheMap[c.Cache.PHYSICS] = this._cache.physics),
          (this._cacheMap[c.Cache.TILEMAP] = this._cache.tilemap),
          (this._cacheMap[c.Cache.BINARY] = this._cache.binary),
          (this._cacheMap[c.Cache.BITMAPDATA] = this._cache.bitmapData),
          (this._cacheMap[c.Cache.BITMAPFONT] = this._cache.bitmapFont),
          (this._cacheMap[c.Cache.JSON] = this._cache.json),
          (this._cacheMap[c.Cache.XML] = this._cache.xml),
          (this._cacheMap[c.Cache.VIDEO] = this._cache.video),
          (this._cacheMap[c.Cache.SHADER] = this._cache.shader),
          (this._cacheMap[c.Cache.RENDER_TEXTURE] = this._cache.renderTexture),
          this.addDefaultImage(),
          this.addMissingImage();
      }),
      (c.Cache.CANVAS = 1),
      (c.Cache.IMAGE = 2),
      (c.Cache.TEXTURE = 3),
      (c.Cache.SOUND = 4),
      (c.Cache.TEXT = 5),
      (c.Cache.PHYSICS = 6),
      (c.Cache.TILEMAP = 7),
      (c.Cache.BINARY = 8),
      (c.Cache.BITMAPDATA = 9),
      (c.Cache.BITMAPFONT = 10),
      (c.Cache.JSON = 11),
      (c.Cache.XML = 12),
      (c.Cache.VIDEO = 13),
      (c.Cache.SHADER = 14),
      (c.Cache.RENDER_TEXTURE = 15),
      (c.Cache.DEFAULT = null),
      (c.Cache.MISSING = null),
      (c.Cache.prototype = {
        addCanvas: function (a, b, c) {
          void 0 === c && (c = b.getContext("2d")), (this._cache.canvas[a] = { canvas: b, context: c });
        },
        addImage: function (a, b, d) {
          this.checkImageKey(a) && this.removeImage(a);
          var e = { key: a, url: b, data: d, base: new PIXI.BaseTexture(d), frame: new c.Frame(0, 0, 0, d.width, d.height, a), frameData: new c.FrameData() };
          return (
            e.frameData.addFrame(new c.Frame(0, 0, 0, d.width, d.height, b)),
            (this._cache.image[a] = e),
            this._resolveURL(b, e),
            "__default" === a ? (c.Cache.DEFAULT = new PIXI.Texture(e.base)) : "__missing" === a && (c.Cache.MISSING = new PIXI.Texture(e.base)),
            e
          );
        },
        addDefaultImage: function () {
          var a = new Image();
          a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
          var b = this.addImage("__default", null, a);
          (b.base.skipRender = !0), (c.Cache.DEFAULT = new PIXI.Texture(b.base));
        },
        addMissingImage: function () {
          var a = new Image();
          a.src =
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
          var b = this.addImage("__missing", null, a);
          c.Cache.MISSING = new PIXI.Texture(b.base);
        },
        addSound: function (a, b, c, d, e) {
          void 0 === d && ((d = !0), (e = !1)), void 0 === e && ((d = !1), (e = !0));
          var f = !1;
          e && (f = !0), (this._cache.sound[a] = { url: b, data: c, isDecoding: !1, decoded: f, webAudio: d, audioTag: e, locked: this.game.sound.touchLocked }), this._resolveURL(b, this._cache.sound[a]);
        },
        addText: function (a, b, c) {
          (this._cache.text[a] = { url: b, data: c }), this._resolveURL(b, this._cache.text[a]);
        },
        addPhysicsData: function (a, b, c, d) {
          (this._cache.physics[a] = { url: b, data: c, format: d }), this._resolveURL(b, this._cache.physics[a]);
        },
        addTilemap: function (a, b, c, d) {
          (this._cache.tilemap[a] = { url: b, data: c, format: d }), this._resolveURL(b, this._cache.tilemap[a]);
        },
        addBinary: function (a, b) {
          this._cache.binary[a] = b;
        },
        addBitmapData: function (a, b, d) {
          return (b.key = a), void 0 === d && ((d = new c.FrameData()), d.addFrame(b.textureFrame)), (this._cache.bitmapData[a] = { data: b, frameData: d }), b;
        },
        addBitmapFont: function (a, b, d, e, f, g, h) {
          var i = { url: b, data: d, font: null, base: new PIXI.BaseTexture(d) };
          void 0 === g && (g = 0),
            void 0 === h && (h = 0),
            "json" === f ? (i.font = c.LoaderParser.jsonBitmapFont(e, i.base, g, h)) : (i.font = c.LoaderParser.xmlBitmapFont(e, i.base, g, h)),
            (this._cache.bitmapFont[a] = i),
            this._resolveURL(b, i);
        },
        addJSON: function (a, b, c) {
          (this._cache.json[a] = { url: b, data: c }), this._resolveURL(b, this._cache.json[a]);
        },
        addXML: function (a, b, c) {
          (this._cache.xml[a] = { url: b, data: c }), this._resolveURL(b, this._cache.xml[a]);
        },
        addVideo: function (a, b, c, d) {
          (this._cache.video[a] = { url: b, data: c, isBlob: d, locked: !0 }), this._resolveURL(b, this._cache.video[a]);
        },
        addShader: function (a, b, c) {
          (this._cache.shader[a] = { url: b, data: c }), this._resolveURL(b, this._cache.shader[a]);
        },
        addRenderTexture: function (a, b) {
          this._cache.renderTexture[a] = { texture: b, frame: new c.Frame(0, 0, 0, b.width, b.height, "", "") };
        },
        addSpriteSheet: function (a, b, d, e, f, g, h, i) {
          void 0 === g && (g = -1), void 0 === h && (h = 0), void 0 === i && (i = 0);
          var j = { key: a, url: b, data: d, frameWidth: e, frameHeight: f, margin: h, spacing: i, base: new PIXI.BaseTexture(d), frameData: c.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i) };
          (this._cache.image[a] = j), this._resolveURL(b, j);
        },
        addTextureAtlas: function (a, b, d, e, f) {
          var g = { key: a, url: b, data: d, base: new PIXI.BaseTexture(d) };
          f === c.Loader.TEXTURE_ATLAS_XML_STARLING
            ? (g.frameData = c.AnimationParser.XMLData(this.game, e, a))
            : f === c.Loader.TEXTURE_ATLAS_JSON_PYXEL
            ? (g.frameData = c.AnimationParser.JSONDataPyxel(this.game, e, a))
            : Array.isArray(e.frames)
            ? (g.frameData = c.AnimationParser.JSONData(this.game, e, a))
            : (g.frameData = c.AnimationParser.JSONDataHash(this.game, e, a)),
            (this._cache.image[a] = g),
            this._resolveURL(b, g);
        },
        reloadSound: function (a) {
          var b = this,
            c = this.getSound(a);
          c &&
            ((c.data.src = c.url),
            c.data.addEventListener(
              "canplaythrough",
              function () {
                return b.reloadSoundComplete(a);
              },
              !1
            ),
            c.data.load());
        },
        reloadSoundComplete: function (a) {
          var b = this.getSound(a);
          b && ((b.locked = !1), this.onSoundUnlock.dispatch(a));
        },
        updateSound: function (a, b, c) {
          var d = this.getSound(a);
          d && (d[b] = c);
        },
        decodedSound: function (a, b) {
          var c = this.getSound(a);
          (c.data = b), (c.decoded = !0), (c.isDecoding = !1);
        },
        isSoundDecoded: function (a) {
          var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
          if (b) return b.decoded;
        },
        isSoundReady: function (a) {
          var b = this.getItem(a, c.Cache.SOUND, "isSoundDecoded");
          if (b) return b.decoded && !this.game.sound.touchLocked;
        },
        checkKey: function (a, b) {
          return !!this._cacheMap[a][b];
        },
        checkURL: function (a) {
          return !!this._urlMap[this._resolveURL(a)];
        },
        checkCanvasKey: function (a) {
          return this.checkKey(c.Cache.CANVAS, a);
        },
        checkImageKey: function (a) {
          return this.checkKey(c.Cache.IMAGE, a);
        },
        checkTextureKey: function (a) {
          return this.checkKey(c.Cache.TEXTURE, a);
        },
        checkSoundKey: function (a) {
          return this.checkKey(c.Cache.SOUND, a);
        },
        checkTextKey: function (a) {
          return this.checkKey(c.Cache.TEXT, a);
        },
        checkPhysicsKey: function (a) {
          return this.checkKey(c.Cache.PHYSICS, a);
        },
        checkTilemapKey: function (a) {
          return this.checkKey(c.Cache.TILEMAP, a);
        },
        checkBinaryKey: function (a) {
          return this.checkKey(c.Cache.BINARY, a);
        },
        checkBitmapDataKey: function (a) {
          return this.checkKey(c.Cache.BITMAPDATA, a);
        },
        checkBitmapFontKey: function (a) {
          return this.checkKey(c.Cache.BITMAPFONT, a);
        },
        checkJSONKey: function (a) {
          return this.checkKey(c.Cache.JSON, a);
        },
        checkXMLKey: function (a) {
          return this.checkKey(c.Cache.XML, a);
        },
        checkVideoKey: function (a) {
          return this.checkKey(c.Cache.VIDEO, a);
        },
        checkShaderKey: function (a) {
          return this.checkKey(c.Cache.SHADER, a);
        },
        checkRenderTextureKey: function (a) {
          return this.checkKey(c.Cache.RENDER_TEXTURE, a);
        },
        getItem: function (a, b, c, d) {
          return this.checkKey(b, a) ? (void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d]) : null;
        },
        getCanvas: function (a) {
          return this.getItem(a, c.Cache.CANVAS, "getCanvas", "canvas");
        },
        getImage: function (a, b) {
          (void 0 !== a && null !== a) || (a = "__default"), void 0 === b && (b = !1);
          var d = this.getItem(a, c.Cache.IMAGE, "getImage");
          return null === d && (d = this.getItem("__missing", c.Cache.IMAGE, "getImage")), b ? d : d.data;
        },
        getTextureFrame: function (a) {
          return this.getItem(a, c.Cache.TEXTURE, "getTextureFrame", "frame");
        },
        getSound: function (a) {
          return this.getItem(a, c.Cache.SOUND, "getSound");
        },
        getSoundData: function (a) {
          return this.getItem(a, c.Cache.SOUND, "getSoundData", "data");
        },
        getText: function (a) {
          return this.getItem(a, c.Cache.TEXT, "getText", "data");
        },
        getPhysicsData: function (a, b, d) {
          var e = this.getItem(a, c.Cache.PHYSICS, "getPhysicsData", "data");
          if (null === e || void 0 === b || null === b) return e;
          if (e[b]) {
            var f = e[b];
            if (!f || !d) return f;
            for (var g in f) if (((g = f[g]), g.fixtureKey === d)) return g;
          }
          return null;
        },
        getTilemapData: function (a) {
          return this.getItem(a, c.Cache.TILEMAP, "getTilemapData");
        },
        getBinary: function (a) {
          return this.getItem(a, c.Cache.BINARY, "getBinary");
        },
        getBitmapData: function (a) {
          return this.getItem(a, c.Cache.BITMAPDATA, "getBitmapData", "data");
        },
        getBitmapFont: function (a) {
          return this.getItem(a, c.Cache.BITMAPFONT, "getBitmapFont");
        },
        getJSON: function (a, b) {
          var d = this.getItem(a, c.Cache.JSON, "getJSON", "data");
          return d ? (b ? c.Utils.extend(!0, Array.isArray(d) ? [] : {}, d) : d) : null;
        },
        getXML: function (a) {
          return this.getItem(a, c.Cache.XML, "getXML", "data");
        },
        getVideo: function (a) {
          return this.getItem(a, c.Cache.VIDEO, "getVideo");
        },
        getShader: function (a) {
          return this.getItem(a, c.Cache.SHADER, "getShader", "data");
        },
        getRenderTexture: function (a) {
          return this.getItem(a, c.Cache.RENDER_TEXTURE, "getRenderTexture");
        },
        getBaseTexture: function (a, b) {
          return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getBaseTexture", "base");
        },
        getFrame: function (a, b) {
          return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrame", "frame");
        },
        getFrameCount: function (a, b) {
          var c = this.getFrameData(a, b);
          return c ? c.total : 0;
        },
        getFrameData: function (a, b) {
          return void 0 === b && (b = c.Cache.IMAGE), this.getItem(a, b, "getFrameData", "frameData");
        },
        hasFrameData: function (a, b) {
          return void 0 === b && (b = c.Cache.IMAGE), null !== this.getItem(a, b, "", "frameData");
        },
        updateFrameData: function (a, b, d) {
          void 0 === d && (d = c.Cache.IMAGE), this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = b);
        },
        getFrameByIndex: function (a, b, c) {
          var d = this.getFrameData(a, c);
          return d ? d.getFrame(b) : null;
        },
        getFrameByName: function (a, b, c) {
          var d = this.getFrameData(a, c);
          return d ? d.getFrameByName(b) : null;
        },
        getURL: function (a) {
          var a = this._resolveURL(a);
          return a ? this._urlMap[a] : null;
        },
        getKeys: function (a) {
          void 0 === a && (a = c.Cache.IMAGE);
          var b = [];
          if (this._cacheMap[a]) for (var d in this._cacheMap[a]) "__default" !== d && "__missing" !== d && b.push(d);
          return b;
        },
        removeCanvas: function (a) {
          delete this._cache.canvas[a];
        },
        removeImage: function (a, b) {
          void 0 === b && (b = !0);
          var c = this.getImage(a, !0);
          b && c.base && c.base.destroy(), delete this._cache.image[a];
        },
        removeSound: function (a) {
          delete this._cache.sound[a];
        },
        removeText: function (a) {
          delete this._cache.text[a];
        },
        removePhysics: function (a) {
          delete this._cache.physics[a];
        },
        removeTilemap: function (a) {
          delete this._cache.tilemap[a];
        },
        removeBinary: function (a) {
          delete this._cache.binary[a];
        },
        removeBitmapData: function (a) {
          delete this._cache.bitmapData[a];
        },
        removeBitmapFont: function (a) {
          delete this._cache.bitmapFont[a];
        },
        removeJSON: function (a) {
          delete this._cache.json[a];
        },
        removeXML: function (a) {
          delete this._cache.xml[a];
        },
        removeVideo: function (a) {
          delete this._cache.video[a];
        },
        removeShader: function (a) {
          delete this._cache.shader[a];
        },
        removeRenderTexture: function (a) {
          delete this._cache.renderTexture[a];
        },
        removeSpriteSheet: function (a) {
          delete this._cache.spriteSheet[a];
        },
        removeTextureAtlas: function (a) {
          delete this._cache.atlas[a];
        },
        clearGLTextures: function () {
          for (var a in this._cache.image) this._cache.image[a].base._glTextures = [];
        },
        _resolveURL: function (a, b) {
          return this.autoResolveURL ? ((this._urlResolver.src = this.game.load.baseURL + a), (this._urlTemp = this._urlResolver.src), (this._urlResolver.src = ""), b && (this._urlMap[this._urlTemp] = b), this._urlTemp) : null;
        },
        destroy: function () {
          for (var a = 0; a < this._cacheMap.length; a++) {
            var b = this._cacheMap[a];
            for (var c in b) "__default" !== c && "__missing" !== c && (b[c].destroy && b[c].destroy(), delete b[c]);
          }
          (this._urlMap = null), (this._urlResolver = null), (this._urlTemp = null);
        },
      }),
      (c.Cache.prototype.constructor = c.Cache),
      (c.Loader = function (a) {
        (this.game = a),
          (this.cache = a.cache),
          (this.resetLocked = !1),
          (this.isLoading = !1),
          (this.hasLoaded = !1),
          (this.preloadSprite = null),
          (this.crossOrigin = !1),
          (this.baseURL = ""),
          (this.path = ""),
          (this.headers = { requestedWith: !1, json: "application/json", xml: "application/xml" }),
          (this.onLoadStart = new c.Signal()),
          (this.onLoadComplete = new c.Signal()),
          (this.onPackComplete = new c.Signal()),
          (this.onFileStart = new c.Signal()),
          (this.onFileComplete = new c.Signal()),
          (this.onFileError = new c.Signal()),
          (this.useXDomainRequest = !1),
          (this._warnedAboutXDomainRequest = !1),
          (this.enableParallel = !0),
          (this.maxParallelDownloads = 4),
          (this._withSyncPointDepth = 0),
          (this._fileList = []),
          (this._flightQueue = []),
          (this._processingHead = 0),
          (this._fileLoadStarted = !1),
          (this._totalPackCount = 0),
          (this._totalFileCount = 0),
          (this._loadedPackCount = 0),
          (this._loadedFileCount = 0);
      }),
      (c.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0),
      (c.Loader.TEXTURE_ATLAS_JSON_HASH = 1),
      (c.Loader.TEXTURE_ATLAS_XML_STARLING = 2),
      (c.Loader.PHYSICS_LIME_CORONA_JSON = 3),
      (c.Loader.PHYSICS_PHASER_JSON = 4),
      (c.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5),
      (c.Loader.prototype = {
        setPreloadSprite: function (a, b) {
          (b = b || 0),
            (this.preloadSprite = { sprite: a, direction: b, width: a.width, height: a.height, rect: null }),
            0 === b ? (this.preloadSprite.rect = new c.Rectangle(0, 0, 1, a.height)) : (this.preloadSprite.rect = new c.Rectangle(0, 0, a.width, 1)),
            a.crop(this.preloadSprite.rect),
            (a.visible = !0);
        },
        resize: function () {
          this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height);
        },
        checkKeyExists: function (a, b) {
          return this.getAssetIndex(a, b) > -1;
        },
        getAssetIndex: function (a, b) {
          for (var c = -1, d = 0; d < this._fileList.length; d++) {
            var e = this._fileList[d];
            if (e.type === a && e.key === b && ((c = d), !e.loaded && !e.loading)) break;
          }
          return c;
        },
        getAsset: function (a, b) {
          var c = this.getAssetIndex(a, b);
          return c > -1 && { index: c, file: this._fileList[c] };
        },
        reset: function (a, b) {
          void 0 === b && (b = !1),
            this.resetLocked ||
              (a && (this.preloadSprite = null),
              (this.isLoading = !1),
              (this._processingHead = 0),
              (this._fileList.length = 0),
              (this._flightQueue.length = 0),
              (this._fileLoadStarted = !1),
              (this._totalFileCount = 0),
              (this._totalPackCount = 0),
              (this._loadedPackCount = 0),
              (this._loadedFileCount = 0),
              b && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()));
        },
        addToFileList: function (a, b, c, d, e, f) {
          if ((void 0 === e && (e = !1), void 0 === b || "" === b)) return this;
          if (void 0 === c || null === c) {
            if (!f) return this;
            c = b + f;
          }
          var g = { type: a, key: b, path: this.path, url: c, syncPoint: this._withSyncPointDepth > 0, data: null, loading: !1, loaded: !1, error: !1 };
          if (d) for (var h in d) g[h] = d[h];
          var i = this.getAssetIndex(a, b);
          if (e && i > -1) {
            var j = this._fileList[i];
            j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : (this._fileList[i] = g);
          } else i === -1 && (this._fileList.push(g), this._totalFileCount++);
          return this;
        },
        replaceInFileList: function (a, b, c, d) {
          return this.addToFileList(a, b, c, d, !0);
        },
        pack: function (a, b, c, d) {
          if ((void 0 === b && (b = null), void 0 === c && (c = null), void 0 === d && (d = null), !b && !c)) return this;
          var e = { type: "packfile", key: a, url: b, path: this.path, syncPoint: !0, data: null, loading: !1, loaded: !1, error: !1, callbackContext: d };
          c && ("string" == typeof c && (c = JSON.parse(c)), (e.data = c || {}), (e.loaded = !0));
          for (var f = 0; f < this._fileList.length + 1; f++) {
            var g = this._fileList[f];
            if (!g || (!g.loaded && !g.loading && "packfile" !== g.type)) {
              this._fileList.splice(f, 0, e), this._totalPackCount++;
              break;
            }
          }
          return this;
        },
        image: function (a, b, c) {
          return this.addToFileList("image", a, b, void 0, c, ".png");
        },
        images: function (a, b) {
          if (Array.isArray(b)) for (var c = 0; c < a.length; c++) this.image(a[c], b[c]);
          else for (var c = 0; c < a.length; c++) this.image(a[c]);
          return this;
        },
        text: function (a, b, c) {
          return this.addToFileList("text", a, b, void 0, c, ".txt");
        },
        json: function (a, b, c) {
          return this.addToFileList("json", a, b, void 0, c, ".json");
        },
        shader: function (a, b, c) {
          return this.addToFileList("shader", a, b, void 0, c, ".frag");
        },
        xml: function (a, b, c) {
          return this.addToFileList("xml", a, b, void 0, c, ".xml");
        },
        script: function (a, b, c, d) {
          return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = this), this.addToFileList("script", a, b, { syncPoint: !0, callback: c, callbackContext: d }, !1, ".js");
        },
        binary: function (a, b, c, d) {
          return void 0 === c && (c = !1), c !== !1 && void 0 === d && (d = c), this.addToFileList("binary", a, b, { callback: c, callbackContext: d }, !1, ".bin");
        },
        spritesheet: function (a, b, c, d, e, f, g) {
          return void 0 === e && (e = -1), void 0 === f && (f = 0), void 0 === g && (g = 0), this.addToFileList("spritesheet", a, b, { frameWidth: c, frameHeight: d, frameMax: e, margin: f, spacing: g }, !1, ".png");
        },
        audio: function (a, b, c) {
          return this.game.sound.noAudio ? this : (void 0 === c && (c = !0), "string" == typeof b && (b = [b]), this.addToFileList("audio", a, b, { buffer: null, autoDecode: c }));
        },
        audioSprite: function (a, b, c, d, e) {
          return this.game.sound.noAudio
            ? this
            : (void 0 === c && (c = null),
              void 0 === d && (d = null),
              void 0 === e && (e = !0),
              this.audio(a, b, e),
              c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addJSON(a + "-audioatlas", "", d)) : void 0,
              this);
        },
        audiosprite: function (a, b, c, d, e) {
          return this.audioSprite(a, b, c, d, e);
        },
        video: function (a, b, c, d) {
          return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === d && (d = !1), "string" == typeof b && (b = [b]), this.addToFileList("video", a, b, { buffer: null, asBlob: d, loadEvent: c });
        },
        tilemap: function (a, b, d, e) {
          if ((void 0 === b && (b = null), void 0 === d && (d = null), void 0 === e && (e = c.Tilemap.CSV), b || d || (b = e === c.Tilemap.CSV ? a + ".csv" : a + ".json"), d)) {
            switch (e) {
              case c.Tilemap.CSV:
                break;
              case c.Tilemap.TILED_JSON:
                "string" == typeof d && (d = JSON.parse(d));
            }
            this.cache.addTilemap(a, null, d, e);
          } else this.addToFileList("tilemap", a, b, { format: e });
          return this;
        },
        physics: function (a, b, d, e) {
          return (
            void 0 === b && (b = null),
            void 0 === d && (d = null),
            void 0 === e && (e = c.Physics.LIME_CORONA_JSON),
            b || d || (b = a + ".json"),
            d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, b, { format: e }),
            this
          );
        },
        bitmapFont: function (a, b, c, d, e, f) {
          if (((void 0 !== b && null !== b) || (b = a + ".png"), void 0 === c && (c = null), void 0 === d && (d = null), null === c && null === d && (c = a + ".xml"), void 0 === e && (e = 0), void 0 === f && (f = 0), c))
            this.addToFileList("bitmapfont", a, b, { atlasURL: c, xSpacing: e, ySpacing: f });
          else if ("string" == typeof d) {
            var g, h;
            try {
              g = JSON.parse(d);
            } catch (a) {
              h = this.parseXml(d);
            }
            if (!h && !g) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
            this.addToFileList("bitmapfont", a, b, { atlasURL: null, atlasData: g || h, atlasType: g ? "json" : "xml", xSpacing: e, ySpacing: f });
          }
          return this;
        },
        atlasJSONArray: function (a, b, d, e) {
          return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        },
        atlasJSONHash: function (a, b, d, e) {
          return this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_JSON_HASH);
        },
        atlasXML: function (a, b, d, e) {
          return void 0 === d && (d = null), void 0 === e && (e = null), d || e || (d = a + ".xml"), this.atlas(a, b, d, e, c.Loader.TEXTURE_ATLAS_XML_STARLING);
        },
        atlas: function (a, b, d, e, f) {
          if (
            ((void 0 !== b && null !== b) || (b = a + ".png"),
            void 0 === d && (d = null),
            void 0 === e && (e = null),
            void 0 === f && (f = c.Loader.TEXTURE_ATLAS_JSON_ARRAY),
            d || e || (d = f === c.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"),
            d)
          )
            this.addToFileList("textureatlas", a, b, { atlasURL: d, format: f });
          else {
            switch (f) {
              case c.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                "string" == typeof e && (e = JSON.parse(e));
                break;
              case c.Loader.TEXTURE_ATLAS_XML_STARLING:
                if ("string" == typeof e) {
                  var g = this.parseXml(e);
                  if (!g) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                  e = g;
                }
            }
            this.addToFileList("textureatlas", a, b, { atlasURL: null, atlasData: e, format: f });
          }
          return this;
        },
        withSyncPoint: function (a, b) {
          this._withSyncPointDepth++;
          try {
            a.call(b || this, this);
          } finally {
            this._withSyncPointDepth--;
          }
          return this;
        },
        addSyncPoint: function (a, b) {
          var c = this.getAsset(a, b);
          return c && (c.file.syncPoint = !0), this;
        },
        removeFile: function (a, b) {
          var c = this.getAsset(a, b);
          c && (c.loaded || c.loading || this._fileList.splice(c.index, 1));
        },
        removeAll: function () {
          (this._fileList.length = 0), (this._flightQueue.length = 0);
        },
        start: function () {
          this.isLoading || ((this.hasLoaded = !1), (this.isLoading = !0), this.updateProgress(), this.processLoadQueue());
        },
        processLoadQueue: function () {
          if (!this.isLoading) return void this.finishedLoading(!0);
          for (var a = 0; a < this._flightQueue.length; a++) {
            var b = this._flightQueue[a];
            (b.loaded || b.error) &&
              (this._flightQueue.splice(a, 1),
              a--,
              (b.loading = !1),
              (b.requestUrl = null),
              (b.requestObject = null),
              b.error && this.onFileError.dispatch(b.key, b),
              "packfile" !== b.type
                ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, b.key, !b.error, this._loadedFileCount, this._totalFileCount))
                : "packfile" === b.type && b.error && (this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)));
          }
          for (var d = !1, e = this.enableParallel ? c.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, a = this._processingHead; a < this._fileList.length; a++) {
            var b = this._fileList[a];
            if (
              ("packfile" === b.type && !b.error && b.loaded && a === this._processingHead && (this.processPack(b), this._loadedPackCount++, this.onPackComplete.dispatch(b.key, !b.error, this._loadedPackCount, this._totalPackCount)),
              b.loaded || b.error
                ? a === this._processingHead && (this._processingHead = a + 1)
                : !b.loading &&
                  this._flightQueue.length < e &&
                  ("packfile" !== b.type || b.data
                    ? d || (this._fileLoadStarted || ((this._fileLoadStarted = !0), this.onLoadStart.dispatch()), this._flightQueue.push(b), (b.loading = !0), this.onFileStart.dispatch(this.progress, b.key, b.url), this.loadFile(b))
                    : (this._flightQueue.push(b), (b.loading = !0), this.loadFile(b))),
              !b.loaded && b.syncPoint && (d = !0),
              this._flightQueue.length >= e || (d && this._loadedPackCount === this._totalPackCount))
            )
              break;
          }
          if ((this.updateProgress(), this._processingHead >= this._fileList.length)) this.finishedLoading();
          else if (!this._flightQueue.length) {
            var f = this;
            setTimeout(function () {
              f.finishedLoading(!0);
            }, 2e3);
          }
        },
        finishedLoading: function (a) {
          this.hasLoaded ||
            ((this.hasLoaded = !0), (this.isLoading = !1), a || this._fileLoadStarted || ((this._fileLoadStarted = !0), this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset());
        },
        asyncComplete: function (a, b) {
          void 0 === b && (b = ""), (a.loaded = !0), (a.error = !!b), b && void (a.errorMessage = b), this.processLoadQueue();
        },
        processPack: function (a) {
          var b = a.data[a.key];
          if (b)
            for (var d = 0; d < b.length; d++) {
              var e = b[d];
              switch (e.type) {
                case "image":
                  this.image(e.key, e.url, e.overwrite);
                  break;
                case "text":
                  this.text(e.key, e.url, e.overwrite);
                  break;
                case "json":
                  this.json(e.key, e.url, e.overwrite);
                  break;
                case "xml":
                  this.xml(e.key, e.url, e.overwrite);
                  break;
                case "script":
                  this.script(e.key, e.url, e.callback, a.callbackContext || this);
                  break;
                case "binary":
                  this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                  break;
                case "spritesheet":
                  this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                  break;
                case "video":
                  this.video(e.key, e.urls);
                  break;
                case "audio":
                  this.audio(e.key, e.urls, e.autoDecode);
                  break;
                case "audiosprite":
                  this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                  break;
                case "tilemap":
                  this.tilemap(e.key, e.url, e.data, c.Tilemap[e.format]);
                  break;
                case "physics":
                  this.physics(e.key, e.url, e.data, c.Loader[e.format]);
                  break;
                case "bitmapFont":
                  this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                  break;
                case "atlasJSONArray":
                  this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                  break;
                case "atlasJSONHash":
                  this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                  break;
                case "atlasXML":
                  this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                  break;
                case "atlas":
                  this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, c.Loader[e.format]);
                  break;
                case "shader":
                  this.shader(e.key, e.url, e.overwrite);
              }
            }
        },
        transformUrl: function (a, b) {
          return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a);
        },
        loadFile: function (a) {
          switch (a.type) {
            case "packfile":
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
              break;
            case "image":
            case "spritesheet":
            case "textureatlas":
            case "bitmapfont":
              this.loadImageTag(a);
              break;
            case "audio":
              (a.url = this.getAudioURL(a.url)),
                a.url
                  ? this.game.sound.usingWebAudio
                    ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete)
                    : this.game.sound.usingAudioTag && this.loadAudioTag(a)
                  : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
              break;
            case "video":
              (a.url = this.getVideoURL(a.url)),
                a.url
                  ? a.asBlob
                    ? this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete)
                    : this.loadVideoTag(a)
                  : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
              break;
            case "json":
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
              break;
            case "xml":
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
              break;
            case "tilemap":
              a.format === c.Tilemap.TILED_JSON
                ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete)
                : a.format === c.Tilemap.CSV
                ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete)
                : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
              break;
            case "text":
            case "script":
            case "shader":
            case "physics":
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
              break;
            case "binary":
              this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
          }
        },
        loadImageTag: function (a) {
          var b = this;
          (a.data = new Image()),
            (a.data.name = a.key),
            this.crossOrigin && (a.data.crossOrigin = this.crossOrigin),
            (a.data.onload = function () {
              a.data.onload && ((a.data.onload = null), (a.data.onerror = null), b.fileComplete(a));
            }),
            (a.data.onerror = function () {
              a.data.onload && ((a.data.onload = null), (a.data.onerror = null), b.fileError(a));
            }),
            (a.data.src = this.transformUrl(a.url, a)),
            a.data.complete && a.data.width && a.data.height && ((a.data.onload = null), (a.data.onerror = null), this.fileComplete(a));
        },
        loadVideoTag: function (a) {
          var b = this;
          (a.data = document.createElement("video")), (a.data.name = a.key), (a.data.controls = !1), (a.data.autoplay = !1);
          var d = function () {
            a.data.removeEventListener(a.loadEvent, d, !1), (a.data.onerror = null), (a.data.canplay = !0), c.GAMES[b.game.id].load.fileComplete(a);
          };
          (a.data.onerror = function () {
            a.data.removeEventListener(a.loadEvent, d, !1), (a.data.onerror = null), (a.data.canplay = !1), b.fileError(a);
          }),
            a.data.addEventListener(a.loadEvent, d, !1),
            (a.data.src = this.transformUrl(a.url, a)),
            a.data.load();
        },
        loadAudioTag: function (a) {
          var b = this;
          if (this.game.sound.touchLocked) (a.data = new Audio()), (a.data.name = a.key), (a.data.preload = "auto"), (a.data.src = this.transformUrl(a.url, a)), this.fileComplete(a);
          else {
            (a.data = new Audio()), (a.data.name = a.key);
            var c = function () {
              a.data.removeEventListener("canplaythrough", c, !1), (a.data.onerror = null), b.fileComplete(a);
            };
            (a.data.onerror = function () {
              a.data.removeEventListener("canplaythrough", c, !1), (a.data.onerror = null), b.fileError(a);
            }),
              (a.data.preload = "auto"),
              (a.data.src = this.transformUrl(a.url, a)),
              a.data.addEventListener("canplaythrough", c, !1),
              a.data.load();
          }
        },
        xhrLoad: function (a, b, c, d, e) {
          if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(a, b, c, d, e);
          var f = new XMLHttpRequest();
          f.open("GET", b, !0),
            (f.responseType = c),
            this.headers.requestedWith !== !1 && f.setRequestHeader("X-Requested-With", this.headers.requestedWith),
            this.headers[a.type] && f.setRequestHeader("Accept", this.headers[a.type]),
            (e = e || this.fileError);
          var g = this;
          (f.onload = function () {
            try {
              return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
            } catch (b) {
              g.hasLoaded ? window.console && void 0 : g.asyncComplete(a, b.message || "Exception");
            }
          }),
            (f.onerror = function () {
              try {
                return e.call(g, a, f);
              } catch (b) {
                g.hasLoaded ? window.console && void 0 : g.asyncComplete(a, b.message || "Exception");
              }
            }),
            (a.requestObject = f),
            (a.requestUrl = b),
            f.send();
        },
        xhrLoadWithXDR: function (a, b, c, d, e) {
          this._warnedAboutXDomainRequest || (this.game.device.ie && !(this.game.device.ieVersion >= 10)) || void (this._warnedAboutXDomainRequest = !0);
          var f = new window.XDomainRequest();
          f.open("GET", b, !0), (f.responseType = c), (f.timeout = 3e3), (e = e || this.fileError);
          var g = this;
          (f.onerror = function () {
            try {
              return e.call(g, a, f);
            } catch (b) {
              g.asyncComplete(a, b.message || "Exception");
            }
          }),
            (f.ontimeout = function () {
              try {
                return e.call(g, a, f);
              } catch (b) {
                g.asyncComplete(a, b.message || "Exception");
              }
            }),
            (f.onprogress = function () {}),
            (f.onload = function () {
              try {
                return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
              } catch (b) {
                g.asyncComplete(a, b.message || "Exception");
              }
            }),
            (a.requestObject = f),
            (a.requestUrl = b),
            setTimeout(function () {
              f.send();
            }, 0);
        },
        getVideoURL: function (a) {
          for (var b = 0; b < a.length; b++) {
            var c,
              d = a[b];
            if (d.uri) {
              if (((c = d.type), (d = d.uri), this.game.device.canPlayVideo(c))) return d;
            } else {
              if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
              d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
              var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
              if (((c = e.toLowerCase()), this.game.device.canPlayVideo(c))) return a[b];
            }
          }
          return null;
        },
        getAudioURL: function (a) {
          if (this.game.sound.noAudio) return null;
          for (var b = 0; b < a.length; b++) {
            var c,
              d = a[b];
            if (d.uri) {
              if (((c = d.type), (d = d.uri), this.game.device.canPlayAudio(c))) return d;
            } else {
              if (0 === d.indexOf("blob:") || 0 === d.indexOf("data:")) return d;
              d.indexOf("?") >= 0 && (d = d.substr(0, d.indexOf("?")));
              var e = d.substr((Math.max(0, d.lastIndexOf(".")) || 1 / 0) + 1);
              if (((c = e.toLowerCase()), this.game.device.canPlayAudio(c))) return a[b];
            }
          }
          return null;
        },
        fileError: function (a, b, c) {
          var d = a.requestUrl || this.transformUrl(a.url, a),
            e = "error loading asset from URL " + d;
          !c && b && (c = b.status), c && (e = e + " (" + c + ")"), this.asyncComplete(a, e);
        },
        fileComplete: function (a, b) {
          var d = !0;
          switch (a.type) {
            case "packfile":
              var e = JSON.parse(b.responseText);
              a.data = e || {};
              break;
            case "image":
              this.cache.addImage(a.key, a.url, a.data);
              break;
            case "spritesheet":
              this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
              break;
            case "textureatlas":
              if (null == a.atlasURL) this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
              else if (((d = !1), a.format === c.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format === c.Loader.TEXTURE_ATLAS_JSON_HASH || a.format === c.Loader.TEXTURE_ATLAS_JSON_PYXEL))
                this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
              else {
                if (a.format !== c.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete);
              }
              break;
            case "bitmapfont":
              a.atlasURL
                ? ((d = !1),
                  this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function (a, b) {
                    var c;
                    try {
                      c = JSON.parse(b.responseText);
                    } catch (a) {}
                    c ? ((a.atlasType = "json"), this.jsonLoadComplete(a, b)) : ((a.atlasType = "xml"), this.xmlLoadComplete(a, b));
                  }))
                : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
              break;
            case "video":
              if (a.asBlob)
                try {
                  a.data = b.response;
                } catch (b) {
                  throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key);
                }
              this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
              break;
            case "audio":
              this.game.sound.usingWebAudio ? ((a.data = b.response), this.cache.addSound(a.key, a.url, a.data, !0, !1), a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
              break;
            case "text":
              (a.data = b.responseText), this.cache.addText(a.key, a.url, a.data);
              break;
            case "shader":
              (a.data = b.responseText), this.cache.addShader(a.key, a.url, a.data);
              break;
            case "physics":
              var e = JSON.parse(b.responseText);
              this.cache.addPhysicsData(a.key, a.url, e, a.format);
              break;
            case "script":
              (a.data = document.createElement("script")),
                (a.data.language = "javascript"),
                (a.data.type = "text/javascript"),
                (a.data.defer = !1),
                (a.data.text = b.responseText),
                document.head.appendChild(a.data),
                a.callback && (a.data = a.callback.call(a.callbackContext, a.key, b.responseText));
              break;
            case "binary":
              a.callback ? (a.data = a.callback.call(a.callbackContext, a.key, b.response)) : (a.data = b.response), this.cache.addBinary(a.key, a.data);
          }
          d && this.asyncComplete(a);
        },
        jsonLoadComplete: function (a, b) {
          var c = JSON.parse(b.responseText);
          "tilemap" === a.type
            ? this.cache.addTilemap(a.key, a.url, c, a.format)
            : "bitmapfont" === a.type
            ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing)
            : "json" === a.type
            ? this.cache.addJSON(a.key, a.url, c)
            : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format),
            this.asyncComplete(a);
        },
        csvLoadComplete: function (a, b) {
          var c = b.responseText;
          this.cache.addTilemap(a.key, a.url, c, a.format), this.asyncComplete(a);
        },
        xmlLoadComplete: function (a, b) {
          var c = b.responseText,
            d = this.parseXml(c);
          if (!d) {
            b.responseType || b.contentType;
            return void this.asyncComplete(a, "invalid XML");
          }
          "bitmapfont" === a.type
            ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing)
            : "textureatlas" === a.type
            ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format)
            : "xml" === a.type && this.cache.addXML(a.key, a.url, d),
            this.asyncComplete(a);
        },
        parseXml: function (a) {
          var b;
          try {
            if (window.DOMParser) {
              var c = new DOMParser();
              b = c.parseFromString(a, "text/xml");
            } else (b = new ActiveXObject("Microsoft.XMLDOM")), (b.async = "false"), b.loadXML(a);
          } catch (a) {
            b = null;
          }
          return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null;
        },
        updateProgress: function () {
          this.preloadSprite &&
            (0 === this.preloadSprite.direction
              ? (this.preloadSprite.rect.width = Math.floor((this.preloadSprite.width / 100) * this.progress))
              : (this.preloadSprite.rect.height = Math.floor((this.preloadSprite.height / 100) * this.progress)),
            this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : (this.preloadSprite = null));
        },
        totalLoadedFiles: function () {
          return this._loadedFileCount;
        },
        totalQueuedFiles: function () {
          return this._totalFileCount - this._loadedFileCount;
        },
        totalLoadedPacks: function () {
          return this._totalPackCount;
        },
        totalQueuedPacks: function () {
          return this._totalPackCount - this._loadedPackCount;
        },
      }),
      Object.defineProperty(c.Loader.prototype, "progressFloat", {
        get: function () {
          var a = (this._loadedFileCount / this._totalFileCount) * 100;
          return c.Math.clamp(a || 0, 0, 100);
        },
      }),
      Object.defineProperty(c.Loader.prototype, "progress", {
        get: function () {
          return Math.round(this.progressFloat);
        },
      }),
      (c.Loader.prototype.constructor = c.Loader),
      (c.LoaderParser = {
        bitmapFont: function (a, b, c, d) {
          return this.xmlBitmapFont(a, b, c, d);
        },
        xmlBitmapFont: function (a, b, c, d) {
          var e = {},
            f = a.getElementsByTagName("info")[0],
            g = a.getElementsByTagName("common")[0];
          (e.font = f.getAttribute("face")), (e.size = parseInt(f.getAttribute("size"), 10)), (e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d), (e.chars = {});
          for (var h = a.getElementsByTagName("char"), i = 0; i < h.length; i++) {
            var j = parseInt(h[i].getAttribute("id"), 10);
            e.chars[j] = {
              x: parseInt(h[i].getAttribute("x"), 10),
              y: parseInt(h[i].getAttribute("y"), 10),
              width: parseInt(h[i].getAttribute("width"), 10),
              height: parseInt(h[i].getAttribute("height"), 10),
              xOffset: parseInt(h[i].getAttribute("xoffset"), 10),
              yOffset: parseInt(h[i].getAttribute("yoffset"), 10),
              xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c,
              kerning: {},
            };
          }
          var k = a.getElementsByTagName("kerning");
          for (i = 0; i < k.length; i++) {
            var l = parseInt(k[i].getAttribute("first"), 10),
              m = parseInt(k[i].getAttribute("second"), 10),
              n = parseInt(k[i].getAttribute("amount"), 10);
            e.chars[m].kerning[l] = n;
          }
          return this.finalizeBitmapFont(b, e);
        },
        jsonBitmapFont: function (a, b, c, d) {
          var e = { font: a.font.info._face, size: parseInt(a.font.info._size, 10), lineHeight: parseInt(a.font.common._lineHeight, 10) + d, chars: {} };
          return (
            a.font.chars["char"].forEach(function (a) {
              var b = parseInt(a._id, 10);
              e.chars[b] = {
                x: parseInt(a._x, 10),
                y: parseInt(a._y, 10),
                width: parseInt(a._width, 10),
                height: parseInt(a._height, 10),
                xOffset: parseInt(a._xoffset, 10),
                yOffset: parseInt(a._yoffset, 10),
                xAdvance: parseInt(a._xadvance, 10) + c,
                kerning: {},
              };
            }),
            a.font.kernings &&
              a.font.kernings.kerning &&
              a.font.kernings.kerning.forEach(function (a) {
                e.chars[a._second].kerning[a._first] = parseInt(a._amount, 10);
              }),
            this.finalizeBitmapFont(b, e)
          );
        },
        finalizeBitmapFont: function (a, b) {
          return (
            Object.keys(b.chars).forEach(function (d) {
              var e = b.chars[d];
              e.texture = new PIXI.Texture(a, new c.Rectangle(e.x, e.y, e.width, e.height));
            }),
            b
          );
        },
      }),
      (c.AudioSprite = function (a, b) {
        (this.game = a), (this.key = b), (this.config = this.game.cache.getJSON(b + "-audioatlas")), (this.autoplayKey = null), (this.autoplay = !1), (this.sounds = {});
        for (var c in this.config.spritemap) {
          var d = this.config.spritemap[c],
            e = this.game.add.sound(this.key);
          e.addMarker(c, d.start, d.end - d.start, null, d.loop), (this.sounds[c] = e);
        }
        this.config.autoplay && ((this.autoplayKey = this.config.autoplay), this.play(this.autoplayKey), (this.autoplay = this.sounds[this.autoplayKey]));
      }),
      (c.AudioSprite.prototype = {
        play: function (a, b) {
          return void 0 === b && (b = 1), this.sounds[a].play(a, null, b);
        },
        stop: function (a) {
          if (a) this.sounds[a].stop();
          else for (var b in this.sounds) this.sounds[b].stop();
        },
        get: function (a) {
          return this.sounds[a];
        },
      }),
      (c.AudioSprite.prototype.constructor = c.AudioSprite),
      (c.Sound = function (a, b, d, e, f) {
        void 0 === d && (d = 1),
          void 0 === e && (e = !1),
          void 0 === f && (f = a.sound.connectToMaster),
          (this.game = a),
          (this.name = b),
          (this.key = b),
          (this.loop = e),
          (this.markers = {}),
          (this.context = null),
          (this.autoplay = !1),
          (this.totalDuration = 0),
          (this.startTime = 0),
          (this.currentTime = 0),
          (this.duration = 0),
          (this.durationMS = 0),
          (this.position = 0),
          (this.stopTime = 0),
          (this.paused = !1),
          (this.pausedPosition = 0),
          (this.pausedTime = 0),
          (this.isPlaying = !1),
          (this.currentMarker = ""),
          (this.fadeTween = null),
          (this.pendingPlayback = !1),
          (this.override = !1),
          (this.allowMultiple = !1),
          (this.usingWebAudio = this.game.sound.usingWebAudio),
          (this.usingAudioTag = this.game.sound.usingAudioTag),
          (this.externalNode = null),
          (this.masterGainNode = null),
          (this.gainNode = null),
          (this._sound = null),
          this.usingWebAudio
            ? ((this.context = this.game.sound.context),
              (this.masterGainNode = this.game.sound.masterGain),
              void 0 === this.context.createGain ? (this.gainNode = this.context.createGainNode()) : (this.gainNode = this.context.createGain()),
              (this.gainNode.gain.value = d * this.game.sound.volume),
              f && this.gainNode.connect(this.masterGainNode))
            : this.usingAudioTag &&
              (this.game.cache.getSound(b) && this.game.cache.isSoundReady(b)
                ? ((this._sound = this.game.cache.getSoundData(b)), (this.totalDuration = 0), this._sound.duration && (this.totalDuration = this._sound.duration))
                : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)),
          (this.onDecoded = new c.Signal()),
          (this.onPlay = new c.Signal()),
          (this.onPause = new c.Signal()),
          (this.onResume = new c.Signal()),
          (this.onLoop = new c.Signal()),
          (this.onStop = new c.Signal()),
          (this.onMute = new c.Signal()),
          (this.onMarkerComplete = new c.Signal()),
          (this.onFadeComplete = new c.Signal()),
          (this._volume = d),
          (this._buffer = null),
          (this._muted = !1),
          (this._tempMarker = 0),
          (this._tempPosition = 0),
          (this._tempVolume = 0),
          (this._tempPause = 0),
          (this._muteVolume = 0),
          (this._tempLoop = 0),
          (this._paused = !1),
          (this._onDecodedEventDispatched = !1);
      }),
      (c.Sound.prototype = {
        soundHasUnlocked: function (a) {
          a === this.key && ((this._sound = this.game.cache.getSoundData(this.key)), (this.totalDuration = this._sound.duration));
        },
        addMarker: function (a, b, c, d, e) {
          (void 0 !== c && null !== c) || (c = 1), (void 0 !== d && null !== d) || (d = 1), void 0 === e && (e = !1), (this.markers[a] = { name: a, start: b, stop: b + c, volume: d, duration: c, durationMS: 1e3 * c, loop: e });
        },
        removeMarker: function (a) {
          delete this.markers[a];
        },
        onEndedHandler: function () {
          (this._sound.onended = null), (this.isPlaying = !1), (this.currentTime = this.durationMS), this.stop();
        },
        update: function () {
          return this.game.cache.checkSoundKey(this.key)
            ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), (this._onDecodedEventDispatched = !0)),
              this.pendingPlayback && this.game.cache.isSoundReady(this.key) && ((this.pendingPlayback = !1), this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)),
              void (
                this.isPlaying &&
                ((this.currentTime = this.game.time.time - this.startTime),
                this.currentTime >= this.durationMS &&
                  (this.usingWebAudio
                    ? this.loop
                      ? (this.onLoop.dispatch(this),
                        (this.isPlaying = !1),
                        "" === this.currentMarker
                          ? ((this.currentTime = 0), (this.startTime = this.game.time.time), (this.isPlaying = !0))
                          : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0)))
                      : "" !== this.currentMarker && this.stop()
                    : this.loop
                    ? (this.onLoop.dispatch(this), "" === this.currentMarker && ((this.currentTime = 0), (this.startTime = this.game.time.time)), (this.isPlaying = !1), this.play(this.currentMarker, 0, this.volume, !0, !0))
                    : this.stop()))
              ))
            : void this.destroy();
        },
        loopFull: function (a) {
          return this.play(null, 0, a, !0);
        },
        play: function (a, b, c, d, e) {
          if (((void 0 !== a && a !== !1 && null !== a) || (a = ""), void 0 === e && (e = !0), this.isPlaying && !this.allowMultiple && !e && !this.override)) return this;
          if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
            if (this.usingWebAudio) {
              if (void 0 === this._sound.stop) this._sound.noteOff(0);
              else
                try {
                  this._sound.stop(0);
                } catch (a) {}
              this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode);
            } else this.usingAudioTag && (this._sound.pause(), (this._sound.currentTime = 0));
            this.isPlaying = !1;
          }
          if ("" === a && Object.keys(this.markers).length > 0) return this;
          if ("" !== a) {
            if (!this.markers[a]) return this;
            (this.currentMarker = a),
              (this.position = this.markers[a].start),
              (this.volume = this.markers[a].volume),
              (this.loop = this.markers[a].loop),
              (this.duration = this.markers[a].duration),
              (this.durationMS = this.markers[a].durationMS),
              "undefined" != typeof c && (this.volume = c),
              "undefined" != typeof d && (this.loop = d),
              (this._tempMarker = a),
              (this._tempPosition = this.position),
              (this._tempVolume = this.volume),
              (this._tempLoop = this.loop);
          } else
            (b = b || 0),
              void 0 === c && (c = this._volume),
              void 0 === d && (d = this.loop),
              (this.position = Math.max(0, b)),
              (this.volume = c),
              (this.loop = d),
              (this.duration = 0),
              (this.durationMS = 0),
              (this._tempMarker = a),
              (this._tempPosition = b),
              (this._tempVolume = c),
              (this._tempLoop = d);
          return (
            this.usingWebAudio
              ? this.game.cache.isSoundDecoded(this.key)
                ? ((this._sound = this.context.createBufferSource()),
                  this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
                  (this._buffer = this.game.cache.getSoundData(this.key)),
                  (this._sound.buffer = this._buffer),
                  this.loop && "" === a && (this._sound.loop = !0),
                  this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)),
                  (this.totalDuration = this._sound.buffer.duration),
                  0 === this.duration && ((this.duration = this.totalDuration), (this.durationMS = Math.ceil(1e3 * this.totalDuration))),
                  void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration),
                  (this.isPlaying = !0),
                  (this.startTime = this.game.time.time),
                  (this.currentTime = 0),
                  (this.stopTime = this.startTime + this.durationMS),
                  this.onPlay.dispatch(this))
                : ((this.pendingPlayback = !0), this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === !1 && this.game.sound.decode(this.key, this))
              : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked
              ? (this.game.cache.reloadSound(this.key), (this.pendingPlayback = !0))
              : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState)
              ? (this._sound.play(),
                (this.totalDuration = this._sound.duration),
                0 === this.duration && ((this.duration = this.totalDuration), (this.durationMS = 1e3 * this.totalDuration)),
                (this._sound.currentTime = this.position),
                (this._sound.muted = this._muted),
                this._muted || this.game.sound.mute ? (this._sound.volume = 0) : (this._sound.volume = this._volume),
                (this.isPlaying = !0),
                (this.startTime = this.game.time.time),
                (this.currentTime = 0),
                (this.stopTime = this.startTime + this.durationMS),
                this.onPlay.dispatch(this))
              : (this.pendingPlayback = !0),
            this
          );
        },
        restart: function (a, b, c, d) {
          (a = a || ""), (b = b || 0), (c = c || 1), void 0 === d && (d = !1), this.play(a, b, c, d, !0);
        },
        pause: function () {
          this.isPlaying && this._sound && ((this.paused = !0), (this.pausedPosition = this.currentTime), (this.pausedTime = this.game.time.time), (this._tempPause = this._sound.currentTime), this.onPause.dispatch(this), this.stop());
        },
        resume: function () {
          if (this.paused && this._sound) {
            if (this.usingWebAudio) {
              var a = Math.max(0, this.position + this.pausedPosition / 1e3);
              (this._sound = this.context.createBufferSource()),
                (this._sound.buffer = this._buffer),
                this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
                this.loop && (this._sound.loop = !0),
                this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
              var b = this.duration - this.pausedPosition / 1e3;
              void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? (42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a)) : this._sound.start(0, a, b);
            } else (this._sound.currentTime = this._tempPause), this._sound.play();
            (this.isPlaying = !0), (this.paused = !1), (this.startTime += this.game.time.time - this.pausedTime), this.onResume.dispatch(this);
          }
        },
        stop: function () {
          if (this.isPlaying && this._sound)
            if (this.usingWebAudio) {
              if (void 0 === this._sound.stop) this._sound.noteOff(0);
              else
                try {
                  this._sound.stop(0);
                } catch (a) {}
              this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode);
            } else this.usingAudioTag && (this._sound.pause(), (this._sound.currentTime = 0));
          if (((this.pendingPlayback = !1), (this.isPlaying = !1), !this.paused)) {
            var a = this.currentMarker;
            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), (this.currentMarker = ""), null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, a);
          }
        },
        fadeIn: function (a, b, c) {
          void 0 === b && (b = !1), void 0 === c && (c = this.currentMarker), this.paused || (this.play(c, 0, 0, b), this.fadeTo(a, 1));
        },
        fadeOut: function (a) {
          this.fadeTo(a, 0);
        },
        fadeTo: function (a, b) {
          if (this.isPlaying && !this.paused && b !== this.volume) {
            if ((void 0 === a && (a = 1e3), void 0 === b)) return;
            (this.fadeTween = this.game.add.tween(this).to({ volume: b }, a, c.Easing.Linear.None, !0)), this.fadeTween.onComplete.add(this.fadeComplete, this);
          }
        },
        fadeComplete: function () {
          this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop();
        },
        updateGlobalVolume: function (a) {
          this.usingAudioTag && this._sound && (this._sound.volume = a * this._volume);
        },
        destroy: function (a) {
          void 0 === a && (a = !0),
            this.stop(),
            a
              ? this.game.sound.remove(this)
              : ((this.markers = {}),
                (this.context = null),
                (this._buffer = null),
                (this.externalNode = null),
                this.onDecoded.dispose(),
                this.onPlay.dispose(),
                this.onPause.dispose(),
                this.onResume.dispose(),
                this.onLoop.dispose(),
                this.onStop.dispose(),
                this.onMute.dispose(),
                this.onMarkerComplete.dispose());
        },
      }),
      (c.Sound.prototype.constructor = c.Sound),
      Object.defineProperty(c.Sound.prototype, "isDecoding", {
        get: function () {
          return this.game.cache.getSound(this.key).isDecoding;
        },
      }),
      Object.defineProperty(c.Sound.prototype, "isDecoded", {
        get: function () {
          return this.game.cache.isSoundDecoded(this.key);
        },
      }),
      Object.defineProperty(c.Sound.prototype, "mute", {
        get: function () {
          return this._muted || this.game.sound.mute;
        },
        set: function (a) {
          (a = a || !1),
            a !== this._muted &&
              (a
                ? ((this._muted = !0), (this._muteVolume = this._tempVolume), this.usingWebAudio ? (this.gainNode.gain.value = 0) : this.usingAudioTag && this._sound && (this._sound.volume = 0))
                : ((this._muted = !1), this.usingWebAudio ? (this.gainNode.gain.value = this._muteVolume) : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)),
              this.onMute.dispatch(this));
        },
      }),
      Object.defineProperty(c.Sound.prototype, "volume", {
        get: function () {
          return this._volume;
        },
        set: function (a) {
          return (
            this.game.device.firefox && this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)),
            this._muted ? void (this._muteVolume = a) : ((this._tempVolume = a), (this._volume = a), void (this.usingWebAudio ? (this.gainNode.gain.value = a) : this.usingAudioTag && this._sound && (this._sound.volume = a)))
          );
        },
      }),
      (c.SoundManager = function (a) {
        (this.game = a),
          (this.onSoundDecode = new c.Signal()),
          (this.onVolumeChange = new c.Signal()),
          (this.onMute = new c.Signal()),
          (this.onUnMute = new c.Signal()),
          (this.context = null),
          (this.usingWebAudio = !1),
          (this.usingAudioTag = !1),
          (this.noAudio = !1),
          (this.connectToMaster = !0),
          (this.touchLocked = !1),
          (this.channels = 32),
          (this.muteOnPause = !0),
          (this._codeMuted = !1),
          (this._muted = !1),
          (this._unlockSource = null),
          (this._volume = 1),
          (this._sounds = []),
          (this._watchList = new c.ArraySet()),
          (this._watching = !1),
          (this._watchCallback = null),
          (this._watchContext = null);
      }),
      (c.SoundManager.prototype = {
        boot: function () {
          if ((this.game.device.iOS && this.game.device.webAudio === !1 && (this.channels = 1), window.PhaserGlobal)) {
            if (window.PhaserGlobal.disableAudio === !0) return (this.noAudio = !0), void (this.touchLocked = !1);
            if (window.PhaserGlobal.disableWebAudio === !0) return (this.usingAudioTag = !0), void (this.touchLocked = !1);
          }
          if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
          else if (window.AudioContext)
            try {
              this.context = new window.AudioContext();
            } catch (a) {
              (this.context = null), (this.usingWebAudio = !1), (this.touchLocked = !1);
            }
          else if (window.webkitAudioContext)
            try {
              this.context = new window.webkitAudioContext();
            } catch (a) {
              (this.context = null), (this.usingWebAudio = !1), (this.touchLocked = !1);
            }
          if (null === this.context) {
            if (void 0 === window.Audio) return void (this.noAudio = !0);
            this.usingAudioTag = !0;
          } else
            (this.usingWebAudio = !0),
              void 0 === this.context.createGain ? (this.masterGain = this.context.createGainNode()) : (this.masterGain = this.context.createGain()),
              (this.masterGain.gain.value = 1),
              this.masterGain.connect(this.context.destination);
          this.noAudio || (((!this.game.device.cocoonJS && this.game.device.iOS) || (window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)) && this.setTouchLock());
        },
        setTouchLock: function () {
          this.noAudio ||
            (window.PhaserGlobal && window.PhaserGlobal.disableAudio === !0) ||
            (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), (this.touchLocked = !0));
        },
        unlock: function () {
          if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
          if (this.usingAudioTag) (this.touchLocked = !1), (this._unlockSource = null);
          else if (this.usingWebAudio) {
            var a = this.context.createBuffer(1, 1, 22050);
            (this._unlockSource = this.context.createBufferSource()),
              (this._unlockSource.buffer = a),
              this._unlockSource.connect(this.context.destination),
              void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0);
          }
          return !0;
        },
        stopAll: function () {
          if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].stop();
        },
        pauseAll: function () {
          if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].pause();
        },
        resumeAll: function () {
          if (!this.noAudio) for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].resume();
        },
        decode: function (a, b) {
          b = b || null;
          var c = this.game.cache.getSoundData(a);
          if (c && this.game.cache.isSoundDecoded(a) === !1) {
            this.game.cache.updateSound(a, "isDecoding", !0);
            var d = this;
            try {
              this.context.decodeAudioData(c, function (c) {
                c && (d.game.cache.decodedSound(a, c), d.onSoundDecode.dispatch(a, b));
              });
            } catch (a) {}
          }
        },
        setDecodedCallback: function (a, b, d) {
          "string" == typeof a && (a = [a]), this._watchList.reset();
          for (var e = 0; e < a.length; e++) a[e] instanceof c.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
          0 === this._watchList.total ? ((this._watching = !1), b.call(d)) : ((this._watching = !0), (this._watchCallback = b), (this._watchContext = d));
        },
        update: function () {
          if (!this.noAudio) {
            !this.touchLocked ||
              null === this._unlockSource ||
              (this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE) ||
              ((this.touchLocked = !1), (this._unlockSource = null));
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a].update();
            if (this._watching) {
              for (var b = this._watchList.first; b; ) this.game.cache.isSoundDecoded(b) && this._watchList.remove(b), (b = this._watchList.next);
              0 === this._watchList.total && ((this._watching = !1), this._watchCallback.call(this._watchContext));
            }
          }
        },
        add: function (a, b, d, e) {
          void 0 === b && (b = 1), void 0 === d && (d = !1), void 0 === e && (e = this.connectToMaster);
          var f = new c.Sound(this.game, a, b, d, e);
          return this._sounds.push(f), f;
        },
        addSprite: function (a) {
          var b = new c.AudioSprite(this.game, a);
          return b;
        },
        remove: function (a) {
          for (var b = this._sounds.length; b--; ) if (this._sounds[b] === a) return this._sounds[b].destroy(!1), this._sounds.splice(b, 1), !0;
          return !1;
        },
        removeByKey: function (a) {
          for (var b = this._sounds.length, c = 0; b--; ) this._sounds[b].key === a && (this._sounds[b].destroy(!1), this._sounds.splice(b, 1), c++);
          return c;
        },
        play: function (a, b, c) {
          if (!this.noAudio) {
            var d = this.add(a, b, c);
            return d.play(), d;
          }
        },
        setMute: function () {
          if (!this._muted) {
            (this._muted = !0), this.usingWebAudio && ((this._muteVolume = this.masterGain.gain.value), (this.masterGain.gain.value = 0));
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
            this.onMute.dispatch();
          }
        },
        unsetMute: function () {
          if (this._muted && !this._codeMuted) {
            (this._muted = !1), this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
            for (var a = 0; a < this._sounds.length; a++) this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
            this.onUnMute.dispatch();
          }
        },
        destroy: function () {
          this.stopAll();
          for (var a = 0; a < this._sounds.length; a++) this._sounds[a] && this._sounds[a].destroy();
          (this._sounds = []), this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? (window.PhaserGlobal.audioContext = this.context) : this.context.close && this.context.close());
        },
      }),
      (c.SoundManager.prototype.constructor = c.SoundManager),
      Object.defineProperty(c.SoundManager.prototype, "mute", {
        get: function () {
          return this._muted;
        },
        set: function (a) {
          if ((a = a || !1)) {
            if (this._muted) return;
            (this._codeMuted = !0), this.setMute();
          } else {
            if (!this._muted) return;
            (this._codeMuted = !1), this.unsetMute();
          }
        },
      }),
      Object.defineProperty(c.SoundManager.prototype, "volume", {
        get: function () {
          return this._volume;
        },
        set: function (a) {
          if ((a < 0 ? (a = 0) : a > 1 && (a = 1), this._volume !== a)) {
            if (((this._volume = a), this.usingWebAudio)) this.masterGain.gain.value = a;
            else for (var b = 0; b < this._sounds.length; b++) this._sounds[b].usingAudioTag && this._sounds[b].updateGlobalVolume(a);
            this.onVolumeChange.dispatch(a);
          }
        },
      }),
      (c.ScaleManager = function (a, b, d) {
        (this.game = a),
          (this.dom = c.DOM),
          (this.grid = null),
          (this.width = 0),
          (this.height = 0),
          (this.minWidth = null),
          (this.maxWidth = null),
          (this.minHeight = null),
          (this.maxHeight = null),
          (this.offset = new c.Point()),
          (this.forceLandscape = !1),
          (this.forcePortrait = !1),
          (this.incorrectOrientation = !1),
          (this._pageAlignHorizontally = !1),
          (this._pageAlignVertically = !1),
          (this.onOrientationChange = new c.Signal()),
          (this.enterIncorrectOrientation = new c.Signal()),
          (this.leaveIncorrectOrientation = new c.Signal()),
          (this.hasPhaserSetFullScreen = !1),
          (this.fullScreenTarget = null),
          (this._createdFullScreenTarget = null),
          (this.onFullScreenInit = new c.Signal()),
          (this.onFullScreenChange = new c.Signal()),
          (this.onFullScreenError = new c.Signal()),
          (this.screenOrientation = this.dom.getScreenOrientation()),
          (this.scaleFactor = new c.Point(1, 1)),
          (this.scaleFactorInversed = new c.Point(1, 1)),
          (this.margin = { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0 }),
          (this.bounds = new c.Rectangle()),
          (this.aspectRatio = 0),
          (this.sourceAspectRatio = 0),
          (this.event = null),
          (this.windowConstraints = { right: "layout", bottom: "" }),
          (this.compatibility = { supportsFullScreen: !1, orientationFallback: null, noMargins: !1, scrollTo: null, forceMinimumDocumentHeight: !1, canExpandParent: !0, clickTrampoline: "" }),
          (this._scaleMode = c.ScaleManager.NO_SCALE),
          (this._fullScreenScaleMode = c.ScaleManager.NO_SCALE),
          (this.parentIsWindow = !1),
          (this.parentNode = null),
          (this.parentScaleFactor = new c.Point(1, 1)),
          (this.trackParentInterval = 2e3),
          (this.onSizeChange = new c.Signal()),
          (this.onResize = null),
          (this.onResizeContext = null),
          (this._pendingScaleMode = null),
          (this._fullScreenRestore = null),
          (this._gameSize = new c.Rectangle()),
          (this._userScaleFactor = new c.Point(1, 1)),
          (this._userScaleTrim = new c.Point(0, 0)),
          (this._lastUpdate = 0),
          (this._updateThrottle = 0),
          (this._updateThrottleReset = 100),
          (this._parentBounds = new c.Rectangle()),
          (this._tempBounds = new c.Rectangle()),
          (this._lastReportedCanvasSize = new c.Rectangle()),
          (this._lastReportedGameSize = new c.Rectangle()),
          (this._booted = !1),
          a.config && this.parseConfig(a.config),
          this.setupScale(b, d);
      }),
      (c.ScaleManager.EXACT_FIT = 0),
      (c.ScaleManager.NO_SCALE = 1),
      (c.ScaleManager.SHOW_ALL = 2),
      (c.ScaleManager.RESIZE = 3),
      (c.ScaleManager.USER_SCALE = 4),
      (c.ScaleManager.prototype = {
        boot: function () {
          var a = this.compatibility;
          (a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS),
            this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? (a.scrollTo = new c.Point(0, 1)) : (a.scrollTo = new c.Point(0, 0))),
            this.game.device.desktop ? ((a.orientationFallback = "screen"), (a.clickTrampoline = "when-not-mouse")) : ((a.orientationFallback = ""), (a.clickTrampoline = ""));
          var b = this;
          (this._orientationChange = function (a) {
            return b.orientationChange(a);
          }),
            (this._windowResize = function (a) {
              return b.windowResize(a);
            }),
            window.addEventListener("orientationchange", this._orientationChange, !1),
            window.addEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen &&
              ((this._fullScreenChange = function (a) {
                return b.fullScreenChange(a);
              }),
              (this._fullScreenError = function (a) {
                return b.fullScreenError(a);
              }),
              document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
              document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1),
              document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1),
              document.addEventListener("fullscreenchange", this._fullScreenChange, !1),
              document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1),
              document.addEventListener("mozfullscreenerror", this._fullScreenError, !1),
              document.addEventListener("MSFullscreenError", this._fullScreenError, !1),
              document.addEventListener("fullscreenerror", this._fullScreenError, !1)),
            this.game.onResume.add(this._gameResumed, this),
            this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.setGameSize(this.game.width, this.game.height),
            (this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback)),
            c.FlexGrid && (this.grid = new c.FlexGrid(this, this.width, this.height)),
            (this._booted = !0),
            null !== this._pendingScaleMode && ((this.scaleMode = this._pendingScaleMode), (this._pendingScaleMode = null));
        },
        parseConfig: function (a) {
          void 0 !== a.scaleMode && (this._booted ? (this.scaleMode = a.scaleMode) : (this._pendingScaleMode = a.scaleMode)),
            void 0 !== a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode),
            a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget);
        },
        setupScale: function (a, b) {
          var d,
            e = new c.Rectangle();
          "" !== this.game.parent && ("string" == typeof this.game.parent ? (d = document.getElementById(this.game.parent)) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)),
            d
              ? ((this.parentNode = d),
                (this.parentIsWindow = !1),
                this.getParentBounds(this._parentBounds),
                (e.width = this._parentBounds.width),
                (e.height = this._parentBounds.height),
                this.offset.set(this._parentBounds.x, this._parentBounds.y))
              : ((this.parentNode = null), (this.parentIsWindow = !0), (e.width = this.dom.visualBounds.width), (e.height = this.dom.visualBounds.height), this.offset.set(0, 0));
          var f = 0,
            g = 0;
          "number" == typeof a ? (f = a) : ((this.parentScaleFactor.x = parseInt(a, 10) / 100), (f = e.width * this.parentScaleFactor.x)),
            "number" == typeof b ? (g = b) : ((this.parentScaleFactor.y = parseInt(b, 10) / 100), (g = e.height * this.parentScaleFactor.y)),
            (f = Math.floor(f)),
            (g = Math.floor(g)),
            this._gameSize.setTo(0, 0, f, g),
            this.updateDimensions(f, g, !1);
        },
        _gameResumed: function () {
          this.queueUpdate(!0);
        },
        setGameSize: function (a, b) {
          this._gameSize.setTo(0, 0, a, b), this.currentScaleMode !== c.ScaleManager.RESIZE && this.updateDimensions(a, b, !0), this.queueUpdate(!0);
        },
        setUserScale: function (a, b, c, d) {
          this._userScaleFactor.setTo(a, b), this._userScaleTrim.setTo(0 | c, 0 | d), this.queueUpdate(!0);
        },
        setResizeCallback: function (a, b) {
          (this.onResize = a), (this.onResizeContext = b);
        },
        signalSizeChange: function () {
          if (!c.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !c.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
            var a = this.width,
              b = this.height;
            this._lastReportedCanvasSize.setTo(0, 0, a, b),
              this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height),
              this.grid && this.grid.onResize(a, b),
              this.onSizeChange.dispatch(this, a, b),
              this.currentScaleMode === c.ScaleManager.RESIZE && (this.game.state.resize(a, b), this.game.load.resize(a, b));
          }
        },
        setMinMax: function (a, b, c, d) {
          (this.minWidth = a), (this.minHeight = b), "undefined" != typeof c && (this.maxWidth = c), "undefined" != typeof d && (this.maxHeight = d);
        },
        preUpdate: function () {
          if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
            var a = this._updateThrottle;
            (this._updateThrottleReset = a >= 400 ? 0 : 100), this.dom.getOffset(this.game.canvas, this.offset);
            var b = this._parentBounds.width,
              d = this._parentBounds.height,
              e = this.getParentBounds(this._parentBounds),
              f = e.width !== b || e.height !== d,
              g = this.updateOrientationState();
            (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e), this.updateLayout(), this.signalSizeChange());
            var h = 2 * this._updateThrottle;
            this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)), (this._updateThrottle = c.Math.clamp(h, 25, this.trackParentInterval)), (this._lastUpdate = this.game.time.time);
          }
        },
        pauseUpdate: function () {
          this.preUpdate(), (this._updateThrottle = this.trackParentInterval);
        },
        updateDimensions: function (a, b, c) {
          (this.width = a * this.parentScaleFactor.x),
            (this.height = b * this.parentScaleFactor.y),
            (this.game.width = this.width),
            (this.game.height = this.height),
            (this.sourceAspectRatio = this.width / this.height),
            this.updateScalingAndBounds(),
            c && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height));
        },
        updateScalingAndBounds: function () {
          (this.scaleFactor.x = this.game.width / this.width),
            (this.scaleFactor.y = this.game.height / this.height),
            (this.scaleFactorInversed.x = this.width / this.game.width),
            (this.scaleFactorInversed.y = this.height / this.game.height),
            (this.aspectRatio = this.width / this.height),
            this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
        },
        forceOrientation: function (a, b) {
          void 0 === b && (b = !1), (this.forceLandscape = a), (this.forcePortrait = b), this.queueUpdate(!0);
        },
        classifyOrientation: function (a) {
          return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null;
        },
        updateOrientationState: function () {
          var a = this.screenOrientation,
            b = this.incorrectOrientation;
          (this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback)), (this.incorrectOrientation = (this.forceLandscape && !this.isLandscape) || (this.forcePortrait && !this.isPortrait));
          var c = a !== this.screenOrientation,
            d = b !== this.incorrectOrientation;
          return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (c || d) && this.onOrientationChange.dispatch(this, a, b), c || d;
        },
        orientationChange: function (a) {
          (this.event = a), this.queueUpdate(!0);
        },
        windowResize: function (a) {
          (this.event = a), this.queueUpdate(!0);
        },
        scrollTop: function () {
          var a = this.compatibility.scrollTo;
          a && window.scrollTo(a.x, a.y);
        },
        refresh: function () {
          this.scrollTop(), this.queueUpdate(!0);
        },
        updateLayout: function () {
          var a = this.currentScaleMode;
          if (a === c.ScaleManager.RESIZE) return void this.reflowGame();
          if (
            (this.scrollTop(),
            this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"),
            this.incorrectOrientation
              ? this.setMaximum()
              : a === c.ScaleManager.EXACT_FIT
              ? this.setExactFit()
              : a === c.ScaleManager.SHOW_ALL
              ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent
                ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll())
                : this.setShowAll()
              : a === c.ScaleManager.NO_SCALE
              ? ((this.width = this.game.width), (this.height = this.game.height))
              : a === c.ScaleManager.USER_SCALE && ((this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x), (this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y)),
            !this.compatibility.canExpandParent && (a === c.ScaleManager.SHOW_ALL || a === c.ScaleManager.USER_SCALE))
          ) {
            var b = this.getParentBounds(this._tempBounds);
            (this.width = Math.min(this.width, b.width)), (this.height = Math.min(this.height, b.height));
          }
          (this.width = 0 | this.width), (this.height = 0 | this.height), this.reflowCanvas();
        },
        getParentBounds: function (a) {
          var b = a || new c.Rectangle(),
            d = this.boundingParent,
            e = this.dom.visualBounds,
            f = this.dom.layoutBounds;
          if (d) {
            var g = d.getBoundingClientRect(),
              h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
            b.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
            var i = this.windowConstraints;
            if (i.right) {
              var j = "layout" === i.right ? f : e;
              b.right = Math.min(b.right, j.width);
            }
            if (i.bottom) {
              var j = "layout" === i.bottom ? f : e;
              b.bottom = Math.min(b.bottom, j.height);
            }
          } else b.setTo(0, 0, e.width, e.height);
          return b.setTo(Math.round(b.x), Math.round(b.y), Math.round(b.width), Math.round(b.height)), b;
        },
        alignCanvas: function (a, b) {
          var c = this.getParentBounds(this._tempBounds),
            d = this.game.canvas,
            e = this.margin;
          if (a) {
            e.left = e.right = 0;
            var f = d.getBoundingClientRect();
            if (this.width < c.width && !this.incorrectOrientation) {
              var g = f.left - c.x,
                h = c.width / 2 - this.width / 2;
              h = Math.max(h, 0);
              var i = h - g;
              e.left = Math.round(i);
            }
            (d.style.marginLeft = e.left + "px"), 0 !== e.left && ((e.right = -(c.width - f.width - e.left)), (d.style.marginRight = e.right + "px"));
          }
          if (b) {
            e.top = e.bottom = 0;
            var f = d.getBoundingClientRect();
            if (this.height < c.height && !this.incorrectOrientation) {
              var g = f.top - c.y,
                h = c.height / 2 - this.height / 2;
              h = Math.max(h, 0);
              var i = h - g;
              e.top = Math.round(i);
            }
            (d.style.marginTop = e.top + "px"), 0 !== e.top && ((e.bottom = -(c.height - f.height - e.top)), (d.style.marginBottom = e.bottom + "px"));
          }
          (e.x = e.left), (e.y = e.top);
        },
        reflowGame: function () {
          this.resetCanvas("", "");
          var a = this.getParentBounds(this._tempBounds);
          this.updateDimensions(a.width, a.height, !0);
        },
        reflowCanvas: function () {
          this.incorrectOrientation || ((this.width = c.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width)), (this.height = c.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height))),
            this.resetCanvas(),
            this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)),
            this.updateScalingAndBounds();
        },
        resetCanvas: function (a, b) {
          void 0 === a && (a = this.width + "px"), void 0 === b && (b = this.height + "px");
          var c = this.game.canvas;
          this.compatibility.noMargins || ((c.style.marginLeft = ""), (c.style.marginTop = ""), (c.style.marginRight = ""), (c.style.marginBottom = "")), (c.style.width = a), (c.style.height = b);
        },
        queueUpdate: function (a) {
          a && ((this._parentBounds.width = 0), (this._parentBounds.height = 0)), (this._updateThrottle = this._updateThrottleReset);
        },
        reset: function (a) {
          a && this.grid && this.grid.reset();
        },
        setMaximum: function () {
          (this.width = this.dom.visualBounds.width), (this.height = this.dom.visualBounds.height);
        },
        setShowAll: function (a) {
          var b,
            c = this.getParentBounds(this._tempBounds),
            d = c.width,
            e = c.height;
          (b = a ? Math.max(e / this.game.height, d / this.game.width) : Math.min(e / this.game.height, d / this.game.width)), (this.width = Math.round(this.game.width * b)), (this.height = Math.round(this.game.height * b));
        },
        setExactFit: function () {
          var a = this.getParentBounds(this._tempBounds);
          (this.width = a.width), (this.height = a.height), this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)));
        },
        createFullScreenTarget: function () {
          var a = document.createElement("div");
          return (a.style.margin = "0"), (a.style.padding = "0"), (a.style.background = "#000"), a;
        },
        startFullScreen: function (a, b) {
          if (this.isFullScreen) return !1;
          if (!this.compatibility.supportsFullScreen) {
            var d = this;
            return void setTimeout(function () {
              d.fullScreenError();
            }, 10);
          }
          if ("when-not-mouse" === this.compatibility.clickTrampoline) {
            var e = this.game.input;
            if (e.activePointer && e.activePointer !== e.mousePointer && (b || b !== !1)) return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [a, !1]);
          }
          void 0 !== a && this.game.renderType === c.CANVAS && (this.game.stage.smoothed = a);
          var f = this.fullScreenTarget;
          f || (this.cleanupCreatedTarget(), (this._createdFullScreenTarget = this.createFullScreenTarget()), (f = this._createdFullScreenTarget));
          var g = { targetElement: f };
          if (((this.hasPhaserSetFullScreen = !0), this.onFullScreenInit.dispatch(this, g), this._createdFullScreenTarget)) {
            var h = this.game.canvas,
              i = h.parentNode;
            i.insertBefore(f, h), f.appendChild(h);
          }
          return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](), !0;
        },
        stopFullScreen: function () {
          return !(!this.isFullScreen || !this.compatibility.supportsFullScreen || ((this.hasPhaserSetFullScreen = !1), document[this.game.device.cancelFullscreen](), 0));
        },
        cleanupCreatedTarget: function () {
          var a = this._createdFullScreenTarget;
          if (a && a.parentNode) {
            var b = a.parentNode;
            b.insertBefore(this.game.canvas, a), b.removeChild(a);
          }
          this._createdFullScreenTarget = null;
        },
        prepScreenMode: function (a) {
          var b = !!this._createdFullScreenTarget,
            d = this._createdFullScreenTarget || this.fullScreenTarget;
          a
            ? (b || this.fullScreenScaleMode === c.ScaleManager.EXACT_FIT) &&
              d !== this.game.canvas &&
              ((this._fullScreenRestore = { targetWidth: d.style.width, targetHeight: d.style.height }), (d.style.width = "100%"), (d.style.height = "100%"))
            : (this._fullScreenRestore && ((d.style.width = this._fullScreenRestore.targetWidth), (d.style.height = this._fullScreenRestore.targetHeight), (this._fullScreenRestore = null)),
              this.updateDimensions(this._gameSize.width, this._gameSize.height, !0),
              this.resetCanvas());
        },
        fullScreenChange: function (a) {
          (this.event = a),
            this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)),
            this.onFullScreenChange.dispatch(this, this.width, this.height);
        },
        fullScreenError: function (a) {
          (this.event = a), this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this);
        },
        scaleSprite: function (a, b, c, d) {
          if ((void 0 === b && (b = this.width), void 0 === c && (c = this.height), void 0 === d && (d = !1), !a || !a.scale)) return a;
          if (((a.scale.x = 1), (a.scale.y = 1), a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0)) return a;
          var e = b,
            f = (a.height * b) / a.width,
            g = (a.width * c) / a.height,
            h = c,
            i = g > b;
          return (i = i ? d : !d), i ? ((a.width = Math.floor(e)), (a.height = Math.floor(f))) : ((a.width = Math.floor(g)), (a.height = Math.floor(h))), a;
        },
        destroy: function () {
          this.game.onResume.remove(this._gameResumed, this),
            window.removeEventListener("orientationchange", this._orientationChange, !1),
            window.removeEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen &&
              (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
              document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1),
              document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1),
              document.removeEventListener("fullscreenchange", this._fullScreenChange, !1),
              document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1),
              document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1),
              document.removeEventListener("MSFullscreenError", this._fullScreenError, !1),
              document.removeEventListener("fullscreenerror", this._fullScreenError, !1));
        },
      }),
      (c.ScaleManager.prototype.constructor = c.ScaleManager),
      Object.defineProperty(c.ScaleManager.prototype, "boundingParent", {
        get: function () {
          if (this.parentIsWindow || (this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget)) return null;
          var a = this.game.canvas && this.game.canvas.parentNode;
          return a || null;
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "scaleMode", {
        get: function () {
          return this._scaleMode;
        },
        set: function (a) {
          return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), (this._scaleMode = a)), this._scaleMode;
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function () {
          return this._fullScreenScaleMode;
        },
        set: function (a) {
          return (
            a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), (this._fullScreenScaleMode = a), this.prepScreenMode(!0), this.queueUpdate(!0)) : (this._fullScreenScaleMode = a)), this._fullScreenScaleMode
          );
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "currentScaleMode", {
        get: function () {
          return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function () {
          return this._pageAlignHorizontally;
        },
        set: function (a) {
          a !== this._pageAlignHorizontally && ((this._pageAlignHorizontally = a), this.queueUpdate(!0));
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "pageAlignVertically", {
        get: function () {
          return this._pageAlignVertically;
        },
        set: function (a) {
          a !== this._pageAlignVertically && ((this._pageAlignVertically = a), this.queueUpdate(!0));
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "isFullScreen", {
        get: function () {
          return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "isPortrait", {
        get: function () {
          return "portrait" === this.classifyOrientation(this.screenOrientation);
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "isLandscape", {
        get: function () {
          return "landscape" === this.classifyOrientation(this.screenOrientation);
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "isGamePortrait", {
        get: function () {
          return this.height > this.width;
        },
      }),
      Object.defineProperty(c.ScaleManager.prototype, "isGameLandscape", {
        get: function () {
          return this.width > this.height;
        },
      }),
      (c.Utils.Debug = function (a) {
        (this.game = a),
          (this.sprite = null),
          (this.bmd = null),
          (this.canvas = null),
          (this.context = null),
          (this.font = "14px Courier"),
          (this.columnWidth = 100),
          (this.lineHeight = 16),
          (this.renderShadow = !0),
          (this.currentX = 0),
          (this.currentY = 0),
          (this.currentAlpha = 1),
          (this.dirty = !1);
      }),
      (c.Utils.Debug.prototype = {
        boot: function () {
          this.game.renderType === c.CANVAS
            ? (this.context = this.game.context)
            : ((this.bmd = new c.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0)),
              (this.sprite = this.game.make.image(0, 0, this.bmd)),
              this.game.stage.addChild(this.sprite),
              this.game.scale.onSizeChange.add(this.resize, this),
              (this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height)),
              (this.context = this.canvas.getContext("2d")));
        },
        resize: function (a, b, c) {
          this.bmd.resize(b, c), (this.canvas.width = b), (this.canvas.height = c);
        },
        preUpdate: function () {
          this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), (this.dirty = !1));
        },
        reset: function () {
          this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear();
        },
        start: function (a, b, c, d) {
          "number" != typeof a && (a = 0),
            "number" != typeof b && (b = 0),
            (c = c || "rgb(255,255,255)"),
            void 0 === d && (d = 0),
            (this.currentX = a),
            (this.currentY = b),
            (this.currentColor = c),
            (this.columnWidth = d),
            (this.dirty = !0),
            this.context.save(),
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            (this.context.strokeStyle = c),
            (this.context.fillStyle = c),
            (this.context.font = this.font),
            (this.context.globalAlpha = this.currentAlpha);
        },
        stop: function () {
          this.context.restore();
        },
        line: function () {
          for (var a = this.currentX, b = 0; b < arguments.length; b++)
            this.renderShadow && ((this.context.fillStyle = "rgb(0,0,0)"), this.context.fillText(arguments[b], a + 1, this.currentY + 1), (this.context.fillStyle = this.currentColor)),
              this.context.fillText(arguments[b], a, this.currentY),
              (a += this.columnWidth);
          this.currentY += this.lineHeight;
        },
        soundInfo: function (a, b, c, d) {
          this.start(b, c, d),
            this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked),
            this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback),
            this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding),
            this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying),
            this.line("Time: " + a.currentTime),
            this.line("Volume: " + a.volume + " Muted: " + a.mute),
            this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag),
            "" !== a.currentMarker &&
              (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"),
              this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop),
              this.line("Position: " + a.position)),
            this.stop();
        },
        cameraInfo: function (a, b, c, d) {
          this.start(b, c, d),
            this.line("Camera (" + a.width + " x " + a.height + ")"),
            this.line("X: " + a.x + " Y: " + a.y),
            a.bounds && this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height),
            this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height),
            this.line("Total in view: " + a.totalInView),
            this.stop();
        },
        timer: function (a, b, c, d) {
          this.start(b, c, d),
            this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"),
            this.line("Next Tick: " + a.next + " Duration: " + a.duration),
            this.line("Paused: " + a.paused + " Length: " + a.length),
            this.stop();
        },
        pointer: function (a, b, c, d, e) {
          null != a &&
            (void 0 === b && (b = !1),
            (c = c || "rgba(0,255,0,0.5)"),
            (d = d || "rgba(255,0,0,0.5)"),
            (b === !0 && a.isUp === !0) ||
              (this.start(a.x, a.y - 100, e),
              this.context.beginPath(),
              this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI),
              a.active ? (this.context.fillStyle = c) : (this.context.fillStyle = d),
              this.context.fill(),
              this.context.closePath(),
              this.context.beginPath(),
              this.context.moveTo(a.positionDown.x, a.positionDown.y),
              this.context.lineTo(a.position.x, a.position.y),
              (this.context.lineWidth = 2),
              this.context.stroke(),
              this.context.closePath(),
              this.line("ID: " + a.id + " Active: " + a.active),
              this.line("World X: " + a.worldX + " World Y: " + a.worldY),
              this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame),
              this.line("Duration: " + a.duration + " ms"),
              this.line("is Down: " + a.isDown + " is Up: " + a.isUp),
              this.stop()));
        },
        spriteInputInfo: function (a, b, c, d) {
          this.start(b, c, d),
            this.line("Sprite Input: (" + a.width + " x " + a.height + ")"),
            this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)),
            this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)),
            this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)),
            this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()),
            this.stop();
        },
        key: function (a, b, c, d) {
          this.start(b, c, d, 150), this.line("Key:", a.keyCode, "isDown:", a.isDown), this.line("justDown:", a.justDown, "justUp:", a.justUp), this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)), this.stop();
        },
        inputInfo: function (a, b, c) {
          this.start(a, b, c),
            this.line("Input"),
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y),
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY),
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)),
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY),
            this.stop();
        },
        spriteBounds: function (a, b, c) {
          var d = a.getBounds();
          (d.x += this.game.camera.x), (d.y += this.game.camera.y), this.rectangle(d, b, c);
        },
        ropeSegments: function (a, b, c) {
          var d = a.segments,
            e = this;
          d.forEach(function (a) {
            e.rectangle(a, b, c);
          }, this);
        },
        spriteInfo: function (a, b, c, d) {
          this.start(b, c, d),
            this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y),
            this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)),
            this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)),
            this.line("visible: " + a.visible + " in camera: " + a.inCamera),
            this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)),
            this.stop();
        },
        spriteCoords: function (a, b, c, d) {
          this.start(b, c, d, 100),
            a.name && this.line(a.name),
            this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)),
            this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)),
            this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)),
            this.stop();
        },
        lineInfo: function (a, b, c, d) {
          this.start(b, c, d, 80),
            this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)),
            this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)),
            this.line("length:", a.length.toFixed(2), "angle:", a.angle),
            this.stop();
        },
        pixel: function (a, b, c, d) {
          (d = d || 2), this.start(), (this.context.fillStyle = c), this.context.fillRect(a, b, d, d), this.stop();
        },
        geom: function (a, b, d, e) {
          void 0 === d && (d = !0),
            void 0 === e && (e = 0),
            (b = b || "rgba(0,255,0,0.4)"),
            this.start(),
            (this.context.fillStyle = b),
            (this.context.strokeStyle = b),
            a instanceof c.Rectangle || 1 === e
              ? d
                ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)
                : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)
              : a instanceof c.Circle || 2 === e
              ? (this.context.beginPath(), this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1), this.context.closePath(), d ? this.context.fill() : this.context.stroke())
              : a instanceof c.Point || 3 === e
              ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4)
              : (a instanceof c.Line || 4 === e) &&
                ((this.context.lineWidth = 1),
                this.context.beginPath(),
                this.context.moveTo(a.start.x + 0.5 - this.game.camera.x, a.start.y + 0.5 - this.game.camera.y),
                this.context.lineTo(a.end.x + 0.5 - this.game.camera.x, a.end.y + 0.5 - this.game.camera.y),
                this.context.closePath(),
                this.context.stroke()),
            this.stop();
        },
        rectangle: function (a, b, c) {
          void 0 === c && (c = !0),
            (b = b || "rgba(0, 255, 0, 0.4)"),
            this.start(),
            c
              ? ((this.context.fillStyle = b), this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height))
              : ((this.context.strokeStyle = b), this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)),
            this.stop();
        },
        text: function (a, b, c, d, e) {
          (d = d || "rgb(255,255,255)"),
            (e = e || "16px Courier"),
            this.start(),
            (this.context.font = e),
            this.renderShadow && ((this.context.fillStyle = "rgb(0,0,0)"), this.context.fillText(a, b + 1, c + 1)),
            (this.context.fillStyle = d),
            this.context.fillText(a, b, c),
            this.stop();
        },
        quadTree: function (a, b) {
          (b = b || "rgba(255,0,0,0.3)"), this.start();
          var c = a.bounds;
          if (0 === a.nodes.length) {
            (this.context.strokeStyle = b), this.context.strokeRect(c.x, c.y, c.width, c.height), this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"), (this.context.strokeStyle = "rgb(0,255,0)");
            for (var d = 0; d < a.objects.length; d++) this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height);
          } else for (var d = 0; d < a.nodes.length; d++) this.quadTree(a.nodes[d]);
          this.stop();
        },
        body: function (a, b, d) {
          a.body &&
            (this.start(),
            a.body.type === c.Physics.ARCADE
              ? c.Physics.Arcade.Body.render(this.context, a.body, b, d)
              : a.body.type === c.Physics.NINJA
              ? c.Physics.Ninja.Body.render(this.context, a.body, b, d)
              : a.body.type === c.Physics.BOX2D && c.Physics.Box2D.renderBody(this.context, a.body, b),
            this.stop());
        },
        bodyInfo: function (a, b, d, e) {
          a.body && (this.start(b, d, e, 210), a.body.type === c.Physics.ARCADE ? c.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === c.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body), this.stop());
        },
        box2dWorld: function () {
          this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop();
        },
        box2dBody: function (a, b) {
          this.start(), c.Physics.Box2D.renderBody(this.context, a, b), this.stop();
        },
        displayList: function (a) {
          if ((void 0 === a && (a = this.game.world), a.hasOwnProperty("renderOrderID"), void 0, a.children && a.children.length > 0)) for (var b = 0; b < a.children.length; b++) this.game.debug.displayList(a.children[b]);
        },
        destroy: function () {
          PIXI.CanvasPool.remove(this);
        },
      }),
      (c.Utils.Debug.prototype.constructor = c.Utils.Debug),
      (c.DOM = {
        getOffset: function (a, b) {
          b = b || new c.Point();
          var d = a.getBoundingClientRect(),
            e = c.DOM.scrollY,
            f = c.DOM.scrollX,
            g = document.documentElement.clientTop,
            h = document.documentElement.clientLeft;
          return (b.x = d.left + f - h), (b.y = d.top + e - g), b;
        },
        getBounds: function (a, b) {
          return void 0 === b && (b = 0), (a = a && !a.nodeType ? a[0] : a), !(!a || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b);
        },
        calibrate: function (a, b) {
          b = +b || 0;
          var c = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 };
          return (c.width = (c.right = a.right + b) - (c.left = a.left - b)), (c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b)), c;
        },
        getAspectRatio: function (a) {
          a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
          var b = a.width,
            c = a.height;
          return "function" == typeof b && (b = b.call(a)), "function" == typeof c && (c = c.call(a)), b / c;
        },
        inLayoutViewport: function (a, b) {
          var c = this.getBounds(a, b);
          return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height;
        },
        getScreenOrientation: function (a) {
          var b = window.screen,
            c = b.orientation || b.mozOrientation || b.msOrientation;
          if (c && "string" == typeof c.type) return c.type;
          if ("string" == typeof c) return c;
          var d = "portrait-primary",
            e = "landscape-primary";
          if ("screen" === a) return b.height > b.width ? d : e;
          if ("viewport" === a) return this.visualBounds.height > this.visualBounds.width ? d : e;
          if ("window.orientation" === a && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? d : e;
          if (window.matchMedia) {
            if (window.matchMedia("(orientation: portrait)").matches) return d;
            if (window.matchMedia("(orientation: landscape)").matches) return e;
          }
          return this.visualBounds.height > this.visualBounds.width ? d : e;
        },
        visualBounds: new c.Rectangle(),
        layoutBounds: new c.Rectangle(),
        documentBounds: new c.Rectangle(),
      }),
      c.Device.whenReady(
        function (a) {
          var b =
              window && "pageXOffset" in window
                ? function () {
                    return window.pageXOffset;
                  }
                : function () {
                    return document.documentElement.scrollLeft;
                  },
            d =
              window && "pageYOffset" in window
                ? function () {
                    return window.pageYOffset;
                  }
                : function () {
                    return document.documentElement.scrollTop;
                  };
          Object.defineProperty(c.DOM, "scrollX", { get: b }),
            Object.defineProperty(c.DOM, "scrollY", { get: d }),
            Object.defineProperty(c.DOM.visualBounds, "x", { get: b }),
            Object.defineProperty(c.DOM.visualBounds, "y", { get: d }),
            Object.defineProperty(c.DOM.layoutBounds, "x", { value: 0 }),
            Object.defineProperty(c.DOM.layoutBounds, "y", { value: 0 });
          var e = a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
          if (e) {
            var f = function () {
                return Math.max(window.innerWidth, document.documentElement.clientWidth);
              },
              g = function () {
                return Math.max(window.innerHeight, document.documentElement.clientHeight);
              };
            Object.defineProperty(c.DOM.visualBounds, "width", { get: f }),
              Object.defineProperty(c.DOM.visualBounds, "height", { get: g }),
              Object.defineProperty(c.DOM.layoutBounds, "width", { get: f }),
              Object.defineProperty(c.DOM.layoutBounds, "height", { get: g });
          } else
            Object.defineProperty(c.DOM.visualBounds, "width", {
              get: function () {
                return window.innerWidth;
              },
            }),
              Object.defineProperty(c.DOM.visualBounds, "height", {
                get: function () {
                  return window.innerHeight;
                },
              }),
              Object.defineProperty(c.DOM.layoutBounds, "width", {
                get: function () {
                  var a = document.documentElement.clientWidth,
                    b = window.innerWidth;
                  return a < b ? b : a;
                },
              }),
              Object.defineProperty(c.DOM.layoutBounds, "height", {
                get: function () {
                  var a = document.documentElement.clientHeight,
                    b = window.innerHeight;
                  return a < b ? b : a;
                },
              });
          Object.defineProperty(c.DOM.documentBounds, "x", { value: 0 }),
            Object.defineProperty(c.DOM.documentBounds, "y", { value: 0 }),
            Object.defineProperty(c.DOM.documentBounds, "width", {
              get: function () {
                var a = document.documentElement;
                return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth);
              },
            }),
            Object.defineProperty(c.DOM.documentBounds, "height", {
              get: function () {
                var a = document.documentElement;
                return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight);
              },
            });
        },
        null,
        !0
      ),
      (c.ArraySet = function (a) {
        (this.position = 0), (this.list = a || []);
      }),
      (c.ArraySet.prototype = {
        add: function (a) {
          return this.exists(a) || this.list.push(a), a;
        },
        getIndex: function (a) {
          return this.list.indexOf(a);
        },
        getByKey: function (a, b) {
          for (var c = this.list.length; c--; ) if (this.list[c][a] === b) return this.list[c];
          return null;
        },
        exists: function (a) {
          return this.list.indexOf(a) > -1;
        },
        reset: function () {
          this.list.length = 0;
        },
        remove: function (a) {
          var b = this.list.indexOf(a);
          if (b > -1) return this.list.splice(b, 1), a;
        },
        setAll: function (a, b) {
          for (var c = this.list.length; c--; ) this.list[c] && (this.list[c][a] = b);
        },
        callAll: function (a) {
          for (var b = Array.prototype.slice.call(arguments, 1), c = this.list.length; c--; ) this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b);
        },
        removeAll: function (a) {
          void 0 === a && (a = !1);
          for (var b = this.list.length; b--; )
            if (this.list[b]) {
              var c = this.remove(this.list[b]);
              a && c.destroy();
            }
          (this.position = 0), (this.list = []);
        },
      }),
      Object.defineProperty(c.ArraySet.prototype, "total", {
        get: function () {
          return this.list.length;
        },
      }),
      Object.defineProperty(c.ArraySet.prototype, "first", {
        get: function () {
          return (this.position = 0), this.list.length > 0 ? this.list[0] : null;
        },
      }),
      Object.defineProperty(c.ArraySet.prototype, "next", {
        get: function () {
          return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
        },
      }),
      (c.ArraySet.prototype.constructor = c.ArraySet),
      (c.ArrayUtils = {
        getRandomItem: function (a, b, c) {
          if (null === a) return null;
          void 0 === b && (b = 0), void 0 === c && (c = a.length);
          var d = b + Math.floor(Math.random() * c);
          return void 0 === a[d] ? null : a[d];
        },
        removeRandomItem: function (a, b, c) {
          if (null == a) return null;
          void 0 === b && (b = 0), void 0 === c && (c = a.length);
          var d = b + Math.floor(Math.random() * c);
          if (d < a.length) {
            var e = a.splice(d, 1);
            return void 0 === e[0] ? null : e[0];
          }
          return null;
        },
        shuffle: function (a) {
          for (var b = a.length - 1; b > 0; b--) {
            var c = Math.floor(Math.random() * (b + 1)),
              d = a[b];
            (a[b] = a[c]), (a[c] = d);
          }
          return a;
        },
        transposeMatrix: function (a) {
          for (var b = a.length, c = a[0].length, d = new Array(c), e = 0; e < c; e++) {
            d[e] = new Array(b);
            for (var f = b - 1; f > -1; f--) d[e][f] = a[f][e];
          }
          return d;
        },
        rotateMatrix: function (a, b) {
          if (("string" != typeof b && (b = ((b % 360) + 360) % 360), 90 === b || b === -270 || "rotateLeft" === b)) (a = c.ArrayUtils.transposeMatrix(a)), (a = a.reverse());
          else if (b === -90 || 270 === b || "rotateRight" === b) (a = a.reverse()), (a = c.ArrayUtils.transposeMatrix(a));
          else if (180 === Math.abs(b) || "rotate180" === b) {
            for (var d = 0; d < a.length; d++) a[d].reverse();
            a = a.reverse();
          }
          return a;
        },
        findClosest: function (a, b) {
          if (!b.length) return NaN;
          if (1 === b.length || a < b[0]) return b[0];
          for (var c = 1; b[c] < a; ) c++;
          var d = b[c - 1],
            e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
          return e - a <= a - d ? e : d;
        },
        rotateRight: function (a) {
          var b = a.pop();
          return a.unshift(b), b;
        },
        rotateLeft: function (a) {
          var b = a.shift();
          return a.push(b), b;
        },
        rotate: function (a) {
          var b = a.shift();
          return a.push(b), b;
        },
        numberArray: function (a, b) {
          for (var c = [], d = a; d <= b; d++) c.push(d);
          return c;
        },
        numberArrayStep: function (a, b, d) {
          (void 0 !== a && null !== a) || (a = 0), (void 0 !== b && null !== b) || ((b = a), (a = 0)), void 0 === d && (d = 1);
          for (var e = [], f = Math.max(c.Math.roundAwayFromZero((b - a) / (d || 1)), 0), g = 0; g < f; g++) e.push(a), (a += d);
          return e;
        },
      }),
      (c.LinkedList = function () {
        (this.next = null), (this.prev = null), (this.first = null), (this.last = null), (this.total = 0);
      }),
      (c.LinkedList.prototype = {
        add: function (a) {
          return 0 === this.total && null === this.first && null === this.last
            ? ((this.first = a), (this.last = a), (this.next = a), (a.prev = this), this.total++, a)
            : ((this.last.next = a), (a.prev = this.last), (this.last = a), this.total++, a);
        },
        reset: function () {
          (this.first = null), (this.last = null), (this.next = null), (this.prev = null), (this.total = 0);
        },
        remove: function (a) {
          return 1 === this.total
            ? (this.reset(), void (a.next = a.prev = null))
            : (a === this.first ? (this.first = this.first.next) : a === this.last && (this.last = this.last.prev),
              a.prev && (a.prev.next = a.next),
              a.next && (a.next.prev = a.prev),
              (a.next = a.prev = null),
              null === this.first && (this.last = null),
              void this.total--);
        },
        callAll: function (a) {
          if (this.first && this.last) {
            var b = this.first;
            do b && b[a] && b[a].call(b), (b = b.next);
            while (b !== this.last.next);
          }
        },
      }),
      (c.LinkedList.prototype.constructor = c.LinkedList),
      (c.Create = function (a) {
        (this.game = a),
          (this.bmd = null),
          (this.canvas = null),
          (this.ctx = null),
          (this.palettes = [
            { 0: "#000", 1: "#9D9D9D", 2: "#FFF", 3: "#BE2633", 4: "#E06F8B", 5: "#493C2B", 6: "#A46422", 7: "#EB8931", 8: "#F7E26B", 9: "#2F484E", A: "#44891A", B: "#A3CE27", C: "#1B2632", D: "#005784", E: "#31A2F2", F: "#B2DCEF" },
            { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#f5f4eb" },
            { 0: "#000", 1: "#2234d1", 2: "#0c7e45", 3: "#44aacc", 4: "#8a3622", 5: "#5c2e78", 6: "#aa5c3d", 7: "#b5b5b5", 8: "#5e606e", 9: "#4c81fb", A: "#6cd947", B: "#7be2f9", C: "#eb8a60", D: "#e23d69", E: "#ffd93f", F: "#fff" },
            { 0: "#000", 1: "#fff", 2: "#8b4131", 3: "#7bbdc5", 4: "#8b41ac", 5: "#6aac41", 6: "#3931a4", 7: "#d5de73", 8: "#945a20", 9: "#5a4100", A: "#bd736a", B: "#525252", C: "#838383", D: "#acee8b", E: "#7b73de", F: "#acacac" },
            { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#fff" },
          ]);
      }),
      (c.Create.PALETTE_ARNE = 0),
      (c.Create.PALETTE_JMP = 1),
      (c.Create.PALETTE_CGA = 2),
      (c.Create.PALETTE_C64 = 3),
      (c.Create.PALETTE_JAPANESE_MACHINE = 4),
      (c.Create.prototype = {
        texture: function (a, b, c, d, e) {
          void 0 === c && (c = 8), void 0 === d && (d = c), void 0 === e && (e = 0);
          var f = b[0].length * c,
            g = b.length * d;
          null === this.bmd && ((this.bmd = this.game.make.bitmapData()), (this.canvas = this.bmd.canvas), (this.ctx = this.bmd.context)), this.bmd.resize(f, g), this.bmd.clear();
          for (var h = 0; h < b.length; h++)
            for (var i = b[h], j = 0; j < i.length; j++) {
              var k = i[j];
              "." !== k && " " !== k && ((this.ctx.fillStyle = this.palettes[e][k]), this.ctx.fillRect(j * c, h * d, c, d));
            }
          return this.bmd.generateTexture(a);
        },
        grid: function (a, b, c, d, e, f) {
          null === this.bmd && ((this.bmd = this.game.make.bitmapData()), (this.canvas = this.bmd.canvas), (this.ctx = this.bmd.context)), this.bmd.resize(b, c), (this.ctx.fillStyle = f);
          for (var g = 0; g < c; g += e) this.ctx.fillRect(0, g, b, 1);
          for (var h = 0; h < b; h += d) this.ctx.fillRect(h, 0, 1, c);
          return this.bmd.generateTexture(a);
        },
      }),
      (c.Create.prototype.constructor = c.Create),
      (c.FlexGrid = function (a, b, d) {
        (this.game = a.game),
          (this.manager = a),
          (this.width = b),
          (this.height = d),
          (this.boundsCustom = new c.Rectangle(0, 0, b, d)),
          (this.boundsFluid = new c.Rectangle(0, 0, b, d)),
          (this.boundsFull = new c.Rectangle(0, 0, b, d)),
          (this.boundsNone = new c.Rectangle(0, 0, b, d)),
          (this.positionCustom = new c.Point(0, 0)),
          (this.positionFluid = new c.Point(0, 0)),
          (this.positionFull = new c.Point(0, 0)),
          (this.positionNone = new c.Point(0, 0)),
          (this.scaleCustom = new c.Point(1, 1)),
          (this.scaleFluid = new c.Point(1, 1)),
          (this.scaleFluidInversed = new c.Point(1, 1)),
          (this.scaleFull = new c.Point(1, 1)),
          (this.scaleNone = new c.Point(1, 1)),
          (this.customWidth = 0),
          (this.customHeight = 0),
          (this.customOffsetX = 0),
          (this.customOffsetY = 0),
          (this.ratioH = b / d),
          (this.ratioV = d / b),
          (this.multiplier = 0),
          (this.layers = []);
      }),
      (c.FlexGrid.prototype = {
        setSize: function (a, b) {
          (this.width = a), (this.height = b), (this.ratioH = a / b), (this.ratioV = b / a), (this.scaleNone = new c.Point(1, 1)), (this.boundsNone.width = this.width), (this.boundsNone.height = this.height), this.refresh();
        },
        createCustomLayer: function (a, b, d, e) {
          void 0 === e && (e = !0), (this.customWidth = a), (this.customHeight = b), (this.boundsCustom.width = a), (this.boundsCustom.height = b);
          var f = new c.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
          return e && this.game.world.add(f), this.layers.push(f), "undefined" != typeof d && null !== typeof d && f.addMultiple(d), f;
        },
        createFluidLayer: function (a, b) {
          void 0 === b && (b = !0);
          var d = new c.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
          return b && this.game.world.add(d), this.layers.push(d), "undefined" != typeof a && null !== typeof a && d.addMultiple(a), d;
        },
        createFullLayer: function (a) {
          var b = new c.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
          return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b;
        },
        createFixedLayer: function (a) {
          var b = new c.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
          return this.game.world.add(b), this.layers.push(b), "undefined" != typeof a && b.addMultiple(a), b;
        },
        reset: function () {
          for (var a = this.layers.length; a--; ) this.layers[a].persist || ((this.layers[a].position = null), (this.layers[a].scale = null), this.layers.slice(a, 1));
        },
        onResize: function (a, b) {
          (this.ratioH = a / b), (this.ratioV = b / a), this.refresh(a, b);
        },
        refresh: function () {
          (this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width)),
            (this.boundsFluid.width = Math.round(this.width * this.multiplier)),
            (this.boundsFluid.height = Math.round(this.height * this.multiplier)),
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height),
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height),
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height),
            (this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x)),
            (this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y)),
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y),
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
        },
        fitSprite: function (a) {
          this.manager.scaleSprite(a), (a.x = this.manager.bounds.centerX), (a.y = this.manager.bounds.centerY);
        },
        debug: function () {
          this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1);
        },
      }),
      (c.FlexGrid.prototype.constructor = c.FlexGrid),
      (c.FlexLayer = function (a, b, d, e) {
        c.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1),
          (this.manager = a.manager),
          (this.grid = a),
          (this.persist = !1),
          (this.position = b),
          (this.bounds = d),
          (this.scale = e),
          (this.topLeft = d.topLeft),
          (this.topMiddle = new c.Point(d.halfWidth, 0)),
          (this.topRight = d.topRight),
          (this.bottomLeft = d.bottomLeft),
          (this.bottomMiddle = new c.Point(d.halfWidth, d.bottom)),
          (this.bottomRight = d.bottomRight);
      }),
      (c.FlexLayer.prototype = Object.create(c.Group.prototype)),
      (c.FlexLayer.prototype.constructor = c.FlexLayer),
      (c.FlexLayer.prototype.resize = function () {}),
      (c.FlexLayer.prototype.debug = function () {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16),
          this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1),
          this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"),
          this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"),
          this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
      }),
      (c.Color = {
        packPixel: function (a, b, d, e) {
          return c.Device.LITTLE_ENDIAN ? ((e << 24) | (d << 16) | (b << 8) | a) >>> 0 : ((a << 24) | (b << 16) | (d << 8) | e) >>> 0;
        },
        unpackPixel: function (a, b, d, e) {
          return (
            (void 0 !== b && null !== b) || (b = c.Color.createColor()),
            (void 0 !== d && null !== d) || (d = !1),
            (void 0 !== e && null !== e) || (e = !1),
            c.Device.LITTLE_ENDIAN
              ? ((b.a = (4278190080 & a) >>> 24), (b.b = (16711680 & a) >>> 16), (b.g = (65280 & a) >>> 8), (b.r = 255 & a))
              : ((b.r = (4278190080 & a) >>> 24), (b.g = (16711680 & a) >>> 16), (b.b = (65280 & a) >>> 8), (b.a = 255 & a)),
            (b.color = a),
            (b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a / 255 + ")"),
            d && c.Color.RGBtoHSL(b.r, b.g, b.b, b),
            e && c.Color.RGBtoHSV(b.r, b.g, b.b, b),
            b
          );
        },
        fromRGBA: function (a, b) {
          return b || (b = c.Color.createColor()), (b.r = (4278190080 & a) >>> 24), (b.g = (16711680 & a) >>> 16), (b.b = (65280 & a) >>> 8), (b.a = 255 & a), (b.rgba = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")"), b;
        },
        toRGBA: function (a, b, c, d) {
          return (a << 24) | (b << 16) | (c << 8) | d;
        },
        toABGR: function (a, b, c, d) {
          return ((d << 24) | (c << 16) | (b << 8) | a) >>> 0;
        },
        RGBtoHSL: function (a, b, d, e) {
          e || (e = c.Color.createColor(a, b, d, 1)), (a /= 255), (b /= 255), (d /= 255);
          var f = Math.min(a, b, d),
            g = Math.max(a, b, d);
          if (((e.h = 0), (e.s = 0), (e.l = (g + f) / 2), g !== f)) {
            var h = g - f;
            (e.s = e.l > 0.5 ? h / (2 - g - f) : h / (g + f)), g === a ? (e.h = (b - d) / h + (b < d ? 6 : 0)) : g === b ? (e.h = (d - a) / h + 2) : g === d && (e.h = (a - b) / h + 4), (e.h /= 6);
          }
          return e;
        },
        HSLtoRGB: function (a, b, d, e) {
          if ((e ? ((e.r = d), (e.g = d), (e.b = d)) : (e = c.Color.createColor(d, d, d)), 0 !== b)) {
            var f = d < 0.5 ? d * (1 + b) : d + b - d * b,
              g = 2 * d - f;
            (e.r = c.Color.hueToColor(g, f, a + 1 / 3)), (e.g = c.Color.hueToColor(g, f, a)), (e.b = c.Color.hueToColor(g, f, a - 1 / 3));
          }
          return (e.r = Math.floor((255 * e.r) | 0)), (e.g = Math.floor((255 * e.g) | 0)), (e.b = Math.floor((255 * e.b) | 0)), c.Color.updateColor(e), e;
        },
        RGBtoHSV: function (a, b, d, e) {
          e || (e = c.Color.createColor(a, b, d, 255)), (a /= 255), (b /= 255), (d /= 255);
          var f = Math.min(a, b, d),
            g = Math.max(a, b, d),
            h = g - f;
          return (e.h = 0), (e.s = 0 === g ? 0 : h / g), (e.v = g), g !== f && (g === a ? (e.h = (b - d) / h + (b < d ? 6 : 0)) : g === b ? (e.h = (d - a) / h + 2) : g === d && (e.h = (a - b) / h + 4), (e.h /= 6)), e;
        },
        HSVtoRGB: function (a, b, d, e) {
          void 0 === e && (e = c.Color.createColor(0, 0, 0, 1, a, b, 0, d));
          var f,
            g,
            h,
            i = Math.floor(6 * a),
            j = 6 * a - i,
            k = d * (1 - b),
            l = d * (1 - j * b),
            m = d * (1 - (1 - j) * b);
          switch (i % 6) {
            case 0:
              (f = d), (g = m), (h = k);
              break;
            case 1:
              (f = l), (g = d), (h = k);
              break;
            case 2:
              (f = k), (g = d), (h = m);
              break;
            case 3:
              (f = k), (g = l), (h = d);
              break;
            case 4:
              (f = m), (g = k), (h = d);
              break;
            case 5:
              (f = d), (g = k), (h = l);
          }
          return (e.r = Math.floor(255 * f)), (e.g = Math.floor(255 * g)), (e.b = Math.floor(255 * h)), c.Color.updateColor(e), e;
        },
        hueToColor: function (a, b, c) {
          return c < 0 && (c += 1), c > 1 && (c -= 1), c < 1 / 6 ? a + 6 * (b - a) * c : c < 0.5 ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a;
        },
        createColor: function (a, b, d, e, f, g, h, i) {
          var j = { r: a || 0, g: b || 0, b: d || 0, a: e || 1, h: f || 0, s: g || 0, l: h || 0, v: i || 0, color: 0, color32: 0, rgba: "" };
          return c.Color.updateColor(j);
        },
        updateColor: function (a) {
          return (a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")"), (a.color = c.Color.getColor(a.r, a.g, a.b)), (a.color32 = c.Color.getColor32(255 * a.a, a.r, a.g, a.b)), a;
        },
        getColor32: function (a, b, c, d) {
          return (a << 24) | (b << 16) | (c << 8) | d;
        },
        getColor: function (a, b, c) {
          return (a << 16) | (b << 8) | c;
        },
        RGBtoString: function (a, b, d, e, f) {
          return (
            void 0 === e && (e = 255),
            void 0 === f && (f = "#"),
            "#" === f ? "#" + ((1 << 24) + (a << 16) + (b << 8) + d).toString(16).slice(1) : "0x" + c.Color.componentToHex(e) + c.Color.componentToHex(a) + c.Color.componentToHex(b) + c.Color.componentToHex(d)
          );
        },
        hexToRGB: function (a) {
          var b = c.Color.hexToColor(a);
          if (b) return c.Color.getColor32(b.a, b.r, b.g, b.b);
        },
        hexToColor: function (a, b) {
          a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (a, b, c, d) {
            return b + b + c + c + d + d;
          });
          var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
          if (d) {
            var e = parseInt(d[1], 16),
              f = parseInt(d[2], 16),
              g = parseInt(d[3], 16);
            b ? ((b.r = e), (b.g = f), (b.b = g)) : (b = c.Color.createColor(e, f, g));
          }
          return b;
        },
        webToColor: function (a, b) {
          b || (b = c.Color.createColor());
          var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
          return d && ((b.r = parseInt(d[1], 10)), (b.g = parseInt(d[2], 10)), (b.b = parseInt(d[3], 10)), (b.a = void 0 !== d[4] ? parseFloat(d[4]) : 1), c.Color.updateColor(b)), b;
        },
        valueToColor: function (a, b) {
          if ((b || (b = c.Color.createColor()), "string" == typeof a)) return 0 === a.indexOf("rgb") ? c.Color.webToColor(a, b) : ((b.a = 1), c.Color.hexToColor(a, b));
          if ("number" == typeof a) {
            var d = c.Color.getRGB(a);
            return (b.r = d.r), (b.g = d.g), (b.b = d.b), (b.a = d.a / 255), b;
          }
          return b;
        },
        componentToHex: function (a) {
          var b = a.toString(16);
          return 1 === b.length ? "0" + b : b;
        },
        HSVColorWheel: function (a, b) {
          void 0 === a && (a = 1), void 0 === b && (b = 1);
          for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSVtoRGB(e / 359, a, b));
          return d;
        },
        HSLColorWheel: function (a, b) {
          void 0 === a && (a = 0.5), void 0 === b && (b = 0.5);
          for (var d = [], e = 0; e <= 359; e++) d.push(c.Color.HSLtoRGB(e / 359, a, b));
          return d;
        },
        interpolateColor: function (a, b, d, e, f) {
          void 0 === f && (f = 255);
          var g = c.Color.getRGB(a),
            h = c.Color.getRGB(b),
            i = ((h.red - g.red) * e) / d + g.red,
            j = ((h.green - g.green) * e) / d + g.green,
            k = ((h.blue - g.blue) * e) / d + g.blue;
          return c.Color.getColor32(f, i, j, k);
        },
        interpolateColorWithRGB: function (a, b, d, e, f, g) {
          var h = c.Color.getRGB(a),
            i = ((b - h.red) * g) / f + h.red,
            j = ((d - h.green) * g) / f + h.green,
            k = ((e - h.blue) * g) / f + h.blue;
          return c.Color.getColor(i, j, k);
        },
        interpolateRGB: function (a, b, d, e, f, g, h, i) {
          var j = ((e - a) * i) / h + a,
            k = ((f - b) * i) / h + b,
            l = ((g - d) * i) / h + d;
          return c.Color.getColor(j, k, l);
        },
        getRandomColor: function (a, b, d) {
          if ((void 0 === a && (a = 0), void 0 === b && (b = 255), void 0 === d && (d = 255), b > 255 || a > b)) return c.Color.getColor(255, 255, 255);
          var e = a + Math.round(Math.random() * (b - a)),
            f = a + Math.round(Math.random() * (b - a)),
            g = a + Math.round(Math.random() * (b - a));
          return c.Color.getColor32(d, e, f, g);
        },
        getRGB: function (a) {
          return a > 16777215
            ? { alpha: a >>> 24, red: (a >> 16) & 255, green: (a >> 8) & 255, blue: 255 & a, a: a >>> 24, r: (a >> 16) & 255, g: (a >> 8) & 255, b: 255 & a }
            : { alpha: 255, red: (a >> 16) & 255, green: (a >> 8) & 255, blue: 255 & a, a: 255, r: (a >> 16) & 255, g: (a >> 8) & 255, b: 255 & a };
        },
        getWebRGB: function (a) {
          if ("object" == typeof a) return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
          var b = c.Color.getRGB(a);
          return "rgba(" + b.r.toString() + "," + b.g.toString() + "," + b.b.toString() + "," + (b.a / 255).toString() + ")";
        },
        getAlpha: function (a) {
          return a >>> 24;
        },
        getAlphaFloat: function (a) {
          return (a >>> 24) / 255;
        },
        getRed: function (a) {
          return (a >> 16) & 255;
        },
        getGreen: function (a) {
          return (a >> 8) & 255;
        },
        getBlue: function (a) {
          return 255 & a;
        },
        blendNormal: function (a) {
          return a;
        },
        blendLighten: function (a, b) {
          return b > a ? b : a;
        },
        blendDarken: function (a, b) {
          return b > a ? a : b;
        },
        blendMultiply: function (a, b) {
          return (a * b) / 255;
        },
        blendAverage: function (a, b) {
          return (a + b) / 2;
        },
        blendAdd: function (a, b) {
          return Math.min(255, a + b);
        },
        blendSubtract: function (a, b) {
          return Math.max(0, a + b - 255);
        },
        blendDifference: function (a, b) {
          return Math.abs(a - b);
        },
        blendNegation: function (a, b) {
          return 255 - Math.abs(255 - a - b);
        },
        blendScreen: function (a, b) {
          return 255 - (((255 - a) * (255 - b)) >> 8);
        },
        blendExclusion: function (a, b) {
          return a + b - (2 * a * b) / 255;
        },
        blendOverlay: function (a, b) {
          return b < 128 ? (2 * a * b) / 255 : 255 - (2 * (255 - a) * (255 - b)) / 255;
        },
        blendSoftLight: function (a, b) {
          return b < 128 ? 2 * ((a >> 1) + 64) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b)) / 255;
        },
        blendHardLight: function (a, b) {
          return c.Color.blendOverlay(b, a);
        },
        blendColorDodge: function (a, b) {
          return 255 === b ? b : Math.min(255, (a << 8) / (255 - b));
        },
        blendColorBurn: function (a, b) {
          return 0 === b ? b : Math.max(0, 255 - ((255 - a) << 8) / b);
        },
        blendLinearDodge: function (a, b) {
          return c.Color.blendAdd(a, b);
        },
        blendLinearBurn: function (a, b) {
          return c.Color.blendSubtract(a, b);
        },
        blendLinearLight: function (a, b) {
          return b < 128 ? c.Color.blendLinearBurn(a, 2 * b) : c.Color.blendLinearDodge(a, 2 * (b - 128));
        },
        blendVividLight: function (a, b) {
          return b < 128 ? c.Color.blendColorBurn(a, 2 * b) : c.Color.blendColorDodge(a, 2 * (b - 128));
        },
        blendPinLight: function (a, b) {
          return b < 128 ? c.Color.blendDarken(a, 2 * b) : c.Color.blendLighten(a, 2 * (b - 128));
        },
        blendHardMix: function (a, b) {
          return c.Color.blendVividLight(a, b) < 128 ? 0 : 255;
        },
        blendReflect: function (a, b) {
          return 255 === b ? b : Math.min(255, (a * a) / (255 - b));
        },
        blendGlow: function (a, b) {
          return c.Color.blendReflect(b, a);
        },
        blendPhoenix: function (a, b) {
          return Math.min(a, b) - Math.max(a, b) + 255;
        },
      }),
      (c.Physics = function (a, b) {
        (b = b || {}), (this.game = a), (this.config = b), (this.arcade = null), (this.p2 = null), (this.ninja = null), (this.box2d = null), (this.chipmunk = null), (this.matter = null), this.parseConfig();
      }),
      (c.Physics.ARCADE = 0),
      (c.Physics.P2JS = 1),
      (c.Physics.NINJA = 2),
      (c.Physics.BOX2D = 3),
      (c.Physics.CHIPMUNK = 4),
      (c.Physics.MATTERJS = 5),
      (c.Physics.prototype = {
        parseConfig: function () {
          (this.config.hasOwnProperty("arcade") && this.config.arcade !== !0) || !c.Physics.hasOwnProperty("Arcade") || (this.arcade = new c.Physics.Arcade(this.game)),
            this.config.hasOwnProperty("ninja") && this.config.ninja === !0 && c.Physics.hasOwnProperty("Ninja") && (this.ninja = new c.Physics.Ninja(this.game)),
            this.config.hasOwnProperty("p2") && this.config.p2 === !0 && c.Physics.hasOwnProperty("P2") && (this.p2 = new c.Physics.P2(this.game, this.config)),
            this.config.hasOwnProperty("box2d") && this.config.box2d === !0 && c.Physics.hasOwnProperty("BOX2D") && (this.box2d = new c.Physics.BOX2D(this.game, this.config)),
            this.config.hasOwnProperty("matter") && this.config.matter === !0 && c.Physics.hasOwnProperty("Matter") && (this.matter = new c.Physics.Matter(this.game, this.config));
        },
        startSystem: function (a) {
          a === c.Physics.ARCADE
            ? (this.arcade = new c.Physics.Arcade(this.game))
            : a === c.Physics.P2JS
            ? null === this.p2
              ? (this.p2 = new c.Physics.P2(this.game, this.config))
              : this.p2.reset()
            : a === c.Physics.NINJA
            ? (this.ninja = new c.Physics.Ninja(this.game))
            : a === c.Physics.BOX2D
            ? null === this.box2d
              ? (this.box2d = new c.Physics.Box2D(this.game, this.config))
              : this.box2d.reset()
            : a === c.Physics.MATTERJS && (null === this.matter ? (this.matter = new c.Physics.Matter(this.game, this.config)) : this.matter.reset());
        },
        enable: function (a, b, d) {
          void 0 === b && (b = c.Physics.ARCADE),
            void 0 === d && (d = !1),
            b === c.Physics.ARCADE
              ? this.arcade.enable(a)
              : b === c.Physics.P2JS && this.p2
              ? this.p2.enable(a, d)
              : b === c.Physics.NINJA && this.ninja
              ? this.ninja.enableAABB(a)
              : b === c.Physics.BOX2D && this.box2d
              ? this.box2d.enable(a)
              : b === c.Physics.MATTERJS && this.matter
              ? this.matter.enable(a)
              : void 0;
        },
        preUpdate: function () {
          this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate();
        },
        update: function () {
          this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update();
        },
        setBoundsToWorld: function () {
          this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld();
        },
        clear: function () {
          this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear();
        },
        reset: function () {
          this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset();
        },
        destroy: function () {
          this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), (this.arcade = null), (this.ninja = null), (this.p2 = null), (this.box2d = null), (this.matter = null);
        },
      }),
      (c.Physics.prototype.constructor = c.Physics),
      (c.Physics.Arcade = function (a) {
        (this.game = a),
          (this.gravity = new c.Point()),
          (this.bounds = new c.Rectangle(0, 0, a.world.width, a.world.height)),
          (this.checkCollision = { up: !0, down: !0, left: !0, right: !0 }),
          (this.maxObjects = 10),
          (this.maxLevels = 4),
          (this.OVERLAP_BIAS = 4),
          (this.forceX = !1),
          (this.sortDirection = c.Physics.Arcade.LEFT_RIGHT),
          (this.skipQuadTree = !0),
          (this.isPaused = !1),
          (this.quadTree = new c.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels)),
          (this._total = 0),
          this.setBoundsToWorld();
      }),
      (c.Physics.Arcade.prototype.constructor = c.Physics.Arcade),
      (c.Physics.Arcade.SORT_NONE = 0),
      (c.Physics.Arcade.LEFT_RIGHT = 1),
      (c.Physics.Arcade.RIGHT_LEFT = 2),
      (c.Physics.Arcade.TOP_BOTTOM = 3),
      (c.Physics.Arcade.BOTTOM_TOP = 4),
      (c.Physics.Arcade.prototype = {
        setBounds: function (a, b, c, d) {
          this.bounds.setTo(a, b, c, d);
        },
        setBoundsToWorld: function () {
          this.bounds.copyFrom(this.game.world.bounds);
        },
        enable: function (a, b) {
          void 0 === b && (b = !0);
          var d = 1;
          if (Array.isArray(a)) for (d = a.length; d--; ) a[d] instanceof c.Group ? this.enable(a[d].children, b) : (this.enableBody(a[d]), b && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0));
          else a instanceof c.Group ? this.enable(a.children, b) : (this.enableBody(a), b && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0));
        },
        enableBody: function (a) {
          a.hasOwnProperty("body") && null === a.body && ((a.body = new c.Physics.Arcade.Body(a)), a.parent && a.parent instanceof c.Group && a.parent.addToHash(a));
        },
        updateMotion: function (a) {
          var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
          (a.angularVelocity += b),
            (a.rotation += a.angularVelocity * this.game.time.physicsElapsed),
            (a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x)),
            (a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y));
        },
        computeVelocity: function (a, b, c, d, e, f) {
          return (
            void 0 === f && (f = 1e4),
            1 === a && b.allowGravity ? (c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed) : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed),
            d ? (c += d * this.game.time.physicsElapsed) : e && ((e *= this.game.time.physicsElapsed), c - e > 0 ? (c -= e) : c + e < 0 ? (c += e) : (c = 0)),
            c > f ? (c = f) : c < -f && (c = -f),
            c
          );
        },
        overlap: function (a, b, c, d, e) {
          if (((c = c || null), (d = d || null), (e = e || c), (this._total = 0), !Array.isArray(a) && Array.isArray(b))) for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !0);
          else if (Array.isArray(a) && !Array.isArray(b)) for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !0);
          else if (Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < a.length; f++) for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !0);
          else this.collideHandler(a, b, c, d, e, !0);
          return this._total > 0;
        },
        collide: function (a, b, c, d, e) {
          if (((c = c || null), (d = d || null), (e = e || c), (this._total = 0), !Array.isArray(a) && Array.isArray(b))) for (var f = 0; f < b.length; f++) this.collideHandler(a, b[f], c, d, e, !1);
          else if (Array.isArray(a) && !Array.isArray(b)) for (var f = 0; f < a.length; f++) this.collideHandler(a[f], b, c, d, e, !1);
          else if (Array.isArray(a) && Array.isArray(b)) for (var f = 0; f < a.length; f++) for (var g = 0; g < b.length; g++) this.collideHandler(a[f], b[g], c, d, e, !1);
          else this.collideHandler(a, b, c, d, e, !1);
          return this._total > 0;
        },
        sortLeftRight: function (a, b) {
          return a.body && b.body ? a.body.x - b.body.x : 0;
        },
        sortRightLeft: function (a, b) {
          return a.body && b.body ? b.body.x - a.body.x : 0;
        },
        sortTopBottom: function (a, b) {
          return a.body && b.body ? a.body.y - b.body.y : 0;
        },
        sortBottomTop: function (a, b) {
          return a.body && b.body ? b.body.y - a.body.y : 0;
        },
        sort: function (a, b) {
          null !== a.physicsSortDirection ? (b = a.physicsSortDirection) : void 0 === b && (b = this.sortDirection),
            b === c.Physics.Arcade.LEFT_RIGHT
              ? a.hash.sort(this.sortLeftRight)
              : b === c.Physics.Arcade.RIGHT_LEFT
              ? a.hash.sort(this.sortRightLeft)
              : b === c.Physics.Arcade.TOP_BOTTOM
              ? a.hash.sort(this.sortTopBottom)
              : b === c.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop);
        },
        collideHandler: function (a, b, d, e, f, g) {
          return void 0 === b && a.physicsType === c.GROUP
            ? (this.sort(a), void this.collideGroupVsSelf(a, d, e, f, g))
            : void (
                a &&
                b &&
                a.exists &&
                b.exists &&
                (this.sortDirection !== c.Physics.Arcade.SORT_NONE && (a.physicsType === c.GROUP && this.sort(a), b.physicsType === c.GROUP && this.sort(b)),
                a.physicsType === c.SPRITE
                  ? b.physicsType === c.SPRITE
                    ? this.collideSpriteVsSprite(a, b, d, e, f, g)
                    : b.physicsType === c.GROUP
                    ? this.collideSpriteVsGroup(a, b, d, e, f, g)
                    : b.physicsType === c.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, b, d, e, f, g)
                  : a.physicsType === c.GROUP
                  ? b.physicsType === c.SPRITE
                    ? this.collideSpriteVsGroup(b, a, d, e, f, g)
                    : b.physicsType === c.GROUP
                    ? this.collideGroupVsGroup(a, b, d, e, f, g)
                    : b.physicsType === c.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, b, d, e, f, g)
                  : a.physicsType === c.TILEMAPLAYER && (b.physicsType === c.SPRITE ? this.collideSpriteVsTilemapLayer(b, a, d, e, f, g) : b.physicsType === c.GROUP && this.collideGroupVsTilemapLayer(b, a, d, e, f, g)))
              );
        },
        collideSpriteVsSprite: function (a, b, c, d, e, f) {
          return !(!a.body || !b.body || (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), this._total++), 0));
        },
        collideSpriteVsGroup: function (a, b, d, e, f, g) {
          if (0 !== b.length && a.body)
            if (this.skipQuadTree || a.body.skipQuadTree)
              for (var h = {}, i = 0; i < b.hash.length; i++) {
                var j = b.hash[i];
                if (j && j.exists && j.body) {
                  if (((h = j.body.getBounds(h)), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT)) {
                    if (a.body.right < h.x) break;
                    if (h.right < a.body.x) continue;
                  } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                    if (a.body.x > h.right) break;
                    if (h.x > a.body.right) continue;
                  } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                    if (a.body.bottom < h.y) break;
                    if (h.bottom < a.body.y) continue;
                  } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                    if (a.body.y > h.bottom) break;
                    if (h.y > a.body.bottom) continue;
                  }
                  this.collideSpriteVsSprite(a, j, d, e, f, g);
                }
              }
            else {
              this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(b);
              for (var k = this.quadTree.retrieve(a), i = 0; i < k.length; i++) this.separate(a.body, k[i], e, f, g) && (d && d.call(f, a, k[i].sprite), this._total++);
            }
        },
        collideGroupVsSelf: function (a, b, d, e, f) {
          if (0 !== a.length)
            for (var g = 0; g < a.hash.length; g++) {
              var h = {},
                i = a.hash[g];
              if (i && i.exists && i.body) {
                h = i.body.getBounds(h);
                for (var j = g + 1; j < a.hash.length; j++) {
                  var k = {},
                    l = a.hash[j];
                  if (l && l.exists && l.body) {
                    if (((k = l.body.getBounds(k)), this.sortDirection === c.Physics.Arcade.LEFT_RIGHT)) {
                      if (h.right < k.x) break;
                      if (k.right < h.x) continue;
                    } else if (this.sortDirection === c.Physics.Arcade.RIGHT_LEFT) {
                      if (h.x > k.right) continue;
                      if (k.x > h.right) break;
                    } else if (this.sortDirection === c.Physics.Arcade.TOP_BOTTOM) {
                      if (h.bottom < k.y) continue;
                      if (k.bottom < h.y) break;
                    } else if (this.sortDirection === c.Physics.Arcade.BOTTOM_TOP) {
                      if (h.y > k.bottom) continue;
                      if (k.y > i.body.bottom) break;
                    }
                    this.collideSpriteVsSprite(i, l, b, d, e, f);
                  }
                }
              }
            }
        },
        collideGroupVsGroup: function (a, b, d, e, f, g) {
          if (0 !== a.length && 0 !== b.length)
            for (var h = 0; h < a.children.length; h++) a.children[h].exists && (a.children[h].physicsType === c.GROUP ? this.collideGroupVsGroup(a.children[h], b, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], b, d, e, f, g));
        },
        separate: function (a, b, c, d, e) {
          if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b)) return !1;
          if (c && c.call(d, a.sprite, b.sprite) === !1) return !1;
          if (a.isCircle && b.isCircle) return this.separateCircle(a, b, e);
          if (a.isCircle !== b.isCircle) {
            var f = a.isCircle ? b : a,
              g = a.isCircle ? a : b,
              h = { x: f.x, y: f.y, right: f.right, bottom: f.bottom },
              i = { x: g.x + g.radius, y: g.y + g.radius };
            if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right)) return this.separateCircle(a, b, e);
          }
          var j = !1,
            k = !1;
          this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x)
            ? ((j = this.separateX(a, b, e)), this.intersects(a, b) && (k = this.separateY(a, b, e)))
            : ((k = this.separateY(a, b, e)), this.intersects(a, b) && (j = this.separateX(a, b, e)));
          var l = j || k;
          return (
            l &&
              (e
                ? (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite))
                : (a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite), b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite))),
            l
          );
        },
        intersects: function (a, b) {
          return (
            a !== b &&
            (a.isCircle
              ? b.isCircle
                ? c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y) <= a.radius + b.radius
                : this.circleBodyIntersects(a, b)
              : b.isCircle
              ? this.circleBodyIntersects(b, a)
              : !(a.right <= b.position.x || a.bottom <= b.position.y || a.position.x >= b.right || a.position.y >= b.bottom))
          );
        },
        circleBodyIntersects: function (a, b) {
          var d = c.Math.clamp(a.center.x, b.left, b.right),
            e = c.Math.clamp(a.center.y, b.top, b.bottom),
            f = (a.center.x - d) * (a.center.x - d),
            g = (a.center.y - e) * (a.center.y - e);
          return f + g <= a.radius * a.radius;
        },
        separateCircle: function (a, b, d) {
          this.getOverlapX(a, b), this.getOverlapY(a, b);
          var e = b.center.x - a.center.x,
            f = b.center.y - a.center.y,
            g = Math.atan2(f, e),
            h = 0;
          if (a.isCircle !== b.isCircle) {
            var i = { x: b.isCircle ? a.position.x : b.position.x, y: b.isCircle ? a.position.y : b.position.y, right: b.isCircle ? a.right : b.right, bottom: b.isCircle ? a.bottom : b.bottom },
              j = { x: a.isCircle ? a.position.x + a.radius : b.position.x + b.radius, y: a.isCircle ? a.position.y + a.radius : b.position.y + b.radius, radius: a.isCircle ? a.radius : b.radius };
            j.y < i.y
              ? j.x < i.x
                ? (h = c.Math.distance(j.x, j.y, i.x, i.y) - j.radius)
                : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.y) - j.radius)
              : j.y > i.bottom && (j.x < i.x ? (h = c.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius) : j.x > i.right && (h = c.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius)),
              (h *= -1);
          } else h = a.radius + b.radius - c.Math.distance(a.center.x, a.center.y, b.center.x, b.center.y);
          if (d || 0 === h || (a.immovable && b.immovable) || a.customSeparateX || b.customSeparateX)
            return 0 !== h && (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite), b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)), 0 !== h;
          var k = { x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g), y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g) },
            l = { x: b.velocity.x * Math.cos(g) + b.velocity.y * Math.sin(g), y: b.velocity.x * Math.sin(g) - b.velocity.y * Math.cos(g) },
            m = ((a.mass - b.mass) * k.x + 2 * b.mass * l.x) / (a.mass + b.mass),
            n = (2 * a.mass * k.x + (b.mass - a.mass) * l.x) / (a.mass + b.mass);
          return (
            a.immovable || ((a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x), (a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y)),
            b.immovable || ((b.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * b.bounce.x), (b.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * b.bounce.y)),
            Math.abs(g) < Math.PI / 2
              ? a.velocity.x > 0 && !a.immovable && b.velocity.x > a.velocity.x
                ? (a.velocity.x *= -1)
                : b.velocity.x < 0 && !b.immovable && a.velocity.x < b.velocity.x
                ? (b.velocity.x *= -1)
                : a.velocity.y > 0 && !a.immovable && b.velocity.y > a.velocity.y
                ? (a.velocity.y *= -1)
                : b.velocity.y < 0 && !b.immovable && a.velocity.y < b.velocity.y && (b.velocity.y *= -1)
              : Math.abs(g) > Math.PI / 2 &&
                (a.velocity.x < 0 && !a.immovable && b.velocity.x < a.velocity.x
                  ? (a.velocity.x *= -1)
                  : b.velocity.x > 0 && !b.immovable && a.velocity.x > b.velocity.x
                  ? (b.velocity.x *= -1)
                  : a.velocity.y < 0 && !a.immovable && b.velocity.y < a.velocity.y
                  ? (a.velocity.y *= -1)
                  : b.velocity.y > 0 && !b.immovable && a.velocity.x > b.velocity.y && (b.velocity.y *= -1)),
            a.immovable || ((a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g)), (a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g))),
            b.immovable || ((b.x += b.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g)), (b.y += b.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g))),
            a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite),
            b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite),
            !0
          );
        },
        getOverlapX: function (a, b, c) {
          var d = 0,
            e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
          return (
            0 === a.deltaX() && 0 === b.deltaX()
              ? ((a.embedded = !0), (b.embedded = !0))
              : a.deltaX() > b.deltaX()
              ? ((d = a.right - b.x), (d > e && !c) || a.checkCollision.right === !1 || b.checkCollision.left === !1 ? (d = 0) : ((a.touching.none = !1), (a.touching.right = !0), (b.touching.none = !1), (b.touching.left = !0)))
              : a.deltaX() < b.deltaX() &&
                ((d = a.x - b.width - b.x), (-d > e && !c) || a.checkCollision.left === !1 || b.checkCollision.right === !1 ? (d = 0) : ((a.touching.none = !1), (a.touching.left = !0), (b.touching.none = !1), (b.touching.right = !0))),
            (a.overlapX = d),
            (b.overlapX = d),
            d
          );
        },
        getOverlapY: function (a, b, c) {
          var d = 0,
            e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
          return (
            0 === a.deltaY() && 0 === b.deltaY()
              ? ((a.embedded = !0), (b.embedded = !0))
              : a.deltaY() > b.deltaY()
              ? ((d = a.bottom - b.y), (d > e && !c) || a.checkCollision.down === !1 || b.checkCollision.up === !1 ? (d = 0) : ((a.touching.none = !1), (a.touching.down = !0), (b.touching.none = !1), (b.touching.up = !0)))
              : a.deltaY() < b.deltaY() &&
                ((d = a.y - b.bottom), (-d > e && !c) || a.checkCollision.up === !1 || b.checkCollision.down === !1 ? (d = 0) : ((a.touching.none = !1), (a.touching.up = !0), (b.touching.none = !1), (b.touching.down = !0))),
            (a.overlapY = d),
            (b.overlapY = d),
            d
          );
        },
        separateX: function (a, b, c) {
          var d = this.getOverlapX(a, b, c);
          if (c || 0 === d || (a.immovable && b.immovable) || a.customSeparateX || b.customSeparateX) return 0 !== d || (a.embedded && b.embedded);
          var e = a.velocity.x,
            f = b.velocity.x;
          if (a.immovable || b.immovable)
            a.immovable ? ((b.x += d), (b.velocity.x = e - f * b.bounce.x), a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : ((a.x -= d), (a.velocity.x = f - e * a.bounce.x), b.moves && (a.y += (b.y - b.prev.y) * b.friction.y));
          else {
            (d *= 0.5), (a.x -= d), (b.x += d);
            var g = Math.sqrt((f * f * b.mass) / a.mass) * (f > 0 ? 1 : -1),
              h = Math.sqrt((e * e * a.mass) / b.mass) * (e > 0 ? 1 : -1),
              i = 0.5 * (g + h);
            (g -= i), (h -= i), (a.velocity.x = i + g * a.bounce.x), (b.velocity.x = i + h * b.bounce.x);
          }
          return !0;
        },
        separateY: function (a, b, c) {
          var d = this.getOverlapY(a, b, c);
          if (c || 0 === d || (a.immovable && b.immovable) || a.customSeparateY || b.customSeparateY) return 0 !== d || (a.embedded && b.embedded);
          var e = a.velocity.y,
            f = b.velocity.y;
          if (a.immovable || b.immovable)
            a.immovable ? ((b.y += d), (b.velocity.y = e - f * b.bounce.y), a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : ((a.y -= d), (a.velocity.y = f - e * a.bounce.y), b.moves && (a.x += (b.x - b.prev.x) * b.friction.x));
          else {
            (d *= 0.5), (a.y -= d), (b.y += d);
            var g = Math.sqrt((f * f * b.mass) / a.mass) * (f > 0 ? 1 : -1),
              h = Math.sqrt((e * e * a.mass) / b.mass) * (e > 0 ? 1 : -1),
              i = 0.5 * (g + h);
            (g -= i), (h -= i), (a.velocity.y = i + g * a.bounce.y), (b.velocity.y = i + h * b.bounce.y);
          }
          return !0;
        },
        getObjectsUnderPointer: function (a, b, c, d) {
          if (0 !== b.length && a.exists) return this.getObjectsAtLocation(a.x, a.y, b, c, d, a);
        },
        getObjectsAtLocation: function (a, b, d, e, f, g) {
          this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(d);
          for (var h = new c.Rectangle(a, b, 1, 1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++) j[k].hitTest(a, b) && (e && e.call(f, g, j[k].sprite), i.push(j[k].sprite));
          return i;
        },
        moveToObject: function (a, b, c, d) {
          void 0 === c && (c = 60), void 0 === d && (d = 0);
          var e = Math.atan2(b.y - a.y, b.x - a.x);
          return d > 0 && (c = this.distanceBetween(a, b) / (d / 1e3)), (a.body.velocity.x = Math.cos(e) * c), (a.body.velocity.y = Math.sin(e) * c), e;
        },
        moveToPointer: function (a, b, c, d) {
          void 0 === b && (b = 60), (c = c || this.game.input.activePointer), void 0 === d && (d = 0);
          var e = this.angleToPointer(a, c);
          return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1e3)), (a.body.velocity.x = Math.cos(e) * b), (a.body.velocity.y = Math.sin(e) * b), e;
        },
        moveToXY: function (a, b, c, d, e) {
          void 0 === d && (d = 60), void 0 === e && (e = 0);
          var f = Math.atan2(c - a.y, b - a.x);
          return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1e3)), (a.body.velocity.x = Math.cos(f) * d), (a.body.velocity.y = Math.sin(f) * d), f;
        },
        velocityFromAngle: function (a, b, d) {
          return void 0 === b && (b = 60), (d = d || new c.Point()), d.setTo(Math.cos(this.game.math.degToRad(a)) * b, Math.sin(this.game.math.degToRad(a)) * b);
        },
        velocityFromRotation: function (a, b, d) {
          return void 0 === b && (b = 60), (d = d || new c.Point()), d.setTo(Math.cos(a) * b, Math.sin(a) * b);
        },
        accelerationFromRotation: function (a, b, d) {
          return void 0 === b && (b = 60), (d = d || new c.Point()), d.setTo(Math.cos(a) * b, Math.sin(a) * b);
        },
        accelerateToObject: function (a, b, c, d, e) {
          void 0 === c && (c = 60), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3);
          var f = this.angleBetween(a, b);
          return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f;
        },
        accelerateToPointer: function (a, b, c, d, e) {
          void 0 === c && (c = 60), void 0 === b && (b = this.game.input.activePointer), void 0 === d && (d = 1e3), void 0 === e && (e = 1e3);
          var f = this.angleToPointer(a, b);
          return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c), a.body.maxVelocity.setTo(d, e), f;
        },
        accelerateToXY: function (a, b, c, d, e, f) {
          void 0 === d && (d = 60), void 0 === e && (e = 1e3), void 0 === f && (f = 1e3);
          var g = this.angleToXY(a, b, c);
          return a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d), a.body.maxVelocity.setTo(e, f), g;
        },
        distanceBetween: function (a, b, c) {
          void 0 === c && (c = !1);
          var d = c ? a.world.x - b.world.x : a.x - b.x,
            e = c ? a.world.y - b.world.y : a.y - b.y;
          return Math.sqrt(d * d + e * e);
        },
        distanceToXY: function (a, b, c, d) {
          void 0 === d && (d = !1);
          var e = d ? a.world.x - b : a.x - b,
            f = d ? a.world.y - c : a.y - c;
          return Math.sqrt(e * e + f * f);
        },
        distanceToPointer: function (a, b, c) {
          void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1);
          var d = c ? a.world.x - b.worldX : a.x - b.worldX,
            e = c ? a.world.y - b.worldY : a.y - b.worldY;
          return Math.sqrt(d * d + e * e);
        },
        angleBetween: function (a, b, c) {
          return void 0 === c && (c = !1), c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x);
        },
        angleBetweenCenters: function (a, b) {
          var c = b.centerX - a.centerX,
            d = b.centerY - a.centerY;
          return Math.atan2(d, c);
        },
        angleToXY: function (a, b, c, d) {
          return void 0 === d && (d = !1), d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x);
        },
        angleToPointer: function (a, b, c) {
          return void 0 === b && (b = this.game.input.activePointer), void 0 === c && (c = !1), c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x);
        },
        worldAngleToPointer: function (a, b) {
          return this.angleToPointer(a, b, !0);
        },
      }),
      (c.Physics.Arcade.Body = function (a) {
        (this.sprite = a),
          (this.game = a.game),
          (this.type = c.Physics.ARCADE),
          (this.enable = !0),
          (this.isCircle = !1),
          (this.radius = 0),
          (this.offset = new c.Point()),
          (this.position = new c.Point(a.x, a.y)),
          (this.prev = new c.Point(this.position.x, this.position.y)),
          (this.allowRotation = !0),
          (this.rotation = a.angle),
          (this.preRotation = a.angle),
          (this.width = a.width),
          (this.height = a.height),
          (this.sourceWidth = a.width),
          (this.sourceHeight = a.height),
          a.texture && ((this.sourceWidth = a.texture.frame.width), (this.sourceHeight = a.texture.frame.height)),
          (this.halfWidth = Math.abs(a.width / 2)),
          (this.halfHeight = Math.abs(a.height / 2)),
          (this.center = new c.Point(a.x + this.halfWidth, a.y + this.halfHeight)),
          (this.velocity = new c.Point()),
          (this.newVelocity = new c.Point()),
          (this.deltaMax = new c.Point()),
          (this.acceleration = new c.Point()),
          (this.drag = new c.Point()),
          (this.allowGravity = !0),
          (this.gravity = new c.Point()),
          (this.bounce = new c.Point()),
          (this.worldBounce = null),
          (this.onWorldBounds = null),
          (this.onCollide = null),
          (this.onOverlap = null),
          (this.maxVelocity = new c.Point(1e4, 1e4)),
          (this.friction = new c.Point(1, 0)),
          (this.angularVelocity = 0),
          (this.angularAcceleration = 0),
          (this.angularDrag = 0),
          (this.maxAngular = 1e3),
          (this.mass = 1),
          (this.angle = 0),
          (this.speed = 0),
          (this.facing = c.NONE),
          (this.immovable = !1),
          (this.moves = !0),
          (this.customSeparateX = !1),
          (this.customSeparateY = !1),
          (this.overlapX = 0),
          (this.overlapY = 0),
          (this.overlapR = 0),
          (this.embedded = !1),
          (this.collideWorldBounds = !1),
          (this.checkCollision = { none: !1, any: !0, up: !0, down: !0, left: !0, right: !0 }),
          (this.touching = { none: !0, up: !1, down: !1, left: !1, right: !1 }),
          (this.wasTouching = { none: !0, up: !1, down: !1, left: !1, right: !1 }),
          (this.blocked = { up: !1, down: !1, left: !1, right: !1 }),
          (this.tilePadding = new c.Point()),
          (this.dirty = !1),
          (this.skipQuadTree = !1),
          (this.syncBounds = !1),
          (this.isMoving = !1),
          (this.stopVelocityOnCollide = !0),
          (this.moveTimer = 0),
          (this.moveDistance = 0),
          (this.moveDuration = 0),
          (this.moveTarget = null),
          (this.moveEnd = null),
          (this.onMoveComplete = new c.Signal()),
          (this.movementCallback = null),
          (this.movementCallbackContext = null),
          (this._reset = !0),
          (this._sx = a.scale.x),
          (this._sy = a.scale.y),
          (this._dx = 0),
          (this._dy = 0);
      }),
      (c.Physics.Arcade.Body.prototype = {
        updateBounds: function () {
          if (this.syncBounds) {
            var a = this.sprite.getBounds();
            a.ceilAll(), (a.width === this.width && a.height === this.height) || ((this.width = a.width), (this.height = a.height), (this._reset = !0));
          } else {
            var b = Math.abs(this.sprite.scale.x),
              c = Math.abs(this.sprite.scale.y);
            (b === this._sx && c === this._sy) || ((this.width = this.sourceWidth * b), (this.height = this.sourceHeight * c), (this._sx = b), (this._sy = c), (this._reset = !0));
          }
          this._reset && ((this.halfWidth = Math.floor(this.width / 2)), (this.halfHeight = Math.floor(this.height / 2)), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight));
        },
        preUpdate: function () {
          this.enable &&
            !this.game.physics.arcade.isPaused &&
            ((this.dirty = !0),
            (this.wasTouching.none = this.touching.none),
            (this.wasTouching.up = this.touching.up),
            (this.wasTouching.down = this.touching.down),
            (this.wasTouching.left = this.touching.left),
            (this.wasTouching.right = this.touching.right),
            (this.touching.none = !0),
            (this.touching.up = !1),
            (this.touching.down = !1),
            (this.touching.left = !1),
            (this.touching.right = !1),
            (this.blocked.up = !1),
            (this.blocked.down = !1),
            (this.blocked.left = !1),
            (this.blocked.right = !1),
            (this.embedded = !1),
            this.updateBounds(),
            (this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x),
            (this.position.x -= this.sprite.scale.x < 0 ? this.width : 0),
            (this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y),
            (this.position.y -= this.sprite.scale.y < 0 ? this.height : 0),
            (this.rotation = this.sprite.angle),
            (this.preRotation = this.rotation),
            (this._reset || this.sprite.fresh) && ((this.prev.x = this.position.x), (this.prev.y = this.position.y)),
            this.moves &&
              (this.game.physics.arcade.updateMotion(this),
              this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed),
              (this.position.x += this.newVelocity.x),
              (this.position.y += this.newVelocity.y),
              (this.position.x === this.prev.x && this.position.y === this.prev.y) || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)),
              (this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y)),
              this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)),
            (this._dx = this.deltaX()),
            (this._dy = this.deltaY()),
            (this._reset = !1));
        },
        updateMovement: function () {
          var a = 0,
            b = 0 !== this.overlapX || 0 !== this.overlapY;
          if (
            (this.moveDuration > 0 ? ((this.moveTimer += this.game.time.elapsedMS), (a = this.moveTimer / this.moveDuration)) : (this.moveTarget.end.set(this.position.x, this.position.y), (a = this.moveTarget.length / this.moveDistance)),
            this.movementCallback)
          )
            var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
          return !(b || a >= 1 || (void 0 !== c && c !== !0)) || (this.stopMovement(a >= 1 || (this.stopVelocityOnCollide && b)), !1);
        },
        stopMovement: function (a) {
          this.isMoving && ((this.isMoving = !1), a && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY));
        },
        postUpdate: function () {
          this.enable &&
            this.dirty &&
            (this.isMoving && this.updateMovement(),
            (this.dirty = !1),
            this.deltaX() < 0 ? (this.facing = c.LEFT) : this.deltaX() > 0 && (this.facing = c.RIGHT),
            this.deltaY() < 0 ? (this.facing = c.UP) : this.deltaY() > 0 && (this.facing = c.DOWN),
            this.moves &&
              ((this._dx = this.deltaX()),
              (this._dy = this.deltaY()),
              0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? (this._dx = -this.deltaMax.x) : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)),
              0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? (this._dy = -this.deltaMax.y) : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)),
              (this.sprite.position.x += this._dx),
              (this.sprite.position.y += this._dy),
              (this._reset = !0)),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
            this.allowRotation && (this.sprite.angle += this.deltaZ()),
            (this.prev.x = this.position.x),
            (this.prev.y = this.position.y));
        },
        checkWorldBounds: function () {
          var a = this.position,
            b = this.game.physics.arcade.bounds,
            c = this.game.physics.arcade.checkCollision,
            d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
            e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
          if (this.isCircle) {
            var f = { x: this.center.x - this.radius, y: this.center.y - this.radius, right: this.center.x + this.radius, bottom: this.center.y + this.radius };
            f.x < b.x && c.left
              ? ((a.x = b.x - this.halfWidth + this.radius), (this.velocity.x *= d), (this.blocked.left = !0))
              : f.right > b.right && c.right && ((a.x = b.right - this.halfWidth - this.radius), (this.velocity.x *= d), (this.blocked.right = !0)),
              f.y < b.y && c.up
                ? ((a.y = b.y - this.halfHeight + this.radius), (this.velocity.y *= e), (this.blocked.up = !0))
                : f.bottom > b.bottom && c.down && ((a.y = b.bottom - this.halfHeight - this.radius), (this.velocity.y *= e), (this.blocked.down = !0));
          } else
            a.x < b.x && c.left ? ((a.x = b.x), (this.velocity.x *= d), (this.blocked.left = !0)) : this.right > b.right && c.right && ((a.x = b.right - this.width), (this.velocity.x *= d), (this.blocked.right = !0)),
              a.y < b.y && c.up ? ((a.y = b.y), (this.velocity.y *= e), (this.blocked.up = !0)) : this.bottom > b.bottom && c.down && ((a.y = b.bottom - this.height), (this.velocity.y *= e), (this.blocked.down = !0));
          return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right;
        },
        moveFrom: function (a, b, c) {
          if ((void 0 === b && (b = this.speed), 0 === b)) return !1;
          var d;
          return (
            void 0 === c ? ((d = this.angle), (c = this.game.math.radToDeg(d))) : (d = this.game.math.degToRad(c)),
            (this.moveTimer = 0),
            (this.moveDuration = a),
            0 === c || 180 === c ? this.velocity.set(Math.cos(d) * b, 0) : 90 === c || 270 === c ? this.velocity.set(0, Math.sin(d) * b) : this.velocity.set(Math.cos(d) * b, Math.sin(d) * b),
            (this.isMoving = !0),
            !0
          );
        },
        moveTo: function (a, b, d) {
          var e = b / (a / 1e3);
          if (0 === e) return !1;
          var f;
          return (
            void 0 === d ? ((f = this.angle), (d = this.game.math.radToDeg(f))) : (f = this.game.math.degToRad(d)),
            (b = Math.abs(b)),
            (this.moveDuration = 0),
            (this.moveDistance = b),
            null === this.moveTarget && ((this.moveTarget = new c.Line()), (this.moveEnd = new c.Point())),
            this.moveTarget.fromAngle(this.x, this.y, f, b),
            this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y),
            this.moveTarget.setTo(this.x, this.y, this.x, this.y),
            0 === d || 180 === d ? this.velocity.set(Math.cos(f) * e, 0) : 90 === d || 270 === d ? this.velocity.set(0, Math.sin(f) * e) : this.velocity.set(Math.cos(f) * e, Math.sin(f) * e),
            (this.isMoving = !0),
            !0
          );
        },
        setSize: function (a, b, c, d) {
          void 0 === c && (c = this.offset.x),
            void 0 === d && (d = this.offset.y),
            (this.sourceWidth = a),
            (this.sourceHeight = b),
            (this.width = this.sourceWidth * this._sx),
            (this.height = this.sourceHeight * this._sy),
            (this.halfWidth = Math.floor(this.width / 2)),
            (this.halfHeight = Math.floor(this.height / 2)),
            this.offset.setTo(c, d),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
            (this.isCircle = !1),
            (this.radius = 0);
        },
        setCircle: function (a, b, c) {
          void 0 === b && (b = this.offset.x),
            void 0 === c && (c = this.offset.y),
            a > 0
              ? ((this.isCircle = !0),
                (this.radius = a),
                (this.sourceWidth = 2 * a),
                (this.sourceHeight = 2 * a),
                (this.width = this.sourceWidth * this._sx),
                (this.height = this.sourceHeight * this._sy),
                (this.halfWidth = Math.floor(this.width / 2)),
                (this.halfHeight = Math.floor(this.height / 2)),
                this.offset.setTo(b, c),
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
              : (this.isCircle = !1);
        },
        reset: function (a, b) {
          this.velocity.set(0),
            this.acceleration.set(0),
            (this.speed = 0),
            (this.angularVelocity = 0),
            (this.angularAcceleration = 0),
            (this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x),
            (this.position.x -= this.sprite.scale.x < 0 ? this.width : 0),
            (this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y),
            (this.position.y -= this.sprite.scale.y < 0 ? this.height : 0),
            (this.prev.x = this.position.x),
            (this.prev.y = this.position.y),
            (this.rotation = this.sprite.angle),
            (this.preRotation = this.rotation),
            (this._sx = this.sprite.scale.x),
            (this._sy = this.sprite.scale.y),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        },
        getBounds: function (a) {
          return (
            this.isCircle
              ? ((a.x = this.center.x - this.radius), (a.y = this.center.y - this.radius), (a.right = this.center.x + this.radius), (a.bottom = this.center.y + this.radius))
              : ((a.x = this.x), (a.y = this.y), (a.right = this.right), (a.bottom = this.bottom)),
            a
          );
        },
        hitTest: function (a, b) {
          return this.isCircle ? c.Circle.contains(this, a, b) : c.Rectangle.contains(this, a, b);
        },
        onFloor: function () {
          return this.blocked.down;
        },
        onCeiling: function () {
          return this.blocked.up;
        },
        onWall: function () {
          return this.blocked.left || this.blocked.right;
        },
        deltaAbsX: function () {
          return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
        },
        deltaAbsY: function () {
          return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
        },
        deltaX: function () {
          return this.position.x - this.prev.x;
        },
        deltaY: function () {
          return this.position.y - this.prev.y;
        },
        deltaZ: function () {
          return this.rotation - this.preRotation;
        },
        destroy: function () {
          this.sprite.parent && this.sprite.parent instanceof c.Group && this.sprite.parent.removeFromHash(this.sprite), (this.sprite.body = null), (this.sprite = null);
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "left", {
        get: function () {
          return this.position.x;
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "right", {
        get: function () {
          return this.position.x + this.width;
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "top", {
        get: function () {
          return this.position.y;
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "bottom", {
        get: function () {
          return this.position.y + this.height;
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "x", {
        get: function () {
          return this.position.x;
        },
        set: function (a) {
          this.position.x = a;
        },
      }),
      Object.defineProperty(c.Physics.Arcade.Body.prototype, "y", {
        get: function () {
          return this.position.y;
        },
        set: function (a) {
          this.position.y = a;
        },
      }),
      (c.Physics.Arcade.Body.render = function (a, b, c, d) {
        void 0 === d && (d = !0),
          (c = c || "rgba(0,255,0,0.4)"),
          (a.fillStyle = c),
          (a.strokeStyle = c),
          b.isCircle
            ? (a.beginPath(), a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.radius, 0, 2 * Math.PI), d ? a.fill() : a.stroke())
            : d
            ? a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height)
            : a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height);
      }),
      (c.Physics.Arcade.Body.renderBodyInfo = function (a, b) {
        a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height),
          a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)),
          a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)),
          a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)),
          a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down),
          a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down);
      }),
      (c.Physics.Arcade.Body.prototype.constructor = c.Physics.Arcade.Body),
      (c.Physics.Arcade.TilemapCollision = function () {}),
      (c.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function (a, b, c, d, e, f) {
          if (a.body) {
            var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
            if (0 !== g.length)
              for (var h = 0; h < g.length; h++)
                d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], b, f) && (this._total++, c && c.call(e, a, g[h]));
          }
        },
        collideGroupVsTilemapLayer: function (a, b, c, d, e, f) {
          if (0 !== a.length) for (var g = 0; g < a.children.length; g++) a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f);
        },
        separateTile: function (a, b, c, d, e) {
          if (!b.enable) return !1;
          var f = d.fixedToCamera ? 0 : d.position.x,
            g = d.fixedToCamera ? 0 : d.position.y;
          if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) return !1;
          if (e) return !0;
          if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) return !1;
          if ("undefined" != typeof c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) return !1;
          if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) return !1;
          var h = 0,
            i = 0,
            j = 0,
            k = 1;
          if (
            (b.deltaAbsX() > b.deltaAbsY() ? (j = -1) : b.deltaAbsX() < b.deltaAbsY() && (k = -1),
            0 !== b.deltaX() &&
              0 !== b.deltaY() &&
              (c.faceLeft || c.faceRight) &&
              (c.faceTop || c.faceBottom) &&
              ((j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left))), (k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top)))),
            j < k)
          ) {
            if ((c.faceLeft || c.faceRight) && ((h = this.tileCheckX(b, c, d)), 0 !== h && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
            (c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d));
          } else {
            if ((c.faceTop || c.faceBottom) && ((i = this.tileCheckY(b, c, d)), 0 !== i && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))) return !0;
            (c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d));
          }
          return 0 !== h || 0 !== i;
        },
        tileCheckX: function (a, b, c) {
          var d = 0,
            e = c.fixedToCamera ? 0 : c.position.x;
          return (
            a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left
              ? b.faceRight && a.x - e < b.right && ((d = a.x - e - b.right), d < -this.TILE_BIAS && (d = 0))
              : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && ((d = a.right - e - b.left), d > this.TILE_BIAS && (d = 0)),
            0 !== d && (a.customSeparateX ? (a.overlapX = d) : this.processTileSeparationX(a, d)),
            d
          );
        },
        tileCheckY: function (a, b, c) {
          var d = 0,
            e = c.fixedToCamera ? 0 : c.position.y;
          return (
            a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up
              ? b.faceBottom && a.y - e < b.bottom && ((d = a.y - e - b.bottom), d < -this.TILE_BIAS && (d = 0))
              : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && ((d = a.bottom - e - b.top), d > this.TILE_BIAS && (d = 0)),
            0 !== d && (a.customSeparateY ? (a.overlapY = d) : this.processTileSeparationY(a, d)),
            d
          );
        },
        processTileSeparationX: function (a, b) {
          b < 0 ? (a.blocked.left = !0) : b > 0 && (a.blocked.right = !0), (a.position.x -= b), 0 === a.bounce.x ? (a.velocity.x = 0) : (a.velocity.x = -a.velocity.x * a.bounce.x);
        },
        processTileSeparationY: function (a, b) {
          b < 0 ? (a.blocked.up = !0) : b > 0 && (a.blocked.down = !0), (a.position.y -= b), 0 === a.bounce.y ? (a.velocity.y = 0) : (a.velocity.y = -a.velocity.y * a.bounce.y);
        },
      }),
      c.Utils.mixinPrototype(c.Physics.Arcade.prototype, c.Physics.Arcade.TilemapCollision.prototype),
      (p2.Body.prototype.parent = null),
      (p2.Spring.prototype.parent = null),
      (c.Physics.P2 = function (a, b) {
        (this.game = a),
          void 0 === b ? (b = { gravity: [0, 0], broadphase: new p2.SAPBroadphase() }) : (b.hasOwnProperty("gravity") || (b.gravity = [0, 0]), b.hasOwnProperty("broadphase") || (b.broadphase = new p2.SAPBroadphase())),
          (this.config = b),
          (this.world = new p2.World(this.config)),
          (this.frameRate = 1 / 60),
          (this.useElapsedTime = !1),
          (this.paused = !1),
          (this.materials = []),
          (this.gravity = new c.Physics.P2.InversePointProxy(this, this.world.gravity)),
          (this.walls = { left: null, right: null, top: null, bottom: null }),
          (this.onBodyAdded = new c.Signal()),
          (this.onBodyRemoved = new c.Signal()),
          (this.onSpringAdded = new c.Signal()),
          (this.onSpringRemoved = new c.Signal()),
          (this.onConstraintAdded = new c.Signal()),
          (this.onConstraintRemoved = new c.Signal()),
          (this.onContactMaterialAdded = new c.Signal()),
          (this.onContactMaterialRemoved = new c.Signal()),
          (this.postBroadphaseCallback = null),
          (this.callbackContext = null),
          (this.onBeginContact = new c.Signal()),
          (this.onEndContact = new c.Signal()),
          b.hasOwnProperty("mpx") && b.hasOwnProperty("pxm") && b.hasOwnProperty("mpxi") && b.hasOwnProperty("pxmi") && ((this.mpx = b.mpx), (this.mpxi = b.mpxi), (this.pxm = b.pxm), (this.pxmi = b.pxmi)),
          this.world.on("beginContact", this.beginContactHandler, this),
          this.world.on("endContact", this.endContactHandler, this),
          (this.collisionGroups = []),
          (this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1)),
          (this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2)),
          (this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648)),
          (this.boundsCollidesWith = []),
          (this._toRemove = []),
          (this._collisionGroupID = 2),
          (this._boundsLeft = !0),
          (this._boundsRight = !0),
          (this._boundsTop = !0),
          (this._boundsBottom = !0),
          (this._boundsOwnGroup = !1),
          this.setBoundsToWorld(!0, !0, !0, !0, !1);
      }),
      (c.Physics.P2.prototype = {
        removeBodyNextStep: function (a) {
          this._toRemove.push(a);
        },
        preUpdate: function () {
          for (var a = this._toRemove.length; a--; ) this.removeBody(this._toRemove[a]);
          this._toRemove.length = 0;
        },
        enable: function (a, b, d) {
          void 0 === b && (b = !1), void 0 === d && (d = !0);
          var e = 1;
          if (Array.isArray(a)) for (e = a.length; e--; ) a[e] instanceof c.Group ? this.enable(a[e].children, b, d) : (this.enableBody(a[e], b), d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], b, !0));
          else a instanceof c.Group ? this.enable(a.children, b, d) : (this.enableBody(a, b), d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, b, !0));
        },
        enableBody: function (a, b) {
          a.hasOwnProperty("body") && null === a.body && ((a.body = new c.Physics.P2.Body(this.game, a, a.x, a.y, 1)), (a.body.debug = b), "undefined" != typeof a.anchor && a.anchor.set(0.5));
        },
        setImpactEvents: function (a) {
          a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this);
        },
        setPostBroadphaseCallback: function (a, b) {
          (this.postBroadphaseCallback = a), (this.callbackContext = b), null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        },
        postBroadphaseHandler: function (a) {
          if (this.postBroadphaseCallback && 0 !== a.pairs.length)
            for (var b = a.pairs.length - 2; b >= 0; b -= 2) a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2);
        },
        impactHandler: function (a) {
          if (a.bodyA.parent && a.bodyB.parent) {
            var b = a.bodyA.parent,
              c = a.bodyB.parent;
            b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB),
              c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA),
              b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB),
              c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA);
          }
        },
        beginContactHandler: function (a) {
          a.bodyA &&
            a.bodyB &&
            (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations),
            a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations),
            a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations));
        },
        endContactHandler: function (a) {
          a.bodyA &&
            a.bodyB &&
            (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB),
            a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB),
            a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA));
        },
        setBoundsToWorld: function (a, b, c, d, e) {
          this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e);
        },
        setWorldMaterial: function (a, b, c, d, e) {
          void 0 === b && (b = !0),
            void 0 === c && (c = !0),
            void 0 === d && (d = !0),
            void 0 === e && (e = !0),
            b && this.walls.left && (this.walls.left.shapes[0].material = a),
            c && this.walls.right && (this.walls.right.shapes[0].material = a),
            d && this.walls.top && (this.walls.top.shapes[0].material = a),
            e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a);
        },
        updateBoundsCollisionGroup: function (a) {
          void 0 === a && (a = !0);
          var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
          this.walls.left && (this.walls.left.shapes[0].collisionGroup = b),
            this.walls.right && (this.walls.right.shapes[0].collisionGroup = b),
            this.walls.top && (this.walls.top.shapes[0].collisionGroup = b),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b),
            (this._boundsOwnGroup = a);
        },
        setBounds: function (a, b, c, d, e, f, g, h, i) {
          void 0 === e && (e = this._boundsLeft),
            void 0 === f && (f = this._boundsRight),
            void 0 === g && (g = this._boundsTop),
            void 0 === h && (h = this._boundsBottom),
            void 0 === i && (i = this._boundsOwnGroup),
            this.setupWall(e, "left", a, b, 1.5707963267948966, i),
            this.setupWall(f, "right", a + c, b, -1.5707963267948966, i),
            this.setupWall(g, "top", a, b, -3.141592653589793, i),
            this.setupWall(h, "bottom", a, b + d, 0, i),
            (this._boundsLeft = e),
            (this._boundsRight = f),
            (this._boundsTop = g),
            (this._boundsBottom = h),
            (this._boundsOwnGroup = i);
        },
        setupWall: function (a, b, c, d, e, f) {
          a
            ? (this.walls[b]
                ? (this.walls[b].position = [this.pxmi(c), this.pxmi(d)])
                : ((this.walls[b] = new p2.Body({ mass: 0, position: [this.pxmi(c), this.pxmi(d)], angle: e })), this.walls[b].addShape(new p2.Plane()), this.world.addBody(this.walls[b])),
              f && (this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask))
            : this.walls[b] && (this.world.removeBody(this.walls[b]), (this.walls[b] = null));
        },
        pause: function () {
          this.paused = !0;
        },
        resume: function () {
          this.paused = !1;
        },
        update: function () {
          this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate));
        },
        reset: function () {
          this.world.on("beginContact", this.beginContactHandler, this),
            this.world.on("endContact", this.endContactHandler, this),
            (this.nothingCollisionGroup = new c.Physics.P2.CollisionGroup(1)),
            (this.boundsCollisionGroup = new c.Physics.P2.CollisionGroup(2)),
            (this.everythingCollisionGroup = new c.Physics.P2.CollisionGroup(2147483648)),
            (this._collisionGroupID = 2),
            this.setBoundsToWorld(!0, !0, !0, !0, !1);
        },
        clear: function () {
          (this.world.time = 0), (this.world.fixedStepTime = 0), this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
          for (var a = this.world.constraints, b = a.length - 1; b >= 0; b--) this.world.removeConstraint(a[b]);
          for (var c = this.world.bodies, b = c.length - 1; b >= 0; b--) this.world.removeBody(c[b]);
          for (var d = this.world.springs, b = d.length - 1; b >= 0; b--) this.world.removeSpring(d[b]);
          for (var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--) this.world.removeContactMaterial(e[b]);
          this.world.off("beginContact", this.beginContactHandler, this),
            this.world.off("endContact", this.endContactHandler, this),
            (this.postBroadphaseCallback = null),
            (this.callbackContext = null),
            (this.impactCallback = null),
            (this.collisionGroups = []),
            (this._toRemove = []),
            (this.boundsCollidesWith = []),
            (this.walls = { left: null, right: null, top: null, bottom: null });
        },
        destroy: function () {
          this.clear(), (this.game = null);
        },
        addBody: function (a) {
          return !a.data.world && (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), !0);
        },
        removeBody: function (a) {
          return a.data.world === this.world && (this.world.removeBody(a.data), this.onBodyRemoved.dispatch(a)), a;
        },
        addSpring: function (a) {
          return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.addSpring(a.data) : this.world.addSpring(a), this.onSpringAdded.dispatch(a), a;
        },
        removeSpring: function (a) {
          return a instanceof c.Physics.P2.Spring || a instanceof c.Physics.P2.RotationalSpring ? this.world.removeSpring(a.data) : this.world.removeSpring(a), this.onSpringRemoved.dispatch(a), a;
        },
        createDistanceConstraint: function (a, b, d, e, f, g) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addConstraint(new c.Physics.P2.DistanceConstraint(this, a, b, d, e, f, g)) : void 0;
        },
        createGearConstraint: function (a, b, d, e) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addConstraint(new c.Physics.P2.GearConstraint(this, a, b, d, e)) : void 0;
        },
        createRevoluteConstraint: function (a, b, d, e, f, g) {
          return (a = this.getBody(a)), (d = this.getBody(d)), a && d ? this.addConstraint(new c.Physics.P2.RevoluteConstraint(this, a, b, d, e, f, g)) : void 0;
        },
        createLockConstraint: function (a, b, d, e, f) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addConstraint(new c.Physics.P2.LockConstraint(this, a, b, d, e, f)) : void 0;
        },
        createPrismaticConstraint: function (a, b, d, e, f, g, h) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addConstraint(new c.Physics.P2.PrismaticConstraint(this, a, b, d, e, f, g, h)) : void 0;
        },
        addConstraint: function (a) {
          return this.world.addConstraint(a), this.onConstraintAdded.dispatch(a), a;
        },
        removeConstraint: function (a) {
          return this.world.removeConstraint(a), this.onConstraintRemoved.dispatch(a), a;
        },
        addContactMaterial: function (a) {
          return this.world.addContactMaterial(a), this.onContactMaterialAdded.dispatch(a), a;
        },
        removeContactMaterial: function (a) {
          return this.world.removeContactMaterial(a), this.onContactMaterialRemoved.dispatch(a), a;
        },
        getContactMaterial: function (a, b) {
          return this.world.getContactMaterial(a, b);
        },
        setMaterial: function (a, b) {
          for (var c = b.length; c--; ) b[c].setMaterial(a);
        },
        createMaterial: function (a, b) {
          a = a || "";
          var d = new c.Physics.P2.Material(a);
          return this.materials.push(d), "undefined" != typeof b && b.setMaterial(d), d;
        },
        createContactMaterial: function (a, b, d) {
          void 0 === a && (a = this.createMaterial()), void 0 === b && (b = this.createMaterial());
          var e = new c.Physics.P2.ContactMaterial(a, b, d);
          return this.addContactMaterial(e);
        },
        getBodies: function () {
          for (var a = [], b = this.world.bodies.length; b--; ) a.push(this.world.bodies[b].parent);
          return a;
        },
        getBody: function (a) {
          return a instanceof p2.Body ? a : a instanceof c.Physics.P2.Body ? a.data : a.body && a.body.type === c.Physics.P2JS ? a.body.data : null;
        },
        getSprings: function () {
          for (var a = [], b = this.world.springs.length; b--; ) a.push(this.world.springs[b].parent);
          return a;
        },
        getConstraints: function () {
          for (var a = [], b = this.world.constraints.length; b--; ) a.push(this.world.constraints[b]);
          return a;
        },
        hitTest: function (a, b, d, e) {
          void 0 === b && (b = this.world.bodies), void 0 === d && (d = 5), void 0 === e && (e = !1);
          for (var f = [this.pxmi(a.x), this.pxmi(a.y)], g = [], h = b.length; h--; )
            b[h] instanceof c.Physics.P2.Body && (!e || b[h].data.type !== p2.Body.STATIC)
              ? g.push(b[h].data)
              : b[h] instanceof p2.Body && b[h].parent && (!e || b[h].type !== p2.Body.STATIC)
              ? g.push(b[h])
              : b[h] instanceof c.Sprite && b[h].hasOwnProperty("body") && (!e || b[h].body.data.type !== p2.Body.STATIC) && g.push(b[h].body.data);
          return this.world.hitTest(f, g, d);
        },
        toJSON: function () {
          return this.world.toJSON();
        },
        createCollisionGroup: function (a) {
          var b = Math.pow(2, this._collisionGroupID);
          this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | b),
            this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | b),
            this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | b),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | b),
            this._collisionGroupID++;
          var d = new c.Physics.P2.CollisionGroup(b);
          return this.collisionGroups.push(d), a && this.setCollisionGroup(a, d), d;
        },
        setCollisionGroup: function (a, b) {
          if (a instanceof c.Group) for (var d = 0; d < a.total; d++) a.children[d].body && a.children[d].body.type === c.Physics.P2JS && a.children[d].body.setCollisionGroup(b);
          else a.body.setCollisionGroup(b);
        },
        createSpring: function (a, b, d, e, f, g, h, i, j) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addSpring(new c.Physics.P2.Spring(this, a, b, d, e, f, g, h, i, j)) : void 0;
        },
        createRotationalSpring: function (a, b, d, e, f) {
          return (a = this.getBody(a)), (b = this.getBody(b)), a && b ? this.addSpring(new c.Physics.P2.RotationalSpring(this, a, b, d, e, f)) : void 0;
        },
        createBody: function (a, b, d, e, f, g) {
          void 0 === e && (e = !1);
          var h = new c.Physics.P2.Body(this.game, null, a, b, d);
          if (g) {
            var i = h.addPolygon(f, g);
            if (!i) return !1;
          }
          return e && this.world.addBody(h.data), h;
        },
        createParticle: function (a, b, d, e, f, g) {
          void 0 === e && (e = !1);
          var h = new c.Physics.P2.Body(this.game, null, a, b, d);
          if (g) {
            var i = h.addPolygon(f, g);
            if (!i) return !1;
          }
          return e && this.world.addBody(h.data), h;
        },
        convertCollisionObjects: function (a, b, c) {
          void 0 === c && (c = !0);
          for (var d = [], e = 0, f = a.collision[b].length; e < f; e++) {
            var g = a.collision[b][e],
              h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
            h && d.push(h);
          }
          return d;
        },
        clearTilemapLayerBodies: function (a, b) {
          b = a.getLayer(b);
          for (var c = a.layers[b].bodies.length; c--; ) a.layers[b].bodies[c].destroy();
          a.layers[b].bodies.length = 0;
        },
        convertTilemap: function (a, b, c, d) {
          (b = a.getLayer(b)), void 0 === c && (c = !0), void 0 === d && (d = !0), this.clearTilemapLayerBodies(a, b);
          for (var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; h < i; h++) {
            e = 0;
            for (var j = 0, k = a.layers[b].width; j < k; j++) {
              var l = a.layers[b].data[h][j];
              if (l && l.index > -1 && l.collides)
                if (d) {
                  var m = a.getTileRight(b, j, h);
                  if ((0 === e && ((f = l.x * l.width), (g = l.y * l.height), (e = l.width)), m && m.collides)) e += l.width;
                  else {
                    var n = this.createBody(f, g, 0, !1);
                    n.addRectangle(e, l.height, e / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n), (e = 0);
                  }
                } else {
                  var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                  n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0), c && this.addBody(n), a.layers[b].bodies.push(n);
                }
            }
          }
          return a.layers[b].bodies;
        },
        mpx: function (a) {
          return (a *= 20);
        },
        pxm: function (a) {
          return 0.05 * a;
        },
        mpxi: function (a) {
          return (a *= -20);
        },
        pxmi: function (a) {
          return a * -0.05;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "friction", {
        get: function () {
          return this.world.defaultContactMaterial.friction;
        },
        set: function (a) {
          this.world.defaultContactMaterial.friction = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "restitution", {
        get: function () {
          return this.world.defaultContactMaterial.restitution;
        },
        set: function (a) {
          this.world.defaultContactMaterial.restitution = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "contactMaterial", {
        get: function () {
          return this.world.defaultContactMaterial;
        },
        set: function (a) {
          this.world.defaultContactMaterial = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "applySpringForces", {
        get: function () {
          return this.world.applySpringForces;
        },
        set: function (a) {
          this.world.applySpringForces = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "applyDamping", {
        get: function () {
          return this.world.applyDamping;
        },
        set: function (a) {
          this.world.applyDamping = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "applyGravity", {
        get: function () {
          return this.world.applyGravity;
        },
        set: function (a) {
          this.world.applyGravity = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "solveConstraints", {
        get: function () {
          return this.world.solveConstraints;
        },
        set: function (a) {
          this.world.solveConstraints = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "time", {
        get: function () {
          return this.world.time;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "emitImpactEvent", {
        get: function () {
          return this.world.emitImpactEvent;
        },
        set: function (a) {
          this.world.emitImpactEvent = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "sleepMode", {
        get: function () {
          return this.world.sleepMode;
        },
        set: function (a) {
          this.world.sleepMode = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.prototype, "total", {
        get: function () {
          return this.world.bodies.length;
        },
      }),
      (c.Physics.P2.FixtureList = function (a) {
        Array.isArray(a) || (a = [a]), (this.rawList = a), this.init(), this.parse(this.rawList);
      }),
      (c.Physics.P2.FixtureList.prototype = {
        init: function () {
          (this.namedFixtures = {}), (this.groupedFixtures = []), (this.allFixtures = []);
        },
        setCategory: function (a, b) {
          var c = function (b) {
            b.collisionGroup = a;
          };
          this.getFixtures(b).forEach(c);
        },
        setMask: function (a, b) {
          var c = function (b) {
            b.collisionMask = a;
          };
          this.getFixtures(b).forEach(c);
        },
        setSensor: function (a, b) {
          var c = function (b) {
            b.sensor = a;
          };
          this.getFixtures(b).forEach(c);
        },
        setMaterial: function (a, b) {
          var c = function (b) {
            b.material = a;
          };
          this.getFixtures(b).forEach(c);
        },
        getFixtures: function (a) {
          var b = [];
          if (a) {
            a instanceof Array || (a = [a]);
            var c = this;
            return (
              a.forEach(function (a) {
                c.namedFixtures[a] && b.push(c.namedFixtures[a]);
              }),
              this.flatten(b)
            );
          }
          return this.allFixtures;
        },
        getFixtureByKey: function (a) {
          return this.namedFixtures[a];
        },
        getGroup: function (a) {
          return this.groupedFixtures[a];
        },
        parse: function () {
          var a, b, c, d;
          (c = this.rawList), (d = []);
          for (a in c)
            (b = c[a]),
              isNaN(a - 0) ? (this.namedFixtures[a] = this.flatten(b)) : ((this.groupedFixtures[a] = this.groupedFixtures[a] || []), (this.groupedFixtures[a] = this.groupedFixtures[a].concat(b))),
              d.push((this.allFixtures = this.flatten(this.groupedFixtures)));
        },
        flatten: function (a) {
          var b, c;
          return (
            (b = []),
            (c = arguments.callee),
            a.forEach(function (a) {
              return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [a]);
            }),
            b
          );
        },
      }),
      (c.Physics.P2.PointProxy = function (a, b) {
        (this.world = a), (this.destination = b);
      }),
      (c.Physics.P2.PointProxy.prototype.constructor = c.Physics.P2.PointProxy),
      Object.defineProperty(c.Physics.P2.PointProxy.prototype, "x", {
        get: function () {
          return this.world.mpx(this.destination[0]);
        },
        set: function (a) {
          this.destination[0] = this.world.pxm(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.PointProxy.prototype, "y", {
        get: function () {
          return this.world.mpx(this.destination[1]);
        },
        set: function (a) {
          this.destination[1] = this.world.pxm(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.PointProxy.prototype, "mx", {
        get: function () {
          return this.destination[0];
        },
        set: function (a) {
          this.destination[0] = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.PointProxy.prototype, "my", {
        get: function () {
          return this.destination[1];
        },
        set: function (a) {
          this.destination[1] = a;
        },
      }),
      (c.Physics.P2.InversePointProxy = function (a, b) {
        (this.world = a), (this.destination = b);
      }),
      (c.Physics.P2.InversePointProxy.prototype.constructor = c.Physics.P2.InversePointProxy),
      Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "x", {
        get: function () {
          return this.world.mpxi(this.destination[0]);
        },
        set: function (a) {
          this.destination[0] = this.world.pxmi(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "y", {
        get: function () {
          return this.world.mpxi(this.destination[1]);
        },
        set: function (a) {
          this.destination[1] = this.world.pxmi(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function () {
          return this.destination[0];
        },
        set: function (a) {
          this.destination[0] = -a;
        },
      }),
      Object.defineProperty(c.Physics.P2.InversePointProxy.prototype, "my", {
        get: function () {
          return this.destination[1];
        },
        set: function (a) {
          this.destination[1] = -a;
        },
      }),
      (c.Physics.P2.Body = function (a, b, d, e, f) {
        (b = b || null),
          (d = d || 0),
          (e = e || 0),
          void 0 === f && (f = 1),
          (this.game = a),
          (this.world = a.physics.p2),
          (this.sprite = b),
          (this.type = c.Physics.P2JS),
          (this.offset = new c.Point()),
          (this.data = new p2.Body({ position: [this.world.pxmi(d), this.world.pxmi(e)], mass: f })),
          (this.data.parent = this),
          (this.velocity = new c.Physics.P2.InversePointProxy(this.world, this.data.velocity)),
          (this.force = new c.Physics.P2.InversePointProxy(this.world, this.data.force)),
          (this.gravity = new c.Point()),
          (this.onBeginContact = new c.Signal()),
          (this.onEndContact = new c.Signal()),
          (this.collidesWith = []),
          (this.removeNextStep = !1),
          (this.debugBody = null),
          (this.dirty = !1),
          (this._collideWorldBounds = !0),
          (this._bodyCallbacks = {}),
          (this._bodyCallbackContext = {}),
          (this._groupCallbacks = {}),
          (this._groupCallbackContext = {}),
          (this._reset = !1),
          b && (this.setRectangleFromSprite(b), b.exists && this.game.physics.p2.addBody(this));
      }),
      (c.Physics.P2.Body.prototype = {
        createBodyCallback: function (a, b, c) {
          var d = -1;
          a.id ? (d = a.id) : a.body && (d = a.body.id), d > -1 && (null === b ? (delete this._bodyCallbacks[d], delete this._bodyCallbackContext[d]) : ((this._bodyCallbacks[d] = b), (this._bodyCallbackContext[d] = c)));
        },
        createGroupCallback: function (a, b, c) {
          null === b ? (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]) : ((this._groupCallbacks[a.mask] = b), (this._groupCallbackContext[a.mask] = c));
        },
        getCollisionMask: function () {
          var a = 0;
          this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
          for (var b = 0; b < this.collidesWith.length; b++) a |= this.collidesWith[b].mask;
          return a;
        },
        updateCollisionMask: function (a) {
          var b = this.getCollisionMask();
          if (void 0 === a) for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].collisionMask = b;
          else a.collisionMask = b;
        },
        setCollisionGroup: function (a, b) {
          var c = this.getCollisionMask();
          if (void 0 === b) for (var d = this.data.shapes.length - 1; d >= 0; d--) (this.data.shapes[d].collisionGroup = a.mask), (this.data.shapes[d].collisionMask = c);
          else (b.collisionGroup = a.mask), (b.collisionMask = c);
        },
        clearCollision: function (a, b, c) {
          if ((void 0 === a && (a = !0), void 0 === b && (b = !0), void 0 === c)) for (var d = this.data.shapes.length - 1; d >= 0; d--) a && (this.data.shapes[d].collisionGroup = null), b && (this.data.shapes[d].collisionMask = null);
          else a && (c.collisionGroup = null), b && (c.collisionMask = null);
          a && (this.collidesWith.length = 0);
        },
        removeCollisionGroup: function (a, b, c) {
          void 0 === b && (b = !0);
          var d;
          if (Array.isArray(a)) for (var e = 0; e < a.length; e++) (d = this.collidesWith.indexOf(a[e])), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
          else (d = this.collidesWith.indexOf(a)), d > -1 && (this.collidesWith.splice(d, 1), b && (delete this._groupCallbacks[a.mask], delete this._groupCallbackContext[a.mask]));
          var f = this.getCollisionMask();
          if (void 0 === c) for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
          else c.collisionMask = f;
        },
        collides: function (a, b, c, d) {
          if (Array.isArray(a)) for (var e = 0; e < a.length; e++) this.collidesWith.indexOf(a[e]) === -1 && (this.collidesWith.push(a[e]), b && this.createGroupCallback(a[e], b, c));
          else this.collidesWith.indexOf(a) === -1 && (this.collidesWith.push(a), b && this.createGroupCallback(a, b, c));
          var f = this.getCollisionMask();
          if (void 0 === d) for (var e = this.data.shapes.length - 1; e >= 0; e--) this.data.shapes[e].collisionMask = f;
          else d.collisionMask = f;
        },
        adjustCenterOfMass: function () {
          this.data.adjustCenterOfMass(), this.shapeChanged();
        },
        getVelocityAtPoint: function (a, b) {
          return this.data.getVelocityAtPoint(a, b);
        },
        applyDamping: function (a) {
          this.data.applyDamping(a);
        },
        applyImpulse: function (a, b, c) {
          this.data.applyImpulse(a, [this.world.pxmi(b), this.world.pxmi(c)]);
        },
        applyImpulseLocal: function (a, b, c) {
          this.data.applyImpulseLocal(a, [this.world.pxmi(b), this.world.pxmi(c)]);
        },
        applyForce: function (a, b, c) {
          this.data.applyForce(a, [this.world.pxmi(b), this.world.pxmi(c)]);
        },
        setZeroForce: function () {
          this.data.setZeroForce();
        },
        setZeroRotation: function () {
          this.data.angularVelocity = 0;
        },
        setZeroVelocity: function () {
          (this.data.velocity[0] = 0), (this.data.velocity[1] = 0);
        },
        setZeroDamping: function () {
          (this.data.damping = 0), (this.data.angularDamping = 0);
        },
        toLocalFrame: function (a, b) {
          return this.data.toLocalFrame(a, b);
        },
        toWorldFrame: function (a, b) {
          return this.data.toWorldFrame(a, b);
        },
        rotateLeft: function (a) {
          this.data.angularVelocity = this.world.pxm(-a);
        },
        rotateRight: function (a) {
          this.data.angularVelocity = this.world.pxm(a);
        },
        moveForward: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle + Math.PI / 2;
          (this.data.velocity[0] = b * Math.cos(c)), (this.data.velocity[1] = b * Math.sin(c));
        },
        moveBackward: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle + Math.PI / 2;
          (this.data.velocity[0] = -(b * Math.cos(c))), (this.data.velocity[1] = -(b * Math.sin(c)));
        },
        thrust: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle + Math.PI / 2;
          (this.data.force[0] += b * Math.cos(c)), (this.data.force[1] += b * Math.sin(c));
        },
        thrustLeft: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle;
          (this.data.force[0] += b * Math.cos(c)), (this.data.force[1] += b * Math.sin(c));
        },
        thrustRight: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle;
          (this.data.force[0] -= b * Math.cos(c)), (this.data.force[1] -= b * Math.sin(c));
        },
        reverse: function (a) {
          var b = this.world.pxmi(-a),
            c = this.data.angle + Math.PI / 2;
          (this.data.force[0] -= b * Math.cos(c)), (this.data.force[1] -= b * Math.sin(c));
        },
        moveLeft: function (a) {
          this.data.velocity[0] = this.world.pxmi(-a);
        },
        moveRight: function (a) {
          this.data.velocity[0] = this.world.pxmi(a);
        },
        moveUp: function (a) {
          this.data.velocity[1] = this.world.pxmi(-a);
        },
        moveDown: function (a) {
          this.data.velocity[1] = this.world.pxmi(a);
        },
        preUpdate: function () {
          (this.dirty = !0), this.removeNextStep && (this.removeFromWorld(), (this.removeNextStep = !1));
        },
        postUpdate: function () {
          (this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x),
            (this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y),
            this.fixedRotation || (this.sprite.rotation = this.data.angle),
            this.debugBody && this.debugBody.updateSpriteTransform(),
            (this.dirty = !1);
        },
        reset: function (a, b, c, d) {
          void 0 === c && (c = !1), void 0 === d && (d = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), c && this.setZeroDamping(), d && (this.mass = 1), (this.x = a), (this.y = b);
        },
        addToWorld: function () {
          if (this.game.physics.p2._toRemove) for (var a = 0; a < this.game.physics.p2._toRemove.length; a++) this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
          this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this);
        },
        removeFromWorld: function () {
          this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this);
        },
        destroy: function () {
          this.removeFromWorld(),
            this.clearShapes(),
            (this._bodyCallbacks = {}),
            (this._bodyCallbackContext = {}),
            (this._groupCallbacks = {}),
            (this._groupCallbackContext = {}),
            this.debugBody && this.debugBody.destroy(!0, !0),
            (this.debugBody = null),
            this.sprite && ((this.sprite.body = null), (this.sprite = null));
        },
        clearShapes: function () {
          for (var a = this.data.shapes.length; a--; ) this.data.removeShape(this.data.shapes[a]);
          this.shapeChanged();
        },
        addShape: function (a, b, c, d) {
          return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.data.addShape(a, [this.world.pxmi(b), this.world.pxmi(c)], d), this.shapeChanged(), a;
        },
        addCircle: function (a, b, c, d) {
          var e = new p2.Circle({ radius: this.world.pxm(a) });
          return this.addShape(e, b, c, d);
        },
        addRectangle: function (a, b, c, d, e) {
          var f = new p2.Box({ width: this.world.pxm(a), height: this.world.pxm(b) });
          return this.addShape(f, c, d, e);
        },
        addPlane: function (a, b, c) {
          var d = new p2.Plane();
          return this.addShape(d, a, b, c);
        },
        addParticle: function (a, b, c) {
          var d = new p2.Particle();
          return this.addShape(d, a, b, c);
        },
        addLine: function (a, b, c, d) {
          var e = new p2.Line({ length: this.world.pxm(a) });
          return this.addShape(e, b, c, d);
        },
        addCapsule: function (a, b, c, d, e) {
          var f = new p2.Capsule({ length: this.world.pxm(a), radius: this.world.pxm(b) });
          return this.addShape(f, c, d, e);
        },
        addPolygon: function (a, b) {
          (a = a || {}), Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
          var c = [];
          if (1 === b.length && Array.isArray(b[0])) c = b[0].slice(0);
          else if (Array.isArray(b[0])) c = b.slice();
          else if ("number" == typeof b[0]) for (var d = 0, e = b.length; d < e; d += 2) c.push([b[d], b[d + 1]]);
          var f = c.length - 1;
          c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
          for (var g = 0; g < c.length; g++) (c[g][0] = this.world.pxmi(c[g][0])), (c[g][1] = this.world.pxmi(c[g][1]));
          var h = this.data.fromPolygon(c, a);
          return this.shapeChanged(), h;
        },
        removeShape: function (a) {
          var b = this.data.removeShape(a);
          return this.shapeChanged(), b;
        },
        setCircle: function (a, b, c, d) {
          return this.clearShapes(), this.addCircle(a, b, c, d);
        },
        setRectangle: function (a, b, c, d, e) {
          return void 0 === a && (a = 16), void 0 === b && (b = 16), this.clearShapes(), this.addRectangle(a, b, c, d, e);
        },
        setRectangleFromSprite: function (a) {
          return void 0 === a && (a = this.sprite), this.clearShapes(), this.addRectangle(a.width, a.height, 0, 0, a.rotation);
        },
        setMaterial: function (a, b) {
          if (void 0 === b) for (var c = this.data.shapes.length - 1; c >= 0; c--) this.data.shapes[c].material = a;
          else b.material = a;
        },
        shapeChanged: function () {
          this.debugBody && this.debugBody.draw();
        },
        addPhaserPolygon: function (a, b) {
          for (var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++) {
            var f = c[e],
              g = this.addFixture(f);
            (d[f.filter.group] = d[f.filter.group] || []), (d[f.filter.group] = d[f.filter.group].concat(g)), f.fixtureKey && (d[f.fixtureKey] = g);
          }
          return (this.data.aabbNeedsUpdate = !0), this.shapeChanged(), d;
        },
        addFixture: function (a) {
          var b = [];
          if (a.circle) {
            var c = new p2.Circle({ radius: this.world.pxm(a.circle.radius) });
            (c.collisionGroup = a.filter.categoryBits), (c.collisionMask = a.filter.maskBits), (c.sensor = a.isSensor);
            var d = p2.vec2.create();
            (d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2)), (d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2)), this.data.addShape(c, d), b.push(c);
          } else
            for (var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++) {
              for (var h = e[g], i = [], j = 0; j < h.length; j += 2) i.push([this.world.pxmi(h[j]), this.world.pxmi(h[j + 1])]);
              for (var c = new p2.Convex({ vertices: i }), k = 0; k !== c.vertices.length; k++) {
                var l = c.vertices[k];
                p2.vec2.sub(l, l, c.centerOfMass);
              }
              p2.vec2.scale(f, c.centerOfMass, 1),
                (f[0] -= this.world.pxmi(this.sprite.width / 2)),
                (f[1] -= this.world.pxmi(this.sprite.height / 2)),
                c.updateTriangles(),
                c.updateCenterOfMass(),
                c.updateBoundingRadius(),
                (c.collisionGroup = a.filter.categoryBits),
                (c.collisionMask = a.filter.maskBits),
                (c.sensor = a.isSensor),
                this.data.addShape(c, f),
                b.push(c);
            }
          return b;
        },
        loadPolygon: function (a, b) {
          if (null === a) var c = b;
          else var c = this.game.cache.getPhysicsData(a, b);
          for (var d = p2.vec2.create(), e = 0; e < c.length; e++) {
            for (var f = [], g = 0; g < c[e].shape.length; g += 2) f.push([this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1])]);
            for (var h = new p2.Convex({ vertices: f }), i = 0; i !== h.vertices.length; i++) {
              var j = h.vertices[i];
              p2.vec2.sub(j, j, h.centerOfMass);
            }
            p2.vec2.scale(d, h.centerOfMass, 1),
              (d[0] -= this.world.pxmi(this.sprite.width / 2)),
              (d[1] -= this.world.pxmi(this.sprite.height / 2)),
              h.updateTriangles(),
              h.updateCenterOfMass(),
              h.updateBoundingRadius(),
              this.data.addShape(h, d);
          }
          return (this.data.aabbNeedsUpdate = !0), this.shapeChanged(), !0;
        },
      }),
      (c.Physics.P2.Body.prototype.constructor = c.Physics.P2.Body),
      (c.Physics.P2.Body.DYNAMIC = 1),
      (c.Physics.P2.Body.STATIC = 2),
      (c.Physics.P2.Body.KINEMATIC = 4),
      Object.defineProperty(c.Physics.P2.Body.prototype, "static", {
        get: function () {
          return this.data.type === c.Physics.P2.Body.STATIC;
        },
        set: function (a) {
          a && this.data.type !== c.Physics.P2.Body.STATIC
            ? ((this.data.type = c.Physics.P2.Body.STATIC), (this.mass = 0))
            : a || this.data.type !== c.Physics.P2.Body.STATIC || ((this.data.type = c.Physics.P2.Body.DYNAMIC), (this.mass = 1));
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "dynamic", {
        get: function () {
          return this.data.type === c.Physics.P2.Body.DYNAMIC;
        },
        set: function (a) {
          a && this.data.type !== c.Physics.P2.Body.DYNAMIC
            ? ((this.data.type = c.Physics.P2.Body.DYNAMIC), (this.mass = 1))
            : a || this.data.type !== c.Physics.P2.Body.DYNAMIC || ((this.data.type = c.Physics.P2.Body.STATIC), (this.mass = 0));
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "kinematic", {
        get: function () {
          return this.data.type === c.Physics.P2.Body.KINEMATIC;
        },
        set: function (a) {
          a && this.data.type !== c.Physics.P2.Body.KINEMATIC
            ? ((this.data.type = c.Physics.P2.Body.KINEMATIC), (this.mass = 4))
            : a || this.data.type !== c.Physics.P2.Body.KINEMATIC || ((this.data.type = c.Physics.P2.Body.STATIC), (this.mass = 0));
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "allowSleep", {
        get: function () {
          return this.data.allowSleep;
        },
        set: function (a) {
          a !== this.data.allowSleep && (this.data.allowSleep = a);
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "angle", {
        get: function () {
          return c.Math.wrapAngle(c.Math.radToDeg(this.data.angle));
        },
        set: function (a) {
          this.data.angle = c.Math.degToRad(c.Math.wrapAngle(a));
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "angularDamping", {
        get: function () {
          return this.data.angularDamping;
        },
        set: function (a) {
          this.data.angularDamping = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "angularForce", {
        get: function () {
          return this.data.angularForce;
        },
        set: function (a) {
          this.data.angularForce = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "angularVelocity", {
        get: function () {
          return this.data.angularVelocity;
        },
        set: function (a) {
          this.data.angularVelocity = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "damping", {
        get: function () {
          return this.data.damping;
        },
        set: function (a) {
          this.data.damping = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "fixedRotation", {
        get: function () {
          return this.data.fixedRotation;
        },
        set: function (a) {
          a !== this.data.fixedRotation && (this.data.fixedRotation = a);
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "inertia", {
        get: function () {
          return this.data.inertia;
        },
        set: function (a) {
          this.data.inertia = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "mass", {
        get: function () {
          return this.data.mass;
        },
        set: function (a) {
          a !== this.data.mass && ((this.data.mass = a), this.data.updateMassProperties());
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "motionState", {
        get: function () {
          return this.data.type;
        },
        set: function (a) {
          a !== this.data.type && (this.data.type = a);
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "rotation", {
        get: function () {
          return this.data.angle;
        },
        set: function (a) {
          this.data.angle = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function () {
          return this.data.sleepSpeedLimit;
        },
        set: function (a) {
          this.data.sleepSpeedLimit = a;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "x", {
        get: function () {
          return this.world.mpxi(this.data.position[0]);
        },
        set: function (a) {
          this.data.position[0] = this.world.pxmi(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "y", {
        get: function () {
          return this.world.mpxi(this.data.position[1]);
        },
        set: function (a) {
          this.data.position[1] = this.world.pxmi(a);
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "id", {
        get: function () {
          return this.data.id;
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "debug", {
        get: function () {
          return null !== this.debugBody;
        },
        set: function (a) {
          a && !this.debugBody ? (this.debugBody = new c.Physics.P2.BodyDebug(this.game, this.data)) : !a && this.debugBody && (this.debugBody.destroy(), (this.debugBody = null));
        },
      }),
      Object.defineProperty(c.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function () {
          return this._collideWorldBounds;
        },
        set: function (a) {
          a && !this._collideWorldBounds ? ((this._collideWorldBounds = !0), this.updateCollisionMask()) : !a && this._collideWorldBounds && ((this._collideWorldBounds = !1), this.updateCollisionMask());
        },
      }),
      (c.Physics.P2.BodyDebug = function (a, b, d) {
        c.Group.call(this, a);
        var e = { pixelsPerLengthUnit: a.physics.p2.mpx(1), debugPolygons: !1, lineWidth: 1, alpha: 0.5 };
        (this.settings = c.Utils.extend(e, d)),
          (this.ppu = this.settings.pixelsPerLengthUnit),
          (this.ppu = -1 * this.ppu),
          (this.body = b),
          (this.canvas = new c.Graphics(a)),
          (this.canvas.alpha = this.settings.alpha),
          this.add(this.canvas),
          this.draw(),
          this.updateSpriteTransform();
      }),
      (c.Physics.P2.BodyDebug.prototype = Object.create(c.Group.prototype)),
      (c.Physics.P2.BodyDebug.prototype.constructor = c.Physics.P2.BodyDebug),
      c.Utils.extend(c.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function () {
          (this.position.x = this.body.position[0] * this.ppu), (this.position.y = this.body.position[1] * this.ppu), (this.rotation = this.body.angle);
        },
        draw: function () {
          var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
          if (((h = this.body), (j = this.canvas), j.clear(), (c = parseInt(this.randomPastelHex(), 16)), (f = 16711680), (g = this.lineWidth), h instanceof p2.Body && h.shapes.length)) {
            var p = h.shapes.length;
            for (d = 0; d !== p; ) {
              if (((b = h.shapes[d]), (i = b.position || 0), (a = b.angle || 0), b instanceof p2.Circle)) this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
              else if (b instanceof p2.Capsule) this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g);
              else if (b instanceof p2.Plane) this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
              else if (b instanceof p2.Line) this.drawLine(j, b.length * this.ppu, f, g);
              else if (b instanceof p2.Box) this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g);
              else if (b instanceof p2.Convex) {
                for (l = [], m = p2.vec2.create(), e = n = 0, o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n)
                  (k = b.vertices[e]), p2.vec2.rotate(m, k, a), l.push([(m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu]);
                this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [i[0] * this.ppu, -i[1] * this.ppu]);
              }
              d++;
            }
          }
        },
        drawRectangle: function (a, b, c, d, e, f, g, h, i) {
          void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1), a.beginFill(h), a.drawRect(b - e / 2, c - f / 2, e, f);
        },
        drawCircle: function (a, b, c, d, e, f, g) {
          void 0 === g && (g = 1), void 0 === f && (f = 16777215), a.lineStyle(g, 0, 1), a.beginFill(f, 1), a.drawCircle(b, c, 2 * -e), a.endFill(), a.moveTo(b, c), a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d));
        },
        drawLine: function (a, b, c, d) {
          void 0 === d && (d = 1), void 0 === c && (c = 0), a.lineStyle(5 * d, c, 1), a.moveTo(-b / 2, 0), a.lineTo(b / 2, 0);
        },
        drawConvex: function (a, b, c, d, e, f, g, h) {
          var i, j, k, l, m, n, o, p, q, r, s;
          if ((void 0 === f && (f = 1), void 0 === d && (d = 0), g)) {
            for (i = [16711680, 65280, 255], j = 0; j !== b.length + 1; )
              (l = b[j % b.length]), (m = b[(j + 1) % b.length]), (o = l[0]), (r = l[1]), (p = m[0]), (s = m[1]), a.lineStyle(f, i[j % i.length], 1), a.moveTo(o, -r), a.lineTo(p, -s), a.drawCircle(o, -r, 2 * f), j++;
            return a.lineStyle(f, 0, 1), a.drawCircle(h[0], h[1], 2 * f);
          }
          for (a.lineStyle(f, d, 1), a.beginFill(e), j = 0; j !== b.length; ) (k = b[j]), (n = k[0]), (q = k[1]), 0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q), j++;
          if ((a.endFill(), b.length > 2)) return a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]), a.lineTo(b[0][0], -b[0][1]);
        },
        drawPath: function (a, b, c, d, e) {
          var f, g, h, i, j, k, l, m, n, o, p, q, r;
          for (void 0 === e && (e = 1), void 0 === c && (c = 0), a.lineStyle(e, c, 1), "number" == typeof d && a.beginFill(d), h = null, i = null, g = 0; g < b.length; )
            (p = b[g]),
              (q = p[0]),
              (r = p[1]),
              (q === h && r === i) ||
                (0 === g ? a.moveTo(q, r) : ((j = h), (k = i), (l = q), (m = r), (n = b[(g + 1) % b.length][0]), (o = b[(g + 1) % b.length][1]), (f = (l - j) * (o - k) - (n - j) * (m - k)), 0 !== f && a.lineTo(q, r)), (h = q), (i = r)),
              g++;
          "number" == typeof d && a.endFill(), b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]), a.lineTo(b[0][0], b[0][1]));
        },
        drawPlane: function (a, b, c, d, e, f, g, h, i, j) {
          var k, l, m;
          void 0 === f && (f = 1),
            void 0 === d && (d = 16777215),
            a.lineStyle(f, e, 11),
            a.beginFill(d),
            (k = i),
            a.moveTo(b, -c),
            (l = b + Math.cos(j) * this.game.width),
            (m = c + Math.sin(j) * this.game.height),
            a.lineTo(l, -m),
            a.moveTo(b, -c),
            (l = b + Math.cos(j) * -this.game.width),
            (m = c + Math.sin(j) * -this.game.height),
            a.lineTo(l, -m);
        },
        drawCapsule: function (a, b, c, d, e, f, g, h, i) {
          void 0 === i && (i = 1), void 0 === g && (g = 0), a.lineStyle(i, g, 1);
          var j = Math.cos(d),
            k = Math.sin(d);
          a.beginFill(h, 1),
            a.drawCircle((-e / 2) * j + b, (-e / 2) * k + c, 2 * -f),
            a.drawCircle((e / 2) * j + b, (e / 2) * k + c, 2 * -f),
            a.endFill(),
            a.lineStyle(i, g, 0),
            a.beginFill(h, 1),
            a.moveTo((-e / 2) * j + f * k + b, (-e / 2) * k + f * j + c),
            a.lineTo((e / 2) * j + f * k + b, (e / 2) * k + f * j + c),
            a.lineTo((e / 2) * j - f * k + b, (e / 2) * k - f * j + c),
            a.lineTo((-e / 2) * j - f * k + b, (-e / 2) * k - f * j + c),
            a.endFill(),
            a.lineStyle(i, g, 1),
            a.moveTo((-e / 2) * j + f * k + b, (-e / 2) * k + f * j + c),
            a.lineTo((e / 2) * j + f * k + b, (e / 2) * k + f * j + c),
            a.moveTo((-e / 2) * j - f * k + b, (-e / 2) * k - f * j + c),
            a.lineTo((e / 2) * j - f * k + b, (e / 2) * k - f * j + c);
        },
        randomPastelHex: function () {
          var a, b, c, d;
          return (
            (c = [255, 255, 255]),
            (d = Math.floor(256 * Math.random())),
            (b = Math.floor(256 * Math.random())),
            (a = Math.floor(256 * Math.random())),
            (d = Math.floor((d + 3 * c[0]) / 4)),
            (b = Math.floor((b + 3 * c[1]) / 4)),
            (a = Math.floor((a + 3 * c[2]) / 4)),
            this.rgbToHex(d, b, a)
          );
        },
        rgbToHex: function (a, b, c) {
          return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c);
        },
        componentToHex: function (a) {
          var b;
          return (b = a.toString(16)), 2 === b.length ? b : b + "0";
        },
      }),
      (c.Physics.P2.Spring = function (a, b, c, d, e, f, g, h, i, j) {
        (this.game = a.game), (this.world = a), void 0 === d && (d = 1), void 0 === e && (e = 100), void 0 === f && (f = 1), (d = a.pxm(d));
        var k = { restLength: d, stiffness: e, damping: f };
        "undefined" != typeof g && null !== g && (k.worldAnchorA = [a.pxm(g[0]), a.pxm(g[1])]),
          "undefined" != typeof h && null !== h && (k.worldAnchorB = [a.pxm(h[0]), a.pxm(h[1])]),
          "undefined" != typeof i && null !== i && (k.localAnchorA = [a.pxm(i[0]), a.pxm(i[1])]),
          "undefined" != typeof j && null !== j && (k.localAnchorB = [a.pxm(j[0]), a.pxm(j[1])]),
          (this.data = new p2.LinearSpring(b, c, k)),
          (this.data.parent = this);
      }),
      (c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring),
      (c.Physics.P2.RotationalSpring = function (a, b, c, d, e, f) {
        (this.game = a.game), (this.world = a), void 0 === d && (d = null), void 0 === e && (e = 100), void 0 === f && (f = 1), d && (d = a.pxm(d));
        var g = { restAngle: d, stiffness: e, damping: f };
        (this.data = new p2.RotationalSpring(b, c, g)), (this.data.parent = this);
      }),
      (c.Physics.P2.Spring.prototype.constructor = c.Physics.P2.Spring),
      (c.Physics.P2.Material = function (a) {
        (this.name = a), p2.Material.call(this);
      }),
      (c.Physics.P2.Material.prototype = Object.create(p2.Material.prototype)),
      (c.Physics.P2.Material.prototype.constructor = c.Physics.P2.Material),
      (c.Physics.P2.ContactMaterial = function (a, b, c) {
        p2.ContactMaterial.call(this, a, b, c);
      }),
      (c.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype)),
      (c.Physics.P2.ContactMaterial.prototype.constructor = c.Physics.P2.ContactMaterial),
      (c.Physics.P2.CollisionGroup = function (a) {
        this.mask = a;
      }),
      (c.Physics.P2.DistanceConstraint = function (a, b, c, d, e, f, g) {
        void 0 === d && (d = 100),
          void 0 === e && (e = [0, 0]),
          void 0 === f && (f = [0, 0]),
          void 0 === g && (g = Number.MAX_VALUE),
          (this.game = a.game),
          (this.world = a),
          (d = a.pxm(d)),
          (e = [a.pxmi(e[0]), a.pxmi(e[1])]),
          (f = [a.pxmi(f[0]), a.pxmi(f[1])]);
        var h = { distance: d, localAnchorA: e, localAnchorB: f, maxForce: g };
        p2.DistanceConstraint.call(this, b, c, h);
      }),
      (c.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype)),
      (c.Physics.P2.DistanceConstraint.prototype.constructor = c.Physics.P2.DistanceConstraint),
      (c.Physics.P2.GearConstraint = function (a, b, c, d, e) {
        void 0 === d && (d = 0), void 0 === e && (e = 1), (this.game = a.game), (this.world = a);
        var f = { angle: d, ratio: e };
        p2.GearConstraint.call(this, b, c, f);
      }),
      (c.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype)),
      (c.Physics.P2.GearConstraint.prototype.constructor = c.Physics.P2.GearConstraint),
      (c.Physics.P2.LockConstraint = function (a, b, c, d, e, f) {
        void 0 === d && (d = [0, 0]), void 0 === e && (e = 0), void 0 === f && (f = Number.MAX_VALUE), (this.game = a.game), (this.world = a), (d = [a.pxm(d[0]), a.pxm(d[1])]);
        var g = { localOffsetB: d, localAngleB: e, maxForce: f };
        p2.LockConstraint.call(this, b, c, g);
      }),
      (c.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype)),
      (c.Physics.P2.LockConstraint.prototype.constructor = c.Physics.P2.LockConstraint),
      (c.Physics.P2.PrismaticConstraint = function (a, b, c, d, e, f, g, h) {
        void 0 === d && (d = !0),
          void 0 === e && (e = [0, 0]),
          void 0 === f && (f = [0, 0]),
          void 0 === g && (g = [0, 0]),
          void 0 === h && (h = Number.MAX_VALUE),
          (this.game = a.game),
          (this.world = a),
          (e = [a.pxmi(e[0]), a.pxmi(e[1])]),
          (f = [a.pxmi(f[0]), a.pxmi(f[1])]);
        var i = { localAnchorA: e, localAnchorB: f, localAxisA: g, maxForce: h, disableRotationalLock: !d };
        p2.PrismaticConstraint.call(this, b, c, i);
      }),
      (c.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype)),
      (c.Physics.P2.PrismaticConstraint.prototype.constructor = c.Physics.P2.PrismaticConstraint),
      (c.Physics.P2.RevoluteConstraint = function (a, b, c, d, e, f, g) {
        void 0 === f && (f = Number.MAX_VALUE), void 0 === g && (g = null), (this.game = a.game), (this.world = a), (c = [a.pxmi(c[0]), a.pxmi(c[1])]), (e = [a.pxmi(e[0]), a.pxmi(e[1])]), g && (g = [a.pxmi(g[0]), a.pxmi(g[1])]);
        var h = { worldPivot: g, localPivotA: c, localPivotB: e, maxForce: f };
        p2.RevoluteConstraint.call(this, b, d, h);
      }),
      (c.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype)),
      (c.Physics.P2.RevoluteConstraint.prototype.constructor = c.Physics.P2.RevoluteConstraint),
      (c.ImageCollection = function (a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32),
          (void 0 === d || d <= 0) && (d = 32),
          void 0 === e && (e = 0),
          void 0 === f && (f = 0),
          (this.name = a),
          (this.firstgid = 0 | b),
          (this.imageWidth = 0 | c),
          (this.imageHeight = 0 | d),
          (this.imageMargin = 0 | e),
          (this.imageSpacing = 0 | f),
          (this.properties = g || {}),
          (this.images = []),
          (this.total = 0);
      }),
      (c.ImageCollection.prototype = {
        containsImageIndex: function (a) {
          return a >= this.firstgid && a < this.firstgid + this.total;
        },
        addImage: function (a, b) {
          this.images.push({ gid: a, image: b }), this.total++;
        },
      }),
      (c.ImageCollection.prototype.constructor = c.ImageCollection),
      (c.Tile = function (a, b, c, d, e, f) {
        (this.layer = a),
          (this.index = b),
          (this.x = c),
          (this.y = d),
          (this.rotation = 0),
          (this.flipped = !1),
          (this.worldX = c * e),
          (this.worldY = d * f),
          (this.width = e),
          (this.height = f),
          (this.centerX = Math.abs(e / 2)),
          (this.centerY = Math.abs(f / 2)),
          (this.alpha = 1),
          (this.properties = {}),
          (this.scanned = !1),
          (this.faceTop = !1),
          (this.faceBottom = !1),
          (this.faceLeft = !1),
          (this.faceRight = !1),
          (this.collideLeft = !1),
          (this.collideRight = !1),
          (this.collideUp = !1),
          (this.collideDown = !1),
          (this.collisionCallback = null),
          (this.collisionCallbackContext = this);
      }),
      (c.Tile.prototype = {
        containsPoint: function (a, b) {
          return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom);
        },
        intersects: function (a, b, c, d) {
          return !(c <= this.worldX || d <= this.worldY || a >= this.worldX + this.width || b >= this.worldY + this.height);
        },
        setCollisionCallback: function (a, b) {
          (this.collisionCallback = a), (this.collisionCallbackContext = b);
        },
        destroy: function () {
          (this.collisionCallback = null), (this.collisionCallbackContext = null), (this.properties = null);
        },
        setCollision: function (a, b, c, d) {
          (this.collideLeft = a), (this.collideRight = b), (this.collideUp = c), (this.collideDown = d), (this.faceLeft = a), (this.faceRight = b), (this.faceTop = c), (this.faceBottom = d);
        },
        resetCollision: function () {
          (this.collideLeft = !1), (this.collideRight = !1), (this.collideUp = !1), (this.collideDown = !1), (this.faceTop = !1), (this.faceBottom = !1), (this.faceLeft = !1), (this.faceRight = !1);
        },
        isInteresting: function (a, b) {
          return a && b
            ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback
            : a
            ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);
        },
        copy: function (a) {
          (this.index = a.index),
            (this.alpha = a.alpha),
            (this.properties = a.properties),
            (this.collideUp = a.collideUp),
            (this.collideDown = a.collideDown),
            (this.collideLeft = a.collideLeft),
            (this.collideRight = a.collideRight),
            (this.collisionCallback = a.collisionCallback),
            (this.collisionCallbackContext = a.collisionCallbackContext);
        },
      }),
      (c.Tile.prototype.constructor = c.Tile),
      Object.defineProperty(c.Tile.prototype, "collides", {
        get: function () {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
        },
      }),
      Object.defineProperty(c.Tile.prototype, "canCollide", {
        get: function () {
          return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
        },
      }),
      Object.defineProperty(c.Tile.prototype, "left", {
        get: function () {
          return this.worldX;
        },
      }),
      Object.defineProperty(c.Tile.prototype, "right", {
        get: function () {
          return this.worldX + this.width;
        },
      }),
      Object.defineProperty(c.Tile.prototype, "top", {
        get: function () {
          return this.worldY;
        },
      }),
      Object.defineProperty(c.Tile.prototype, "bottom", {
        get: function () {
          return this.worldY + this.height;
        },
      }),
      (c.Tilemap = function (a, b, d, e, f, g) {
        (this.game = a), (this.key = b);
        var h = c.TilemapParser.parse(this.game, b, d, e, f, g);
        null !== h &&
          ((this.width = h.width),
          (this.height = h.height),
          (this.tileWidth = h.tileWidth),
          (this.tileHeight = h.tileHeight),
          (this.orientation = h.orientation),
          (this.format = h.format),
          (this.version = h.version),
          (this.properties = h.properties),
          (this.widthInPixels = h.widthInPixels),
          (this.heightInPixels = h.heightInPixels),
          (this.layers = h.layers),
          (this.tilesets = h.tilesets),
          (this.imagecollections = h.imagecollections),
          (this.tiles = h.tiles),
          (this.objects = h.objects),
          (this.collideIndexes = []),
          (this.collision = h.collision),
          (this.images = h.images),
          (this.enableDebug = !1),
          (this.currentLayer = 0),
          (this.debugMap = []),
          (this._results = []),
          (this._tempA = 0),
          (this._tempB = 0));
      }),
      (c.Tilemap.CSV = 0),
      (c.Tilemap.TILED_JSON = 1),
      (c.Tilemap.NORTH = 0),
      (c.Tilemap.EAST = 1),
      (c.Tilemap.SOUTH = 2),
      (c.Tilemap.WEST = 3),
      (c.Tilemap.prototype = {
        create: function (a, b, c, d, e, f) {
          return void 0 === f && (f = this.game.world), (this.width = b), (this.height = c), this.setTileSize(d, e), (this.layers.length = 0), this.createBlankLayer(a, b, c, d, e, f);
        },
        setTileSize: function (a, b) {
          (this.tileWidth = a), (this.tileHeight = b), (this.widthInPixels = this.width * a), (this.heightInPixels = this.height * b);
        },
        addTilesetImage: function (a, b, d, e, f, g, h) {
          if (void 0 === a) return null;
          void 0 === d && (d = this.tileWidth), void 0 === e && (e = this.tileHeight), void 0 === f && (f = 0), void 0 === g && (g = 0), void 0 === h && (h = 0), 0 === d && (d = 32), 0 === e && (e = 32);
          var i = null;
          if (((void 0 !== b && null !== b) || (b = a), b instanceof c.BitmapData)) i = b.canvas;
          else {
            if (!this.game.cache.checkImageKey(b)) return null;
            i = this.game.cache.getImage(b);
          }
          var j = this.getTilesetIndex(a);
          if (null === j && this.format === c.Tilemap.TILED_JSON) return null;
          if (this.tilesets[j]) return this.tilesets[j].setImage(i), this.tilesets[j];
          var k = new c.Tileset(a, h, d, e, f, g, {});
          k.setImage(i), this.tilesets.push(k);
          for (
            var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h;
            r < h + k.total && ((this.tiles[r] = [m, n, l]), (m += d + g), o++, o !== k.total) && (p++, p !== k.columns || ((m = f), (n += e + g), (p = 0), q++, q !== k.rows));
            r++
          );
          return k;
        },
        createFromObjects: function (a, b, d, e, f, g, h, i, j) {
          if ((void 0 === f && (f = !0), void 0 === g && (g = !1), void 0 === h && (h = this.game.world), void 0 === i && (i = c.Sprite), void 0 === j && (j = !0), this.objects[a]))
            for (var k = 0; k < this.objects[a].length; k++) {
              var l = !1,
                m = this.objects[a][k];
              if ((void 0 !== m.gid && "number" == typeof b && m.gid === b ? (l = !0) : void 0 !== m.id && "number" == typeof b && m.id === b ? (l = !0) : void 0 !== m.name && "string" == typeof b && m.name === b && (l = !0), l)) {
                var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
                (n.name = m.name), (n.visible = m.visible), (n.autoCull = g), (n.exists = f), m.width && (n.width = m.width), m.height && (n.height = m.height), m.rotation && (n.angle = m.rotation), j && (n.y -= n.height), h.add(n);
                for (var o in m.properties) h.set(n, o, m.properties[o], !1, !1, 0, !0);
              }
            }
        },
        createFromTiles: function (a, b, d, e, f, g) {
          "number" == typeof a && (a = [a]),
            void 0 === b || null === b ? (b = []) : "number" == typeof b && (b = [b]),
            (e = this.getLayer(e)),
            void 0 === f && (f = this.game.world),
            void 0 === g && (g = {}),
            void 0 === g.customClass && (g.customClass = c.Sprite),
            void 0 === g.adjustY && (g.adjustY = !0);
          var h = this.layers[e].width,
            i = this.layers[e].height;
          if ((this.copy(0, 0, h, i, e), this._results.length < 2)) return 0;
          for (var j, k = 0, l = 1, m = this._results.length; l < m; l++)
            if (a.indexOf(this._results[l].index) !== -1) {
              j = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
              for (var n in g) j[n] = g[n];
              f.add(j), k++;
            }
          if (1 === b.length) for (l = 0; l < a.length; l++) this.replace(a[l], b[0], 0, 0, h, i, e);
          else if (b.length > 1) for (l = 0; l < a.length; l++) this.replace(a[l], b[l], 0, 0, h, i, e);
          return k;
        },
        createLayer: function (a, b, d, e) {
          void 0 === b && (b = this.game.width), void 0 === d && (d = this.game.height), void 0 === e && (e = this.game.world);
          var f = a;
          if (("string" == typeof a && (f = this.getLayerIndex(a)), !(null === f || f > this.layers.length))) {
            void 0 === b || b <= 0 ? (b = Math.min(this.game.width, this.layers[f].widthInPixels)) : b > this.game.width && (b = this.game.width),
              void 0 === d || d <= 0 ? (d = Math.min(this.game.height, this.layers[f].heightInPixels)) : d > this.game.height && (d = this.game.height),
              this.enableDebug && void 0;
            var g = e.add(new c.TilemapLayer(this.game, this, f, b, d));
            return this.enableDebug && void 0, g;
          }
        },
        createBlankLayer: function (a, b, d, e, f, g) {
          if ((void 0 === g && (g = this.game.world), null === this.getLayerIndex(a))) {
            for (var h, i = { name: a, x: 0, y: 0, width: b, height: d, widthInPixels: b * e, heightInPixels: d * f, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: null }, j = [], k = 0; k < d; k++) {
              h = [];
              for (var l = 0; l < b; l++) h.push(new c.Tile(i, -1, l, k, e, f));
              j.push(h);
            }
            (i.data = j), this.layers.push(i), (this.currentLayer = this.layers.length - 1);
            var m = i.widthInPixels,
              n = i.heightInPixels;
            m > this.game.width && (m = this.game.width), n > this.game.height && (n = this.game.height);
            var j = new c.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
            return (j.name = a), g.add(j);
          }
        },
        getIndex: function (a, b) {
          for (var c = 0; c < a.length; c++) if (a[c].name === b) return c;
          return null;
        },
        getLayerIndex: function (a) {
          return this.getIndex(this.layers, a);
        },
        getTilesetIndex: function (a) {
          return this.getIndex(this.tilesets, a);
        },
        getImageIndex: function (a) {
          return this.getIndex(this.images, a);
        },
        setTileIndexCallback: function (a, b, c, d) {
          if (((d = this.getLayer(d)), "number" == typeof a)) this.layers[d].callbacks[a] = { callback: b, callbackContext: c };
          else for (var e = 0, f = a.length; e < f; e++) this.layers[d].callbacks[a[e]] = { callback: b, callbackContext: c };
        },
        setTileLocationCallback: function (a, b, c, d, e, f, g) {
          if (((g = this.getLayer(g)), this.copy(a, b, c, d, g), !(this._results.length < 2))) for (var h = 1; h < this._results.length; h++) this._results[h].setCollisionCallback(e, f);
        },
        setCollision: function (a, b, c, d) {
          if ((void 0 === b && (b = !0), void 0 === d && (d = !0), (c = this.getLayer(c)), "number" == typeof a)) return this.setCollisionByIndex(a, b, c, !0);
          if (Array.isArray(a)) {
            for (var e = 0; e < a.length; e++) this.setCollisionByIndex(a[e], b, c, !1);
            d && this.calculateFaces(c);
          }
        },
        setCollisionBetween: function (a, b, c, d, e) {
          if ((void 0 === c && (c = !0), void 0 === e && (e = !0), (d = this.getLayer(d)), !(a > b))) {
            for (var f = a; f <= b; f++) this.setCollisionByIndex(f, c, d, !1);
            e && this.calculateFaces(d);
          }
        },
        setCollisionByExclusion: function (a, b, c, d) {
          void 0 === b && (b = !0), void 0 === d && (d = !0), (c = this.getLayer(c));
          for (var e = 0, f = this.tiles.length; e < f; e++) a.indexOf(e) === -1 && this.setCollisionByIndex(e, b, c, !1);
          d && this.calculateFaces(c);
        },
        setCollisionByIndex: function (a, b, c, d) {
          if ((void 0 === b && (b = !0), void 0 === c && (c = this.currentLayer), void 0 === d && (d = !0), b)) this.collideIndexes.push(a);
          else {
            var e = this.collideIndexes.indexOf(a);
            e > -1 && this.collideIndexes.splice(e, 1);
          }
          for (var f = 0; f < this.layers[c].height; f++)
            for (var g = 0; g < this.layers[c].width; g++) {
              var h = this.layers[c].data[f][g];
              h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(), (h.faceTop = b), (h.faceBottom = b), (h.faceLeft = b), (h.faceRight = b));
            }
          return d && this.calculateFaces(c), c;
        },
        getLayer: function (a) {
          return void 0 === a ? (a = this.currentLayer) : "string" == typeof a ? (a = this.getLayerIndex(a)) : a instanceof c.TilemapLayer && (a = a.index), a;
        },
        setPreventRecalculate: function (a) {
          if ((a === !0 && this.preventingRecalculate !== !0 && ((this.preventingRecalculate = !0), (this.needToRecalculate = {})), a === !1 && this.preventingRecalculate === !0)) {
            this.preventingRecalculate = !1;
            for (var b in this.needToRecalculate) this.calculateFaces(b);
            this.needToRecalculate = !1;
          }
        },
        calculateFaces: function (a) {
          if (this.preventingRecalculate) return void (this.needToRecalculate[a] = !0);
          for (var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; f < g; f++)
            for (var h = 0, i = this.layers[a].width; h < i; h++) {
              var j = this.layers[a].data[f][h];
              j &&
                ((b = this.getTileAbove(a, h, f)),
                (c = this.getTileBelow(a, h, f)),
                (d = this.getTileLeft(a, h, f)),
                (e = this.getTileRight(a, h, f)),
                j.collides && ((j.faceTop = !0), (j.faceBottom = !0), (j.faceLeft = !0), (j.faceRight = !0)),
                b && b.collides && (j.faceTop = !1),
                c && c.collides && (j.faceBottom = !1),
                d && d.collides && (j.faceLeft = !1),
                e && e.collides && (j.faceRight = !1));
            }
        },
        getTileAbove: function (a, b, c) {
          return c > 0 ? this.layers[a].data[c - 1][b] : null;
        },
        getTileBelow: function (a, b, c) {
          return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null;
        },
        getTileLeft: function (a, b, c) {
          return b > 0 ? this.layers[a].data[c][b - 1] : null;
        },
        getTileRight: function (a, b, c) {
          return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null;
        },
        setLayer: function (a) {
          (a = this.getLayer(a)), this.layers[a] && (this.currentLayer = a);
        },
        hasTile: function (a, b, c) {
          return (c = this.getLayer(c)), void 0 !== this.layers[c].data[b] && void 0 !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1;
        },
        removeTile: function (a, b, d) {
          if (((d = this.getLayer(d)), a >= 0 && a < this.layers[d].width && b >= 0 && b < this.layers[d].height && this.hasTile(a, b, d))) {
            var e = this.layers[d].data[b][a];
            return (this.layers[d].data[b][a] = new c.Tile(this.layers[d], -1, a, b, this.tileWidth, this.tileHeight)), (this.layers[d].dirty = !0), this.calculateFaces(d), e;
          }
        },
        removeTileWorldXY: function (a, b, c, d, e) {
          return (e = this.getLayer(e)), (a = this.game.math.snapToFloor(a, c) / c), (b = this.game.math.snapToFloor(b, d) / d), this.removeTile(a, b, e);
        },
        putTile: function (a, b, d, e) {
          if (null === a) return this.removeTile(b, d, e);
          if (((e = this.getLayer(e)), b >= 0 && b < this.layers[e].width && d >= 0 && d < this.layers[e].height)) {
            var f;
            return (
              a instanceof c.Tile
                ? ((f = a.index), this.hasTile(b, d, e) ? this.layers[e].data[d][b].copy(a) : (this.layers[e].data[d][b] = new c.Tile(e, f, b, d, a.width, a.height)))
                : ((f = a), this.hasTile(b, d, e) ? (this.layers[e].data[d][b].index = f) : (this.layers[e].data[d][b] = new c.Tile(this.layers[e], f, b, d, this.tileWidth, this.tileHeight))),
              this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][b].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][b].resetCollision(),
              (this.layers[e].dirty = !0),
              this.calculateFaces(e),
              this.layers[e].data[d][b]
            );
          }
          return null;
        },
        putTileWorldXY: function (a, b, c, d, e, f) {
          return (f = this.getLayer(f)), (b = this.game.math.snapToFloor(b, d) / d), (c = this.game.math.snapToFloor(c, e) / e), this.putTile(a, b, c, f);
        },
        searchTileIndex: function (a, b, c, d) {
          void 0 === b && (b = 0), void 0 === c && (c = !1), (d = this.getLayer(d));
          var e = 0;
          if (c) {
            for (var f = this.layers[d].height - 1; f >= 0; f--)
              for (var g = this.layers[d].width - 1; g >= 0; g--)
                if (this.layers[d].data[f][g].index === a) {
                  if (e === b) return this.layers[d].data[f][g];
                  e++;
                }
          } else
            for (var f = 0; f < this.layers[d].height; f++)
              for (var g = 0; g < this.layers[d].width; g++)
                if (this.layers[d].data[f][g].index === a) {
                  if (e === b) return this.layers[d].data[f][g];
                  e++;
                }
          return null;
        },
        getTile: function (a, b, c, d) {
          return (
            void 0 === d && (d = !1),
            (c = this.getLayer(c)),
            a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? (this.layers[c].data[b][a].index === -1 ? (d ? this.layers[c].data[b][a] : null) : this.layers[c].data[b][a]) : null
          );
        },
        getTileWorldXY: function (a, b, c, d, e, f) {
          return void 0 === c && (c = this.tileWidth), void 0 === d && (d = this.tileHeight), (e = this.getLayer(e)), (a = this.game.math.snapToFloor(a, c) / c), (b = this.game.math.snapToFloor(b, d) / d), this.getTile(a, b, e, f);
        },
        copy: function (a, b, c, d, e) {
          if (((e = this.getLayer(e)), !this.layers[e])) return void (this._results.length = 0);
          void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            void 0 === c && (c = this.layers[e].width),
            void 0 === d && (d = this.layers[e].height),
            a < 0 && (a = 0),
            b < 0 && (b = 0),
            c > this.layers[e].width && (c = this.layers[e].width),
            d > this.layers[e].height && (d = this.layers[e].height),
            (this._results.length = 0),
            this._results.push({ x: a, y: b, width: c, height: d, layer: e });
          for (var f = b; f < b + d; f++) for (var g = a; g < a + c; g++) this._results.push(this.layers[e].data[f][g]);
          return this._results;
        },
        paste: function (a, b, c, d) {
          if ((void 0 === a && (a = 0), void 0 === b && (b = 0), (d = this.getLayer(d)), c && !(c.length < 2))) {
            for (var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++) this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
            (this.layers[d].dirty = !0), this.calculateFaces(d);
          }
        },
        swap: function (a, b, c, d, e, f, g) {
          (g = this.getLayer(g)), this.copy(c, d, e, f, g), this._results.length < 2 || ((this._tempA = a), (this._tempB = b), this._results.forEach(this.swapHandler, this), this.paste(c, d, this._results, g));
        },
        swapHandler: function (a) {
          a.index === this._tempA ? (a.index = this._tempB) : a.index === this._tempB && (a.index = this._tempA);
        },
        forEach: function (a, b, c, d, e, f, g) {
          (g = this.getLayer(g)), this.copy(c, d, e, f, g), this._results.length < 2 || (this._results.forEach(a, b), this.paste(c, d, this._results, g));
        },
        replace: function (a, b, c, d, e, f, g) {
          if (((g = this.getLayer(g)), this.copy(c, d, e, f, g), !(this._results.length < 2))) {
            for (var h = 1; h < this._results.length; h++) this._results[h].index === a && (this._results[h].index = b);
            this.paste(c, d, this._results, g);
          }
        },
        random: function (a, b, c, d, e) {
          if (((e = this.getLayer(e)), this.copy(a, b, c, d, e), !(this._results.length < 2))) {
            for (var f = [], g = 1; g < this._results.length; g++)
              if (this._results[g].index) {
                var h = this._results[g].index;
                f.indexOf(h) === -1 && f.push(h);
              }
            for (var i = 1; i < this._results.length; i++) this._results[i].index = this.game.rnd.pick(f);
            this.paste(a, b, this._results, e);
          }
        },
        shuffle: function (a, b, d, e, f) {
          if (((f = this.getLayer(f)), this.copy(a, b, d, e, f), !(this._results.length < 2))) {
            for (var g = [], h = 1; h < this._results.length; h++) this._results[h].index && g.push(this._results[h].index);
            c.ArrayUtils.shuffle(g);
            for (var i = 1; i < this._results.length; i++) this._results[i].index = g[i - 1];
            this.paste(a, b, this._results, f);
          }
        },
        fill: function (a, b, c, d, e, f) {
          if (((f = this.getLayer(f)), this.copy(b, c, d, e, f), !(this._results.length < 2))) {
            for (var g = 1; g < this._results.length; g++) this._results[g].index = a;
            this.paste(b, c, this._results, f);
          }
        },
        removeAllLayers: function () {
          (this.layers.length = 0), (this.currentLayer = 0);
        },
        dump: function () {
          for (var a = "", b = [""], c = 0; c < this.layers[this.currentLayer].height; c++) {
            for (var d = 0; d < this.layers[this.currentLayer].width; d++)
              (a += "%c  "),
                this.layers[this.currentLayer].data[c][d] > 1
                  ? this.debugMap[this.layers[this.currentLayer].data[c][d]]
                    ? b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]])
                    : b.push("background: #ffffff")
                  : b.push("background: rgb(0, 0, 0)");
            a += "\n";
          }
          void (b[0] = a);
        },
        destroy: function () {
          this.removeAllLayers(), (this.data = []), (this.game = null);
        },
      }),
      (c.Tilemap.prototype.constructor = c.Tilemap),
      Object.defineProperty(c.Tilemap.prototype, "layer", {
        get: function () {
          return this.layers[this.currentLayer];
        },
        set: function (a) {
          a !== this.currentLayer && this.setLayer(a);
        },
      }),
      (c.TilemapLayer = function (a, b, d, e, f) {
        (e |= 0),
          (f |= 0),
          c.Sprite.call(this, a, 0, 0),
          (this.map = b),
          (this.index = d),
          (this.layer = b.layers[d]),
          (this.canvas = PIXI.CanvasPool.create(this, e, f)),
          (this.context = this.canvas.getContext("2d")),
          this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))),
          (this.type = c.TILEMAPLAYER),
          (this.physicsType = c.TILEMAPLAYER),
          (this.renderSettings = { enableScrollDelta: !1, overdrawRatio: 0.2, copyCanvas: null }),
          (this.debug = !1),
          (this.exists = !0),
          (this.debugSettings = { missingImageFill: "rgb(255,255,255)", debuggedTileOverfill: "rgba(0,255,0,0.4)", forceFullRedraw: !0, debugAlpha: 0.5, facingEdgeStroke: "rgba(0,255,0,1)", collidingTileOverfill: "rgba(0,255,0,0.2)" }),
          (this.scrollFactorX = 1),
          (this.scrollFactorY = 1),
          (this.dirty = !0),
          (this.rayStepRate = 4),
          (this._wrap = !1),
          (this._mc = { scrollX: 0, scrollY: 0, renderWidth: 0, renderHeight: 0, tileWidth: b.tileWidth, tileHeight: b.tileHeight, cw: b.tileWidth, ch: b.tileHeight, tilesets: [] }),
          (this._scrollX = 0),
          (this._scrollY = 0),
          (this._results = []),
          a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = c.TilemapLayer.ensureSharedCopyCanvas()),
          (this.fixedToCamera = !0);
      }),
      (c.TilemapLayer.prototype = Object.create(c.Sprite.prototype)),
      (c.TilemapLayer.prototype.constructor = c.TilemapLayer),
      (c.TilemapLayer.prototype.preUpdateCore = c.Component.Core.preUpdate),
      (c.TilemapLayer.sharedCopyCanvas = null),
      (c.TilemapLayer.ensureSharedCopyCanvas = function () {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas;
      }),
      (c.TilemapLayer.prototype.preUpdate = function () {
        return this.preUpdateCore();
      }),
      (c.TilemapLayer.prototype.postUpdate = function () {
        this.fixedToCamera && ((this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x), (this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)),
          (this._scrollX = (this.game.camera.view.x * this.scrollFactorX) / this.scale.x),
          (this._scrollY = (this.game.camera.view.y * this.scrollFactorY) / this.scale.y);
      }),
      (c.TilemapLayer.prototype._renderCanvas = function (a) {
        this.fixedToCamera && ((this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x), (this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)),
          (this._scrollX = (this.game.camera.view.x * this.scrollFactorX) / this.scale.x),
          (this._scrollY = (this.game.camera.view.y * this.scrollFactorY) / this.scale.y),
          this.render(),
          PIXI.Sprite.prototype._renderCanvas.call(this, a);
      }),
      (c.TilemapLayer.prototype._renderWebGL = function (a) {
        this.fixedToCamera && ((this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x), (this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)),
          (this._scrollX = (this.game.camera.view.x * this.scrollFactorX) / this.scale.x),
          (this._scrollY = (this.game.camera.view.y * this.scrollFactorY) / this.scale.y),
          this.render(),
          PIXI.Sprite.prototype._renderWebGL.call(this, a);
      }),
      (c.TilemapLayer.prototype.destroy = function () {
        PIXI.CanvasPool.remove(this), c.Component.Destroy.prototype.destroy.call(this);
      }),
      (c.TilemapLayer.prototype.resize = function (a, b) {
        (this.canvas.width = a),
          (this.canvas.height = b),
          this.texture.frame.resize(a, b),
          (this.texture.width = a),
          (this.texture.height = b),
          (this.texture.crop.width = a),
          (this.texture.crop.height = b),
          (this.texture.baseTexture.width = a),
          (this.texture.baseTexture.height = b),
          this.texture.baseTexture.dirty(),
          (this.texture.requiresUpdate = !0),
          this.texture._updateUvs(),
          (this.dirty = !0);
      }),
      (c.TilemapLayer.prototype.resizeWorld = function () {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y);
      }),
      (c.TilemapLayer.prototype._fixX = function (a) {
        return 1 === this.scrollFactorX || (0 === this.scrollFactorX && 0 === this.position.x) ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX);
      }),
      (c.TilemapLayer.prototype._unfixX = function (a) {
        return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX);
      }),
      (c.TilemapLayer.prototype._fixY = function (a) {
        return 1 === this.scrollFactorY || (0 === this.scrollFactorY && 0 === this.position.y) ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY);
      }),
      (c.TilemapLayer.prototype._unfixY = function (a) {
        return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY);
      }),
      (c.TilemapLayer.prototype.getTileX = function (a) {
        return Math.floor(this._fixX(a) / this._mc.tileWidth);
      }),
      (c.TilemapLayer.prototype.getTileY = function (a) {
        return Math.floor(this._fixY(a) / this._mc.tileHeight);
      }),
      (c.TilemapLayer.prototype.getTileXY = function (a, b, c) {
        return (c.x = this.getTileX(a)), (c.y = this.getTileY(b)), c;
      }),
      (c.TilemapLayer.prototype.getRayCastTiles = function (a, b, c, d) {
        b || (b = this.rayStepRate), void 0 === c && (c = !1), void 0 === d && (d = !1);
        var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
        if (0 === e.length) return [];
        for (var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++)
          for (var i = 0; i < f.length; i++) {
            var j = e[h],
              k = f[i];
            if (j.containsPoint(k[0], k[1])) {
              g.push(j);
              break;
            }
          }
        return g;
      }),
      (c.TilemapLayer.prototype.getTiles = function (a, b, c, d, e, f) {
        void 0 === e && (e = !1), void 0 === f && (f = !1);
        var g = !(e || f);
        (a = this._fixX(a)), (b = this._fixY(b));
        for (
          var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i;
          this._results.length;

        )
          this._results.pop();
        for (var l = i; l < i + k; l++)
          for (var m = h; m < h + j; m++) {
            var n = this.layer.data[l];
            n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m]);
          }
        return this._results.slice();
      }),
      (c.TilemapLayer.prototype.resolveTileset = function (a) {
        var b = this._mc.tilesets;
        if (a < 2e3) for (; b.length < a; ) b.push(void 0);
        var c = this.map.tiles[a] && this.map.tiles[a][2];
        if (null !== c) {
          var d = this.map.tilesets[c];
          if (d && d.containsTileIndex(a)) return (b[a] = d);
        }
        return (b[a] = null);
      }),
      (c.TilemapLayer.prototype.resetTilesetCache = function () {
        for (var a = this._mc.tilesets; a.length; ) a.pop();
      }),
      (c.TilemapLayer.prototype.setScale = function (a, b) {
        (a = a || 1), (b = b || a);
        for (var c = 0; c < this.layer.data.length; c++)
          for (var d = this.layer.data[c], e = 0; e < d.length; e++) {
            var f = d[e];
            (f.width = this.map.tileWidth * a), (f.height = this.map.tileHeight * b), (f.worldX = f.x * f.width), (f.worldY = f.y * f.height);
          }
        this.scale.setTo(a, b);
      }),
      (c.TilemapLayer.prototype.shiftCanvas = function (a, b, c) {
        var d = a.canvas,
          e = d.width - Math.abs(b),
          f = d.height - Math.abs(c),
          g = 0,
          h = 0,
          i = b,
          j = c;
        b < 0 && ((g = -b), (i = 0)), c < 0 && ((h = -c), (j = 0));
        var k = this.renderSettings.copyCanvas;
        if (k) {
          (k.width < e || k.height < f) && ((k.width = e), (k.height = f));
          var l = k.getContext("2d");
          l.clearRect(0, 0, e, f), l.drawImage(d, g, h, e, f, 0, 0, e, f), a.clearRect(i, j, e, f), a.drawImage(k, 0, 0, e, f, i, j, e, f);
        } else a.save(), (a.globalCompositeOperation = "copy"), a.drawImage(d, g, h, e, f, i, j, e, f), a.restore();
      }),
      (c.TilemapLayer.prototype.renderRegion = function (a, b, c, d, e, f) {
        var g = this.context,
          h = this.layer.width,
          i = this.layer.height,
          j = this._mc.tileWidth,
          k = this._mc.tileHeight,
          l = this._mc.tilesets,
          m = NaN;
        this._wrap || (c <= e && ((c = Math.max(0, c)), (e = Math.min(h - 1, e))), d <= f && ((d = Math.max(0, d)), (f = Math.min(i - 1, f))));
        var n,
          o,
          p,
          q,
          r,
          s,
          t = c * j - a,
          u = d * k - b,
          v = (c + (1 << 20) * h) % h,
          w = (d + (1 << 20) * i) % i;
        for (q = w, s = f - d, o = u; s >= 0; q++, s--, o += k) {
          q >= i && (q -= i);
          var x = this.layer.data[q];
          for (p = v, r = e - c, n = t; r >= 0; p++, r--, n += j) {
            p >= h && (p -= h);
            var y = x[p];
            if (y && !(y.index < 0)) {
              var z = y.index,
                A = l[z];
              void 0 === A && (A = this.resolveTileset(z)),
                y.alpha === m || this.debug || ((g.globalAlpha = y.alpha), (m = y.alpha)),
                A
                  ? y.rotation || y.flipped
                    ? (g.save(), g.translate(n + y.centerX, o + y.centerY), g.rotate(y.rotation), y.flipped && g.scale(-1, 1), A.draw(g, -y.centerX, -y.centerY, z), g.restore())
                    : A.draw(g, n, o, z)
                  : this.debugSettings.missingImageFill && ((g.fillStyle = this.debugSettings.missingImageFill), g.fillRect(n, o, j, k)),
                y.debug && this.debugSettings.debuggedTileOverfill && ((g.fillStyle = this.debugSettings.debuggedTileOverfill), g.fillRect(n, o, j, k));
            }
          }
        }
      }),
      (c.TilemapLayer.prototype.renderDeltaScroll = function (a, b) {
        var c = this._mc.scrollX,
          d = this._mc.scrollY,
          e = this.canvas.width,
          f = this.canvas.height,
          g = this._mc.tileWidth,
          h = this._mc.tileHeight,
          i = 0,
          j = -g,
          k = 0,
          l = -h;
        if (
          (a < 0 ? ((i = e + a), (j = e - 1)) : a > 0 && (j = a),
          b < 0 ? ((k = f + b), (l = f - 1)) : b > 0 && (l = b),
          this.shiftCanvas(this.context, a, b),
          (i = Math.floor((i + c) / g)),
          (j = Math.floor((j + c) / g)),
          (k = Math.floor((k + d) / h)),
          (l = Math.floor((l + d) / h)),
          i <= j)
        ) {
          this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
          var m = Math.floor((0 + d) / h),
            n = Math.floor((f - 1 + d) / h);
          this.renderRegion(c, d, i, m, j, n);
        }
        if (k <= l) {
          this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
          var o = Math.floor((0 + c) / g),
            p = Math.floor((e - 1 + c) / g);
          this.renderRegion(c, d, o, k, p, l);
        }
      }),
      (c.TilemapLayer.prototype.renderFull = function () {
        var a = this._mc.scrollX,
          b = this._mc.scrollY,
          c = this.canvas.width,
          d = this.canvas.height,
          e = this._mc.tileWidth,
          f = this._mc.tileHeight,
          g = Math.floor(a / e),
          h = Math.floor((c - 1 + a) / e),
          i = Math.floor(b / f),
          j = Math.floor((d - 1 + b) / f);
        this.context.clearRect(0, 0, c, d), this.renderRegion(a, b, g, i, h, j);
      }),
      (c.TilemapLayer.prototype.render = function () {
        var a = !1;
        if (this.visible) {
          (this.dirty || this.layer.dirty) && ((this.layer.dirty = !1), (a = !0));
          var b = this.canvas.width,
            c = this.canvas.height,
            d = 0 | this._scrollX,
            e = 0 | this._scrollY,
            f = this._mc,
            g = f.scrollX - d,
            h = f.scrollY - e;
          if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c)
            return (
              this.context.save(),
              (f.scrollX = d),
              (f.scrollY = e),
              (f.renderWidth === b && f.renderHeight === c) || ((f.renderWidth = b), (f.renderHeight = c)),
              this.debug && ((this.context.globalAlpha = this.debugSettings.debugAlpha), this.debugSettings.forceFullRedraw && (a = !0)),
              !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(),
              this.debug && ((this.context.globalAlpha = 1), this.renderDebug()),
              this.texture.baseTexture.dirty(),
              (this.dirty = !1),
              this.context.restore(),
              !0
            );
        }
      }),
      (c.TilemapLayer.prototype.renderDebug = function () {
        var a,
          b,
          c,
          d,
          e,
          f,
          g = this._mc.scrollX,
          h = this._mc.scrollY,
          i = this.context,
          j = this.canvas.width,
          k = this.canvas.height,
          l = this.layer.width,
          m = this.layer.height,
          n = this._mc.tileWidth,
          o = this._mc.tileHeight,
          p = Math.floor(g / n),
          q = Math.floor((j - 1 + g) / n),
          r = Math.floor(h / o),
          s = Math.floor((k - 1 + h) / o),
          t = p * n - g,
          u = r * o - h,
          v = (p + (1 << 20) * l) % l,
          w = (r + (1 << 20) * m) % m;
        for (i.strokeStyle = this.debugSettings.facingEdgeStroke, d = w, f = s - r, b = u; f >= 0; d++, f--, b += o) {
          d >= m && (d -= m);
          var x = this.layer.data[d];
          for (c = v, e = q - p, a = t; e >= 0; c++, e--, a += n) {
            c >= l && (c -= l);
            var y = x[c];
            !y ||
              y.index < 0 ||
              !y.collides ||
              (this.debugSettings.collidingTileOverfill && ((i.fillStyle = this.debugSettings.collidingTileOverfill), i.fillRect(a, b, this._mc.cw, this._mc.ch)),
              this.debugSettings.facingEdgeStroke &&
                (i.beginPath(),
                y.faceTop && (i.moveTo(a, b), i.lineTo(a + this._mc.cw, b)),
                y.faceBottom && (i.moveTo(a, b + this._mc.ch), i.lineTo(a + this._mc.cw, b + this._mc.ch)),
                y.faceLeft && (i.moveTo(a, b), i.lineTo(a, b + this._mc.ch)),
                y.faceRight && (i.moveTo(a + this._mc.cw, b), i.lineTo(a + this._mc.cw, b + this._mc.ch)),
                i.closePath(),
                i.stroke()));
          }
        }
      }),
      Object.defineProperty(c.TilemapLayer.prototype, "wrap", {
        get: function () {
          return this._wrap;
        },
        set: function (a) {
          (this._wrap = a), (this.dirty = !0);
        },
      }),
      Object.defineProperty(c.TilemapLayer.prototype, "scrollX", {
        get: function () {
          return this._scrollX;
        },
        set: function (a) {
          this._scrollX = a;
        },
      }),
      Object.defineProperty(c.TilemapLayer.prototype, "scrollY", {
        get: function () {
          return this._scrollY;
        },
        set: function (a) {
          this._scrollY = a;
        },
      }),
      Object.defineProperty(c.TilemapLayer.prototype, "collisionWidth", {
        get: function () {
          return this._mc.cw;
        },
        set: function (a) {
          (this._mc.cw = 0 | a), (this.dirty = !0);
        },
      }),
      Object.defineProperty(c.TilemapLayer.prototype, "collisionHeight", {
        get: function () {
          return this._mc.ch;
        },
        set: function (a) {
          (this._mc.ch = 0 | a), (this.dirty = !0);
        },
      }),
      (c.TilemapParser = {
        INSERT_NULL: !1,
        parse: function (a, b, d, e, f, g) {
          if ((void 0 === d && (d = 32), void 0 === e && (e = 32), void 0 === f && (f = 10), void 0 === g && (g = 10), void 0 === b)) return this.getEmptyData();
          if (null === b) return this.getEmptyData(d, e, f, g);
          var h = a.cache.getTilemapData(b);
          if (h) {
            if (h.format === c.Tilemap.CSV) return this.parseCSV(b, h.data, d, e);
            if (!h.format || h.format === c.Tilemap.TILED_JSON) return this.parseTiledJSON(h.data);
          }
        },
        parseCSV: function (a, b, d, e) {
          var f = this.getEmptyData();
          b = b.trim();
          for (var g = [], h = b.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++) {
            g[k] = [];
            for (var l = h[k].split(","), m = 0; m < l.length; m++) g[k][m] = new c.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
            0 === j && (j = l.length);
          }
          return (
            (f.format = c.Tilemap.CSV),
            (f.name = a),
            (f.width = j),
            (f.height = i),
            (f.tileWidth = d),
            (f.tileHeight = e),
            (f.widthInPixels = j * d),
            (f.heightInPixels = i * e),
            (f.layers[0].width = j),
            (f.layers[0].height = i),
            (f.layers[0].widthInPixels = f.widthInPixels),
            (f.layers[0].heightInPixels = f.heightInPixels),
            (f.layers[0].data = g),
            f
          );
        },
        getEmptyData: function (a, b, c, d) {
          return {
            width: void 0 !== c && null !== c ? c : 0,
            height: void 0 !== d && null !== d ? d : 0,
            tileWidth: void 0 !== a && null !== a ? a : 0,
            tileHeight: void 0 !== b && null !== b ? b : 0,
            orientation: "orthogonal",
            version: "1",
            properties: {},
            widthInPixels: 0,
            heightInPixels: 0,
            layers: [{ name: "layer", x: 0, y: 0, width: 0, height: 0, widthInPixels: 0, heightInPixels: 0, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: [] }],
            images: [],
            objects: {},
            collision: {},
            tilesets: [],
            tiles: [],
          };
        },
        parseTiledJSON: function (a) {
          function b(a, b) {
            var c = {};
            for (var d in b) {
              var e = b[d];
              "undefined" != typeof a[e] && (c[e] = a[e]);
            }
            return c;
          }
          if ("orthogonal" !== a.orientation) return null;
          for (
            var d = {
                width: a.width,
                height: a.height,
                tileWidth: a.tilewidth,
                tileHeight: a.tileheight,
                orientation: a.orientation,
                format: c.Tilemap.TILED_JSON,
                version: a.version,
                properties: a.properties,
                widthInPixels: a.width * a.tilewidth,
                heightInPixels: a.height * a.tileheight,
              },
              e = [],
              f = 0;
            f < a.layers.length;
            f++
          )
            if ("tilelayer" === a.layers[f].type) {
              var g = a.layers[f];
              if (!g.compression && g.encoding && "base64" === g.encoding) {
                for (var h = window.atob(g.data), i = h.length, j = new Array(i), k = 0; k < i; k += 4) j[k / 4] = (h.charCodeAt(k) | (h.charCodeAt(k + 1) << 8) | (h.charCodeAt(k + 2) << 16) | (h.charCodeAt(k + 3) << 24)) >>> 0;
                (g.data = j), delete g.encoding;
              } else if (g.compression) continue;
              var l = {
                name: g.name,
                x: g.x,
                y: g.y,
                width: g.width,
                height: g.height,
                widthInPixels: g.width * a.tilewidth,
                heightInPixels: g.height * a.tileheight,
                alpha: g.opacity,
                visible: g.visible,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
              };
              g.properties && (l.properties = g.properties);
              for (var m, n, o, p, q = 0, r = [], s = [], t = 0, i = g.data.length; t < i; t++) {
                if (((m = 0), (n = !1), (p = g.data[t]), (o = 0), p > 536870912))
                  switch ((p > 2147483648 && ((p -= 2147483648), (o += 4)), p > 1073741824 && ((p -= 1073741824), (o += 2)), p > 536870912 && ((p -= 536870912), (o += 1)), o)) {
                    case 5:
                      m = Math.PI / 2;
                      break;
                    case 6:
                      m = Math.PI;
                      break;
                    case 3:
                      m = (3 * Math.PI) / 2;
                      break;
                    case 4:
                      (m = 0), (n = !0);
                      break;
                    case 7:
                      (m = Math.PI / 2), (n = !0);
                      break;
                    case 2:
                      (m = Math.PI), (n = !0);
                      break;
                    case 1:
                      (m = (3 * Math.PI) / 2), (n = !0);
                  }
                if (p > 0) {
                  var u = new c.Tile(l, p, q, s.length, a.tilewidth, a.tileheight);
                  (u.rotation = m), (u.flipped = n), 0 !== o && (u.flippedVal = o), r.push(u);
                } else c.TilemapParser.INSERT_NULL ? r.push(null) : r.push(new c.Tile(l, -1, q, s.length, a.tilewidth, a.tileheight));
                q++, q === g.width && (s.push(r), (q = 0), (r = []));
              }
              (l.data = s), e.push(l);
            }
          d.layers = e;
          for (var v = [], f = 0; f < a.layers.length; f++)
            if ("imagelayer" === a.layers[f].type) {
              var w = a.layers[f],
                x = { name: w.name, image: w.image, x: w.x, y: w.y, alpha: w.opacity, visible: w.visible, properties: {} };
              w.properties && (x.properties = w.properties), v.push(x);
            }
          d.images = v;
          for (var y = [], z = [], A = null, f = 0; f < a.tilesets.length; f++) {
            var B = a.tilesets[f];
            if (B.image) {
              var C = new c.Tileset(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
              B.tileproperties && (C.tileProperties = B.tileproperties), C.updateTileData(B.imagewidth, B.imageheight), y.push(C);
            } else {
              var D = new c.ImageCollection(B.name, B.firstgid, B.tilewidth, B.tileheight, B.margin, B.spacing, B.properties);
              for (var E in B.tiles) {
                var x = B.tiles[E].image,
                  p = B.firstgid + parseInt(E, 10);
                D.addImage(p, x);
              }
              z.push(D);
            }
            A && (A.lastgid = B.firstgid - 1), (A = B);
          }
          (d.tilesets = y), (d.imagecollections = z);
          for (var F = {}, G = {}, f = 0; f < a.layers.length; f++)
            if ("objectgroup" === a.layers[f].type) {
              var H = a.layers[f];
              (F[H.name] = []), (G[H.name] = []);
              for (var I = 0, i = H.objects.length; I < i; I++)
                if (H.objects[I].gid) {
                  var J = {
                    gid: H.objects[I].gid,
                    name: H.objects[I].name,
                    type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "",
                    x: H.objects[I].x,
                    y: H.objects[I].y,
                    visible: H.objects[I].visible,
                    properties: H.objects[I].properties,
                  };
                  H.objects[I].rotation && (J.rotation = H.objects[I].rotation), F[H.name].push(J);
                } else if (H.objects[I].polyline) {
                  var J = {
                    name: H.objects[I].name,
                    type: H.objects[I].type,
                    x: H.objects[I].x,
                    y: H.objects[I].y,
                    width: H.objects[I].width,
                    height: H.objects[I].height,
                    visible: H.objects[I].visible,
                    properties: H.objects[I].properties,
                  };
                  H.objects[I].rotation && (J.rotation = H.objects[I].rotation), (J.polyline = []);
                  for (var K = 0; K < H.objects[I].polyline.length; K++) J.polyline.push([H.objects[I].polyline[K].x, H.objects[I].polyline[K].y]);
                  G[H.name].push(J), F[H.name].push(J);
                } else if (H.objects[I].polygon) {
                  var J = b(H.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                  J.polygon = [];
                  for (var K = 0; K < H.objects[I].polygon.length; K++) J.polygon.push([H.objects[I].polygon[K].x, H.objects[I].polygon[K].y]);
                  F[H.name].push(J);
                } else if (H.objects[I].ellipse) {
                  var J = b(H.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                  F[H.name].push(J);
                } else {
                  var J = b(H.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                  (J.rectangle = !0), F[H.name].push(J);
                }
            }
          (d.objects = F), (d.collision = G), (d.tiles = []);
          for (var f = 0; f < d.tilesets.length; f++)
            for (
              var B = d.tilesets[f], q = B.tileMargin, L = B.tileMargin, M = 0, N = 0, O = 0, t = B.firstgid;
              t < B.firstgid + B.total && ((d.tiles[t] = [q, L, f]), (q += B.tileWidth + B.tileSpacing), M++, M !== B.total) && (N++, N !== B.columns || ((q = B.tileMargin), (L += B.tileHeight + B.tileSpacing), (N = 0), O++, O !== B.rows));
              t++
            );
          for (var l, u, P, B, f = 0; f < d.layers.length; f++) {
            (l = d.layers[f]), (B = null);
            for (var k = 0; k < l.data.length; k++) {
              r = l.data[k];
              for (var Q = 0; Q < r.length; Q++)
                (u = r[Q]),
                  null === u ||
                    u.index < 0 ||
                    ((P = d.tiles[u.index][2]), (B = d.tilesets[P]), B.tileProperties && B.tileProperties[u.index - B.firstgid] && (u.properties = c.Utils.mixin(B.tileProperties[u.index - B.firstgid], u.properties)));
            }
          }
          return d;
        },
      }),
      (c.Tileset = function (a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32),
          (void 0 === d || d <= 0) && (d = 32),
          void 0 === e && (e = 0),
          void 0 === f && (f = 0),
          (this.name = a),
          (this.firstgid = 0 | b),
          (this.tileWidth = 0 | c),
          (this.tileHeight = 0 | d),
          (this.tileMargin = 0 | e),
          (this.tileSpacing = 0 | f),
          (this.properties = g || {}),
          (this.image = null),
          (this.rows = 0),
          (this.columns = 0),
          (this.total = 0),
          (this.drawCoords = []);
      }),
      (c.Tileset.prototype = {
        draw: function (a, b, c, d) {
          var e = (d - this.firstgid) << 1;
          e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight);
        },
        containsTileIndex: function (a) {
          return a >= this.firstgid && a < this.firstgid + this.total;
        },
        setImage: function (a) {
          (this.image = a), this.updateTileData(a.width, a.height);
        },
        setSpacing: function (a, b) {
          (this.tileMargin = 0 | a), (this.tileSpacing = 0 | b), this.image && this.updateTileData(this.image.width, this.image.height);
        },
        updateTileData: function (a, b) {
          var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
            d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
          (c = Math.floor(c)), (d = Math.floor(d)), ((this.rows && this.rows !== c) || (this.columns && this.columns !== d)) && void 0, (this.rows = c), (this.columns = d), (this.total = c * d), (this.drawCoords.length = 0);
          for (var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++) {
            for (var h = 0; h < this.columns; h++) this.drawCoords.push(e), this.drawCoords.push(f), (e += this.tileWidth + this.tileSpacing);
            (e = this.tileMargin), (f += this.tileHeight + this.tileSpacing);
          }
        },
      }),
      (c.Tileset.prototype.constructor = c.Tileset),
      (c.Particle = function (a, b, d, e, f) {
        c.Sprite.call(this, a, b, d, e, f), (this.autoScale = !1), (this.scaleData = null), (this._s = 0), (this.autoAlpha = !1), (this.alphaData = null), (this._a = 0);
      }),
      (c.Particle.prototype = Object.create(c.Sprite.prototype)),
      (c.Particle.prototype.constructor = c.Particle),
      (c.Particle.prototype.update = function () {
        this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : (this.autoScale = !1)),
          this.autoAlpha && (this._a--, this._a ? (this.alpha = this.alphaData[this._a].v) : (this.autoAlpha = !1));
      }),
      (c.Particle.prototype.onEmit = function () {}),
      (c.Particle.prototype.setAlphaData = function (a) {
        (this.alphaData = a), (this._a = a.length - 1), (this.alpha = this.alphaData[this._a].v), (this.autoAlpha = !0);
      }),
      (c.Particle.prototype.setScaleData = function (a) {
        (this.scaleData = a), (this._s = a.length - 1), this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), (this.autoScale = !0);
      }),
      (c.Particle.prototype.reset = function (a, b, d) {
        return c.Component.Reset.prototype.reset.call(this, a, b, d), (this.alpha = 1), this.scale.set(1), (this.autoScale = !1), (this.autoAlpha = !1), this;
      }),
      (c.Particles = function (a) {
        (this.game = a), (this.emitters = {}), (this.ID = 0);
      }),
      (c.Particles.prototype = {
        add: function (a) {
          return (this.emitters[a.name] = a), a;
        },
        remove: function (a) {
          delete this.emitters[a.name];
        },
        update: function () {
          for (var a in this.emitters) this.emitters[a].exists && this.emitters[a].update();
        },
      }),
      (c.Particles.prototype.constructor = c.Particles),
      (c.Particles.Arcade = {}),
      (c.Particles.Arcade.Emitter = function (a, b, d, e) {
        (this.maxParticles = e || 50),
          c.Group.call(this, a),
          (this.name = "emitter" + this.game.particles.ID++),
          (this.type = c.EMITTER),
          (this.physicsType = c.GROUP),
          (this.area = new c.Rectangle(b, d, 1, 1)),
          (this.minParticleSpeed = new c.Point(-100, -100)),
          (this.maxParticleSpeed = new c.Point(100, 100)),
          (this.minParticleScale = 1),
          (this.maxParticleScale = 1),
          (this.scaleData = null),
          (this.minRotation = -360),
          (this.maxRotation = 360),
          (this.minParticleAlpha = 1),
          (this.maxParticleAlpha = 1),
          (this.alphaData = null),
          (this.gravity = 100),
          (this.particleClass = c.Particle),
          (this.particleDrag = new c.Point()),
          (this.angularDrag = 0),
          (this.frequency = 100),
          (this.lifespan = 2e3),
          (this.bounce = new c.Point()),
          (this.on = !1),
          (this.particleAnchor = new c.Point(0.5, 0.5)),
          (this.blendMode = c.blendModes.NORMAL),
          (this.emitX = b),
          (this.emitY = d),
          (this.autoScale = !1),
          (this.autoAlpha = !1),
          (this.particleBringToTop = !1),
          (this.particleSendToBack = !1),
          (this._minParticleScale = new c.Point(1, 1)),
          (this._maxParticleScale = new c.Point(1, 1)),
          (this._quantity = 0),
          (this._timer = 0),
          (this._counter = 0),
          (this._flowQuantity = 0),
          (this._flowTotal = 0),
          (this._explode = !0),
          (this._frames = null);
      }),
      (c.Particles.Arcade.Emitter.prototype = Object.create(c.Group.prototype)),
      (c.Particles.Arcade.Emitter.prototype.constructor = c.Particles.Arcade.Emitter),
      (c.Particles.Arcade.Emitter.prototype.update = function () {
        if (this.on && this.game.time.time >= this._timer)
          if (((this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion), 0 !== this._flowTotal))
            if (this._flowQuantity > 0) {
              for (var a = 0; a < this._flowQuantity; a++)
                if (this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal)) {
                  this.on = !1;
                  break;
                }
            } else this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal && (this.on = !1));
          else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
        for (var a = this.children.length; a--; ) this.children[a].exists && this.children[a].update();
      }),
      (c.Particles.Arcade.Emitter.prototype.makeParticles = function (a, b, c, d, e) {
        void 0 === b && (b = 0), void 0 === c && (c = this.maxParticles), void 0 === d && (d = !1), void 0 === e && (e = !1);
        var f,
          g = 0,
          h = a,
          i = b;
        for (this._frames = b, c > this.maxParticles && (this.maxParticles = c); g < c; )
          Array.isArray(a) && (h = this.game.rnd.pick(a)),
            Array.isArray(b) && (i = this.game.rnd.pick(b)),
            (f = new this.particleClass(this.game, 0, 0, h, i)),
            this.game.physics.arcade.enable(f, !1),
            d ? ((f.body.checkCollision.any = !0), (f.body.checkCollision.none = !1)) : (f.body.checkCollision.none = !0),
            (f.body.collideWorldBounds = e),
            (f.body.skipQuadTree = !0),
            (f.exists = !1),
            (f.visible = !1),
            f.anchor.copyFrom(this.particleAnchor),
            this.add(f),
            g++;
        return this;
      }),
      (c.Particles.Arcade.Emitter.prototype.kill = function () {
        return (this.on = !1), (this.alive = !1), (this.exists = !1), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.revive = function () {
        return (this.alive = !0), (this.exists = !0), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.explode = function (a, b) {
        return (this._flowTotal = 0), this.start(!0, a, 0, b, !1), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.flow = function (a, b, c, d, e) {
        return (
          (void 0 !== c && 0 !== c) || (c = 1),
          void 0 === d && (d = -1),
          void 0 === e && (e = !0),
          c > this.maxParticles && (c = this.maxParticles),
          (this._counter = 0),
          (this._flowQuantity = c),
          (this._flowTotal = d),
          e ? (this.start(!0, a, b, c), (this._counter += c), (this.on = !0), (this._timer = this.game.time.time + b * this.game.time.slowMotion)) : this.start(!1, a, b, c),
          this
        );
      }),
      (c.Particles.Arcade.Emitter.prototype.start = function (a, b, c, d, e) {
        if (
          (void 0 === a && (a = !0),
          void 0 === b && (b = 0),
          (void 0 !== c && null !== c) || (c = 250),
          void 0 === d && (d = 0),
          void 0 === e && (e = !1),
          d > this.maxParticles && (d = this.maxParticles),
          this.revive(),
          (this.visible = !0),
          (this.lifespan = b),
          (this.frequency = c),
          a || e)
        )
          for (var f = 0; f < d; f++) this.emitParticle();
        else (this.on = !0), (this._quantity = d), (this._counter = 0), (this._timer = this.game.time.time + c * this.game.time.slowMotion);
        return this;
      }),
      (c.Particles.Arcade.Emitter.prototype.emitParticle = function (a, b, c, d) {
        void 0 === a && (a = null), void 0 === b && (b = null);
        var e = this.getFirstExists(!1);
        if (null === e) return !1;
        var f = this.game.rnd;
        void 0 !== c && void 0 !== d ? e.loadTexture(c, d) : void 0 !== c && e.loadTexture(c);
        var g = this.emitX,
          h = this.emitY;
        null !== a ? (g = a) : this.width > 1 && (g = f.between(this.left, this.right)),
          null !== b ? (h = b) : this.height > 1 && (h = f.between(this.top, this.bottom)),
          e.reset(g, h),
          (e.angle = 0),
          (e.lifespan = this.lifespan),
          this.particleBringToTop ? this.bringToTop(e) : this.particleSendToBack && this.sendToBack(e),
          this.autoScale
            ? e.setScaleData(this.scaleData)
            : 1 !== this.minParticleScale || 1 !== this.maxParticleScale
            ? e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale))
            : (this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y) ||
              e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y)),
          void 0 === d && (Array.isArray(this._frames) ? (e.frame = this.game.rnd.pick(this._frames)) : (e.frame = this._frames)),
          this.autoAlpha ? e.setAlphaData(this.alphaData) : (e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha)),
          (e.blendMode = this.blendMode);
        var i = e.body;
        return (
          i.updateBounds(),
          i.bounce.copyFrom(this.bounce),
          i.drag.copyFrom(this.particleDrag),
          (i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x)),
          (i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y)),
          (i.angularVelocity = f.between(this.minRotation, this.maxRotation)),
          (i.gravity.y = this.gravity),
          (i.angularDrag = this.angularDrag),
          e.onEmit(),
          !0
        );
      }),
      (c.Particles.Arcade.Emitter.prototype.destroy = function () {
        this.game.particles.remove(this), c.Group.prototype.destroy.call(this, !0, !1);
      }),
      (c.Particles.Arcade.Emitter.prototype.setSize = function (a, b) {
        return (this.area.width = a), (this.area.height = b), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.setXSpeed = function (a, b) {
        return (a = a || 0), (b = b || 0), (this.minParticleSpeed.x = a), (this.maxParticleSpeed.x = b), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.setYSpeed = function (a, b) {
        return (a = a || 0), (b = b || 0), (this.minParticleSpeed.y = a), (this.maxParticleSpeed.y = b), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.setRotation = function (a, b) {
        return (a = a || 0), (b = b || 0), (this.minRotation = a), (this.maxRotation = b), this;
      }),
      (c.Particles.Arcade.Emitter.prototype.setAlpha = function (a, b, d, e, f) {
        if (
          (void 0 === a && (a = 1),
          void 0 === b && (b = 1),
          void 0 === d && (d = 0),
          void 0 === e && (e = c.Easing.Linear.None),
          void 0 === f && (f = !1),
          (this.minParticleAlpha = a),
          (this.maxParticleAlpha = b),
          (this.autoAlpha = !1),
          d > 0 && a !== b)
        ) {
          var g = { v: a },
            h = this.game.make.tween(g).to({ v: b }, d, e);
          h.yoyo(f), (this.alphaData = h.generateData(60)), this.alphaData.reverse(), (this.autoAlpha = !0);
        }
        return this;
      }),
      (c.Particles.Arcade.Emitter.prototype.setScale = function (a, b, d, e, f, g, h) {
        if (
          (void 0 === a && (a = 1),
          void 0 === b && (b = 1),
          void 0 === d && (d = 1),
          void 0 === e && (e = 1),
          void 0 === f && (f = 0),
          void 0 === g && (g = c.Easing.Linear.None),
          void 0 === h && (h = !1),
          (this.minParticleScale = 1),
          (this.maxParticleScale = 1),
          this._minParticleScale.set(a, d),
          this._maxParticleScale.set(b, e),
          (this.autoScale = !1),
          f > 0 && (a !== b || d !== e))
        ) {
          var i = { x: a, y: d },
            j = this.game.make.tween(i).to({ x: b, y: e }, f, g);
          j.yoyo(h), (this.scaleData = j.generateData(60)), this.scaleData.reverse(), (this.autoScale = !0);
        }
        return this;
      }),
      (c.Particles.Arcade.Emitter.prototype.at = function (a) {
        return a.center ? ((this.emitX = a.center.x), (this.emitY = a.center.y)) : ((this.emitX = a.world.x + a.anchor.x * a.width), (this.emitY = a.world.y + a.anchor.y * a.height)), this;
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "width", {
        get: function () {
          return this.area.width;
        },
        set: function (a) {
          this.area.width = a;
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "height", {
        get: function () {
          return this.area.height;
        },
        set: function (a) {
          this.area.height = a;
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "x", {
        get: function () {
          return this.emitX;
        },
        set: function (a) {
          this.emitX = a;
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "y", {
        get: function () {
          return this.emitY;
        },
        set: function (a) {
          this.emitY = a;
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "left", {
        get: function () {
          return Math.floor(this.x - this.area.width / 2);
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "right", {
        get: function () {
          return Math.floor(this.x + this.area.width / 2);
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "top", {
        get: function () {
          return Math.floor(this.y - this.area.height / 2);
        },
      }),
      Object.defineProperty(c.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function () {
          return Math.floor(this.y + this.area.height / 2);
        },
      }),
      (c.Weapon = function (a, b) {
        c.Plugin.call(this, a, b),
          (this.bullets = null),
          (this.autoExpandBulletsGroup = !1),
          (this.autofire = !1),
          (this.shots = 0),
          (this.fireLimit = 0),
          (this.fireRate = 100),
          (this.fireRateVariance = 0),
          (this.fireFrom = new c.Rectangle(0, 0, 1, 1)),
          (this.fireAngle = c.ANGLE_UP),
          (this.bulletInheritSpriteSpeed = !1),
          (this.bulletAnimation = ""),
          (this.bulletFrameRandom = !1),
          (this.bulletFrameCycle = !1),
          (this.bulletWorldWrap = !1),
          (this.bulletWorldWrapPadding = 0),
          (this.bulletAngleOffset = 0),
          (this.bulletAngleVariance = 0),
          (this.bulletSpeed = 200),
          (this.bulletSpeedVariance = 0),
          (this.bulletLifespan = 0),
          (this.bulletKillDistance = 0),
          (this.bulletGravity = new c.Point(0, 0)),
          (this.bulletRotateToVelocity = !1),
          (this.bulletKey = ""),
          (this.bulletFrame = ""),
          (this._bulletClass = c.Bullet),
          (this._bulletCollideWorldBounds = !1),
          (this._bulletKillType = c.Weapon.KILL_WORLD_BOUNDS),
          (this._data = { customBody: !1, width: 0, height: 0, offsetX: 0, offsetY: 0 }),
          (this.bounds = new c.Rectangle()),
          (this.bulletBounds = a.world.bounds),
          (this.bulletFrames = []),
          (this.bulletFrameIndex = 0),
          (this.anims = {}),
          (this.onFire = new c.Signal()),
          (this.onKill = new c.Signal()),
          (this.onFireLimit = new c.Signal()),
          (this.trackedSprite = null),
          (this.trackedPointer = null),
          (this.trackRotation = !1),
          (this.trackOffset = new c.Point()),
          (this._nextFire = 0),
          (this._rotatedPoint = new c.Point());
      }),
      (c.Weapon.prototype = Object.create(c.Plugin.prototype)),
      (c.Weapon.prototype.constructor = c.Weapon),
      (c.Weapon.KILL_NEVER = 0),
      (c.Weapon.KILL_LIFESPAN = 1),
      (c.Weapon.KILL_DISTANCE = 2),
      (c.Weapon.KILL_WEAPON_BOUNDS = 3),
      (c.Weapon.KILL_CAMERA_BOUNDS = 4),
      (c.Weapon.KILL_WORLD_BOUNDS = 5),
      (c.Weapon.KILL_STATIC_BOUNDS = 6),
      (c.Weapon.prototype.createBullets = function (a, b, d, e) {
        return (
          void 0 === a && (a = 1),
          void 0 === e && (e = this.game.world),
          this.bullets || ((this.bullets = this.game.add.physicsGroup(c.Physics.ARCADE, e)), (this.bullets.classType = this._bulletClass)),
          0 !== a && (a === -1 && ((this.autoExpandBulletsGroup = !0), (a = 1)), this.bullets.createMultiple(a, b, d), this.bullets.setAll("data.bulletManager", this), (this.bulletKey = b), (this.bulletFrame = d)),
          this
        );
      }),
      (c.Weapon.prototype.forEach = function (a, b) {
        return this.bullets.forEachExists(a, b, arguments), this;
      }),
      (c.Weapon.prototype.pauseAll = function () {
        return this.bullets.setAll("body.enable", !1), this;
      }),
      (c.Weapon.prototype.resumeAll = function () {
        return this.bullets.setAll("body.enable", !0), this;
      }),
      (c.Weapon.prototype.killAll = function () {
        return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this;
      }),
      (c.Weapon.prototype.resetShots = function (a) {
        return (this.shots = 0), void 0 !== a && (this.fireLimit = a), this;
      }),
      (c.Weapon.prototype.destroy = function () {
        this.parent.remove(this, !1), this.bullets.destroy(), (this.game = null), (this.parent = null), (this.active = !1), (this.visible = !1);
      }),
      (c.Weapon.prototype.update = function () {
        this._bulletKillType === c.Weapon.KILL_WEAPON_BOUNDS &&
          (this.trackedSprite
            ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y))
            : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)),
          this.autofire && this.fire();
      }),
      (c.Weapon.prototype.trackSprite = function (a, b, c, d) {
        return void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = !1), (this.trackedPointer = null), (this.trackedSprite = a), (this.trackRotation = d), this.trackOffset.set(b, c), this;
      }),
      (c.Weapon.prototype.trackPointer = function (a, b, c) {
        return void 0 === a && (a = this.game.input.activePointer), void 0 === b && (b = 0), void 0 === c && (c = 0), (this.trackedPointer = a), (this.trackedSprite = null), (this.trackRotation = !1), this.trackOffset.set(b, c), this;
      }),
      (c.Weapon.prototype.fire = function (a, b, d) {
        if (this.game.time.now < this._nextFire || (this.fireLimit > 0 && this.shots === this.fireLimit)) return !1;
        var e = this.bulletSpeed;
        0 !== this.bulletSpeedVariance && (e += c.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)),
          a
            ? this.fireFrom.width > 1
              ? this.fireFrom.centerOn(a.x, a.y)
              : ((this.fireFrom.x = a.x), (this.fireFrom.y = a.y))
            : this.trackedSprite
            ? (this.trackRotation
                ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y),
                  this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation),
                  this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : ((this.fireFrom.x = this._rotatedPoint.x), (this.fireFrom.y = this._rotatedPoint.y)))
                : this.fireFrom.width > 1
                ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y)
                : ((this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x), (this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y)),
              this.bulletInheritSpriteSpeed && (e += this.trackedSprite.body.speed))
            : this.trackedPointer &&
              (this.fireFrom.width > 1
                ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y)
                : ((this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x), (this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)));
        var f = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
          g = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
          h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
        void 0 !== b && void 0 !== d && (h = this.game.math.radToDeg(Math.atan2(d - g, b - f))), 0 !== this.bulletAngleVariance && (h += c.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
        var i = 0,
          j = 0;
        0 === h || 180 === h
          ? (i = Math.cos(this.game.math.degToRad(h)) * e)
          : 90 === h || 270 === h
          ? (j = Math.sin(this.game.math.degToRad(h)) * e)
          : ((i = Math.cos(this.game.math.degToRad(h)) * e), (j = Math.sin(this.game.math.degToRad(h)) * e));
        var k = null;
        if ((this.autoExpandBulletsGroup ? ((k = this.bullets.getFirstExists(!1, !0, f, g, this.bulletKey, this.bulletFrame)), (k.data.bulletManager = this)) : (k = this.bullets.getFirstExists(!1)), k)) {
          if (
            (k.reset(f, g),
            (k.data.fromX = f),
            (k.data.fromY = g),
            (k.data.killType = this.bulletKillType),
            (k.data.killDistance = this.bulletKillDistance),
            (k.data.rotateToVelocity = this.bulletRotateToVelocity),
            this.bulletKillType === c.Weapon.KILL_LIFESPAN && (k.lifespan = this.bulletLifespan),
            (k.angle = h + this.bulletAngleOffset),
            "" !== this.bulletAnimation)
          ) {
            if (null === k.animations.getAnimation(this.bulletAnimation)) {
              var l = this.anims[this.bulletAnimation];
              k.animations.add(l.name, l.frames, l.frameRate, l.loop, l.useNumericIndex);
            }
            k.animations.play(this.bulletAnimation);
          } else
            this.bulletFrameCycle
              ? ((k.frame = this.bulletFrames[this.bulletFrameIndex]), this.bulletFrameIndex++, this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0))
              : this.bulletFrameRandom && (k.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
          if (
            (k.data.bodyDirty && (this._data.customBody && k.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), (k.body.collideWorldBounds = this.bulletCollideWorldBounds), (k.data.bodyDirty = !1)),
            k.body.velocity.set(i, j),
            k.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y),
            0 !== this.bulletSpeedVariance)
          ) {
            var m = this.fireRate;
            (m += c.Math.between(-this.fireRateVariance, this.fireRateVariance)), m < 0 && (m = 0), (this._nextFire = this.game.time.now + m);
          } else this._nextFire = this.game.time.now + this.fireRate;
          this.shots++, this.onFire.dispatch(k, this, e), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit);
        }
        return k;
      }),
      (c.Weapon.prototype.fireAtPointer = function (a) {
        return void 0 === a && (a = this.game.input.activePointer), this.fire(null, a.worldX, a.worldY);
      }),
      (c.Weapon.prototype.fireAtSprite = function (a) {
        return this.fire(null, a.world.x, a.world.y);
      }),
      (c.Weapon.prototype.fireAtXY = function (a, b) {
        return this.fire(null, a, b);
      }),
      (c.Weapon.prototype.setBulletBodyOffset = function (a, b, c, d) {
        return (
          void 0 === c && (c = 0),
          void 0 === d && (d = 0),
          (this._data.customBody = !0),
          (this._data.width = a),
          (this._data.height = b),
          (this._data.offsetX = c),
          (this._data.offsetY = d),
          this.bullets.callAll("body.setSize", "body", a, b, c, d),
          this.bullets.setAll("data.bodyDirty", !1),
          this
        );
      }),
      (c.Weapon.prototype.setBulletFrames = function (a, b, d, e) {
        return void 0 === d && (d = !0), void 0 === e && (e = !1), (this.bulletFrames = c.ArrayUtils.numberArray(a, b)), (this.bulletFrameIndex = 0), (this.bulletFrameCycle = d), (this.bulletFrameRandom = e), this;
      }),
      (c.Weapon.prototype.addBulletAnimation = function (a, b, c, d, e) {
        return (this.anims[a] = { name: a, frames: b, frameRate: c, loop: d, useNumericIndex: e }), this.bullets.callAll("animations.add", "animations", a, b, c, d, e), (this.bulletAnimation = a), this;
      }),
      (c.Weapon.prototype.debug = function (a, b, c) {
        void 0 === a && (a = 16),
          void 0 === b && (b = 32),
          void 0 === c && (c = !1),
          this.game.debug.text("Weapon Plugin", a, b),
          this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24),
          c && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)");
      }),
      Object.defineProperty(c.Weapon.prototype, "bulletClass", {
        get: function () {
          return this._bulletClass;
        },
        set: function (a) {
          (this._bulletClass = a), (this.bullets.classType = this._bulletClass);
        },
      }),
      Object.defineProperty(c.Weapon.prototype, "bulletKillType", {
        get: function () {
          return this._bulletKillType;
        },
        set: function (a) {
          switch (a) {
            case c.Weapon.KILL_STATIC_BOUNDS:
            case c.Weapon.KILL_WEAPON_BOUNDS:
              this.bulletBounds = this.bounds;
              break;
            case c.Weapon.KILL_CAMERA_BOUNDS:
              this.bulletBounds = this.game.camera.view;
              break;
            case c.Weapon.KILL_WORLD_BOUNDS:
              this.bulletBounds = this.game.world.bounds;
          }
          this._bulletKillType = a;
        },
      }),
      Object.defineProperty(c.Weapon.prototype, "bulletCollideWorldBounds", {
        get: function () {
          return this._bulletCollideWorldBounds;
        },
        set: function (a) {
          (this._bulletCollideWorldBounds = a), this.bullets.setAll("body.collideWorldBounds", a), this.bullets.setAll("data.bodyDirty", !1);
        },
      }),
      Object.defineProperty(c.Weapon.prototype, "x", {
        get: function () {
          return this.fireFrom.x;
        },
        set: function (a) {
          this.fireFrom.x = a;
        },
      }),
      Object.defineProperty(c.Weapon.prototype, "y", {
        get: function () {
          return this.fireFrom.y;
        },
        set: function (a) {
          this.fireFrom.y = a;
        },
      }),
      (c.Bullet = function (a, b, d, e, f) {
        c.Sprite.call(this, a, b, d, e, f), this.anchor.set(0.5), (this.data = { bulletManager: null, fromX: 0, fromY: 0, bodyDirty: !0, rotateToVelocity: !1, killType: 0, killDistance: 0 });
      }),
      (c.Bullet.prototype = Object.create(c.Sprite.prototype)),
      (c.Bullet.prototype.constructor = c.Bullet),
      (c.Bullet.prototype.kill = function () {
        return (this.alive = !1), (this.exists = !1), (this.visible = !1), this.data.bulletManager.onKill.dispatch(this), this;
      }),
      (c.Bullet.prototype.update = function () {
        this.exists &&
          (this.data.killType > c.Weapon.KILL_LIFESPAN &&
            (this.data.killType === c.Weapon.KILL_DISTANCE
              ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill()
              : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()),
          this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)),
          this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding));
      }),
      (c.Video = function (a, b, d) {
        if (
          (void 0 === b && (b = null),
          void 0 === d && (d = null),
          (this.game = a),
          (this.key = b),
          (this.width = 0),
          (this.height = 0),
          (this.type = c.VIDEO),
          (this.disableTextureUpload = !1),
          (this.touchLocked = !1),
          (this.onPlay = new c.Signal()),
          (this.onChangeSource = new c.Signal()),
          (this.onComplete = new c.Signal()),
          (this.onAccess = new c.Signal()),
          (this.onError = new c.Signal()),
          (this.onTimeout = new c.Signal()),
          (this.timeout = 15e3),
          (this._timeOutID = null),
          (this.video = null),
          (this.videoStream = null),
          (this.isStreaming = !1),
          (this.retryLimit = 20),
          (this.retry = 0),
          (this.retryInterval = 500),
          (this._retryID = null),
          (this._codeMuted = !1),
          (this._muted = !1),
          (this._codePaused = !1),
          (this._paused = !1),
          (this._pending = !1),
          (this._autoplay = !1),
          (this._endCallback = null),
          (this._playCallback = null),
          b && this.game.cache.checkVideoKey(b))
        ) {
          var e = this.game.cache.getVideo(b);
          e.isBlob ? this.createVideoFromBlob(e.data) : (this.video = e.data), (this.width = this.video.videoWidth), (this.height = this.video.videoHeight);
        } else d && this.createVideoFromURL(d, !1);
        this.video && !d
          ? ((this.baseTexture = new PIXI.BaseTexture(this.video)), this.baseTexture.forceLoaded(this.width, this.height))
          : ((this.baseTexture = new PIXI.BaseTexture(c.Cache.DEFAULT.baseTexture.source)), this.baseTexture.forceLoaded(this.width, this.height)),
          (this.texture = new PIXI.Texture(this.baseTexture)),
          (this.textureFrame = new c.Frame(0, 0, 0, this.width, this.height, "video")),
          this.texture.setFrame(this.textureFrame),
          (this.texture.valid = !1),
          null !== b && this.video && (this.texture.valid = this.video.canplay),
          (this.snapshot = null),
          c.BitmapData && (this.snapshot = new c.BitmapData(this.game, "", this.width, this.height)),
          (!this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android)) || (window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) ? this.setTouchLock() : e && (e.locked = !1);
      }),
      (c.Video.prototype = {
        connectToMediaStream: function (a, b) {
          return (
            a && b && ((this.video = a), (this.videoStream = b), (this.isStreaming = !0), (this.baseTexture.source = this.video), this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
          );
        },
        startMediaStream: function (a, b, c) {
          if ((void 0 === a && (a = !1), void 0 === b && (b = null), void 0 === c && (c = null), !this.game.device.getUserMedia)) return this.onError.dispatch(this, "No getUserMedia"), !1;
          null !== this.videoStream && (this.videoStream.active ? (this.videoStream.active = !1) : this.videoStream.stop()),
            this.removeVideoElement(),
            (this.video = document.createElement("video")),
            this.video.setAttribute("autoplay", "autoplay"),
            null !== b && (this.video.width = b),
            null !== c && (this.video.height = c),
            (this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout));
          try {
            navigator.getUserMedia({ audio: a, video: !0 }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
          } catch (a) {
            this.getUserMediaError(a);
          }
          return this;
        },
        getUserMediaTimeout: function () {
          clearTimeout(this._timeOutID), this.onTimeout.dispatch(this);
        },
        getUserMediaError: function (a) {
          clearTimeout(this._timeOutID), this.onError.dispatch(this, a);
        },
        getUserMediaSuccess: function (a) {
          clearTimeout(this._timeOutID), (this.videoStream = a), void 0 !== this.video.mozSrcObject ? (this.video.mozSrcObject = a) : (this.video.src = (window.URL && window.URL.createObjectURL(a)) || a);
          var b = this;
          this.video.onloadeddata = function () {
            function a() {
              if (c > 0)
                if (b.video.videoWidth > 0) {
                  var d = b.video.videoWidth,
                    e = b.video.videoHeight;
                  isNaN(b.video.videoHeight) && (e = d / (4 / 3)), b.video.play(), (b.isStreaming = !0), (b.baseTexture.source = b.video), b.updateTexture(null, d, e), b.onAccess.dispatch(b);
                } else window.setTimeout(a, 500);
              c--;
            }
            var c = 10;
            a();
          };
        },
        createVideoFromBlob: function (a) {
          var b = this;
          return (
            (this.video = document.createElement("video")),
            (this.video.controls = !1),
            this.video.setAttribute("autoplay", "autoplay"),
            this.video.addEventListener(
              "loadeddata",
              function (a) {
                b.updateTexture(a);
              },
              !0
            ),
            (this.video.src = window.URL.createObjectURL(a)),
            (this.video.canplay = !0),
            this
          );
        },
        createVideoFromURL: function (a, b) {
          return (
            void 0 === b && (b = !1),
            this.texture && (this.texture.valid = !1),
            (this.video = document.createElement("video")),
            (this.video.controls = !1),
            b && this.video.setAttribute("autoplay", "autoplay"),
            (this.video.src = a),
            (this.video.canplay = !0),
            this.video.load(),
            (this.retry = this.retryLimit),
            (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)),
            (this.key = a),
            this
          );
        },
        updateTexture: function (a, b, c) {
          var d = !1;
          (void 0 !== b && null !== b) || ((b = this.video.videoWidth), (d = !0)),
            (void 0 !== c && null !== c) || (c = this.video.videoHeight),
            (this.width = b),
            (this.height = c),
            this.baseTexture.source !== this.video && (this.baseTexture.source = this.video),
            this.baseTexture.forceLoaded(b, c),
            this.texture.frame.resize(b, c),
            (this.texture.width = b),
            (this.texture.height = c),
            (this.texture.valid = !0),
            this.snapshot && this.snapshot.resize(b, c),
            d && null !== this.key && (this.onChangeSource.dispatch(this, b, c), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)));
        },
        complete: function () {
          this.onComplete.dispatch(this);
        },
        play: function (a, b) {
          return (
            void 0 === a && (a = !1),
            void 0 === b && (b = 1),
            this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()),
            this.game.onPause.add(this.setPause, this),
            this.game.onResume.add(this.setResume, this),
            (this._endCallback = this.complete.bind(this)),
            this.video.addEventListener("ended", this._endCallback, !0),
            this.video.addEventListener("webkitendfullscreen", this._endCallback, !0),
            a ? (this.video.loop = "loop") : (this.video.loop = ""),
            (this.video.playbackRate = b),
            this.touchLocked
              ? (this._pending = !0)
              : ((this._pending = !1),
                null !== this.key &&
                  (4 !== this.video.readyState
                    ? ((this.retry = this.retryLimit), (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)))
                    : ((this._playCallback = this.playHandler.bind(this)), this.video.addEventListener("playing", this._playCallback, !0))),
                this.video.play(),
                this.onPlay.dispatch(this, a, b)),
            this
          );
        },
        playHandler: function () {
          this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture();
        },
        stop: function () {
          return (
            this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)),
            this.game.onPause.remove(this.setPause, this),
            this.game.onResume.remove(this.setResume, this),
            this.isStreaming
              ? (this.video.mozSrcObject
                  ? (this.video.mozSrcObject.stop(), (this.video.src = null))
                  : ((this.video.src = ""),
                    this.videoStream.active
                      ? (this.videoStream.active = !1)
                      : this.videoStream.getTracks
                      ? this.videoStream.getTracks().forEach(function (a) {
                          a.stop();
                        })
                      : this.videoStream.stop()),
                (this.videoStream = null),
                (this.isStreaming = !1))
              : (this.video.removeEventListener("ended", this._endCallback, !0),
                this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0),
                this.video.removeEventListener("playing", this._playCallback, !0),
                this.touchLocked ? (this._pending = !1) : this.video.pause()),
            this
          );
        },
        add: function (a) {
          if (Array.isArray(a)) for (var b = 0; b < a.length; b++) a[b].loadTexture && a[b].loadTexture(this);
          else a.loadTexture(this);
          return this;
        },
        addToWorld: function (a, b, c, d, e, f) {
          (e = e || 1), (f = f || 1);
          var g = this.game.add.image(a, b, this);
          return g.anchor.set(c, d), g.scale.set(e, f), g;
        },
        render: function () {
          !this.disableTextureUpload && this.playing && this.baseTexture.dirty();
        },
        setMute: function () {
          this._muted || ((this._muted = !0), (this.video.muted = !0));
        },
        unsetMute: function () {
          this._muted && !this._codeMuted && ((this._muted = !1), (this.video.muted = !1));
        },
        setPause: function () {
          this._paused || this.touchLocked || ((this._paused = !0), this.video.pause());
        },
        setResume: function () {
          !this._paused || this._codePaused || this.touchLocked || ((this._paused = !1), this.video.ended || this.video.play());
        },
        changeSource: function (a, b) {
          return (
            void 0 === b && (b = !0),
            (this.texture.valid = !1),
            this.video.pause(),
            (this.retry = this.retryLimit),
            (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)),
            (this.video.src = a),
            this.video.load(),
            (this._autoplay = b),
            b || (this.paused = !0),
            this
          );
        },
        checkVideoProgress: function () {
          4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 ? (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : void 0);
        },
        setTouchLock: function () {
          this.game.input.touch.addTouchLockCallback(this.unlock, this), (this.touchLocked = !0);
        },
        unlock: function () {
          if (((this.touchLocked = !1), this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key)) {
            var a = this.game.cache.getVideo(this.key);
            a && !a.isBlob && (a.locked = !1);
          }
          return !0;
        },
        grab: function (a, b, c) {
          return (
            void 0 === a && (a = !1),
            void 0 === b && (b = 1),
            void 0 === c && (c = null),
            null === this.snapshot ? void 0 : (a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), this.snapshot)
          );
        },
        removeVideoElement: function () {
          if (this.video) {
            for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes(); ) this.video.removeChild(this.video.firstChild);
            this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), (this.video = null);
          }
        },
        destroy: function () {
          this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID);
        },
      }),
      Object.defineProperty(c.Video.prototype, "currentTime", {
        get: function () {
          return this.video ? this.video.currentTime : 0;
        },
        set: function (a) {
          this.video.currentTime = a;
        },
      }),
      Object.defineProperty(c.Video.prototype, "duration", {
        get: function () {
          return this.video ? this.video.duration : 0;
        },
      }),
      Object.defineProperty(c.Video.prototype, "progress", {
        get: function () {
          return this.video ? this.video.currentTime / this.video.duration : 0;
        },
      }),
      Object.defineProperty(c.Video.prototype, "mute", {
        get: function () {
          return this._muted;
        },
        set: function (a) {
          if ((a = a || null)) {
            if (this._muted) return;
            (this._codeMuted = !0), this.setMute();
          } else {
            if (!this._muted) return;
            (this._codeMuted = !1), this.unsetMute();
          }
        },
      }),
      Object.defineProperty(c.Video.prototype, "paused", {
        get: function () {
          return this._paused;
        },
        set: function (a) {
          if (((a = a || null), !this.touchLocked))
            if (a) {
              if (this._paused) return;
              (this._codePaused = !0), this.setPause();
            } else {
              if (!this._paused) return;
              (this._codePaused = !1), this.setResume();
            }
        },
      }),
      Object.defineProperty(c.Video.prototype, "volume", {
        get: function () {
          return this.video ? this.video.volume : 1;
        },
        set: function (a) {
          a < 0 ? (a = 0) : a > 1 && (a = 1), this.video && (this.video.volume = a);
        },
      }),
      Object.defineProperty(c.Video.prototype, "playbackRate", {
        get: function () {
          return this.video ? this.video.playbackRate : 1;
        },
        set: function (a) {
          this.video && (this.video.playbackRate = a);
        },
      }),
      Object.defineProperty(c.Video.prototype, "loop", {
        get: function () {
          return !!this.video && this.video.loop;
        },
        set: function (a) {
          a && this.video ? (this.video.loop = "loop") : this.video && (this.video.loop = "");
        },
      }),
      Object.defineProperty(c.Video.prototype, "playing", {
        get: function () {
          return !(this.video.paused && this.video.ended);
        },
      }),
      (c.Video.prototype.constructor = c.Video),
      void 0 === PIXI.blendModes && (PIXI.blendModes = c.blendModes),
      void 0 === PIXI.scaleModes && (PIXI.scaleModes = c.scaleModes),
      void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture())),
      void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix()),
      void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix()),
      PIXI.Graphics && void 0 === PIXI.Graphics.POLY && ((PIXI.Graphics.POLY = c.POLYGON), (PIXI.Graphics.RECT = c.RECTANGLE), (PIXI.Graphics.CIRC = c.CIRCLE), (PIXI.Graphics.ELIP = c.ELLIPSE), (PIXI.Graphics.RREC = c.ROUNDEDRECTANGLE)),
      (PIXI.TextureSilentFail = !0),
      "undefined" != typeof exports
        ? ("undefined" != typeof module && module.exports && (exports = module.exports = c), (exports.Phaser = c))
        : "undefined" != typeof define && define.amd
        ? define("Phaser", (function () {
            return (b.Phaser = c);
          })())
        : (b.Phaser = c),
      c
    );
  }.call(this);
var __extends =
    (this && this.__extends) ||
    function (a, b) {
      function c() {
        this.constructor = a;
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      a.prototype = null === b ? Object.create(b) : ((c.prototype = b.prototype), new c());
    },
  Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, c), this.patchLoader();
      }
      return (
        __extends(b, a),
        (b.prototype.patchLoader = function () {
          Object.defineProperty(Phaser.Loader, "cacheBuster", { value: null }),
            (Phaser.Loader.prototype.transformUrl = function (a, b) {
              return a ? (null !== this.cacheBuster && null === a.match(/^(data:)/) && (a += "?v=" + this.cacheBuster), a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a) : "";
            });
        }),
        b
      );
    })(Phaser.Plugin);
    a.CacheBuster = b;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {}));
var spine = {
  radDeg: 180 / Math.PI,
  degRad: Math.PI / 180,
  Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
  Uint32Array: "undefined" == typeof Uint32Array ? Array : Uint32Array,
  Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array,
};
(spine.temp = new spine.Float32Array(2)),
  (spine.BoneData = function (a, b) {
    (this.name = a), (this.parent = b);
  }),
  (spine.BoneData.prototype = { length: 0, x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1, inheritScale: !0, inheritRotation: !0 }),
  (spine.BlendMode = { normal: 0, additive: 1, multiply: 2, screen: 3 }),
  (spine.SlotData = function (a, b) {
    (this.name = a), (this.boneData = b);
  }),
  (spine.SlotData.prototype = { r: 1, g: 1, b: 1, a: 1, attachmentName: null, blendMode: spine.BlendMode.normal }),
  (spine.IkConstraintData = function (a) {
    (this.name = a), (this.bones = []);
  }),
  (spine.IkConstraintData.prototype = { target: null, bendDirection: 1, mix: 1 }),
  (spine.TransformConstraintData = function (a) {
    this.name = a;
  }),
  (spine.TransformConstraintData.prototype = { bone: null, target: null, translateMix: 1, x: 0, y: 0 }),
  (spine.Bone = function (a, b, c) {
    (this.data = a), (this.skeleton = b), (this.parent = c), this.setToSetupPose();
  }),
  (spine.Bone.yDown = !1),
  (spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    a: 0,
    b: 0,
    worldX: 0,
    c: 0,
    d: 0,
    worldY: 0,
    worldSignX: 1,
    worldSignY: 1,
    update: function () {
      this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
    },
    updateWorldTransformWith: function () {
      this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY);
    },
    updateWorldTransform: function (a, b, c, d, e) {
      (this.appliedRotation = c), (this.appliedScaleX = d), (this.appliedScaleY = e), (c *= spine.degRad);
      var f = Math.cos(c),
        g = Math.sin(c),
        h = f * d,
        i = -g * e,
        j = g * d,
        k = f * e,
        l = this.parent;
      if (!l) {
        var m = this.skeleton;
        return (
          m.flipX && ((a = -a), (h = -h), (i = -i)),
          m.flipY != spine.Bone.yDown && ((b = -b), (j = -j), (k = -k)),
          (this.a = h),
          (this.b = i),
          (this.c = j),
          (this.d = k),
          (this.worldX = a),
          (this.worldY = b),
          (this.worldSignX = 0 > d ? -1 : 1),
          void (this.worldSignY = 0 > e ? -1 : 1)
        );
      }
      var n = l.a,
        o = l.b,
        p = l.c,
        q = l.d;
      if (
        ((this.worldX = n * a + o * b + l.worldX),
        (this.worldY = p * a + q * b + l.worldY),
        (this.worldSignX = l.worldSignX * (0 > d ? -1 : 1)),
        (this.worldSignY = l.worldSignY * (0 > e ? -1 : 1)),
        this.data.inheritRotation && this.data.inheritScale)
      )
        (this.a = n * h + o * j), (this.b = n * i + o * k), (this.c = p * h + q * j), (this.d = p * i + q * k);
      else {
        if (this.data.inheritRotation) {
          (n = 1), (o = 0), (p = 0), (q = 1);
          do {
            (c = l.appliedRotation * spine.degRad), (f = Math.cos(c)), (g = Math.sin(c));
            var r = n * f + o * g;
            if (((o = n * -g + o * f), (n = r), (r = p * f + q * g), (q = p * -g + q * f), (p = r), !l.data.inheritRotation)) break;
            l = l.parent;
          } while (l);
          (this.a = n * h + o * j), (this.b = n * i + o * k), (this.c = p * h + q * j), (this.d = p * i + q * k);
        } else if (this.data.inheritScale) {
          (n = 1), (o = 0), (p = 0), (q = 1);
          do {
            (c = l.appliedRotation * spine.degRad), (f = Math.cos(c)), (g = Math.sin(c));
            var s = l.appliedScaleX,
              t = l.appliedScaleY,
              u = f * s,
              v = -g * t,
              w = g * s,
              x = f * t,
              r = n * u + o * w;
            if (
              ((o = n * v + o * x),
              (n = r),
              (r = p * u + q * w),
              (q = p * v + q * x),
              (p = r),
              0 > s && (c = -c),
              (f = Math.cos(-c)),
              (g = Math.sin(-c)),
              (r = n * f + o * g),
              (o = n * -g + o * f),
              (n = r),
              (r = p * f + q * g),
              (q = p * -g + q * f),
              (p = r),
              !l.data.inheritScale)
            )
              break;
            l = l.parent;
          } while (l);
          (this.a = n * h + o * j), (this.b = n * i + o * k), (this.c = p * h + q * j), (this.d = p * i + q * k);
        } else (this.a = h), (this.b = i), (this.c = j), (this.d = k);
        this.skeleton.flipX && ((this.a = -this.a), (this.b = -this.b)), this.skeleton.flipY != spine.Bone.yDown && ((this.c = -this.c), (this.d = -this.d));
      }
    },
    setToSetupPose: function () {
      var a = this.data;
      (this.x = a.x), (this.y = a.y), (this.rotation = a.rotation), (this.scaleX = a.scaleX), (this.scaleY = a.scaleY);
    },
    getWorldRotationX: function () {
      return Math.atan2(this.c, this.a) * spine.radDeg;
    },
    getWorldRotationY: function () {
      return Math.atan2(this.d, this.b) * spine.radDeg;
    },
    getWorldScaleX: function () {
      return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX;
    },
    getWorldScaleY: function () {
      return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY;
    },
    worldToLocal: function (a) {
      var b = a[0] - this.worldX,
        c = a[1] - this.worldY,
        d = this.a,
        e = this.b,
        f = this.c,
        g = this.d,
        h = 1 / (d * g - e * f);
      return (a[0] = b * g * h - c * e * h), (a[1] = c * d * h - b * f * h), a;
    },
    localToWorld: function (a) {
      var b = a[0],
        c = a[1];
      return (a[0] = b * this.a + c * this.b + this.worldX), (a[1] = b * this.c + c * this.d + this.worldY), a;
    },
  }),
  (spine.Slot = function (a, b) {
    (this.data = a), (this.bone = b), (this.attachmentVertices = new spine.Float32Array()), this.setToSetupPose();
  }),
  (spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function (a) {
      this.attachment != a && ((this.attachment = a), (this._attachmentTime = this.bone.skeleton.time), (this.attachmentVertices.length = 0));
    },
    setAttachmentTime: function (a) {
      this._attachmentTime = this.bone.skeleton.time - a;
    },
    getAttachmentTime: function () {
      return this.bone.skeleton.time - this._attachmentTime;
    },
    setToSetupPose: function () {
      var a = this.data;
      if (((this.r = a.r), (this.g = a.g), (this.b = a.b), (this.a = a.a), a.attachmentName)) {
        for (var b = this.bone.skeleton.data.slots, c = 0, d = b.length; d > c; c++)
          if (b[c] == a) {
            (this.attachment = null), this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(c, a.attachmentName));
            break;
          }
      } else this.setAttachment(null);
    },
  }),
  (spine.IkConstraint = function (a, b) {
    (this.data = a), (this.mix = a.mix), (this.bendDirection = a.bendDirection), (this.bones = []);
    for (var c = 0, d = a.bones.length; d > c; c++) this.bones[c] = b.findBone(a.bones[c].name);
    this.target = b.findBone(a.target.name);
  }),
  (spine.IkConstraint.prototype = {
    apply: function () {
      this.update();
    },
    update: function () {
      var a = this.target,
        b = this.bones;
      switch (b.length) {
        case 1:
          spine.IkConstraint.apply1(b[0], a.worldX, a.worldY, this.mix);
          break;
        case 2:
          spine.IkConstraint.apply2(b[0], b[1], a.worldX, a.worldY, this.bendDirection, this.mix);
      }
    },
  }),
  (spine.IkConstraint.apply1 = function (a, b, c, d) {
    var e = a.parent ? a.parent.getWorldRotationX() : 0,
      f = a.rotation,
      g = Math.atan2(c - a.worldY, b - a.worldX) * spine.radDeg - e;
    (a.worldSignX != a.worldSignY) != (a.skeleton.flipX != (a.skeleton.flipY != spine.Bone.yDown)) && (g = 360 - g),
      g > 180 ? (g -= 360) : -180 > g && (g += 360),
      a.updateWorldTransform(a.x, a.y, f + (g - f) * d, a.appliedScaleX, a.appliedScaleY);
  }),
  (spine.IkConstraint.apply2 = function (a, b, c, d, e, f) {
    if (0 != f) {
      var g,
        h,
        i,
        j = a.x,
        k = a.y,
        l = a.appliedScaleX,
        m = a.appliedScaleY;
      0 > l ? ((l = -l), (g = 180), (i = -1)) : ((g = 0), (i = 1)), 0 > m && ((m = -m), (i = -i));
      var n = b.x,
        o = b.y,
        p = b.appliedScaleX,
        q = Math.abs(l - m) <= 1e-4;
      q || 0 == o || ((b.worldX = a.a * n + a.worldX), (b.worldY = a.c * n + a.worldY), (o = 0)), 0 > p ? ((p = -p), (h = 180)) : (h = 0);
      var r,
        s,
        t,
        u,
        v = a.parent;
      if (v) {
        var w = v.a,
          x = v.b,
          y = v.c,
          z = v.d,
          A = 1 / (w * z - x * y),
          B = v.worldX,
          C = v.worldY,
          D = c - B,
          E = d - C;
        (r = (D * z - E * x) * A - j), (s = (E * w - D * y) * A - k), (D = b.worldX - B), (E = b.worldY - C), (t = (D * z - E * x) * A - j), (u = (E * w - D * y) * A - k);
      } else (r = c - j), (s = d - k), (t = b.worldX - j), (u = b.worldY - k);
      var F,
        G,
        H = Math.sqrt(t * t + u * u),
        I = b.data.length * p;
      a: if (q) {
        I *= l;
        var J = (r * r + s * s - H * H - I * I) / (2 * H * I);
        -1 > J ? (J = -1) : J > 1 && (J = 1), (G = Math.acos(J) * e);
        var w = H + I * J,
          K = I * Math.sin(G);
        F = Math.atan2(s * w - r * K, r * w + s * K);
      } else {
        var w = l * I,
          x = m * I,
          L = Math.atan2(s, r),
          M = w * w,
          N = x * x,
          O = H * H,
          P = r * r + s * s,
          Q = N * O + M * P - M * N,
          R = -2 * N * H,
          S = N - M,
          z = R * R - 4 * S * Q;
        if (z >= 0) {
          var T = Math.sqrt(z);
          0 > R && (T = -T), (T = -(R + T) / 2);
          var U = T / S,
            V = Q / T,
            W = Math.abs(U) < Math.abs(V) ? U : V;
          if (P >= W * W) {
            var E = Math.sqrt(P - W * W) * e;
            (F = L - Math.atan2(E, W)), (G = Math.atan2(E / m, (W - H) / l));
            break a;
          }
        }
        var X = 0,
          Y = Number.MAX_VALUE,
          Z = 0,
          $ = 0,
          _ = 0,
          aa = 0,
          ba = 0,
          ca = 0,
          D = H + w,
          da = D * D;
        da > aa && ((_ = 0), (aa = da), (ba = D)), (D = H - w), (da = D * D), Y > da && ((X = Math.PI), (Y = da), (Z = D));
        var ea = Math.acos((-w * H) / (M - N));
        D = w * Math.cos(ea) + H;
        var E = x * Math.sin(ea);
        (da = D * D + E * E),
          Y > da && ((X = ea), (Y = da), (Z = D), ($ = E)),
          da > aa && ((_ = ea), (aa = da), (ba = D), (ca = E)),
          (Y + aa) / 2 >= P ? ((F = L - Math.atan2($ * e, Z)), (G = X * e)) : ((F = L - Math.atan2(ca * e, ba)), (G = _ * e));
      }
      var fa = Math.atan2(o, n) * i;
      (F = (F - fa) * spine.radDeg + g), (G = (G + fa) * spine.radDeg * i + h), F > 180 ? (F -= 360) : -180 > F && (F += 360), G > 180 ? (G -= 360) : -180 > G && (G += 360);
      var ga = a.rotation;
      a.updateWorldTransform(j, k, ga + (F - ga) * f, a.appliedScaleX, a.appliedScaleY), (ga = b.rotation), b.updateWorldTransform(n, o, ga + (G - ga) * f, b.appliedScaleX, b.appliedScaleY);
    }
  }),
  (spine.TransformConstraint = function (a, b) {
    (this.data = a), (this.translateMix = a.translateMix), (this.x = a.x), (this.y = a.y), (this.bone = b.findBone(a.bone.name)), (this.target = b.findBone(a.target.name));
  }),
  (spine.TransformConstraint.prototype = {
    apply: function () {
      this.update();
    },
    update: function () {
      var a = this.translateMix;
      if (a > 0) {
        var b = spine.temp;
        (b[0] = x), (b[1] = y), this.target.localToWorld(b);
        var c = this.bone;
        (c.worldX += (b[0] - c.worldX) * a), (c.worldY += (b[1] - c.worldY) * a);
      }
    },
  }),
  (spine.Skin = function (a) {
    (this.name = a), (this.attachments = {});
  }),
  (spine.Skin.prototype = {
    addAttachment: function (a, b, c) {
      this.attachments[a + ":" + b] = c;
    },
    getAttachment: function (a, b) {
      return this.attachments[a + ":" + b];
    },
    _attachAll: function (a, b) {
      for (var c in b.attachments) {
        var d = c.indexOf(":"),
          e = parseInt(c.substring(0, d)),
          f = c.substring(d + 1),
          g = a.slots[e];
        if (g.attachment && g.attachment.name == f) {
          var h = this.getAttachment(e, f);
          h && g.setAttachment(h);
        }
      }
    },
  }),
  (spine.Animation = function (a, b, c) {
    (this.name = a), (this.timelines = b), (this.duration = c);
  }),
  (spine.Animation.prototype = {
    apply: function (a, b, c, d, e) {
      d && 0 != this.duration && ((c %= this.duration), b > 0 && (b %= this.duration));
      for (var f = this.timelines, g = 0, h = f.length; h > g; g++) f[g].apply(a, b, c, e, 1);
    },
    mix: function (a, b, c, d, e, f) {
      d && 0 != this.duration && ((c %= this.duration), b > 0 && (b %= this.duration));
      for (var g = this.timelines, h = 0, i = g.length; i > h; h++) g[h].apply(a, b, c, e, f);
    },
  }),
  (spine.Animation.binarySearch = function (a, b, c) {
    var d = 0,
      e = Math.floor(a.length / c) - 2;
    if (!e) return c;
    for (var f = e >>> 1; ; ) {
      if ((a[(f + 1) * c] <= b ? (d = f + 1) : (e = f), d == e)) return (d + 1) * c;
      f = (d + e) >>> 1;
    }
  }),
  (spine.Animation.binarySearch1 = function (a, b) {
    var c = 0,
      d = a.length - 2;
    if (!d) return 1;
    for (var e = d >>> 1; ; ) {
      if ((a[e + 1] <= b ? (c = e + 1) : (d = e), c == d)) return c + 1;
      e = (c + d) >>> 1;
    }
  }),
  (spine.Animation.linearSearch = function (a, b, c) {
    for (var d = 0, e = a.length - c; e >= d; d += c) if (a[d] > b) return d;
    return -1;
  }),
  (spine.Curves = function (a) {
    var b = 19 * (a - 1);
    (this.curves = new spine.Float32Array(b)), (this.curves.length = b);
  }),
  (spine.Curves.prototype = {
    setLinear: function (a) {
      this.curves[19 * a] = 0;
    },
    setStepped: function (a) {
      this.curves[19 * a] = 1;
    },
    setCurve: function (a, b, c, d, e) {
      var f = 0.1,
        g = f * f,
        h = g * f,
        i = 3 * f,
        j = 3 * g,
        k = 6 * g,
        l = 6 * h,
        m = 2 * -b + d,
        n = 2 * -c + e,
        o = 3 * (b - d) + 1,
        p = 3 * (c - e) + 1,
        q = b * i + m * j + o * h,
        r = c * i + n * j + p * h,
        s = m * k + o * l,
        t = n * k + p * l,
        u = o * l,
        v = p * l,
        w = 19 * a,
        x = this.curves;
      x[w++] = 2;
      for (var y = q, z = r, A = w + 19 - 1; A > w; w += 2) (x[w] = y), (x[w + 1] = z), (q += s), (r += t), (s += u), (t += v), (y += q), (z += r);
    },
    getCurvePercent: function (a, b) {
      b = 0 > b ? 0 : b > 1 ? 1 : b;
      var c = this.curves,
        d = 19 * a,
        e = c[d];
      if (0 === e) return b;
      if (1 == e) return 0;
      d++;
      for (var f = 0, g = d, h = d + 19 - 1; h > d; d += 2)
        if (((f = c[d]), f >= b)) {
          var i, j;
          return d == g ? ((i = 0), (j = 0)) : ((i = c[d - 2]), (j = c[d - 1])), j + ((c[d + 1] - j) * (b - i)) / (f - i);
        }
      var k = c[d - 1];
      return k + ((1 - k) * (b - f)) / (1 - f);
    },
  }),
  (spine.RotateTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(2 * a)), (this.frames.length = 2 * a);
  }),
  (spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
      return this.frames.length / 2;
    },
    setFrame: function (a, b, c) {
      (a *= 2), (this.frames[a] = b), (this.frames[a + 1] = c);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g = a.bones[this.boneIndex];
        if (c >= f[f.length - 2]) {
          for (var h = g.data.rotation + f[f.length - 1] - g.rotation; h > 180; ) h -= 360;
          for (; -180 > h; ) h += 360;
          return void (g.rotation += h * e);
        }
        var i = spine.Animation.binarySearch(f, c, 2),
          j = f[i - 1],
          k = f[i],
          l = 1 - (c - k) / (f[i - 2] - k);
        l = this.curves.getCurvePercent(i / 2 - 1, l);
        for (var h = f[i + 1] - j; h > 180; ) h -= 360;
        for (; -180 > h; ) h += 360;
        for (h = g.data.rotation + (j + h * l) - g.rotation; h > 180; ) h -= 360;
        for (; -180 > h; ) h += 360;
        g.rotation += h * e;
      }
    },
  }),
  (spine.TranslateTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(3 * a)), (this.frames.length = 3 * a);
  }),
  (spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
      return this.frames.length / 3;
    },
    setFrame: function (a, b, c, d) {
      (a *= 3), (this.frames[a] = b), (this.frames[a + 1] = c), (this.frames[a + 2] = d);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g = a.bones[this.boneIndex];
        if (c >= f[f.length - 3]) return (g.x += (g.data.x + f[f.length - 2] - g.x) * e), void (g.y += (g.data.y + f[f.length - 1] - g.y) * e);
        var h = spine.Animation.binarySearch(f, c, 3),
          i = f[h - 2],
          j = f[h - 1],
          k = f[h],
          l = 1 - (c - k) / (f[h + -3] - k);
        (l = this.curves.getCurvePercent(h / 3 - 1, l)), (g.x += (g.data.x + i + (f[h + 1] - i) * l - g.x) * e), (g.y += (g.data.y + j + (f[h + 2] - j) * l - g.y) * e);
      }
    },
  }),
  (spine.ScaleTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(3 * a)), (this.frames.length = 3 * a);
  }),
  (spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function () {
      return this.frames.length / 3;
    },
    setFrame: function (a, b, c, d) {
      (a *= 3), (this.frames[a] = b), (this.frames[a + 1] = c), (this.frames[a + 2] = d);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g = a.bones[this.boneIndex];
        if (c >= f[f.length - 3]) return (g.scaleX += (g.data.scaleX * f[f.length - 2] - g.scaleX) * e), void (g.scaleY += (g.data.scaleY * f[f.length - 1] - g.scaleY) * e);
        var h = spine.Animation.binarySearch(f, c, 3),
          i = f[h - 2],
          j = f[h - 1],
          k = f[h],
          l = 1 - (c - k) / (f[h + -3] - k);
        (l = this.curves.getCurvePercent(h / 3 - 1, l)), (g.scaleX += (g.data.scaleX * (i + (f[h + 1] - i) * l) - g.scaleX) * e), (g.scaleY += (g.data.scaleY * (j + (f[h + 2] - j) * l) - g.scaleY) * e);
      }
    },
  }),
  (spine.ColorTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(5 * a)), (this.frames.length = 5 * a);
  }),
  (spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
      return this.frames.length / 5;
    },
    setFrame: function (a, b, c, d, e, f) {
      (a *= 5), (this.frames[a] = b), (this.frames[a + 1] = c), (this.frames[a + 2] = d), (this.frames[a + 3] = e), (this.frames[a + 4] = f);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g, h, i, j;
        if (c >= f[f.length - 5]) {
          var k = f.length - 1;
          (g = f[k - 3]), (h = f[k - 2]), (i = f[k - 1]), (j = f[k]);
        } else {
          var l = spine.Animation.binarySearch(f, c, 5),
            m = f[l - 4],
            n = f[l - 3],
            o = f[l - 2],
            p = f[l - 1],
            q = f[l],
            r = 1 - (c - q) / (f[l - 5] - q);
          (r = this.curves.getCurvePercent(l / 5 - 1, r)), (g = m + (f[l + 1] - m) * r), (h = n + (f[l + 2] - n) * r), (i = o + (f[l + 3] - o) * r), (j = p + (f[l + 4] - p) * r);
        }
        var s = a.slots[this.slotIndex];
        1 > e ? ((s.r += (g - s.r) * e), (s.g += (h - s.g) * e), (s.b += (i - s.b) * e), (s.a += (j - s.a) * e)) : ((s.r = g), (s.g = h), (s.b = i), (s.a = j));
      }
    },
  }),
  (spine.AttachmentTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(a)), (this.frames.length = a), (this.attachmentNames = []), (this.attachmentNames.length = a);
  }),
  (spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function () {
      return this.frames.length;
    },
    setFrame: function (a, b, c) {
      (this.frames[a] = b), (this.attachmentNames[a] = c);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (c < f[0]) return void (b > c && this.apply(a, b, Number.MAX_VALUE, null, 0));
      b > c && (b = -1);
      var g = c >= f[f.length - 1] ? f.length - 1 : spine.Animation.binarySearch1(f, c) - 1;
      if (!(f[g] < b)) {
        var h = this.attachmentNames[g];
        a.slots[this.slotIndex].setAttachment(h ? a.getAttachmentBySlotIndex(this.slotIndex, h) : null);
      }
    },
  }),
  (spine.EventTimeline = function (a) {
    (this.frames = new spine.Float32Array(a)), (this.frames.length = a), (this.events = []), (this.events.length = a);
  }),
  (spine.EventTimeline.prototype = {
    getFrameCount: function () {
      return this.frames.length;
    },
    setFrame: function (a, b) {
      (this.frames[a] = b.time), (this.events[a] = b);
    },
    apply: function (a, b, c, d, e) {
      if (d) {
        var f = this.frames,
          g = f.length;
        if (b > c) this.apply(a, b, Number.MAX_VALUE, d, e), (b = -1);
        else if (b >= f[g - 1]) return;
        if (!(c < f[0])) {
          var h;
          if (b < f[0]) h = 0;
          else {
            h = spine.Animation.binarySearch1(f, b);
            for (var i = f[h]; h > 0 && f[h - 1] == i; ) h--;
          }
          for (var j = this.events; g > h && c >= f[h]; h++) d[d.length] = j[h];
        }
      }
    },
  }),
  (spine.DrawOrderTimeline = function (a) {
    (this.frames = new spine.Float32Array(a)), (this.frames.length = a), (this.drawOrders = []), (this.drawOrders.length = a);
  }),
  (spine.DrawOrderTimeline.prototype = {
    getFrameCount: function () {
      return this.frames.length;
    },
    setFrame: function (a, b, c) {
      (this.frames[a] = b), (this.drawOrders[a] = c);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g;
        g = c >= f[f.length - 1] ? f.length - 1 : spine.Animation.binarySearch1(f, c) - 1;
        var h = a.drawOrder,
          i = a.slots,
          j = this.drawOrders[g];
        if (j) for (var k = 0, l = j.length; l > k; k++) h[k] = a.slots[j[k]];
        else for (var k = 0, l = i.length; l > k; k++) h[k] = i[k];
      }
    },
  }),
  (spine.FfdTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(a)), (this.frames.length = a), (this.frameVertices = []), (this.frameVertices.length = a);
  }),
  (spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function () {
      return this.frames.length;
    },
    setFrame: function (a, b, c) {
      (this.frames[a] = b), (this.frameVertices[a] = c);
    },
    apply: function (a, b, c, d, e) {
      var f = a.slots[this.slotIndex],
        g = f.attachment;
      if (g && (g == this.attachment || (g.inheritFFD && g.parentMesh == this.attachment))) {
        var h = this.frames;
        if (!(c < h[0])) {
          var i = this.frameVertices,
            j = i[0].length,
            k = f.attachmentVertices;
          if ((k.length != j && ((f.attachmentVertices = k = new spine.Float32Array(j)), (e = 1)), c >= h[h.length - 1])) {
            var l = i[h.length - 1];
            if (1 > e) for (var m = 0; j > m; m++) k[m] += (l[m] - k[m]) * e;
            else for (var m = 0; j > m; m++) k[m] = l[m];
          } else {
            var n = spine.Animation.binarySearch1(h, c),
              o = h[n],
              p = 1 - (c - o) / (h[n - 1] - o);
            p = this.curves.getCurvePercent(n - 1, 0 > p ? 0 : p > 1 ? 1 : p);
            var q = i[n - 1],
              r = i[n];
            if (1 > e)
              for (var m = 0; j > m; m++) {
                var s = q[m];
                k[m] += (s + (r[m] - s) * p - k[m]) * e;
              }
            else
              for (var m = 0; j > m; m++) {
                var s = q[m];
                k[m] = s + (r[m] - s) * p;
              }
          }
        }
      }
    },
  }),
  (spine.IkConstraintTimeline = function (a) {
    (this.curves = new spine.Curves(a)), (this.frames = new spine.Float32Array(3 * a)), (this.frames.length = 3 * a);
  }),
  (spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function () {
      return this.frames.length / 3;
    },
    setFrame: function (a, b, c, d) {
      (a *= 3), (this.frames[a] = b), (this.frames[a + 1] = c), (this.frames[a + 2] = d);
    },
    apply: function (a, b, c, d, e) {
      var f = this.frames;
      if (!(c < f[0])) {
        var g = a.ikConstraints[this.ikConstraintIndex];
        if (c >= f[f.length - 3]) return (g.mix += (f[f.length - 2] - g.mix) * e), void (g.bendDirection = f[f.length - 1]);
        var h = spine.Animation.binarySearch(f, c, 3),
          i = f[h + -2],
          j = f[h],
          k = 1 - (c - j) / (f[h + -3] - j);
        k = this.curves.getCurvePercent(h / 3 - 1, k);
        var l = i + (f[h + 1] - i) * k;
        (g.mix += (l - g.mix) * e), (g.bendDirection = f[h + -1]);
      }
    },
  }),
  (spine.SkeletonData = function () {
    (this.bones = []), (this.slots = []), (this.skins = []), (this.events = []), (this.animations = []), (this.ikConstraints = []), (this.transformConstraints = []);
  }),
  (spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0,
    height: 0,
    version: null,
    hash: null,
    findBone: function (a) {
      for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    findBoneIndex: function (a) {
      for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return c;
      return -1;
    },
    findSlot: function (a) {
      for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return slot[c];
      return null;
    },
    findSlotIndex: function (a) {
      for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return c;
      return -1;
    },
    findSkin: function (a) {
      for (var b = this.skins, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    findEvent: function (a) {
      for (var b = this.events, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    findAnimation: function (a) {
      for (var b = this.animations, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    findIkConstraint: function (a) {
      for (var b = this.ikConstraints, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    findTransformConstraints: function (a) {
      for (var b = this.transformConstraints, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
  }),
  (spine.Skeleton = function (a) {
    (this.data = a), (this.bones = []);
    for (var b = 0, c = a.bones.length; c > b; b++) {
      var d = a.bones[b],
        e = d.parent ? this.bones[a.bones.indexOf(d.parent)] : null;
      this.bones[b] = new spine.Bone(d, this, e);
    }
    (this.slots = []), (this.drawOrder = []);
    for (var b = 0, c = a.slots.length; c > b; b++) {
      var f = a.slots[b],
        g = this.bones[a.bones.indexOf(f.boneData)],
        h = new spine.Slot(f, g);
      (this.slots[b] = h), (this.drawOrder[b] = h);
    }
    this.ikConstraints = [];
    for (var b = 0, c = a.ikConstraints.length; c > b; b++) this.ikConstraints[b] = new spine.IkConstraint(a.ikConstraints[b], this);
    this.transformConstraints = [];
    for (var b = 0, c = a.transformConstraints.length; c > b; b++) this.transformConstraints[b] = new spine.TransformConstraint(a.transformConstraints[b], this);
    (this.cache = []), this.updateCache();
  }),
  (spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateCache: function () {
      var a = this.bones,
        b = this.cache,
        c = this.ikConstraints,
        d = this.transformConstraints,
        e = c.length,
        f = d.length;
      b.length = 0;
      for (var g = 0, h = a.length; h > g; g++) {
        var i = a[g];
        b[b.length] = i;
        for (var j = 0; e > j; j++) {
          var k = c[j];
          if (i == k.bones[k.bones.length - 1]) {
            b[b.length] = k;
            break;
          }
        }
      }
      for (var g = 0; f > g; g++)
        for (var l = d[g], j = b.length - 1; j >= 0; j--) {
          var m = b[j];
          if (m == l.bone || m == l.target) {
            b.splice(j + 1, 0, l);
            break;
          }
        }
    },
    updateWorldTransform: function () {
      for (var a = this.cache, b = 0, c = a.length; c > b; b++) a[b].update();
    },
    setToSetupPose: function () {
      this.setBonesToSetupPose(), this.setSlotsToSetupPose();
    },
    setBonesToSetupPose: function () {
      for (var a = this.bones, b = 0, c = a.length; c > b; b++) a[b].setToSetupPose();
      for (var d = this.ikConstraints, b = 0, c = d.length; c > b; b++) {
        var e = d[b];
        (e.bendDirection = e.data.bendDirection), (e.mix = e.data.mix);
      }
      for (var f = this.transformConstraints, b = 0, c = f.length; c > b; b++) {
        var e = f[b];
        (e.translateMix = e.data.translateMix), (e.x = e.data.x), (e.y = e.data.y);
      }
    },
    setSlotsToSetupPose: function () {
      for (var a = this.slots, b = this.drawOrder, c = 0, d = a.length; d > c; c++) (b[c] = a[c]), a[c].setToSetupPose(c);
    },
    getRootBone: function () {
      return this.bones.length ? this.bones[0] : null;
    },
    findBone: function (a) {
      for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
      return null;
    },
    findBoneIndex: function (a) {
      for (var b = this.bones, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return c;
      return -1;
    },
    findSlot: function (a) {
      for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
      return null;
    },
    findSlotIndex: function (a) {
      for (var b = this.slots, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return c;
      return -1;
    },
    setSkinByName: function (a) {
      var b = this.data.findSkin(a);
      if (!b) throw "Skin not found: " + a;
      this.setSkin(b);
    },
    setSkin: function (a) {
      if (a)
        if (this.skin) a._attachAll(this, this.skin);
        else
          for (var b = this.slots, c = 0, d = b.length; d > c; c++) {
            var e = b[c],
              f = e.data.attachmentName;
            if (f) {
              var g = a.getAttachment(c, f);
              g && e.setAttachment(g);
            }
          }
      this.skin = a;
    },
    getAttachmentBySlotName: function (a, b) {
      return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b);
    },
    getAttachmentBySlotIndex: function (a, b) {
      if (this.skin) {
        var c = this.skin.getAttachment(a, b);
        if (c) return c;
      }
      return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null;
    },
    setAttachment: function (a, b) {
      for (var c = this.slots, d = 0, e = c.length; e > d; d++) {
        var f = c[d];
        if (f.data.name == a) {
          var g = null;
          if (b && ((g = this.getAttachmentBySlotIndex(d, b)), !g)) throw "Attachment not found: " + b + ", for slot: " + a;
          return void f.setAttachment(g);
        }
      }
      throw "Slot not found: " + a;
    },
    findIkConstraint: function (a) {
      for (var b = this.ikConstraints, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
      return null;
    },
    findTransformConstraint: function (a) {
      for (var b = this.transformConstraints, c = 0, d = b.length; d > c; c++) if (b[c].data.name == a) return b[c];
      return null;
    },
    update: function (a) {
      this.time += a;
    },
  }),
  (spine.EventData = function (a) {
    this.name = a;
  }),
  (spine.EventData.prototype = { intValue: 0, floatValue: 0, stringValue: null }),
  (spine.Event = function (a, b) {
    (this.time = a), (this.data = b);
  }),
  (spine.Event.prototype = { intValue: 0, floatValue: 0, stringValue: null }),
  (spine.AttachmentType = { region: 0, boundingbox: 1, mesh: 2, weightedmesh: 3, linkedmesh: 4, weightedlinkedmesh: 5 }),
  (spine.RegionAttachment = function (a) {
    (this.name = a), (this.offset = new spine.Float32Array(8)), (this.offset.length = 8), (this.uvs = new spine.Float32Array(8)), (this.uvs.length = 8);
  }),
  (spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function (a, b, c, d, e) {
      var f = this.uvs;
      e ? ((f[2] = a), (f[3] = d), (f[4] = a), (f[5] = b), (f[6] = c), (f[7] = b), (f[0] = c), (f[1] = d)) : ((f[0] = a), (f[1] = d), (f[2] = a), (f[3] = b), (f[4] = c), (f[5] = b), (f[6] = c), (f[7] = d));
    },
    updateOffset: function () {
      var a = (this.width / this.regionOriginalWidth) * this.scaleX,
        b = (this.height / this.regionOriginalHeight) * this.scaleY,
        c = (-this.width / 2) * this.scaleX + this.regionOffsetX * a,
        d = (-this.height / 2) * this.scaleY + this.regionOffsetY * b,
        e = c + this.regionWidth * a,
        f = d + this.regionHeight * b,
        g = this.rotation * spine.degRad,
        h = Math.cos(g),
        i = Math.sin(g),
        j = c * h + this.x,
        k = c * i,
        l = d * h + this.y,
        m = d * i,
        n = e * h + this.x,
        o = e * i,
        p = f * h + this.y,
        q = f * i,
        r = this.offset;
      (r[0] = j - m), (r[1] = l + k), (r[2] = j - q), (r[3] = p + k), (r[4] = n - q), (r[5] = p + o), (r[6] = n - m), (r[7] = l + o);
    },
    computeVertices: function (a, b, c, d) {
      (a += c.worldX), (b += c.worldY);
      var e = c.a,
        f = c.b,
        g = c.c,
        h = c.d,
        i = this.offset;
      (d[0] = i[0] * e + i[1] * f + a),
        (d[1] = i[0] * g + i[1] * h + b),
        (d[2] = i[2] * e + i[3] * f + a),
        (d[3] = i[2] * g + i[3] * h + b),
        (d[4] = i[4] * e + i[5] * f + a),
        (d[5] = i[4] * g + i[5] * h + b),
        (d[6] = i[6] * e + i[7] * f + a),
        (d[7] = i[6] * g + i[7] * h + b);
    },
  }),
  (spine.MeshAttachment = function (a) {
    this.name = a;
  }),
  (spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function () {
      var a = this.regionU2 - this.regionU,
        b = this.regionV2 - this.regionV,
        c = this.regionUVs.length;
      if (((this.uvs && this.uvs.length == c) || (this.uvs = new spine.Float32Array(c)), this.regionRotate))
        for (var d = 0; c > d; d += 2) (this.uvs[d] = this.regionU + this.regionUVs[d + 1] * a), (this.uvs[d + 1] = this.regionV + b - this.regionUVs[d] * b);
      else for (var d = 0; c > d; d += 2) (this.uvs[d] = this.regionU + this.regionUVs[d] * a), (this.uvs[d + 1] = this.regionV + this.regionUVs[d + 1] * b);
    },
    computeWorldVertices: function (a, b, c, d) {
      var e = c.bone;
      (a += e.worldX), (b += e.worldY);
      var f = e.a,
        g = e.b,
        h = e.c,
        i = e.d,
        j = this.vertices,
        k = j.length;
      c.attachmentVertices.length == k && (j = c.attachmentVertices);
      for (var l = 0; k > l; l += 2) {
        var m = j[l],
          n = j[l + 1];
        (d[l] = m * f + n * g + a), (d[l + 1] = m * h + n * i + b);
      }
    },
    setParentMesh: function (a) {
      (this.parentMesh = a), a && ((this.vertices = a.vertices), (this.regionUVs = a.regionUVs), (this.triangles = a.triangles), (this.hullLength = a.hullLength), (this.edges = a.edges), (this.width = a.width), (this.height = a.height));
    },
  }),
  (spine.WeightedMeshAttachment = function (a) {
    this.name = a;
  }),
  (spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function (a, b, c, d, e) {
      var f = this.regionU2 - this.regionU,
        g = this.regionV2 - this.regionV,
        h = this.regionUVs.length;
      if (((this.uvs && this.uvs.length == h) || (this.uvs = new spine.Float32Array(h)), this.regionRotate))
        for (var i = 0; h > i; i += 2) (this.uvs[i] = this.regionU + this.regionUVs[i + 1] * f), (this.uvs[i + 1] = this.regionV + g - this.regionUVs[i] * g);
      else for (var i = 0; h > i; i += 2) (this.uvs[i] = this.regionU + this.regionUVs[i] * f), (this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * g);
    },
    computeWorldVertices: function (a, b, c, d) {
      var e,
        f,
        g,
        h,
        i,
        j,
        k,
        l = c.bone.skeleton.bones,
        m = this.weights,
        n = this.bones,
        o = 0,
        p = 0,
        q = 0,
        r = 0,
        s = n.length;
      if (c.attachmentVertices.length)
        for (var t = c.attachmentVertices; s > p; o += 2) {
          for (f = 0, g = 0, e = n[p++] + p; e > p; p++, q += 3, r += 2) (h = l[n[p]]), (i = m[q] + t[r]), (j = m[q + 1] + t[r + 1]), (k = m[q + 2]), (f += (i * h.a + j * h.b + h.worldX) * k), (g += (i * h.c + j * h.d + h.worldY) * k);
          (d[o] = f + a), (d[o + 1] = g + b);
        }
      else
        for (; s > p; o += 2) {
          for (f = 0, g = 0, e = n[p++] + p; e > p; p++, q += 3) (h = l[n[p]]), (i = m[q]), (j = m[q + 1]), (k = m[q + 2]), (f += (i * h.a + j * h.b + h.worldX) * k), (g += (i * h.c + j * h.d + h.worldY) * k);
          (d[o] = f + a), (d[o + 1] = g + b);
        }
    },
    setParentMesh: function (a) {
      (this.parentMesh = a),
        a && ((this.bones = a.bones), (this.weights = a.weights), (this.regionUVs = a.regionUVs), (this.triangles = a.triangles), (this.hullLength = a.hullLength), (this.edges = a.edges), (this.width = a.width), (this.height = a.height));
    },
  }),
  (spine.BoundingBoxAttachment = function (a) {
    (this.name = a), (this.vertices = new spine.Float32Array());
  }),
  (spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function (a, b, c, d) {
      (a += c.worldX), (b += c.worldY);
      for (var e = c.a, f = c.b, g = c.c, h = c.d, i = this.vertices, j = 0, k = i.length; k > j; j += 2) {
        var l = i[j],
          m = i[j + 1];
        (d[j] = l * e + m * f + a), (d[j + 1] = l * g + m * h + b);
      }
    },
  }),
  (spine.AnimationStateData = function (a) {
    (this.skeletonData = a), (this.animationToMixTime = {});
  }),
  (spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function (a, b, c) {
      var d = this.skeletonData.findAnimation(a);
      if (!d) throw "Animation not found: " + a;
      var e = this.skeletonData.findAnimation(b);
      if (!e) throw "Animation not found: " + b;
      this.setMix(d, e, c);
    },
    setMix: function (a, b, c) {
      this.animationToMixTime[a.name + ":" + b.name] = c;
    },
    getMix: function (a, b) {
      var c = a.name + ":" + b.name;
      return this.animationToMixTime.hasOwnProperty(c) ? this.animationToMixTime[c] : this.defaultMix;
    },
  }),
  (spine.TrackEntry = function () {}),
  (spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
  }),
  (spine.AnimationState = function (a) {
    (this.data = a), (this.tracks = []), (this.events = []);
  }),
  (spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function (a) {
      a *= this.timeScale;
      for (var b = 0; b < this.tracks.length; b++) {
        var c = this.tracks[b];
        if (c) {
          if (((c.time += a * c.timeScale), c.previous)) {
            var d = a * c.previous.timeScale;
            (c.previous.time += d), (c.mixTime += d);
          }
          var e = c.next;
          e ? ((e.time = c.lastTime - e.delay), e.time >= 0 && this.setCurrent(b, e)) : !c.loop && c.lastTime >= c.endTime && this.clearTrack(b);
        }
      }
    },
    apply: function (a) {
      for (var b = 0; b < this.tracks.length; b++) {
        var c = this.tracks[b];
        if (c) {
          this.events.length = 0;
          var d = c.time,
            e = c.lastTime,
            f = c.endTime,
            g = c.loop;
          !g && d > f && (d = f);
          var h = c.previous;
          if (h) {
            var i = h.time;
            !h.loop && i > h.endTime && (i = h.endTime), h.animation.apply(a, i, i, h.loop, null);
            var j = (c.mixTime / c.mixDuration) * c.mix;
            j >= 1 && ((j = 1), (c.previous = null)), c.animation.mix(a, c.lastTime, d, g, this.events, j);
          } else 1 == c.mix ? c.animation.apply(a, c.lastTime, d, g, this.events) : c.animation.mix(a, c.lastTime, d, g, this.events, c.mix);
          for (var k = 0, l = this.events.length; l > k; k++) {
            var m = this.events[k];
            c.onEvent && c.onEvent(b, m), this.onEvent && this.onEvent(b, m);
          }
          if (g ? e % f > d % f : f > e && d >= f) {
            var n = Math.floor(d / f);
            c.onComplete && c.onComplete(b, n), this.onComplete && this.onComplete(b, n);
          }
          c.lastTime = c.time;
        }
      }
    },
    clearTracks: function () {
      for (var a = 0, b = this.tracks.length; b > a; a++) this.clearTrack(a);
      this.tracks.length = 0;
    },
    clearTrack: function (a) {
      if (!(a >= this.tracks.length)) {
        var b = this.tracks[a];
        b && (b.onEnd && b.onEnd(a), this.onEnd && this.onEnd(a), (this.tracks[a] = null));
      }
    },
    _expandToIndex: function (a) {
      if (a < this.tracks.length) return this.tracks[a];
      for (; a >= this.tracks.length; ) this.tracks[this.tracks.length] = null;
      return null;
    },
    setCurrent: function (a, b) {
      var c = this._expandToIndex(a);
      if (c) {
        var d = c.previous;
        (c.previous = null),
          c.onEnd && c.onEnd(a),
          this.onEnd && this.onEnd(a),
          (b.mixDuration = this.data.getMix(c.animation, b.animation)),
          b.mixDuration > 0 && ((b.mixTime = 0), d && c.mixTime / c.mixDuration < 0.5 ? (b.previous = d) : (b.previous = c));
      }
      (this.tracks[a] = b), b.onStart && b.onStart(a), this.onStart && this.onStart(a);
    },
    setAnimationByName: function (a, b, c) {
      var d = this.data.skeletonData.findAnimation(b);
      if (!d) throw "Animation not found: " + b;
      return this.setAnimation(a, d, c);
    },
    setAnimation: function (a, b, c) {
      var d = new spine.TrackEntry();
      return (d.animation = b), (d.loop = c), (d.endTime = b.duration), this.setCurrent(a, d), d;
    },
    addAnimationByName: function (a, b, c, d) {
      var e = this.data.skeletonData.findAnimation(b);
      if (!e) throw "Animation not found: " + b;
      return this.addAnimation(a, e, c, d);
    },
    addAnimation: function (a, b, c, d) {
      var e = new spine.TrackEntry();
      (e.animation = b), (e.loop = c), (e.endTime = b.duration);
      var f = this._expandToIndex(a);
      if (f) {
        for (; f.next; ) f = f.next;
        f.next = e;
      } else this.tracks[a] = e;
      return 0 >= d && (f ? (d += f.endTime - this.data.getMix(f.animation, b)) : (d = 0)), (e.delay = d), e;
    },
    getCurrent: function (a) {
      return a >= this.tracks.length ? null : this.tracks[a];
    },
  }),
  (spine.SkeletonJson = function (a) {
    (this.attachmentLoader = a), (this.linkedMeshes = []);
  }),
  (spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function (a, b) {
      var c = new spine.SkeletonData();
      c.name = b;
      var d = a.skeleton;
      d && ((c.hash = d.hash), (c.version = d.spine), (c.width = d.width || 0), (c.height = d.height || 0));
      for (var e = a.bones, f = 0, g = e.length; g > f; f++) {
        var h = e[f],
          i = null;
        if (h.parent && ((i = c.findBone(h.parent)), !i)) throw "Parent bone not found: " + h.parent;
        var j = new spine.BoneData(h.name, i);
        (j.length = (h.length || 0) * this.scale),
          (j.x = (h.x || 0) * this.scale),
          (j.y = (h.y || 0) * this.scale),
          (j.rotation = h.rotation || 0),
          (j.scaleX = h.hasOwnProperty("scaleX") ? h.scaleX : 1),
          (j.scaleY = h.hasOwnProperty("scaleY") ? h.scaleY : 1),
          (j.inheritScale = !h.hasOwnProperty("inheritScale") || h.inheritScale),
          (j.inheritRotation = !h.hasOwnProperty("inheritRotation") || h.inheritRotation),
          (c.bones[f] = j);
      }
      var k = a.ik;
      if (k)
        for (var f = 0, g = k.length; g > f; f++) {
          for (var l = k[f], m = new spine.IkConstraintData(l.name), e = l.bones, n = 0, o = e.length; o > n; n++) {
            var p = c.findBone(e[n]);
            if (!p) throw "IK bone not found: " + e[n];
            m.bones[n] = p;
          }
          if (((m.target = c.findBone(l.target)), !m.target)) throw "Target bone not found: " + l.target;
          (m.bendDirection = !l.hasOwnProperty("bendPositive") || l.bendPositive ? 1 : -1), (m.mix = l.hasOwnProperty("mix") ? l.mix : 1), (c.ikConstraints[f] = m);
        }
      var q = a.transform;
      if (q)
        for (var f = 0, g = q.length; g > f; f++) {
          var r = q[f],
            s = new spine.TransformConstraintData(r.name);
          if (((s.bone = c.findBone(r.bone)), !s.bone)) throw "Bone not found: " + r.bone;
          if (((s.target = c.findBone(r.target)), !s.target)) throw "Target bone not found: " + r.target;
          (s.mix = r.hasOwnProperty("translateMix") ? l.translateMix : 1), (s.x = (r.x || 0) * this.scale), (s.y = (r.y || 0) * this.scale), (c.transformConstraints[f] = s);
        }
      for (var t = a.slots, f = 0, g = t.length; g > f; f++) {
        var u = t[f],
          j = c.findBone(u.bone);
        if (!j) throw "Slot bone not found: " + u.bone;
        var v = new spine.SlotData(u.name, j),
          w = u.color;
        w && ((v.r = this.toColor(w, 0)), (v.g = this.toColor(w, 1)), (v.b = this.toColor(w, 2)), (v.a = this.toColor(w, 3))), (v.attachmentName = u.attachment), (v.blendMode = spine.BlendMode[u.blend || "normal"]), (c.slots[f] = v);
      }
      var x = a.skins;
      for (var y in x)
        if (x.hasOwnProperty(y)) {
          var z = x[y],
            A = new spine.Skin(y);
          for (var B in z)
            if (z.hasOwnProperty(B)) {
              var C = c.findSlotIndex(B),
                D = z[B];
              for (var E in D)
                if (D.hasOwnProperty(E)) {
                  var F = this.readAttachment(A, C, E, D[E]);
                  F && A.addAttachment(C, E, F);
                }
            }
          (c.skins[c.skins.length] = A), "default" == A.name && (c.defaultSkin = A);
        }
      for (var f = 0, g = this.linkedMeshes.length; g > f; f++) {
        var G = this.linkedMeshes[f],
          A = G.skin ? c.findSkin(G.skin) : c.defaultSkin;
        if (!A) throw "Skin not found: " + G.skin;
        var i = A.getAttachment(G.slotIndex, G.parent);
        if (!i) throw "Parent mesh not found: " + G.parent;
        G.mesh.setParentMesh(i), G.mesh.updateUVs();
      }
      this.linkedMeshes.length = 0;
      var H = a.events;
      for (var I in H)
        if (H.hasOwnProperty(I)) {
          var J = H[I],
            K = new spine.EventData(I);
          (K.intValue = J["int"] || 0), (K.floatValue = J["float"] || 0), (K.stringValue = J.string || null), (c.events[c.events.length] = K);
        }
      var L = a.animations;
      for (var M in L) L.hasOwnProperty(M) && this.readAnimation(M, L[M], c);
      return c;
    },
    readAttachment: function (a, b, c, d) {
      c = d.name || c;
      var e = d.type || "region";
      "skinnedmesh" == e && (e = "weightedmesh"), (e = spine.AttachmentType[e]);
      var f = d.path || c,
        g = this.scale;
      switch (e) {
        case spine.AttachmentType.region:
          var h = this.attachmentLoader.newRegionAttachment(a, c, f);
          if (!h) return null;
          (h.path = f),
            (h.x = (d.x || 0) * g),
            (h.y = (d.y || 0) * g),
            (h.scaleX = d.hasOwnProperty("scaleX") ? d.scaleX : 1),
            (h.scaleY = d.hasOwnProperty("scaleY") ? d.scaleY : 1),
            (h.rotation = d.rotation || 0),
            (h.width = (d.width || 0) * g),
            (h.height = (d.height || 0) * g);
          var i = d.color;
          return i && ((h.r = this.toColor(i, 0)), (h.g = this.toColor(i, 1)), (h.b = this.toColor(i, 2)), (h.a = this.toColor(i, 3))), h.updateOffset(), h;
        case spine.AttachmentType.mesh:
        case spine.AttachmentType.linkedmesh:
          var j = this.attachmentLoader.newMeshAttachment(a, c, f);
          return j
            ? ((j.path = f),
              (i = d.color),
              i && ((j.r = this.toColor(i, 0)), (j.g = this.toColor(i, 1)), (j.b = this.toColor(i, 2)), (j.a = this.toColor(i, 3))),
              (j.width = (d.width || 0) * g),
              (j.height = (d.height || 0) * g),
              d.parent
                ? ((j.inheritFFD = !d.hasOwnProperty("ffd") || d.ffd), (this.linkedMeshes[this.linkedMeshes.length] = { mesh: j, skin: d.skin, slotIndex: b, parent: d.parent }))
                : ((j.vertices = this.getFloatArray(d, "vertices", g)),
                  (j.triangles = this.getUint32Array(d, "triangles")),
                  (j.regionUVs = this.getFloatArray(d, "uvs", 1)),
                  j.updateUVs(),
                  (j.hullLength = 2 * (d.hull || 0)),
                  d.edges && (j.edges = this.getUint16Array(d, "edges"))),
              j)
            : null;
        case spine.AttachmentType.weightedmesh:
        case spine.AttachmentType.weightedlinkedmesh:
          var j = this.attachmentLoader.newWeightedMeshAttachment(a, c, f);
          if (!j) return null;
          if (((j.path = f), (i = d.color), i && ((j.r = this.toColor(i, 0)), (j.g = this.toColor(i, 1)), (j.b = this.toColor(i, 2)), (j.a = this.toColor(i, 3))), (j.width = (d.width || 0) * g), (j.height = (d.height || 0) * g), d.parent))
            (j.inheritFFD = !d.hasOwnProperty("ffd") || d.ffd), (this.linkedMeshes[this.linkedMeshes.length] = { mesh: j, skin: d.skin, slotIndex: b, parent: d.parent });
          else {
            for (var k = this.getFloatArray(d, "uvs", 1), l = this.getFloatArray(d, "vertices", 1), m = new spine.Float32Array(3 * k.length * 3), n = new spine.Uint32Array(3 * k.length), o = 0, p = 0, q = 0, r = l.length; r > o; ) {
              var s = 0 | l[o++];
              n[p++] = s;
              for (var t = o + 4 * s; t > o; ) (n[p++] = l[o]), (m[q++] = l[o + 1] * g), (m[q++] = l[o + 2] * g), (m[q++] = l[o + 3]), (o += 4);
            }
            (j.bones = n), (j.weights = m), (j.triangles = this.getUint32Array(d, "triangles")), (j.regionUVs = k), j.updateUVs(), (j.hullLength = 2 * (d.hull || 0)), d.edges && (j.edges = this.getUint16Array(d, "edges"));
          }
          return j;
        case spine.AttachmentType.boundingbox:
          for (var u = this.attachmentLoader.newBoundingBoxAttachment(a, c), l = d.vertices, o = 0, r = l.length; r > o; o++) u.vertices[o] = l[o] * g;
          return u;
      }
      throw "Unknown attachment type: " + e;
    },
    readAnimation: function (a, b, c) {
      var d = [],
        e = 0,
        f = b.slots;
      for (var g in f)
        if (f.hasOwnProperty(g)) {
          var h = f[g],
            i = c.findSlotIndex(g);
          for (var j in h)
            if (h.hasOwnProperty(j)) {
              var k = h[j];
              if ("color" == j) {
                var l = new spine.ColorTimeline(k.length);
                l.slotIndex = i;
                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                  var p = k[n],
                    q = p.color,
                    r = this.toColor(q, 0),
                    s = this.toColor(q, 1),
                    t = this.toColor(q, 2),
                    u = this.toColor(q, 3);
                  l.setFrame(m, p.time, r, s, t, u), this.readCurve(l, m, p), m++;
                }
                (d[d.length] = l), (e = Math.max(e, l.frames[5 * l.getFrameCount() - 5]));
              } else {
                if ("attachment" != j) throw "Invalid timeline type for a slot: " + j + " (" + g + ")";
                var l = new spine.AttachmentTimeline(k.length);
                l.slotIndex = i;
                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                  var p = k[n];
                  l.setFrame(m++, p.time, p.name);
                }
                (d[d.length] = l), (e = Math.max(e, l.frames[l.getFrameCount() - 1]));
              }
            }
        }
      var v = b.bones;
      for (var w in v)
        if (v.hasOwnProperty(w)) {
          var x = c.findBoneIndex(w);
          if (-1 == x) throw "Bone not found: " + w;
          var y = v[w];
          for (var j in y)
            if (y.hasOwnProperty(j)) {
              var k = y[j];
              if ("rotate" == j) {
                var l = new spine.RotateTimeline(k.length);
                l.boneIndex = x;
                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                  var p = k[n];
                  l.setFrame(m, p.time, p.angle), this.readCurve(l, m, p), m++;
                }
                (d[d.length] = l), (e = Math.max(e, l.frames[2 * l.getFrameCount() - 2]));
              } else {
                if ("translate" != j && "scale" != j) throw "Invalid timeline type for a bone: " + j + " (" + w + ")";
                var l,
                  z = 1;
                "scale" == j ? (l = new spine.ScaleTimeline(k.length)) : ((l = new spine.TranslateTimeline(k.length)), (z = this.scale)), (l.boneIndex = x);
                for (var m = 0, n = 0, o = k.length; o > n; n++) {
                  var p = k[n],
                    A = (p.x || 0) * z,
                    B = (p.y || 0) * z;
                  l.setFrame(m, p.time, A, B), this.readCurve(l, m, p), m++;
                }
                (d[d.length] = l), (e = Math.max(e, l.frames[3 * l.getFrameCount() - 3]));
              }
            }
        }
      var C = b.ik;
      for (var D in C)
        if (C.hasOwnProperty(D)) {
          var E = c.findIkConstraint(D),
            k = C[D],
            l = new spine.IkConstraintTimeline(k.length);
          l.ikConstraintIndex = c.ikConstraints.indexOf(E);
          for (var m = 0, n = 0, o = k.length; o > n; n++) {
            var p = k[n],
              F = p.hasOwnProperty("mix") ? p.mix : 1,
              G = !p.hasOwnProperty("bendPositive") || p.bendPositive ? 1 : -1;
            l.setFrame(m, p.time, F, G), this.readCurve(l, m, p), m++;
          }
          (d[d.length] = l), (e = Math.max(e, l.frames[3 * l.getFrameCount() - 3]));
        }
      var H = b.ffd;
      for (var I in H) {
        var J = c.findSkin(I),
          h = H[I];
        for (g in h) {
          var i = c.findSlotIndex(g),
            K = h[g];
          for (var L in K) {
            var k = K[L],
              l = new spine.FfdTimeline(k.length),
              M = J.getAttachment(i, L);
            if (!M) throw "FFD attachment not found: " + L;
            (l.slotIndex = i), (l.attachment = M);
            var N,
              O = M.type == spine.AttachmentType.mesh;
            N = O ? M.vertices.length : (M.weights.length / 3) * 2;
            for (var m = 0, n = 0, o = k.length; o > n; n++) {
              var P,
                p = k[n];
              if (p.vertices) {
                var Q = p.vertices,
                  P = new spine.Float32Array(N);
                P.length = N;
                var R = p.offset || 0,
                  S = Q.length;
                if (1 == this.scale) for (var T = 0; S > T; T++) P[T + R] = Q[T];
                else for (var T = 0; S > T; T++) P[T + R] = Q[T] * this.scale;
                if (O) for (var U = M.vertices, T = 0, S = P.length; S > T; T++) P[T] += U[T];
              } else O ? (P = M.vertices) : ((P = new spine.Float32Array(N)), (P.length = N));
              l.setFrame(m, p.time, P), this.readCurve(l, m, p), m++;
            }
            (d[d.length] = l), (e = Math.max(e, l.frames[l.getFrameCount() - 1]));
          }
        }
      }
      var V = b.drawOrder;
      if ((V || (V = b.draworder), V)) {
        for (var l = new spine.DrawOrderTimeline(V.length), W = c.slots.length, m = 0, n = 0, o = V.length; o > n; n++) {
          var X = V[n],
            Y = null;
          if (X.offsets) {
            (Y = new spine.Uint32Array(W)), (Y.length = W);
            for (var T = W - 1; T >= 0; T--) Y[T] = 4294967295;
            var Z = X.offsets,
              $ = new spine.Uint32Array(W - Z.length);
            $.length = W - Z.length;
            for (var _ = 0, aa = 0, T = 0, S = Z.length; S > T; T++) {
              var ba = Z[T],
                i = c.findSlotIndex(ba.slot);
              if (-1 == i) throw "Slot not found: " + ba.slot;
              for (; _ != i; ) $[aa++] = _++;
              Y[_ + ba.offset] = _++;
            }
            for (; W > _; ) $[aa++] = _++;
            for (var T = W - 1; T >= 0; T--) 4294967295 == Y[T] && (Y[T] = $[--aa]);
          }
          l.setFrame(m++, X.time, Y);
        }
        (d[d.length] = l), (e = Math.max(e, l.frames[l.getFrameCount() - 1]));
      }
      var ca = b.events;
      if (ca) {
        for (var l = new spine.EventTimeline(ca.length), m = 0, n = 0, o = ca.length; o > n; n++) {
          var da = ca[n],
            ea = c.findEvent(da.name);
          if (!ea) throw "Event not found: " + da.name;
          var fa = new spine.Event(da.time, ea);
          (fa.intValue = da.hasOwnProperty("int") ? da["int"] : ea.intValue),
            (fa.floatValue = da.hasOwnProperty("float") ? da["float"] : ea.floatValue),
            (fa.stringValue = da.hasOwnProperty("string") ? da.string : ea.stringValue),
            l.setFrame(m++, fa);
        }
        (d[d.length] = l), (e = Math.max(e, l.frames[l.getFrameCount() - 1]));
      }
      c.animations[c.animations.length] = new spine.Animation(a, d, e);
    },
    readCurve: function (a, b, c) {
      var d = c.curve;
      d ? ("stepped" == d ? a.curves.setStepped(b) : d instanceof Array && a.curves.setCurve(b, d[0], d[1], d[2], d[3])) : a.curves.setLinear(b);
    },
    toColor: function (a, b) {
      if (8 != a.length) throw "Color hexidecimal length must be 8, recieved: " + a;
      return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255;
    },
    getFloatArray: function (a, b, c) {
      var d = a[b],
        e = new spine.Float32Array(d.length),
        f = 0,
        g = d.length;
      if (1 == c) for (; g > f; f++) e[f] = d[f];
      else for (; g > f; f++) e[f] = d[f] * c;
      return e;
    },
    getUint32Array: function (a, b) {
      for (var c = a[b], d = new spine.Uint32Array(c.length), e = 0, f = c.length; f > e; e++) d[e] = 0 | c[e];
      return d;
    },
    getUint16Array: function (a, b) {
      for (var c = a[b], d = new spine.Uint16Array(c.length), e = 0, f = c.length; f > e; e++) d[e] = 0 | c[e];
      return d;
    },
  }),
  (spine.Atlas = function (a, b) {
    (this.textureLoader = b), (this.pages = []), (this.regions = []);
    var c = new spine.AtlasReader(a),
      d = [];
    d.length = 4;
    for (var e = null; ; ) {
      var f = c.readLine();
      if (null === f) break;
      if (((f = c.trim(f)), f.length))
        if (e) {
          var g = new spine.AtlasRegion();
          (g.name = f), (g.page = e), (g.rotate = "true" == c.readValue()), c.readTuple(d);
          var h = parseInt(d[0]),
            i = parseInt(d[1]);
          c.readTuple(d);
          var j = parseInt(d[0]),
            k = parseInt(d[1]);
          (g.u = h / e.width),
            (g.v = i / e.height),
            g.rotate ? ((g.u2 = (h + k) / e.width), (g.v2 = (i + j) / e.height)) : ((g.u2 = (h + j) / e.width), (g.v2 = (i + k) / e.height)),
            (g.x = h),
            (g.y = i),
            (g.width = Math.abs(j)),
            (g.height = Math.abs(k)),
            4 == c.readTuple(d) && ((g.splits = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])]), 4 == c.readTuple(d) && ((g.pads = [parseInt(d[0]), parseInt(d[1]), parseInt(d[2]), parseInt(d[3])]), c.readTuple(d))),
            (g.originalWidth = parseInt(d[0])),
            (g.originalHeight = parseInt(d[1])),
            c.readTuple(d),
            (g.offsetX = parseInt(d[0])),
            (g.offsetY = parseInt(d[1])),
            (g.index = parseInt(c.readValue())),
            (this.regions[this.regions.length] = g);
        } else {
          (e = new spine.AtlasPage()),
            (e.name = f),
            2 == c.readTuple(d) && ((e.width = parseInt(d[0])), (e.height = parseInt(d[1])), c.readTuple(d)),
            (e.format = spine.Atlas.Format[d[0]]),
            c.readTuple(d),
            (e.minFilter = spine.Atlas.TextureFilter[d[0]]),
            (e.magFilter = spine.Atlas.TextureFilter[d[1]]);
          var l = c.readValue();
          (e.uWrap = spine.Atlas.TextureWrap.clampToEdge),
            (e.vWrap = spine.Atlas.TextureWrap.clampToEdge),
            "x" == l ? (e.uWrap = spine.Atlas.TextureWrap.repeat) : "y" == l ? (e.vWrap = spine.Atlas.TextureWrap.repeat) : "xy" == l && (e.uWrap = e.vWrap = spine.Atlas.TextureWrap.repeat),
            b.load(e, f, this),
            (this.pages[this.pages.length] = e);
        }
      else e = null;
    }
  }),
  (spine.Atlas.prototype = {
    findRegion: function (a) {
      for (var b = this.regions, c = 0, d = b.length; d > c; c++) if (b[c].name == a) return b[c];
      return null;
    },
    dispose: function () {
      for (var a = this.pages, b = 0, c = a.length; c > b; b++) this.textureLoader.unload(a[b].rendererObject);
    },
    updateUVs: function (a) {
      for (var b = this.regions, c = 0, d = b.length; d > c; c++) {
        var e = b[c];
        e.page == a && ((e.u = e.x / a.width), (e.v = e.y / a.height), e.rotate ? ((e.u2 = (e.x + e.height) / a.width), (e.v2 = (e.y + e.width) / a.height)) : ((e.u2 = (e.x + e.width) / a.width), (e.v2 = (e.y + e.height) / a.height)));
      }
    },
  }),
  (spine.Atlas.Format = { alpha: 0, intensity: 1, luminanceAlpha: 2, rgb565: 3, rgba4444: 4, rgb888: 5, rgba8888: 6 }),
  (spine.Atlas.TextureFilter = { nearest: 0, linear: 1, mipMap: 2, mipMapNearestNearest: 3, mipMapLinearNearest: 4, mipMapNearestLinear: 5, mipMapLinearLinear: 6 }),
  (spine.Atlas.TextureWrap = { mirroredRepeat: 0, clampToEdge: 1, repeat: 2 }),
  (spine.AtlasPage = function () {}),
  (spine.AtlasPage.prototype = { name: null, format: null, minFilter: null, magFilter: null, uWrap: null, vWrap: null, rendererObject: null, width: 0, height: 0 }),
  (spine.AtlasRegion = function () {}),
  (spine.AtlasRegion.prototype = { page: null, name: null, x: 0, y: 0, width: 0, height: 0, u: 0, v: 0, u2: 0, v2: 0, offsetX: 0, offsetY: 0, originalWidth: 0, originalHeight: 0, index: 0, rotate: !1, splits: null, pads: null }),
  (spine.AtlasReader = function (a) {
    this.lines = a.split(/\r\n|\r|\n/);
  }),
  (spine.AtlasReader.prototype = {
    index: 0,
    trim: function (a) {
      return a.replace(/^\s+|\s+$/g, "");
    },
    readLine: function () {
      return this.index >= this.lines.length ? null : this.lines[this.index++];
    },
    readValue: function () {
      var a = this.readLine(),
        b = a.indexOf(":");
      if (-1 == b) throw "Invalid line: " + a;
      return this.trim(a.substring(b + 1));
    },
    readTuple: function (a) {
      var b = this.readLine(),
        c = b.indexOf(":");
      if (-1 == c) throw "Invalid line: " + b;
      for (var d = 0, e = c + 1; 3 > d; d++) {
        var f = b.indexOf(",", e);
        if (-1 == f) break;
        (a[d] = this.trim(b.substr(e, f - e))), (e = f + 1);
      }
      return (a[d] = this.trim(b.substring(e))), d + 1;
    },
  }),
  (spine.AtlasAttachmentLoader = function (a) {
    this.atlas = a;
  }),
  (spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function (a, b, c) {
      var d = this.atlas.findRegion(c);
      if (!d) throw "Region not found in atlas: " + c + " (region attachment: " + b + ")";
      var e = new spine.RegionAttachment(b);
      return (
        (e.rendererObject = d),
        e.setUVs(d.u, d.v, d.u2, d.v2, d.rotate),
        (e.regionOffsetX = d.offsetX),
        (e.regionOffsetY = d.offsetY),
        (e.regionWidth = d.width),
        (e.regionHeight = d.height),
        (e.regionOriginalWidth = d.originalWidth),
        (e.regionOriginalHeight = d.originalHeight),
        e
      );
    },
    newMeshAttachment: function (a, b, c) {
      var d = this.atlas.findRegion(c);
      if (!d) throw "Region not found in atlas: " + c + " (mesh attachment: " + b + ")";
      var e = new spine.MeshAttachment(b);
      return (
        (e.rendererObject = d),
        (e.regionU = d.u),
        (e.regionV = d.v),
        (e.regionU2 = d.u2),
        (e.regionV2 = d.v2),
        (e.regionRotate = d.rotate),
        (e.regionOffsetX = d.offsetX),
        (e.regionOffsetY = d.offsetY),
        (e.regionWidth = d.width),
        (e.regionHeight = d.height),
        (e.regionOriginalWidth = d.originalWidth),
        (e.regionOriginalHeight = d.originalHeight),
        e
      );
    },
    newWeightedMeshAttachment: function (a, b, c) {
      var d = this.atlas.findRegion(c);
      if (!d) throw "Region not found in atlas: " + c + " (weighted mesh attachment: " + b + ")";
      var e = new spine.WeightedMeshAttachment(b);
      return (
        (e.rendererObject = d),
        (e.regionU = d.u),
        (e.regionV = d.v),
        (e.regionU2 = d.u2),
        (e.regionV2 = d.v2),
        (e.regionRotate = d.rotate),
        (e.regionOffsetX = d.offsetX),
        (e.regionOffsetY = d.offsetY),
        (e.regionWidth = d.width),
        (e.regionHeight = d.height),
        (e.regionOriginalWidth = d.originalWidth),
        (e.regionOriginalHeight = d.originalHeight),
        e
      );
    },
    newBoundingBoxAttachment: function (a, b) {
      return new spine.BoundingBoxAttachment(b);
    },
  }),
  (spine.SkeletonBounds = function () {
    (this.polygonPool = []), (this.polygons = []), (this.boundingBoxes = []);
  }),
  (spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function (a, b) {
      var c = a.slots,
        d = c.length,
        e = a.x,
        f = a.y,
        g = this.boundingBoxes,
        h = this.polygonPool,
        i = this.polygons;
      g.length = 0;
      for (var j = 0, k = i.length; k > j; j++) h[h.length] = i[j];
      i.length = 0;
      for (var j = 0; d > j; j++) {
        var l = c[j],
          m = l.attachment;
        if (m.type == spine.AttachmentType.boundingbox) {
          g[g.length] = m;
          var n,
            o = h.length;
          o > 0 ? ((n = h[o - 1]), h.splice(o - 1, 1)) : (n = new spine.Float32Array()), (i[i.length] = n), (n.length = m.vertices.length), m.computeWorldVertices(e, f, l.bone, n);
        }
      }
      b && this.aabbCompute();
    },
    aabbCompute: function () {
      for (var a = this.polygons, b = Number.MAX_VALUE, c = Number.MAX_VALUE, d = -Number.MAX_VALUE, e = -Number.MAX_VALUE, f = 0, g = a.length; g > f; f++)
        for (var h = a[f], i = 0, j = h.length; j > i; i += 2) {
          var k = h[i],
            l = h[i + 1];
          (b = Math.min(b, k)), (c = Math.min(c, l)), (d = Math.max(d, k)), (e = Math.max(e, l));
        }
      (this.minX = b), (this.minY = c), (this.maxX = d), (this.maxY = e);
    },
    aabbContainsPoint: function (a, b) {
      return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY;
    },
    aabbIntersectsSegment: function (a, b, c, d) {
      var e = this.minX,
        f = this.minY,
        g = this.maxX,
        h = this.maxY;
      if ((e >= a && e >= c) || (f >= b && f >= d) || (a >= g && c >= g) || (b >= h && d >= h)) return !1;
      var i = (d - b) / (c - a),
        j = i * (e - a) + b;
      if (j > f && h > j) return !0;
      if (((j = i * (g - a) + b), j > f && h > j)) return !0;
      var k = (f - b) / i + a;
      return (k > e && g > k) || ((k = (h - b) / i + a), k > e && g > k);
    },
    aabbIntersectsSkeleton: function (a) {
      return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY;
    },
    containsPoint: function (a, b) {
      for (var c = this.polygons, d = 0, e = c.length; e > d; d++) if (this.polygonContainsPoint(c[d], a, b)) return this.boundingBoxes[d];
      return null;
    },
    intersectsSegment: function (a, b, c, d) {
      for (var e = this.polygons, f = 0, g = e.length; g > f; f++) if (e[f].intersectsSegment(a, b, c, d)) return this.boundingBoxes[f];
      return null;
    },
    polygonContainsPoint: function (a, b, c) {
      for (var d = a.length, e = d - 2, f = !1, g = 0; d > g; g += 2) {
        var h = a[g + 1],
          i = a[e + 1];
        if ((c > h && i >= c) || (c > i && h >= c)) {
          var j = a[g];
          j + ((c - h) / (i - h)) * (a[e] - j) < b && (f = !f);
        }
        e = g;
      }
      return f;
    },
    polygonIntersectsSegment: function (a, b, c, d, e) {
      for (var f = a.length, g = b - d, h = c - e, i = b * e - c * d, j = a[f - 2], k = a[f - 1], l = 0; f > l; l += 2) {
        var m = a[l],
          n = a[l + 1],
          o = j * n - k * m,
          p = j - m,
          q = k - n,
          r = g * q - h * p,
          s = (i * p - g * o) / r;
        if (((s >= j && m >= s) || (s >= m && j >= s)) && ((s >= b && d >= s) || (s >= d && b >= s))) {
          var t = (i * q - h * o) / r;
          if (((t >= k && n >= t) || (t >= n && k >= t)) && ((t >= c && e >= t) || (t >= e && c >= t))) return !0;
        }
        (j = m), (k = n);
      }
      return !1;
    },
    getPolygon: function (a) {
      var b = this.boundingBoxes.indexOf(a);
      return -1 == b ? null : this.polygons[b];
    },
    getWidth: function () {
      return this.maxX - this.minX;
    },
    getHeight: function () {
      return this.maxY - this.minY;
    },
  });
var __extends =
    (this && this.__extends) ||
    function (a, b) {
      function c() {
        this.constructor = a;
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      a.prototype = null === b ? Object.create(b) : ((c.prototype = b.prototype), new c());
    },
  Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (b) {
      function c(a, c) {
        b.call(this, a, c), this.addSpineCache(), this.addSpineFactory(), this.addSpineLoader();
      }
      return (
        __extends(c, b),
        (c.prototype.addSpineLoader = function () {
          Phaser.Loader.prototype.spine = function (a, b, c) {
            var d = this,
              e = a + "Atlas",
              f = { atlas: e, basePath: "" === b.substring(0, b.lastIndexOf("/")) ? "." : b.substring(0, b.lastIndexOf("/")), variants: void 0 };
            void 0 === c ? (c = [""]) : (f.variants = c),
              c.forEach(function (a) {
                d.onFileComplete.add(function (b, c) {
                  c === e &&
                    new spine.Atlas(d.game.cache.getText(c), {
                      load: function (b, c, e) {
                        d.image(c, f.basePath + "/" + c.substr(0, c.lastIndexOf(".")) + a + ".png");
                      },
                    });
                }),
                  d.text(e, b.substr(0, b.lastIndexOf(".")) + a + ".atlas");
              }),
              this.json(a, b),
              this.game.cache.addSpine(a, f);
          };
        }),
        (c.prototype.addSpineFactory = function () {
          Phaser.GameObjectFactory.prototype.spine = function (b, c, d, e, f) {
            void 0 === f && (f = this.world);
            var g = new a.Spine(this.game, d, e);
            return g.setToSetupPose(), (g.position.x = b), (g.position.y = c), f.add(g);
          };
        }),
        (c.prototype.addSpineCache = function () {
          (Phaser.Cache.prototype.spine = {}),
            (Phaser.Cache.prototype.addSpine = function (a, b) {
              this.spine[a] = b;
            }),
            (Phaser.Cache.prototype.getSpine = function (a) {
              return !this.spine.hasOwnProperty(a), this.spine[a];
            });
        }),
        (c.RESOLUTION_REGEXP = /@(.+)x/),
        c
      );
    })(Phaser.Plugin);
    b.Spine = c;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {})),
  (PIXI.Strip.prototype.postUpdate = function () {}),
  (spine.Bone.yDown = !0);
var Fabrique;
!(function (a) {
  var b = (function (b) {
    function c(c, d, e) {
      b.call(this, c), (this.imageScale = 1);
      var f = this.game.cache.getSpine(d);
      void 0 !== e && -1 !== f.variants.indexOf(e) ? (this.imageScale = this.getScaleFromVariant(e)) : f.variants && f.variants.length >= 1 && (this.imageScale = this.getScaleFromVariant(f.variants[0]));
      var g = new a.SpineTextureLoader(c),
        h = new spine.Atlas(c.cache.getText(f.atlas), g),
        i = new spine.AtlasAttachmentLoader(h),
        j = new spine.SkeletonJson(i);
      if (((this.skeletonData = j.readSkeletonData(c.cache.getJSON(d))), !this.skeletonData)) throw new Error("Spine data must be preloaded using Loader.spine");
      (this.skeleton = new spine.Skeleton(this.skeletonData)),
        this.skeleton.updateWorldTransform(),
        (this.stateData = new spine.AnimationStateData(this.skeletonData)),
        (this.state = new spine.AnimationState(this.stateData)),
        (this.slotContainers = []);
      for (var k = 0, l = this.skeleton.slots.length; l > k; k++) {
        var m = this.skeleton.slots[k],
          n = m.attachment,
          o = new Phaser.Group(c);
        if ((this.slotContainers.push(o), this.add(o), n instanceof spine.RegionAttachment)) {
          var p = n.rendererObject.name,
            q = this.createSprite(m, n);
          (m.currentSprite = q), (m.currentSpriteName = p), o.add(q);
        } else {
          if (!(n instanceof spine.WeightedMeshAttachment)) continue;
          var r = this.createMesh(m, n);
          (m.currentMesh = r), (m.currentMeshName = n.name), o.add(r);
        }
      }
      this.autoUpdate = !0;
    }
    return (
      __extends(c, b),
      Object.defineProperty(c.prototype, "autoUpdate", {
        get: function () {
          return this.updateTransform === a.Spine.prototype.autoUpdateTransform;
        },
        set: function (b) {
          this.updateTransform = b ? a.Spine.prototype.autoUpdateTransform : PIXI.DisplayObjectContainer.prototype.updateTransform;
        },
        enumerable: !0,
        configurable: !0,
      }),
      (c.prototype.getScaleFromVariant = function (b) {
        var c = a.Plugins.Spine.RESOLUTION_REGEXP.exec(b);
        return c ? parseFloat(c[1]) : 1;
      }),
      (c.prototype.update = function (a) {
        if (void 0 !== a) {
          this.state.update(a), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
          for (var b = this.skeleton.drawOrder, c = this.skeleton.slots, d = 0, e = b.length; e > d; d++) void 0 !== b[d].currentSprite && (this.children[d] = b[d].currentSprite.parent);
          for (var d = 0, e = c.length; e > d; d++) {
            var f = c[d],
              g = f.attachment,
              h = this.slotContainers[d];
            if (g) {
              var i = g.type;
              if (i === spine.AttachmentType.region) {
                if (g.rendererObject && (!f.currentSpriteName || f.currentSpriteName !== g.name)) {
                  var j = g.rendererObject.name;
                  if ((void 0 !== f.currentSprite && (f.currentSprite.visible = !1), (f.sprites = f.sprites || {}), void 0 !== f.sprites[j])) f.sprites[j].visible = !0;
                  else {
                    var k = this.createSprite(f, g);
                    h.add(k);
                  }
                  (f.currentSprite = f.sprites[j]), (f.currentSpriteName = j);
                }
                var l = f.bone;
                (h.position.x = g.x * l.a + g.y * l.b + l.worldX),
                  (h.position.y = g.x * l.c + g.y * l.d + l.worldY),
                  (h.scale.x = l.getWorldScaleX()),
                  (h.scale.y = l.getWorldScaleY()),
                  (h.rotation = ((l.getWorldRotationX() - g.rotation) * Math.PI) / 180),
                  (l.getWorldScaleY() < 0 || l.getWorldScaleX() < 0) && ((h.scale.y = -h.scale.y), (h.scale.x = -h.scale.x), (h.rotation = -h.rotation)),
                  (f.currentSprite.blendMode = f.blendMode),
                  (f.currentSprite.tint = PIXI.rgb2hex([f.r, f.g, f.b]));
              } else {
                if (i !== spine.AttachmentType.weightedmesh && i !== spine.AttachmentType.weightedlinkedmesh) {
                  h.visible = !1;
                  continue;
                }
                if (!f.currentMeshName || f.currentMeshName !== g.name) {
                  var m = g.name;
                  if ((void 0 !== f.currentMesh && (f.currentMesh.visible = !1), (f.meshes = f.meshes || {}), void 0 !== f.meshes[m])) f.meshes[m].visible = !0;
                  else {
                    var n = this.createMesh(f, g);
                    h.add(n);
                  }
                  (f.currentMesh = f.meshes[m]), (f.currentMeshName = m);
                }
                g.computeWorldVertices(f.bone.skeleton.x, f.bone.skeleton.y, f, f.currentMesh.vertices);
              }
              (h.visible = !0), (h.alpha = f.a);
            } else h.visible = !1;
          }
        }
      }),
      (c.prototype.destroy = function (a, c) {
        b.prototype.destroy.call(this, !0, c);
      }),
      (c.prototype.autoUpdateTransform = function () {
        this.lastTime = this.lastTime || Date.now();
        var a = 0.001 * (Date.now() - this.lastTime);
        (this.lastTime = Date.now()), this.update(a), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
      }),
      (c.prototype.createSprite = function (a, b) {
        var c = b.rendererObject,
          d = c.page.rendererObject,
          e = new PIXI.Rectangle(c.x, c.y, c.rotate ? c.height : c.width, c.rotate ? c.width : c.height),
          f = new PIXI.Texture(d, e),
          g = new Phaser.Sprite(this.game, 0, 0, f),
          h = c.rotate ? 0.5 * Math.PI : 0;
        if (
          ((g.scale.x = ((c.width / c.originalWidth) * b.scaleX) / this.imageScale),
          (g.scale.y = ((c.height / c.originalHeight) * b.scaleY) / this.imageScale),
          (g.rotation = h),
          (g.anchor.x = (0.5 * c.originalWidth - c.offsetX) / c.width),
          (g.anchor.y = 1 - (0.5 * c.originalHeight - c.offsetY) / c.height),
          (g.alpha = b.a),
          c.rotate)
        ) {
          var i = g.scale.x;
          (g.scale.x = g.scale.y), (g.scale.y = i);
        }
        return (a.sprites = a.sprites || {}), (a.sprites[c.name] = g), g;
      }),
      (c.prototype.createMesh = function (a, b) {
        var c = b.rendererObject,
          d = c.page.rendererObject,
          e = new PIXI.Texture(d),
          f = new PIXI.Strip(e);
        return (f.drawMode = 1), (f.canvasPadding = 1.5), (f.vertices = new spine.Float32Array(b.uvs.length)), (f.uvs = b.uvs), (f.indices = b.triangles), (f.alpha = b.a), (a.meshes = a.meshes || {}), (a.meshes[b.name] = f), f;
      }),
      (c.prototype.setMixByName = function (a, b, c) {
        this.stateData.setMixByName(a, b, c);
      }),
      (c.prototype.setAnimationByName = function (a, b, c) {
        void 0 === c && (c = !1);
        var d = this.state.data.skeletonData.findAnimation(b);
        return d ? this.state.setAnimation(a, d, c) : null;
      }),
      (c.prototype.addAnimationByName = function (a, b, c, d) {
        void 0 === c && (c = !1), void 0 === d && (d = 0);
        var e = this.state.data.skeletonData.findAnimation(b);
        return e ? this.state.addAnimation(a, e, c, d) : null;
      }),
      (c.prototype.setSkinByName = function (a) {
        var b = this.skeleton.data.findSkin(a);
        b && this.skeleton.setSkin(b);
      }),
      (c.prototype.setSkin = function (a) {
        this.skeleton.setSkin(a);
      }),
      (c.prototype.setToSetupPose = function () {
        this.skeleton.setToSetupPose();
      }),
      (c.prototype.createCombinedSkin = function (a) {
        for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
        if (0 !== b.length) {
          for (var d = new spine.Skin(a), e = 0; e < b.length; e++) {
            var f = b[e],
              g = this.skeleton.data.findSkin(f);
            if (!g) return;
            for (var h in g.attachments) {
              var i = h.split(":"),
                j = i[0],
                k = i[1],
                l = g.attachments[h];
              if (void 0 === j || void 0 === k) return;
              void 0 === d.getAttachment(j, k) && d.addAttachment(j, k, l);
            }
          }
          return this.skeleton.data.skins.push(d), d;
        }
      }),
      c
    );
  })(Phaser.Group);
  a.Spine = b;
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b = (function () {
    function a(a) {
      (this.load = function (a, b, c) {
        var d = this.game.make.image(0, 0, b);
        a.rendererObject = d.texture.baseTexture;
      }),
        (this.unload = function (a) {
          a.destroy();
        }),
        (this.game = a);
    }
    return a;
  })();
  a.SpineTextureLoader = b;
})(Fabrique || (Fabrique = {}));
var __extends =
    (this && this.__extends) ||
    function (a, b) {
      function c() {
        this.constructor = a;
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      a.prototype = null === b ? Object.create(b) : ((c.prototype = b.prototype), new c());
    },
  Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    !(function (a) {
      (a[(a.start = 0)] = "start"), (a[(a.firstQuartile = 1)] = "firstQuartile"), (a[(a.midPoint = 2)] = "midPoint"), (a[(a.thirdQuartile = 3)] = "thirdQuartile"), (a[(a.complete = 4)] = "complete");
    })(b.AdEvent || (b.AdEvent = {}));
    var c =
      (b.AdEvent,
      (function (b) {
        function c(a, c) {
          b.call(this, a, c),
            (this.onContentPaused = new Phaser.Signal()),
            (this.onContentResumed = new Phaser.Signal()),
            (this.onAdProgression = new Phaser.Signal()),
            (this.onAdsDisabled = new Phaser.Signal()),
            (this.onAdClicked = new Phaser.Signal()),
            (this.onAdRewardGranted = new Phaser.Signal()),
            (this.provider = null),
            (this.wasMuted = !1),
            Object.defineProperty(a, "ads", { value: this });
        }
        return (
          __extends(c, b),
          (c.prototype.setAdProvider = function (a) {
            var b = this;
            (this.provider = a),
              this.provider.setManager(this),
              this.onContentResumed.add(function () {
                b.wasMuted || (b.game.sound.mute = !1);
              });
          }),
          (c.prototype.showAd = function () {
            for (var b = [], c = 0; c < arguments.length; c++) b[c - 0] = arguments[c];
            if (null === this.provider) throw new Error("Can not request an ad without an provider, please attach an ad provider!");
            b[0] && b[0] !== a.AdProvider.CocoonAdType.banner && ((this.wasMuted = this.game.sound.mute), (this.game.sound.mute = !0)), this.provider.showAd.apply(this.provider, b);
          }),
          (c.prototype.preloadAd = function () {
            for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
            if (null === this.provider) throw new Error("Can not preload an ad without an provider, please attach an ad provider!");
            this.provider.preloadAd.apply(this.provider, a);
          }),
          (c.prototype.destroyAd = function () {
            for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
            if (null === this.provider) throw new Error("Can not destroy an ad without an provider, please attach an ad provider!");
            this.provider.destroyAd.apply(this.provider, a);
          }),
          (c.prototype.hideAd = function () {
            for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
            if (null === this.provider) throw new Error("Can not hide an ad without an provider, please attach an ad provider!");
            this.wasMuted || (this.game.sound.mute = !1), this.provider.hideAd.apply(this.provider, a);
          }),
          (c.prototype.adsEnabled = function () {
            return this.provider.adsEnabled;
          }),
          c
        );
      })(Phaser.Plugin));
    b.AdManager = c;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    !(function (a) {
      (a[(a.AdMob = 0)] = "AdMob"), (a[(a.MoPub = 1)] = "MoPub"), (a[(a.Chartboost = 2)] = "Chartboost"), (a[(a.Heyzap = 3)] = "Heyzap");
    })(a.CocoonProvider || (a.CocoonProvider = {}));
    var b = a.CocoonProvider;
    !(function (a) {
      (a[(a.banner = 0)] = "banner"), (a[(a.interstitial = 1)] = "interstitial"), (a[(a.insentive = 2)] = "insentive");
    })(a.CocoonAdType || (a.CocoonAdType = {}));
    var c = a.CocoonAdType,
      d = (function () {
        function a(a, c, d) {
          if (
            ((this.adsEnabled = !1),
            (this.banner = null),
            (this.bannerShowable = !1),
            (this.interstitial = null),
            (this.interstitialShowable = !1),
            (this.insentive = null),
            (this.insentiveShowable = !1),
            (a.device.cordova || a.device.crosswalk) && Cocoon && Cocoon.Ad)
          ) {
            switch (((this.adsEnabled = !0), c)) {
              default:
              case b.AdMob:
                this.cocoonProvider = Cocoon.Ad.AdMob;
                break;
              case b.Chartboost:
                this.cocoonProvider = Cocoon.Ad.Chartboost;
                break;
              case b.Heyzap:
                this.cocoonProvider = Cocoon.Ad.Heyzap;
                break;
              case b.MoPub:
                this.cocoonProvider = Cocoon.Ad.MoPub;
            }
            this.cocoonProvider.configure(d);
          }
        }
        return (
          (a.prototype.setManager = function (a) {
            this.adManager = a;
          }),
          (a.prototype.showAd = function (a) {
            if (!this.adsEnabled) return void this.adManager.onContentResumed.dispatch();
            if (a === c.banner) {
              if (!this.bannerShowable || null === this.banner) return void this.adManager.onContentResumed.dispatch(c.banner);
              this.banner.show();
            }
            if (a === c.interstitial) {
              if (!this.interstitialShowable || null === this.interstitial) return void this.adManager.onContentResumed.dispatch(c.interstitial);
              this.interstitial.show();
            }
            if (a === c.insentive) {
              if (!this.interstitialShowable || null === this.insentive) return void this.adManager.onContentResumed.dispatch(c.insentive);
              this.insentive.show();
            }
          }),
          (a.prototype.preloadAd = function (a, b, d) {
            var e = this;
            this.adsEnabled &&
              (this.destroyAd(a),
              a === c.banner &&
                ((this.banner = this.cocoonProvider.createBanner(b)),
                d && this.banner.setLayout(d),
                this.banner.on("load", function () {
                  e.bannerShowable = !0;
                }),
                this.banner.on("fail", function () {
                  (e.bannerShowable = !1), (e.banner = null);
                }),
                this.banner.on("click", function () {
                  e.adManager.onAdClicked.dispatch(c.banner);
                }),
                this.banner.on("show", function () {}),
                this.banner.on("dismiss", function () {}),
                this.banner.load()),
              a === c.interstitial &&
                ((this.interstitial = this.cocoonProvider.createInterstitial(b)),
                this.interstitial.on("load", function () {
                  e.interstitialShowable = !0;
                }),
                this.interstitial.on("fail", function () {
                  (e.interstitialShowable = !1), (e.interstitial = null);
                }),
                this.interstitial.on("click", function () {
                  e.adManager.onAdClicked.dispatch(c.interstitial);
                }),
                this.interstitial.on("show", function () {
                  e.adManager.onContentPaused.dispatch(c.interstitial);
                }),
                this.interstitial.on("dismiss", function () {
                  e.adManager.onContentResumed.dispatch(c.interstitial), (e.interstitialShowable = !1), (e.interstitial = null);
                }),
                this.interstitial.load()),
              a === c.insentive &&
                ((this.insentive = this.cocoonProvider.createRewardedVideo(b)),
                this.insentive.on("load", function () {
                  e.insentiveShowable = !0;
                }),
                this.insentive.on("fail", function () {
                  (e.insentiveShowable = !1), (e.insentive = null);
                }),
                this.insentive.on("click", function () {
                  e.adManager.onAdClicked.dispatch(c.insentive);
                }),
                this.insentive.on("show", function () {
                  e.adManager.onContentPaused.dispatch(c.insentive);
                }),
                this.insentive.on("dismiss", function () {
                  e.adManager.onContentResumed.dispatch(c.insentive), (e.insentiveShowable = !1), (e.insentive = null);
                }),
                this.insentive.on("reward", function () {
                  e.adManager.onAdRewardGranted.dispatch(c.insentive), (e.insentiveShowable = !1), (e.insentive = null);
                }),
                this.insentive.load()));
          }),
          (a.prototype.destroyAd = function (a) {
            this.adsEnabled &&
              (a === c.banner && null !== this.banner && (this.cocoonProvider.releaseBanner(this.banner), (this.banner = null), (this.bannerShowable = !1)),
              a === c.interstitial && null !== this.interstitial && (this.cocoonProvider.releaseInterstitial(this.interstitial), (this.interstitial = null), (this.interstitialShowable = !1)));
          }),
          (a.prototype.hideAd = function (a) {
            this.adsEnabled &&
              (a === c.interstitial && null !== this.interstitial && this.interstitial.hide(), a === c.banner && null !== this.banner && this.banner.hide(), a === c.insentive && null !== this.insentive && this.insentive.hide());
          }),
          a
        );
      })();
    a.CocoonAds = d;
  })((b = a.AdProvider || (a.AdProvider = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    !(function (a) {
      (a[(a.Interstitial = 0)] = "Interstitial"), (a[(a.Video = 1)] = "Video"), (a[(a.Rewarded = 2)] = "Rewarded"), (a[(a.Banner = 3)] = "Banner");
    })(a.HeyzapAdTypes || (a.HeyzapAdTypes = {}));
    var b = a.HeyzapAdTypes,
      c = (function () {
        function a(a, b) {
          var c = this;
          (this.adsEnabled = !1),
            (a.device.cordova || a.device.crosswalk) &&
              ((this.adsEnabled = !0),
              HeyzapAds.start(b).then(
                function () {},
                function (a) {
                  c.adsEnabled = !1;
                }
              ));
        }
        return (
          (a.prototype.setManager = function (a) {
            this.adManager = a;
          }),
          (a.prototype.showAd = function (a, c) {
            var d = this;
            switch ((this.adsEnabled || this.adManager.onContentResumed.dispatch(), a)) {
              case b.Interstitial:
                HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.HIDE, function () {
                  d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.HIDE);
                }),
                  HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.SHOW_FAILED, function () {
                    d.adManager.onContentResumed.dispatch(HeyzapAds.InterstitialAd.Events.SHOW_FAILED);
                  }),
                  HeyzapAds.InterstitialAd.addEventListener(HeyzapAds.InterstitialAd.Events.CLICKED, function () {
                    d.adManager.onAdClicked.dispatch(HeyzapAds.InterstitialAd.Events.CLICKED);
                  }),
                  HeyzapAds.InterstitialAd.show().then(
                    function () {
                      d.adManager.onContentPaused.dispatch();
                    },
                    function (a) {
                      d.adManager.onContentResumed.dispatch();
                    }
                  );
                break;
              case b.Video:
                HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.HIDE, function () {
                  d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.HIDE);
                }),
                  HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.SHOW_FAILED, function () {
                    d.adManager.onContentResumed.dispatch(HeyzapAds.VideoAd.Events.SHOW_FAILED);
                  }),
                  HeyzapAds.VideoAd.addEventListener(HeyzapAds.VideoAd.Events.CLICKED, function () {
                    d.adManager.onAdClicked.dispatch(HeyzapAds.VideoAd.Events.CLICKED);
                  }),
                  HeyzapAds.VideoAd.show().then(
                    function () {
                      d.adManager.onContentPaused.dispatch();
                    },
                    function (a) {
                      d.adManager.onContentResumed.dispatch();
                    }
                  );
                break;
              case b.Rewarded:
                HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.HIDE, function () {
                  d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.HIDE);
                }),
                  HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED, function () {
                    d.adManager.onContentResumed.dispatch(HeyzapAds.IncentivizedAd.Events.SHOW_FAILED);
                  }),
                  HeyzapAds.IncentivizedAd.addEventListener(HeyzapAds.IncentivizedAd.Events.CLICKED, function () {
                    d.adManager.onAdClicked.dispatch(HeyzapAds.IncentivizedAd.Events.CLICKED);
                  }),
                  HeyzapAds.IncentivizedAd.show().then(
                    function () {
                      d.adManager.onContentPaused.dispatch();
                    },
                    function (a) {
                      d.adManager.onContentResumed.dispatch();
                    }
                  );
                break;
              case b.Banner:
                HeyzapAds.BannerAd.show(c).then(
                  function () {},
                  function (a) {}
                );
            }
          }),
          (a.prototype.preloadAd = function (a) {
            this.adsEnabled &&
              a === b.Rewarded &&
              HeyzapAds.IncentivizedAd.fetch().then(
                function () {},
                function (a) {}
              );
          }),
          (a.prototype.destroyAd = function (a) {
            this.adsEnabled &&
              a === b.Banner &&
              HeyzapAds.BannerAd.destroy().then(
                function () {},
                function (a) {}
              );
          }),
          (a.prototype.hideAd = function (a) {
            this.adsEnabled &&
              a === b.Banner &&
              HeyzapAds.BannerAd.hide().then(
                function () {},
                function (a) {}
              );
          }),
          a
        );
      })();
    a.CordovaHeyzap = c;
  })((b = a.AdProvider || (a.AdProvider = {})));
})(Fabrique || (Fabrique = {}));
var AdManager = Fabrique.Plugins.AdManager,
  Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function () {
      function b(a, b) {
        (this.adsManager = null),
          (this.googleEnabled = !1),
          (this.adsEnabled = !0),
          (this.adTagUrl = ""),
          (this.adRequested = !1),
          (this.adManager = null),
          (this.resizeListener = null),
          (this.adsEnabled = this.areAdsEnabled()),
          "undefined" != typeof google &&
            ((this.googleEnabled = !0),
            (this.gameContent = "string" == typeof a.parent ? document.getElementById(a.parent) : a.parent),
            (this.gameContent.style.position = "absolute"),
            (this.gameContent.style.width = "100%"),
            (this.adContent = this.gameContent.parentNode.appendChild(document.createElement("div"))),
            (this.adContent.id = "phaser-ad-container"),
            (this.adContent.style.position = "absolute"),
            (this.adContent.style.zIndex = "9999"),
            (this.adContent.style.display = "none"),
            (this.adContent.style.top = "0"),
            (this.adContent.style.left = "0"),
            (this.adContent.style.width = "100%"),
            (this.adContent.style.height = "100%"),
            (this.adContent.style.overflow = "hidden"),
            (this.adTagUrl = b),
            (this.game = a),
            (this.adDisplay = new google.ima.AdDisplayContainer(this.adContent)),
            google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED),
            google.ima.settings.setLocale("nl"),
            (this.adLoader = new google.ima.AdsLoader(this.adDisplay)),
            this.adLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdManagerLoader, !1, this),
            this.adLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this));
      }
      return (
        (b.prototype.setManager = function (a) {
          this.adManager = a;
        }),
        (b.prototype.showAd = function (a) {
          if (!this.adRequested) {
            if ((this.adsEnabled || this.adManager.onAdsDisabled.dispatch(!0), !this.googleEnabled)) return void this.onContentResumeRequested();
            this.adDisplay.initialize();
            var b = new google.ima.AdsRequest();
            b.adTagUrl = this.adTagUrl + this.parseCustomParams(a);
            var c = window.innerWidth,
              d = window.innerHeight;
            this.game.scale.isFullScreen && document.body.clientHeight < window.innerHeight && ((d = document.body.clientHeight), (c = document.body.clientWidth)),
              (b.linearAdSlotWidth = c),
              (b.linearAdSlotHeight = d),
              (b.nonLinearAdSlotWidth = c),
              (b.nonLinearAdSlotHeight = d),
              (b.forceNonLinearFullSlot = !0);
            try {
              (this.adRequested = !0), this.adLoader.requestAds(b);
            } catch (e) {
              this.onContentResumeRequested();
            }
          }
        }),
        (b.prototype.preloadAd = function () {}),
        (b.prototype.destroyAd = function () {}),
        (b.prototype.hideAd = function () {}),
        (b.prototype.onAdManagerLoader = function (a) {
          var b = this,
            c = new google.ima.AdsRenderingSettings();
          c.restoreCustomPlaybackStateOnAdBreakComplete = !0;
          var d = a.getAdsManager(this.gameContent, c);
          (this.adsManager = d),
            d.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, this.onContentPauseRequested, !1, this),
            d.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, this.onContentResumeRequested, !1, this),
            d.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError, !1, this),
            [
              google.ima.AdEvent.Type.ALL_ADS_COMPLETED,
              google.ima.AdEvent.Type.CLICK,
              google.ima.AdEvent.Type.COMPLETE,
              google.ima.AdEvent.Type.FIRST_QUARTILE,
              google.ima.AdEvent.Type.LOADED,
              google.ima.AdEvent.Type.MIDPOINT,
              google.ima.AdEvent.Type.PAUSED,
              google.ima.AdEvent.Type.STARTED,
              google.ima.AdEvent.Type.THIRD_QUARTILE,
            ].forEach(function (a) {
              d.addEventListener(a, b.onAdEvent, !1, b);
            });
          try {
            this.adContent.style.display = "block";
            var e = window.innerWidth,
              f = window.innerHeight;
            this.adsManager.init(e, f, google.ima.ViewMode.NORMAL),
              this.adsManager.start(),
              (this.resizeListener = function () {
                b.adsManager.resize(window.innerWidth, window.innerHeight, google.ima.ViewMode.NORMAL);
              }),
              window.addEventListener("resize", this.resizeListener);
          } catch (g) {
            this.onAdError(g);
          }
        }),
        (b.prototype.onAdEvent = function (b) {
          switch (b.type) {
            case google.ima.AdEvent.Type.CLICK:
              this.adManager.onAdClicked.dispatch();
              break;
            case google.ima.AdEvent.Type.LOADED:
              this.adRequested = !1;
              var c = b.getAd();
              c.isLinear() || this.onContentResumeRequested();
              break;
            case google.ima.AdEvent.Type.STARTED:
              this.adManager.onAdProgression.dispatch(a.Plugins.AdEvent.start);
              break;
            case google.ima.AdEvent.Type.FIRST_QUARTILE:
              this.adManager.onAdProgression.dispatch(a.Plugins.AdEvent.firstQuartile);
              break;
            case google.ima.AdEvent.Type.MIDPOINT:
              this.adManager.onAdProgression.dispatch(a.Plugins.AdEvent.midPoint);
              break;
            case google.ima.AdEvent.Type.THIRD_QUARTILE:
              this.adManager.onAdProgression.dispatch(a.Plugins.AdEvent.thirdQuartile);
              break;
            case google.ima.AdEvent.Type.COMPLETE:
              this.adManager.onAdProgression.dispatch(a.Plugins.AdEvent.complete);
              break;
            case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
              this.onContentResumeRequested();
          }
        }),
        (b.prototype.onAdError = function (a) {
          null !== this.adsManager && (this.adsManager.destroy(), (this.adsManager = null), null !== this.resizeListener && (window.removeEventListener("resize", this.resizeListener), (this.resizeListener = null))),
            this.adRequested && (this.adRequested = !1),
            this.onContentResumeRequested();
        }),
        (b.prototype.onContentPauseRequested = function () {
          this.adManager.onContentPaused.dispatch();
        }),
        (b.prototype.onContentResumeRequested = function () {
          return "undefined" == typeof google ? void this.adManager.onContentResumed.dispatch() : ((this.adContent.style.display = "none"), void this.adManager.onContentResumed.dispatch());
        }),
        (b.prototype.parseCustomParams = function (a) {
          if (void 0 !== a) {
            var b = "";
            for (var c in a)
              if (a.hasOwnProperty(c)) {
                b.length > 0 && (b += "&");
                var d = Array.isArray(a[c]) ? a[c].join(",") : a[c];
                b += c + "=" + d;
              }
            return "&cust_params=" + encodeURIComponent(b);
          }
          return "";
        }),
        (b.prototype.areAdsEnabled = function () {
          var a = document.createElement("div");
          (a.innerHTML = "&nbsp;"), (a.className = "adsbox"), document.body.appendChild(a);
          var b,
            c = function () {
              var b = !0;
              return 0 === a.offsetHeight && (b = !1), a.parentNode.removeChild(a), b;
            };
          return window.setTimeout((b = c()), 100), b;
        }),
        b
      );
    })();
    b.Ima3 = c;
  })((b = a.AdProvider || (a.AdProvider = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a(a) {
        void 0 === a && (a = ""), (this.namespace = ""), (this.forcePromises = !1), this.setNamespace(a);
      }
      return (
        Object.defineProperty(a.prototype, "length", {
          get: function () {
            return null !== this.getNameSpaceMatches() ? this.getNameSpaceMatches().length : 0;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (a.prototype.key = function (a) {
          var b = this.getNameSpaceMatches()[a],
            c = this.getCookiesForNameSpace()[b] || null;
          return this.forcePromises ? this.promisefy(c) : c;
        }),
        (a.prototype.getItem = function (a) {
          var b = this.getCookiesForNameSpace()[a] || null;
          return this.forcePromises ? this.promisefy(b) : b;
        }),
        (a.prototype.setItem = function (a, b) {
          if (((document.cookie = encodeURIComponent(this.namespace + a) + "=" + encodeURIComponent(b) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"), this.forcePromises)) return this.promisefy(null);
        }),
        (a.prototype.removeItem = function (a) {
          if (((document.cookie = encodeURIComponent(this.namespace + a) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"), this.forcePromises)) return this.promisefy(null);
        }),
        (a.prototype.clear = function () {
          var a = this.getCookiesForNameSpace();
          for (var b in a) a.hasOwnProperty(b) && this.removeItem(b);
          if (this.forcePromises) return this.promisefy(null);
        }),
        (a.prototype.setNamespace = function (a) {
          if ((a && ((this.namespace = a + ":"), (this.reg = new RegExp("^" + this.namespace + "[a-zA-Z0-9]*", "g"))), this.forcePromises)) return this.promisefy(a);
        }),
        (a.prototype.getNameSpaceMatches = function () {
          var a = this,
            b = decodeURIComponent(document.cookie).split("; ");
          return b.filter(function (b) {
            return null !== b.match(a.reg) && b.match(a.reg).length > 0;
          });
        }),
        (a.prototype.getCookiesForNameSpace = function () {
          var a = this,
            b = {};
          return (
            this.getNameSpaceMatches().forEach(function (c) {
              var d = c.replace(a.namespace, "").split("=");
              b[d[0]] = d[1];
            }),
            b
          );
        }),
        (a.prototype.promisefy = function (a) {
          return new Promise(function (b, c) {
            b(a);
          });
        }),
        a
      );
    })();
    a.CookieStorage = b;
  })((b = a.StorageAdapters || (a.StorageAdapters = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a() {
        (this.namespace = ""), (this.keys = []);
      }
      return (
        Object.defineProperty(a.prototype, "forcePromises", {
          get: function () {
            return !0;
          },
          set: function (a) {},
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(a.prototype, "length", {
          get: function () {
            return this.keys.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (a.prototype.key = function (a) {
          return this.promisefy(this.keys[a]);
        }),
        (a.prototype.getItem = function (a) {
          var b = this;
          return new Promise(function (c, d) {
            NativeStorage.getItem(
              b.namespace + a,
              function (a) {
                c(a);
              },
              function (a) {
                2 === a.code ? c(null) : d(a);
              }
            );
          });
        }),
        (a.prototype.setItem = function (a, b) {
          var c = this;
          return a.length < 1
            ? void 0
            : new Promise(function (d, e) {
                NativeStorage.setItem(
                  c.namespace + a,
                  b,
                  function () {
                    c.keys.indexOf(a) < 0 && (c.keys.push(a), c.save()), d(null);
                  },
                  function (a) {
                    e(a);
                  }
                );
              });
        }),
        (a.prototype.removeItem = function (a) {
          var b = this;
          return new Promise(function (c, d) {
            NativeStorage.remove(
              b.namespace + ":" + a,
              function () {
                var d = b.keys.indexOf(a);
                d >= 0 && (b.keys.splice(d, 1), b.save()), c(null);
              },
              function (a) {
                d(a);
              }
            );
          });
        }),
        (a.prototype.clear = function () {
          var a = this;
          return new Promise(function (b, c) {
            for (var d = 0, e = 0; e < a.keys.length; e++)
              NativeStorage.remove(
                a.namespace + ":" + a.keys[e],
                function () {
                  ++d >= a.keys.length && ((a.keys = []), a.save(), b(null));
                },
                function (a) {
                  c(a);
                }
              );
          });
        }),
        (a.prototype.setNamespace = function (a) {
          var b = this;
          return (
            void 0 === a && (a = ""),
            (this.namespace = a + ":"),
            (this.keys = []),
            new Promise(function (a, c) {
              b.load().then(a)["catch"](a);
            })
          );
        }),
        (a.prototype.promisefy = function (a) {
          return new Promise(function (b, c) {
            b(a);
          });
        }),
        (a.prototype.load = function () {
          var a = this;
          return new Promise(function (b, c) {
            NativeStorage.getItem(
              a.namespace,
              function (c) {
                (a.keys = JSON.parse(c)), b(null);
              },
              function (a) {
                c(a);
              }
            );
          });
        }),
        (a.prototype.save = function () {
          NativeStorage.setItem(
            this.namespace,
            JSON.stringify(this.keys),
            function () {},
            function (a) {}
          );
        }),
        a
      );
    })();
    a.CordovaStorage = b;
  })((b = a.StorageAdapters || (a.StorageAdapters = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function () {
      function b(a, b) {
        void 0 === a && (a = ""), void 0 === b && (b = "*"), (this.namespace = ""), (this.expectedOrigin = ""), (this.storageLength = 0), (this.enabled = !1), "" !== a && this.setNamespace(a), (this.expectedOrigin = b);
      }
      return (
        Object.defineProperty(b.prototype, "forcePromises", {
          get: function () {
            return !0;
          },
          set: function (a) {},
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(b.prototype, "length", {
          get: function () {
            return this.storageLength;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (b.prototype.init = function () {
          var b = this;
          return this.sendMessage({ command: a.StorageCommand.init }).then(function () {
            b.enabled = !0;
          });
        }),
        (b.prototype.key = function (b) {
          return this.sendMessage({ command: a.StorageCommand.key, value: b });
        }),
        (b.prototype.getItem = function (b) {
          return this.sendMessage({ command: a.StorageCommand.getItem, key: b });
        }),
        (b.prototype.setItem = function (b, c) {
          return this.sendMessage({ command: a.StorageCommand.setItem, key: b, value: c });
        }),
        (b.prototype.removeItem = function (b) {
          return this.sendMessage({ command: a.StorageCommand.removeItem, key: b });
        }),
        (b.prototype.clear = function () {
          return this.sendMessage({ command: a.StorageCommand.clear });
        }),
        (b.prototype.setNamespace = function (b) {
          return this.sendMessage({ command: a.StorageCommand.setNamespace, value: b });
        }),
        (b.prototype.sendMessage = function (b) {
          var c,
            d = this;
          b.command === a.StorageCommand.init && (c = !1);
          var e = new MessageChannel();
          return new Promise(function (f, g) {
            d.enabled || b.command === a.StorageCommand.init || g("Messaging not enabled!"),
              b.command === a.StorageCommand.init &&
                setTimeout(function () {
                  c || g("Unable to get a response in time");
                }, 1e3),
              (e.port1.onmessage = function (b) {
                var e = a.StorageUtils.validateMessage(b.data);
                switch ((e.command === a.StorageCommand.init && (c = !0), (void 0 !== e.status && "ok" === e.status) || g(e.value), void 0 !== e.length && (d.storageLength = e.length), e.command)) {
                  case a.StorageCommand.setNamespace:
                    d.namespace = e.value + ":";
                  case a.StorageCommand.getItem:
                  case a.StorageCommand.length:
                  case a.StorageCommand.key:
                    f(e.value);
                    break;
                  case a.StorageCommand.setItem:
                  case a.StorageCommand.removeItem:
                  case a.StorageCommand.clear:
                  case a.StorageCommand.init:
                    f(e.status);
                    break;
                  default:
                    g(e.value);
                }
              }),
              (d.enabled || b.command === a.StorageCommand.init) && window.parent.postMessage(b, d.expectedOrigin, [e.port2]);
          });
        }),
        b
      );
    })();
    b.IframeStorage = c;
  })((b = a.StorageAdapters || (a.StorageAdapters = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function () {
      function b(a) {
        void 0 === a && (a = ""), (this.namespace = ""), (this.forcePromises = !1), this.setNamespace(a);
      }
      return (
        Object.defineProperty(b.prototype, "length", {
          get: function () {
            var b = Object.keys(localStorage);
            return a.StorageUtils.nameSpaceKeyFilter(b, this.namespace).length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (b.prototype.key = function (b) {
          var c = Object.keys(localStorage),
            d = a.StorageUtils.nameSpaceKeyFilter(c, this.namespace),
            e = localStorage.getItem(d[b]);
          return this.forcePromises ? this.promisefy(e) : e;
        }),
        (b.prototype.getItem = function (a) {
          var b = localStorage.getItem(this.namespace + a);
          return this.forcePromises ? this.promisefy(b) : b;
        }),
        (b.prototype.setItem = function (a, b) {
          if ((localStorage.setItem(this.namespace + a, b), this.forcePromises)) return this.promisefy(null);
        }),
        (b.prototype.removeItem = function (a) {
          if ((localStorage.removeItem(this.namespace + a), this.forcePromises)) return this.promisefy(null);
        }),
        (b.prototype.clear = function () {
          for (var b = Object.keys(localStorage), c = a.StorageUtils.nameSpaceKeyFilter(b, this.namespace), d = 0; d < c.length; d++) localStorage.removeItem(c[d]);
          if (this.forcePromises) return this.promisefy(null);
        }),
        (b.prototype.setNamespace = function (a) {
          if ((a && (this.namespace = a + ":"), this.forcePromises)) return this.promisefy(a);
        }),
        (b.prototype.promisefy = function (a) {
          return new Promise(function (b, c) {
            b(a);
          });
        }),
        b
      );
    })();
    b.LocalStorage = c;
  })((b = a.StorageAdapters || (a.StorageAdapters = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function () {
      function b(c) {
        if (void 0 !== c) Object.defineProperty(c, "storage", { value: this });
        else {
          if (null !== b.instance) return b.instance;
          b.instance = this;
        }
        a.StorageUtils.isLocalStorageSupport() ? this.setAdapter(new a.StorageAdapters.LocalStorage()) : this.setAdapter(new a.StorageAdapters.CookieStorage());
      }
      return (
        (b.prototype.setAdapter = function (a) {
          this.storage = a;
        }),
        Object.defineProperty(b.prototype, "forcePromises", {
          get: function () {
            return this.storage.forcePromises;
          },
          set: function (a) {
            this.storage.forcePromises = a;
          },
          enumerable: !0,
          configurable: !0,
        }),
        Object.defineProperty(b.prototype, "length", {
          get: function () {
            return null === this.storage ? 0 : this.storage.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (b.prototype.setNamespace = function (a) {
          if (null !== this.storage) return this.storage.setNamespace(a);
        }),
        (b.prototype.key = function (a) {
          return null === this.storage ? "" : this.storage.key(a);
        }),
        (b.prototype.getItem = function (a) {
          return null === this.storage ? null : this.storage.getItem(a);
        }),
        (b.prototype.setItem = function (a, b) {
          if (null !== this.storage) return this.storage.setItem(a, b);
        }),
        (b.prototype.removeItem = function (a) {
          if (null !== this.storage) return this.storage.removeItem(a);
        }),
        (b.prototype.clear = function () {
          if (null !== this.storage) return this.storage.clear();
        }),
        (b.instance = null),
        b
      );
    })();
    b.SuperStorage = c;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {})),
  void 0 !== window.Phaser && Phaser.Utils.mixinPrototype(Fabrique.Plugins.SuperStorage, Phaser.Plugin);
var Fabrique;
!(function (a) {
  !(function (a) {
    (a[(a.init = 0)] = "init"),
      (a[(a.setItem = 1)] = "setItem"),
      (a[(a.getItem = 2)] = "getItem"),
      (a[(a.removeItem = 3)] = "removeItem"),
      (a[(a.clear = 4)] = "clear"),
      (a[(a.setNamespace = 5)] = "setNamespace"),
      (a[(a.length = 6)] = "length"),
      (a[(a.key = 7)] = "key");
  })(a.StorageCommand || (a.StorageCommand = {}));
  var b =
    (a.StorageCommand,
    (function () {
      function a() {}
      return (
        (a.isLocalStorageSupport = function () {
          try {
            if ("object" == typeof localStorage) return localStorage.setItem("testingLocalStorage", "foo"), localStorage.removeItem("testingLocalStorage"), !0;
          } catch (a) {
            return !1;
          }
          return !1;
        }),
        (a.validateMessage = function (a) {
          return a.hasOwnProperty("command") ? a : null;
        }),
        (a.nameSpaceKeyFilter = function (a, b) {
          return a.filter(function (a) {
            return a.substring(0, b.length) === b;
          });
        }),
        a
      );
    })());
  a.StorageUtils = b;
})(Fabrique || (Fabrique = {}));
var __extends =
    (this && this.__extends) ||
    function (a, b) {
      function c() {
        this.constructor = a;
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      a.prototype = null === b ? Object.create(b) : ((c.prototype = b.prototype), new c());
    },
  Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, null, "splash-background"), (this.back = this.game.make.graphics(0, 0)), this.add(this.back), this.resize(c);
      }
      return (
        __extends(b, a),
        (b.prototype.resize = function (a) {
          this.back.clear().beginFill(14548992).drawRect(0, 0, this.game.width, this.game.height);
        }),
        (b.prototype.update = function () {}),
        (b.prototype.destroy = function (b) {
          a.prototype.destroy.call(this, b), this.back.destroy(!0), (this.back = null);
        }),
        b
      );
    })(Phaser.Group);
    a.Bild = b;
  })((b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, null, "splash-background"),
          (this.triangles = []),
          (this.triangleSizes = [350, 650, 950, 1250]),
          (this.back = this.game.make.graphics(0, 0)),
          (this.t = this.game.make.graphics(0, 0)),
          (this.gradientBitmap = this.game.make.bitmapData(this.game.width, this.game.height)),
          (this.gradient = this.game.make.sprite(0, 0, this.gradientBitmap)),
          this.add(this.back),
          this.add(this.t),
          this.add(this.gradient),
          this.resize(c);
      }
      return (
        __extends(b, a),
        (b.prototype.resize = function (a) {
          var b = this;
          this.back.clear().beginFill(3387647).drawRect(0, 0, this.game.width, this.game.height),
            this.updateTrinagles(a),
            (this.t.x = this.game.width / 2),
            (this.t.y = this.game.height / 2),
            this.t.clear(),
            this.t.lineStyle(80 * a, 16777215, 0.3),
            this.triangles.forEach(function (a) {
              b.t.drawPolygon(a);
            }),
            (this.t.angle = 30),
            this.gradientBitmap.resize(this.game.width, this.game.height);
          var c = this.gradientBitmap.context.createLinearGradient(0, 0, 0, this.game.height - 200);
          c.addColorStop(0, "rgba(51, 176, 255, 0)"),
            c.addColorStop(1, "rgba(51, 176, 255, 1)"),
            (this.gradientBitmap.context.fillStyle = c),
            this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height),
            this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height);
        }),
        (b.prototype.updateTrinagles = function (a) {
          var b = this;
          new Phaser.Point(this.game.width / 2, this.game.height / 2),
            (this.triangles = []),
            this.triangleSizes.forEach(function (c, d) {
              (c *= a),
                b.triangles.push(
                  new Phaser.Polygon([
                    new Phaser.Point(c * Math.cos(0), c * Math.sin(0)),
                    new Phaser.Point(c * Math.cos((1 / 3) * (2 * Math.PI)), c * Math.sin((1 / 3) * (2 * Math.PI))),
                    new Phaser.Point(c * Math.cos((2 / 3) * (2 * Math.PI)), c * Math.sin((2 / 3) * (2 * Math.PI))),
                    new Phaser.Point(c * Math.cos(0), c * Math.sin(0)),
                  ])
                );
            });
        }),
        (b.prototype.update = function () {
          this.t.angle += 0.3;
        }),
        (b.prototype.destroy = function (b) {
          a.prototype.destroy.call(this, b),
            this.back.destroy(!0),
            this.gradientBitmap.destroy(),
            this.gradient.destroy(!0),
            this.t.destroy(!0),
            (this.back = null),
            (this.gradientBitmap = null),
            (this.gradient = null),
            (this.t = null),
            (this.triangles = null),
            (this.triangleSizes = null);
        }),
        b
      );
    })(Phaser.Group);
    a.FunnyGames = b;
  })((b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, null, "splash-background"),
          (this.back = this.game.make.graphics(0, 0)),
          (this.gradientBitmap = this.game.make.bitmapData(this.game.width, this.game.height)),
          (this.gradient = this.game.make.sprite(0, 0, this.gradientBitmap)),
          this.add(this.back),
          this.add(this.gradient),
          this.resize(c);
      }
      return (
        __extends(b, a),
        (b.prototype.resize = function (a) {
          this.back.clear().beginFill(4879021).drawRect(0, 0, this.game.width, this.game.height);
        }),
        (b.prototype.update = function () {}),
        (b.prototype.destroy = function (b) {
          a.prototype.destroy.call(this, b), this.back.destroy(!0), this.gradientBitmap.destroy(), this.gradient.destroy(!0), (this.back = null), (this.gradientBitmap = null), (this.gradient = null);
        }),
        b
      );
    })(Phaser.Group);
    a.Spele = b;
  })((b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, null, "splash-background"),
          (this.back = this.game.make.graphics(0, 0)),
          (this.gradientBitmap = this.game.make.bitmapData(this.game.width, this.game.height)),
          (this.gradient = this.game.make.sprite(0, 0, this.gradientBitmap)),
          this.add(this.back),
          this.add(this.gradient),
          this.resize(c);
      }
      return (
        __extends(b, a),
        (b.prototype.resize = function (a) {
          this.back.clear().beginFill(357287).drawRect(0, 0, this.game.width, this.game.height), this.gradientBitmap.resize(this.game.width, this.game.height), this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height);
          var b = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 2);
          b.addColorStop(0, "rgba(0, 81, 125, 0)"), b.addColorStop(1, "rgba(0, 81, 125, 1)"), (this.gradientBitmap.context.fillStyle = b), this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height);
          var c = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 2);
          c.addColorStop(0, "rgba(4, 176, 240, 1)"), c.addColorStop(1, "rgba(4, 176, 240, 0)"), (this.gradientBitmap.context.fillStyle = c), this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height);
        }),
        (b.prototype.update = function () {}),
        (b.prototype.destroy = function (b) {
          a.prototype.destroy.call(this, b), this.back.destroy(!0), this.gradientBitmap.destroy(), this.gradient.destroy(!0), (this.back = null), (this.gradientBitmap = null), (this.gradient = null);
        }),
        b
      );
    })(Phaser.Group);
    a.Yepi = b;
  })((b = a.SplashScreenBackgrounds || (a.SplashScreenBackgrounds = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  !(function (a) {
    (a[(a.splashscreen = 0)] = "splashscreen"),
      (a[(a.logo = 1)] = "logo"),
      (a[(a.facebook = 2)] = "facebook"),
      (a[(a.twitter = 3)] = "twitter"),
      (a[(a.playstore = 4)] = "playstore"),
      (a[(a.appstore = 5)] = "appstore"),
      (a[(a.more_games = 6)] = "more_games"),
      (a[(a.download_game = 7)] = "download_game"),
      (a[(a.walkthrough = 8)] = "walkthrough"),
      (a[(a.disclaimer = 9)] = "disclaimer"),
      (a[(a.highscores = 10)] = "highscores");
  })(a.UtmTargets || (a.UtmTargets = {}));
  var b = a.UtmTargets,
    c = (function () {
      function c() {}
      return (
        (c.preloadImages = function (b) {
          var d,
            e = a.Utils.getSourceSite();
          switch (
            (a.Utils.isOnDevice(b) || c.isAirfi()
              ? (a.Utils.ASSET_LOCATION = "assets/")
              : a.Utils.isTc()
              ? (a.Utils.ASSET_LOCATION = "/repository/download/Fabrique_FunnyGamesSplash/.lastSuccessful/build/assets/")
              : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION = "//" + window.location.host + "/orange-games-splash/assets/"),
            e)
          ) {
            case "spele.nl":
              d = "spele";
              break;
            case "yepi.com":
              d = "yepi";
              break;
            case "bildspielt.de":
              d = "bild";
              break;
            default:
              d = "3kh0";
          }
          a.Utils.isTc() || (b.load.crossOrigin = "anonymous"), b.load.image(c.LOGO_KEY, a.Utils.ASSET_LOCATION + "images/branding_logo_" + d + ".png");
        }),
        (c.openCampaignLink = function (d, e, f) {
          if (a.Utils.isOnDevice(d) || c.isContracted(d) || c.isSpecial(d)) return null;
          var g,
            h = a.Utils.getSourceSite();
          switch (h) {
            case "spele.nl":
              g = "http://www.spele.nl";
              break;
            case "yepi.com":
              g = "http://www.yepi.com";
              break;
            default:
              g = "http://www.funnygames.nu";
          }
          var i = "string" == typeof f ? f : b[f],
            j = window.open("http://3kh0.github.io", "_blank");
          j.focus();
        }),
        (c.getLogoWithLink = function (b, d) {
          var e,
            f = a.Utils.getSourceSite();
          switch (f) {
            case "spele.nl":
              e = "http://www.spele.nl";
              break;
            default:
              e = "http://3kh0.github.io";
          }
          var g = new Phaser.Image(b, 0, 0, c.LOGO_KEY);
          return (
            a.Utils.isOnDevice(b) ||
              c.isContracted(b) ||
              c.isSpecial(b) ||
              c.isAirfi() ||
              ((g.inputEnabled = !0),
              (g.input.useHandCursor = !0),
              g.events.onInputUp.add(function () {
                a.Branding.openCampaignLink(b, d, a.UtmTargets.logo);
              }, this)),
            g
          );
        }),
        (c.isInternal = function (a) {
          return c.hostMatchesList(a.cache.getJSON(c.INTERNAL_PORTALS_KEY));
        }),
        (c.isContracted = function (a) {
          return c.hostMatchesList(a.cache.getJSON(c.CONTRACTED_PORTALS_KEY));
        }),
        (c.isSpecial = function (a) {
          return c.hostMatchesList(a.cache.getJSON(c.SPECIAL_PORTALS_KEY));
        }),
        (c.isAirfi = function () {
          return !!window.hasOwnProperty("airfi") && window.airfi;
        }),
        (c.hostMatchesList = function (b) {
          b = b || [];
          for (var c = a.Utils.getSourceSite(), d = 0; d < b.length; d++) if (c === b[d]) return !0;
          return !1;
        }),
        (c.LOGO_KEY = "branding_logo"),
        (c.INTERNAL_PORTALS_KEY = "branding_portals"),
        (c.CONTRACTED_PORTALS_KEY = "branding_contracted"),
        (c.SPECIAL_PORTALS_KEY = "branding_special"),
        (c.SITELOCK_PORTALS = "sitelock_portals"),
        (c.GAME_ICONS_KEY = "more_games"),
        c
      );
    })();
  a.Branding = c;
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b = (function () {
    function b() {}
    return (
      (b.loadPortalScript = function (b) {
        b &&
          b.hasOwnProperty("minijuegos") &&
          b.minijuegos.indexOf(a.Utils.getSourceSite()) !== -1 &&
          (void 0 !== window.mpConfig ? (window.mpConfig.partner = "orange-games") : (window.mpConfig = { partner: "orange-games" }),
          "function" == typeof addScript && addScript("http://ext.minijuegosgratis.com/external-host/main.js", Date.now() / 1e3));
      }),
      b
    );
  })();
  a.PortalScripts = b;
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c, d, e, f, g, h) {
        a.call(this, b, d, e, "", this.openGame, this),
          (this.id = c.data.key),
          (this.url = c.data.url),
          (this.icon = this.game.add.image(0, 0, c.data.key)),
          (this.icon.width = f),
          (this.icon.height = f),
          (this.input.priorityID = 680),
          this.addChild(this.icon);
        var i = this.game.make.graphics(0, 0);
        i
          .beginFill(h)
          .drawRect(0, 0, f, g - f)
          .endFill(),
          (this.titleBg = this.game.add.image(0, f, i.generateTexture())),
          this.addChild(this.titleBg);
        var j = c.data.title;
        j.length > 16 && (j = j.replace(j.substring(14, j.length), "...")),
          (this.title = this.game.add.text(f / 2, this.titleBg.y + (g - f) / 2 + 4, j.toUpperCase(), { font: "bold " + 0.35 * (g - f) + "px Arial", fill: "#FFF", align: "center", wordWrap: !0, wordWrapWidth: f - 10 })),
          this.title.anchor.set(0.5, 0.5),
          this.addChild(this.title),
          (i = this.game.make.graphics(0, 0)),
          i.beginFill(16777215).drawCircle(0, 0, 80).beginFill(h).lineTo(-15, -25).lineTo(25, 0).lineTo(-15, 25).lineTo(-15, -25).endFill(),
          (this.playImg = this.game.add.image(f / 2, (f / 3) * 2.7, i.generateTexture())),
          this.playImg.anchor.set(0.5, 0.5),
          this.addChild(this.playImg);
      }
      return (
        __extends(b, a),
        (b.prototype.openGame = function () {
          this.game.analytics && this.game.analytics.google.sendGenericEvent("MoreGames", "Click", this.id);
          var a = window.open(this.url, "_self");
          a.focus();
        }),
        b
      );
    })(Phaser.Button);
    a.Item = b;
  })((b = a.MoreGames || (a.MoreGames = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d(b, d) {
        var e = this;
        c.call(this, b, null, "moreGames-background"),
          (this.size = 800),
          (this.items = []),
          (this.offset = 14),
          (this.gameName = d),
          (this.deviceRatio = b.width / this.size),
          (this.overlay = b.add.graphics(0, 0)),
          this.overlay.beginFill(0, 0.4).drawRect(0, 0, b.width, b.height).endFill(),
          this.overlay.pivot.set(b.width / 2, b.height / 2),
          (this.overlay.inputEnabled = !0),
          (this.overlay.input.priorityID = 660),
          (this.onClose = new Phaser.Signal()),
          this.overlay.events.onInputUp.add(function () {
            e.hide();
          }),
          this.add(this.overlay),
          (this.menuGrp = new Phaser.Group(b, this, "menuGrp")),
          this.add(this.menuGrp);
        var f = b.make.graphics(0, 0);
        f
          .beginFill(2507370)
          .drawRoundedRect(0, 0, this.size, this.size + 20, 15)
          .endFill(),
          (this.background = this.game.add.image(0, 0, f.generateTexture())),
          this.background.anchor.set(0.5),
          (this.background.inputEnabled = !0),
          (this.background.input.priorityID = 670),
          (this.background.input.useHandCursor = !1),
          this.menuGrp.add(this.background),
          (this.logoBtn = this.game.add.button(
            0,
            -(this.background.height / 2) + this.offset,
            a.Branding.LOGO_KEY,
            function () {
              a.Branding.openCampaignLink(e.game, e.gameName, a.UtmTargets.more_games);
            },
            this
          )),
          this.logoBtn.scale.setTo(0.3),
          this.logoBtn.anchor.set(0.5, 0),
          this.menuGrp.add(this.logoBtn),
          (this.closeBtn = b.add.button(this.size / 2 - 10, -(this.size / 2) + 25, "close_btn", this.hide, this)),
          this.closeBtn.anchor.set(1),
          (this.closeBtn.input.priorityID = 680),
          this.menuGrp.add(this.closeBtn),
          this.createItems();
        var g = b.make.graphics(0, 0);
        g.beginFill(2507370).drawRect(0, 0, 270, 40).endFill(),
          (this.moreGamesBtn = b.add.button(
            0,
            this.background.y + this.background.height / 2 - g.height - this.offset,
            "",
            function () {
              a.Branding.openCampaignLink(e.game, e.gameName, a.UtmTargets.more_games);
            },
            this
          )),
          (this.moreGamesBtn.texture = g.generateTexture()),
          (this.moreGamesBtn.input.priorityID = 680),
          this.moreGamesBtn.anchor.set(0.5, 0),
          this.menuGrp.add(this.moreGamesBtn);
        var h = { font: "bold 26px Tahoma", fill: "#ffffff" };
        (this.moreGamesText = b.add.text(0, this.moreGamesBtn.height / 2 + 2, "PLAY MORE GAMES", h)),
          this.moreGamesText.anchor.set(0.5),
          this.moreGamesBtn.addChild(this.moreGamesText),
          (this.visible = !1),
          this.resize(),
          (this.resizeListener = function () {
            setTimeout(function () {
              e.resize();
            }, 100);
          }),
          this.game.scale.onSizeChange.add(this.resizeListener, this);
      }
      return (
        __extends(d, c),
        (d.prototype.createItems = function () {
          (this.itemGrp = this.game.make.group(this, "items")), (this.itemGrp.x = 0), (this.itemGrp.y = this.size / 2 + this.logoBtn.y + this.logoBtn.height), this.menuGrp.add(this.itemGrp);
          var c,
            e,
            f,
            g,
            h = this.game.cache.getJSON(a.Branding.GAME_ICONS_KEY),
            i = 3,
            j = Math.floor(this.size / i - 1.25 * this.offset),
            k = Math.floor(j + 0.25 * j),
            l = 0;
          for (var m in h)
            h.hasOwnProperty(m) &&
              l < 6 &&
              !this.isCurrentGame(m) &&
              ((e = (l % i) * j + this.offset + (l % i) * this.offset),
              (f = Math.floor(l / i) * k + this.offset + Math.floor(l / i) * this.offset),
              (g = l % d.BG_COLORS.length),
              (c = new b.Item(this.game, h[m], e - this.size / 2, f - this.size / 2, j, k, d.BG_COLORS[g])),
              this.itemGrp.add(c),
              this.items.push(c),
              l++);
        }),
        (d.prototype.isCurrentGame = function (a) {
          var b = window.location.href.replace(/-/g, "");
          return (a = a.replace(/-/g, "")), b.indexOf(a) >= 0;
        }),
        (d.prototype.show = function () {
          this.visible || (this.game.analytics && (this.game.analytics.google.sendScreenView("moregames"), this.game.analytics.google.sendGenericEvent("MoreGames", "Open")), (this.visible = !0));
        }),
        (d.prototype.hide = function () {
          this.visible && (this.onClose.dispatch(), this.game.analytics && this.game.analytics.google.sendGenericEvent("MoreGames", "Close"), (this.visible = !1));
        }),
        (d.preloadImages = function (b) {
          a.Utils.getSourceSite(),
            a.Utils.isOnDevice(b) || a.Branding.isAirfi()
              ? (a.Utils.ASSET_LOCATION = "assets/")
              : a.Utils.isTc()
              ? (a.Utils.ASSET_LOCATION = "/repository/download/Fabrique_FunnyGamesSplash/.lastSuccessful/build/assets/")
              : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION = "//" + window.location.host + "/orange-games-splash/assets/"),
            a.Utils.isTc() || (b.load.crossOrigin = "anonymous"),
            b.load.image("close_btn", a.Utils.ASSET_LOCATION + "images/close_btn.png");
          var c = b.cache.getJSON(a.Branding.GAME_ICONS_KEY);
          for (var d in c) c.hasOwnProperty(d) && ((c[d].data.key = d), b.load.image(d, a.Utils.ASSET_LOCATION + "icons/" + d + ".png"));
        }),
        (d.prototype.getScale = function () {
          return this.game.height > this.game.width && this.game.width < this.size ? (this.game.width - 20) / this.size : this.game.width > this.game.height && this.game.height < this.size ? (this.game.height - 40) / this.size : 1;
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()),
            this.overlay.clear().beginFill(0, 0.4).drawRect(0, 0, this.game.width, this.game.height).endFill(),
            this.overlay.pivot.set(this.game.width / 2, this.game.height / 2),
            this.menuGrp.scale.set(this.scaleFactor);
        }),
        (d.prototype.destroy = function () {
          this.game.scale.onSizeChange.remove(this.resizeListener, this), this.onClose.removeAll(), (this.onClose = null);
        }),
        (d.BG_COLORS = [2201331, 10233776, 15936542, 15690752, 16361509, 5025616]),
        d
      );
    })(Phaser.Group);
    b.Menu = c;
  })((b = a.MoreGames || (a.MoreGames = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, c), (this.ga = GA.getInstance()), b.hasOwnProperty("analytics") ? Object.defineProperty(b.analytics, "game", { value: this }) : (b.analytics = { game: this });
      }
      return (
        __extends(b, a),
        (b.prototype.setup = function (a, b, c, d, e) {
          void 0 === e && (e = !0), this.ga.init(a, b, c, d).addEvent(new GA.Events.User()), e && this.setupErrorTracking();
        }),
        (b.prototype.createUser = function (a, b, c, d) {
          return new GA.User(a, b, c, d);
        }),
        (b.prototype.addEvent = function (a) {
          this.ga.addEvent(a);
        }),
        (b.prototype.sendEvents = function () {
          this.ga.sendData();
        }),
        (b.prototype.setupErrorTracking = function () {
          var a = this,
            b = [];
          window.addEventListener("error", function (c) {
            if (b.indexOf(c.message) === -1) {
              b.push(c.message);
              var d = "Error: " + c.message;
              c.filename && (d += "\nurl: " + c.filename),
                c.lineno && (d += "\nline: " + c.lineno),
                c.colno && (d += "\ncolumn: " + c.colno),
                c.error && (d += "\nDetails: " + c.error),
                a.ga.addEvent(new GA.Events.Exception(GA.Events.ErrorSeverity.critical, d)).sendData();
            }
          }),
            window.addEventListener("error", function (b) {
              var c = b.message;
              b.hasOwnProperty("error") && b.error.hasOwnProperty("stack") && (c = b.error.stack), a.ga.addEvent(new GA.Events.Exception(GA.Events.ErrorSeverity.critical, c)).sendData();
            });
        }),
        b
      );
    })(Phaser.Plugin);
    a.GameAnalytics = b;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (b) {
      function c(c, d) {
        b.call(this, c, d), c.hasOwnProperty("analytics") ? Object.defineProperty(c.analytics, "google", { value: this }) : (c.analytics = { google: this });
        var e = a.Utils.isOnDevice(c) ? "https://" : "//";
        !(function (a, b, c, d, e, f, g) {
          (a.GoogleAnalyticsObject = e),
            (a[e] = a[e]
              ? a[e]
              : function () {
                  (a[e].q = a[e].q || []).push(arguments);
                }),
            (a[e].l = Date.now()),
            (f = b.createElement(c)),
            (g = b.getElementsByTagName(c)[0]),
            (f.async = 1),
            (f.src = d),
            g.parentNode.insertBefore(f, g);
        })(window, document, "script", e + "www.google-analytics.com/analytics.js", "ga");
      }
      return (
        __extends(c, b),
        (c.prototype.setup = function (b, c, d, e) {
          if (
            (void 0 === e && (e = "auto"),
            ga("create", b, e),
            a.Utils.isOnDevice(this.game) && ga("set", "checkProtocolTask", null),
            void 0 !== c && ga("set", "appName", c),
            void 0 !== c && ga("set", "appVersion", d),
            ga("send", "pageview"),
            "auto" !== e)
          ) {
            var f = { name: "fbrq" };
            for (var g in e) e.hasOwnProperty(g) && (f[g] = e[g]);
            ga("create", "UA-78960661-1", f);
          } else ga("create", "UA-78960661-1", e, "fbrq");
          if (a.Utils.isSpil()) {
            var h = a.Utils.getReferrer(decodeURIComponent(document.referrer));
            ga("fbrq.set", "referrer", h), ga("set", "referrer", h);
          }
          return a.Utils.isOnDevice(this.game) && ga("fbrq.set", "checkProtocolTask", null), ga("fbrq.send", "pageview"), ga("fbrq.set", "appName", "All"), ga;
        }),
        (c.prototype.sendScreenView = function (a) {
          ga("fbrq.send", "screenview", { screenName: a }), ga("send", "screenview", { screenName: a });
        }),
        (c.prototype.sendGenericEvent = function (a, b, c) {
          ga("fbrq.send", "event", a, b, c);
        }),
        c
      );
    })(Phaser.Plugin);
    b.GoogleAnalytics = c;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (a) {
      function b(b, c) {
        a.call(this, b, c),
          b.hasOwnProperty("events")
            ? void 0
            : (b.events = { onGameStart: new Phaser.Signal(), onGameEnd: new Phaser.Signal(), onLevelStart: new Phaser.Signal(), onLevelEnd: new Phaser.Signal(), onPause: new Phaser.Signal(), onResume: new Phaser.Signal() });
      }
      return __extends(b, a), b;
    })(Phaser.Plugin);
    a.GameEvents = b;
  })((b = a.Plugins || (a.Plugins = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d() {
        c.call(this), (this.name = d.Name), (this.scaleFactor = 1), (this.created = !1);
      }
      return (
        __extends(d, c),
        (d.prototype.init = function (b) {
          if (((this.config = b), this.game.scale.onSizeChange.add(this.resize, this), void 0 === !this.game.load.spine)) throw new Error("You tried to play the Splash screen without spine support enabled!");
          a.Utils.isOnDevice(this.game) || a.Branding.isAirfi()
            ? (a.Utils.ASSET_LOCATION = "assets/")
            : a.Utils.isTc()
            ? (a.Utils.ASSET_LOCATION = "/repository/download/Fabrique_FunnyGamesSplash/.lastSuccessful/build/assets/")
            : "fbrq.io" === a.Utils.getSourceSite(!0) && (a.Utils.ASSET_LOCATION = "//" + window.location.host + "/orange-games-splash/assets/");
        }),
        (d.prototype.preload = function () {
          (this.scaleFactor = this.getScale()), a.Utils.isTc() || (this.game.load.crossOrigin = "anonymous");
          var b = (Date.now() / 1e3) | 0;
          switch (
            (a.Utils.isOnDevice(this.game) ||
              (this.game.load.json(a.Branding.INTERNAL_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/internal.json?v=" + b),
              this.game.load.json(a.Branding.CONTRACTED_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/contracted.json?v=" + b),
              this.game.load.json(a.Branding.SPECIAL_PORTALS_KEY, a.Utils.ASSET_LOCATION + "json/special.json?v=" + b),
              this.game.load.json(a.Branding.SITELOCK_PORTALS, a.Utils.ASSET_LOCATION + "json/sitelock.json?v=" + b),
              this.game.load.json(a.Branding.GAME_ICONS_KEY, a.Utils.ASSET_LOCATION + "json/games.json?v=" + b),
              this.game.load.json(a.Domain.KEY, a.Utils.ASSET_LOCATION + "json/domains.json")),
            a.Utils.getSourceSite())
          ) {
            case "spele.nl":
              (this.background = new a.SplashScreenBackgrounds.Spele(this.game, this.scaleFactor)), this.game.add.existing(this.background);
              break;
            case "yepi.com":
              (this.background = new a.SplashScreenBackgrounds.Yepi(this.game, this.scaleFactor)), this.game.add.existing(this.background);
              break;
            case "bildspielt.de":
              (this.background = new a.SplashScreenBackgrounds.Bild(this.game, this.scaleFactor)), this.game.add.existing(this.background);
              break;
            default:
              (this.background = new a.SplashScreenBackgrounds.FunnyGames(this.game, this.scaleFactor)), this.game.add.existing(this.background);
          }
        }),
        (d.prototype.getScale = function () {
          return this.game.device.desktop
            ? this.game.width < 1.5 * b.FunnyGames.IdealWidth
              ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
            : ((this.game.width / 6) * 3) / b.FunnyGames.IdealWidth;
        }),
        (d.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (d.prototype.update = function () {
          this.background.update();
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor);
        }),
        (d.prototype.shutdown = function () {
          this.game.scale.onSizeChange.remove(this.resize, this), this.world.remove(this.background);
        }),
        (d.prototype.create = function () {
          a.Domain.setList(this.cache.getJSON(a.Domain.KEY, !0)),
            a.PortalScripts.loadPortalScript(this.cache.getJSON(a.Branding.SITELOCK_PORTALS)),
            this.game.state.add(b.SplashPreloader.Name, b.SplashPreloader),
            this.game.state.add(b.SplashPreloader.Name, b.SplashPreloader),
            this.game.state.start(b.SplashPreloader.Name, !0, !1, this.config, this.background);
        }),
        (d.Name = "preloader"),
        d
      );
    })(Phaser.State);
    b.Preloader = c;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d() {
        c.call(this), (this.name = d.Name), (this.scaleFactor = 1), (this.created = !1);
      }
      return (
        __extends(d, c),
        (d.prototype.init = function (a, b) {
          (this.config = a), this.game.scale.onSizeChange.add(this.resize, this), (this.background = b), this.game.add.existing(this.background);
        }),
        (d.prototype.preload = function () {
          if (((this.scaleFactor = this.getScale()), a.Utils.isTc() || (this.game.load.crossOrigin = "anonymous"), a.Branding.isSpecial(this.game)))
            this.game.add.existing(this.background), this.game.load.spritesheet("fgs_play", a.Utils.ASSET_LOCATION + "images/fgs_btn_play.png", 130, 130), this.game.load.image("loader", a.Utils.ASSET_LOCATION + "images/loader_back.png");
          else
            switch (a.Utils.getSourceSite()) {
              case "spele.nl":
                this.game.load.image("ss_play", a.Utils.ASSET_LOCATION + "images/ss_btn_play.png"),
                  this.game.load.spine("ss_splash", a.Utils.ASSET_LOCATION + "spine/ss_splash.json"),
                  this.game.device.iOS
                    ? this.game.load.audio("cheer", [a.Utils.ASSET_LOCATION + "sound/ss_intro.m4a"])
                    : this.game.load.audio("cheer", [a.Utils.ASSET_LOCATION + "sound/ss_intro.ogg", a.Utils.ASSET_LOCATION + "sound/ss_intro.mp3"]);
                break;
              case "yepi.com":
                (this.background = new a.SplashScreenBackgrounds.Yepi(this.game, this.scaleFactor)),
                  this.game.add.existing(this.background),
                  this.game.load.spine("yp_splash", a.Utils.ASSET_LOCATION + "spine/yp_splash.json"),
                  this.game.load.atlas("yp_atlas", a.Utils.ASSET_LOCATION + "atlas/yp_atlas.png", a.Utils.ASSET_LOCATION + "atlas/yp_atlas.json");
                break;
              case "bildspielt.de":
                (this.background = new a.SplashScreenBackgrounds.Bild(this.game, this.scaleFactor)),
                  this.game.load.image("bild_play", a.Utils.ASSET_LOCATION + "images/bild_btn_play.png"),
                  this.game.load.image("bild_logo", a.Utils.ASSET_LOCATION + "images/branding_logo_bild.png"),
                  this.game.add.existing(this.background);
                break;
              default:
                (this.background = new a.SplashScreenBackgrounds.FunnyGames(this.game, this.scaleFactor)),
                  this.game.add.existing(this.background),
                  this.game.load.image("fgs_logo", a.Utils.ASSET_LOCATION + "images/fgs_logo.png"),
                  this.game.load.spritesheet("fgs_play", a.Utils.ASSET_LOCATION + "images/fgs_btn_play.png", 130, 130),
                  this.game.load.spine("fgs_monster_1", a.Utils.ASSET_LOCATION + "spine/fgs_monster_1.json"),
                  this.game.load.spine("fgs_monster_2", a.Utils.ASSET_LOCATION + "spine/fgs_monster_2.json"),
                  this.game.load.spine("fgs_monster_3", a.Utils.ASSET_LOCATION + "spine/fgs_monster_3.json"),
                  this.game.device.iOS
                    ? this.game.load.audio("fg", [a.Utils.ASSET_LOCATION + "sound/fgs_intro.m4a"])
                    : this.game.load.audio("fg", [a.Utils.ASSET_LOCATION + "sound/fgs_intro.ogg", a.Utils.ASSET_LOCATION + "sound/fgs_intro.mp3"]);
            }
        }),
        (d.prototype.getScale = function () {
          return this.game.device.desktop
            ? this.game.width < 1.5 * b.FunnyGames.IdealWidth
              ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
            : ((this.game.width / 6) * 3) / b.FunnyGames.IdealWidth;
        }),
        (d.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (d.prototype.update = function () {
          this.background.update();
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor);
        }),
        (d.prototype.shutdown = function () {
          this.game.scale.onSizeChange.remove(this.resize, this), this.world.remove(this.background);
        }),
        (d.prototype.create = function () {
          if (a.Branding.isSpecial(this.game)) this.game.state.add(b.Neutral.Name, b.Neutral), this.game.state.start(b.Neutral.Name, !0, !1, this.config, this.background);
          else
            switch (a.Utils.getSourceSite()) {
              case "spele.nl":
                this.game.state.add(b.Spele.Name, b.Spele), this.game.state.start(b.Spele.Name, !0, !1, this.config, this.background);
                break;
              case "yepi.com":
                this.game.state.add(b.Yepi.Name, b.Yepi), this.game.state.start(b.Yepi.Name, !0, !1, this.config, this.background);
                break;
              case "bildspielt.de":
                this.game.state.add(b.Bild.Name, b.Bild), this.game.state.start(b.Bild.Name, !0, !1, this.config, this.background);
                break;
              default:
                this.game.state.add(b.FunnyGames.Name, b.FunnyGames), this.game.state.start(b.FunnyGames.Name, !0, !1, this.config, this.background);
            }
        }),
        (d.Name = "splashloader"),
        d
      );
    })(Phaser.State);
    b.SplashPreloader = c;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d() {
        c.call(this), (this.name = d.Name), (this.scaleFactor = 1), (this.created = !1), (this.preloadReady = !1), (this.clicked = !1), (this.preloadTexts = []), (this.tId = 0);
      }
      return (
        __extends(d, c),
        (d.prototype.init = function (a, b) {
          (this.config = a), (this.background = b), this.game.scale.onSizeChange.add(this.resize, this);
        }),
        (d.prototype.preload = function () {
          this.game.add.existing(this.background),
            this.createObjects(),
            (this.scaleFactor = this.getScale()),
            this.resizeObjects(),
            this.startAnimation(),
            this.game.load.onLoadStart.add(this.onPreloadStart, this),
            this.game.load.onFileComplete.add(this.onPreloadedFile, this),
            this.game.load.onLoadComplete.add(this.onPreloadEnd, this),
            this.config.preloadHandler(),
            0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd();
        }),
        (d.prototype.onPreloadStart = function () {}),
        (d.prototype.onPreloadedFile = function () {}),
        (d.prototype.onPreloadEnd = function () {
          var b = this;
          (this.preloadReady = !0),
            (this.loadBack.visible = !1),
            (this.loadBar.visible = !1),
            a.Utils.isOnDevice(this.game) || this.game.device.desktop
              ? this.game.time.events.add(Phaser.Timer.SECOND, function () {
                  void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState);
                })
              : (this.game.input.onDown.add(function (a) {
                  b.clicked || ((b.clicked = !0), void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b));
                }, this),
                this.animateButton());
        }),
        (d.prototype.createObjects = function () {
          var a = this;
          (this.logo = this.game.add.sprite(this.game.width / 2, this.game.height / 2 - 200, "bild_logo")), this.logo.anchor.set(0.5);
          var b = this.game.make.graphics(0, 0);
          b.beginFill(16777215, 0.5).drawRect(0, 0, 350, 20).endFill(), (this.loadBack = this.game.add.sprite(this.game.width / 2, this.game.height / 2, b.generateTexture())), this.loadBack.anchor.set(0.5);
          var c = this.game.make.graphics(0, 0);
          c.beginFill(16777215, 1).drawRect(0, 0, 350, 20).endFill(),
            (this.loadBar = this.game.add.sprite(this.game.width / 2 - 175, this.game.height / 2, c.generateTexture())),
            this.loadBar.anchor.set(0, 0.5),
            this.load.setPreloadSprite(this.loadBar),
            (this.playButton = this.game.add.button(
              this.game.width / 2,
              this.game.height / 2 + 100,
              "bild_play",
              function () {
                a.clicked || ((a.clicked = !0), void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a));
              },
              this
            )),
            this.playButton.anchor.set(0.5),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !1),
            (this.created = !0);
        }),
        (d.prototype.resizeObjects = function () {
          this.created && (a.Utils.isOnDevice(this.game) || ((this.playButton.x = this.game.width / 2), (this.playButton.y = this.game.height / 2 + 100), (this.logo.x = this.game.width / 2), (this.logo.y = this.game.height / 2 - 200)));
        }),
        (d.prototype.playClick = function () {
          var a = this;
          this.game.tweens.remove(this.buttonTween);
          var b = this.game.add.tween(this.playButton.scale);
          b.to({ x: 0, y: 0 }, 350, Phaser.Easing.Back.In).onComplete.add(function () {
            a.game.state.start(a.config.nextState);
          }),
            b.start();
        }),
        (d.prototype.getScale = function () {
          return a.Utils.isOnDevice(this.game)
            ? this.game.width < 1.5 * b.FunnyGames.IdealWidth
              ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
            : ((this.game.width / 6) * 3) / b.FunnyGames.IdealWidth;
        }),
        (d.prototype.startAnimation = function () {}),
        (d.prototype.animateButton = function () {
          a.Utils.isOnDevice(this.game) ||
            (this.game.tweens.remove(this.buttonTween),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !0),
            (this.buttonTween = this.game.add.tween(this.playButton.scale)),
            this.buttonTween.to({ x: 1.14 * this.scaleFactor, y: 1.14 * this.scaleFactor }, 420, Phaser.Easing.Quadratic.InOut, !0, 500),
            this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this),
            this.buttonTween.start());
        }),
        (d.prototype.update = function () {
          this.background.update();
        }),
        (d.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton();
        }),
        (d.prototype.shutdown = function () {
          this.game.scale.onSizeChange.remove(this.resize, this);
        }),
        (d.Name = "bildSplashScreen"),
        (d.IdealWidth = 463),
        (d.MaxDots = 3),
        d
      );
    })(Phaser.State);
    b.Bild = c;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d() {
        c.call(this),
          (this.name = d.Name),
          (this.scaleFactor = 1),
          (this.created = !1),
          (this.preloadReady = !1),
          (this.clicked = !1),
          (this.preloadTexts = ["Loading images", "Loading music", "Loading sound effects", "Calculating Pi"]),
          (this.dots = 1),
          (this.dotText = "."),
          (this.tId = 0);
      }
      return (
        __extends(d, c),
        (d.prototype.init = function (a, b) {
          (this.config = a), (this.background = b), this.config.preloadTexts && (this.preloadTexts = this.config.preloadTexts), this.game.scale.onSizeChange.add(this.resize, this);
        }),
        (d.prototype.preload = function () {
          this.game.add.existing(this.background),
            this.createObjects(),
            (this.scaleFactor = this.getScale()),
            this.resizeObjects(),
            this.startAnimation(),
            this.game.load.onLoadStart.add(this.onPreloadStart, this),
            this.game.load.onFileComplete.add(this.onPreloadedFile, this),
            this.game.load.onLoadComplete.add(this.onPreloadEnd, this),
            this.config.preloadHandler(),
            0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd();
        }),
        (d.prototype.onPreloadStart = function () {
          (this.t = Date.now()), this.preloadText.setText(this.preloadTexts[this.tId]);
        }),
        (d.prototype.onPreloadedFile = function () {
          Date.now() - this.t > 1e3 && ((this.t = Date.now()), this.tId++, this.tId >= this.preloadTexts.length && (this.tId = 0)),
            this.dotText.length >= 3 ? (this.dotText = ".") : (this.dotText += "."),
            this.preloadText.setText(this.preloadTexts[this.tId] + this.dotText);
        }),
        (d.prototype.onPreloadEnd = function () {
          var b = this;
          (this.preloadReady = !0),
            (this.preloadText.visible = !1),
            a.Utils.isOnDevice(this.game) || this.game.device.desktop
              ? this.game.time.events.add(Phaser.Timer.SECOND, function () {
                  void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState);
                })
              : (this.game.input.onDown.add(function (a) {
                  b.clicked || ((b.clicked = !0), void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b));
                }, this),
                this.animateButton());
        }),
        (d.prototype.createObjects = function () {
          var a = this;
          (this.monster1 = this.game.add.spine(0, 0, "fgs_monster_1")),
            this.monster1.setAnimationByName(0, "idle", !0),
            (this.monster2 = this.game.add.spine(0, 0, "fgs_monster_2")),
            this.monster2.setAnimationByName(0, "idle", !0),
            (this.monster3 = this.game.add.spine(0, 0, "fgs_monster_3")),
            this.monster3.setAnimationByName(0, "idle", !0),
            (this.preloadText = this.game.add.text(this.game.width / 2, this.game.height / 2 + 230, "", {
              font: "Arial",
              fontSize: 40,
              fill: "#ffffff",
              fontWeight: "bold",
            })),
            this.preloadText.anchor.set(0.5),
            (this.logo = this.game.add.image(0, 0, "fgs_logo")),
            this.logo.anchor.set(0.5),
            (d.IdealWidth = 1.5 * this.logo.getBounds().width),
            (this.playButton = this.game.add.button(
              this.game.width / 2,
              this.game.height / 2 + 230 * this.scaleFactor,
              "fgs_play",
              function () {
                a.clicked || ((a.clicked = !0), void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a));
              },
              this,
              0,
              0,
              1,
              0
            )),
            this.playButton.anchor.set(0.5),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !1),
            (this.created = !0);
        }),
        (d.prototype.resizeObjects = function () {
          this.created &&
            (this.logo.scale.set(1.5 * this.scaleFactor),
            (this.logo.y = this.game.height / 2 + 70 * this.scaleFactor),
            (this.logo.x = this.game.width / 2),
            (this.monster1.x = this.game.width / 2 + 40 * this.scaleFactor),
            (this.monster1.y = this.game.height / 2 - 10 * this.scaleFactor),
            this.monster1.scale.set(0.4 * this.scaleFactor),
            (this.monster2.x = this.game.width / 2 + 190 * this.scaleFactor),
            (this.monster2.y = this.game.height / 2 - 10 * this.scaleFactor),
            this.monster2.scale.set(0.4 * this.scaleFactor),
            (this.monster3.x = this.game.width / 2 - 140 * this.scaleFactor),
            (this.monster3.y = this.game.height / 2 - 10 * this.scaleFactor),
            this.monster3.scale.set(0.4 * this.scaleFactor),
            (this.preloadText.x = this.game.width / 2),
            (this.preloadText.y = this.game.height / 2 + 230 * this.scaleFactor),
            this.preloadText.scale.set(this.scaleFactor),
            a.Utils.isOnDevice(this.game) || ((this.playButton.x = this.game.width / 2), (this.playButton.y = this.game.height / 2 + 230 * this.scaleFactor)));
        }),
        (d.prototype.playClick = function () {
          var a = this;
          this.game.tweens.remove(this.buttonTween);
          var b = this.game.add.tween(this.playButton.scale);
          b.to({ x: 0, y: 0 }, 350, Phaser.Easing.Back.In).onComplete.add(function () {
            a.game.state.start(a.config.nextState);
          }),
            b.start();
        }),
        (d.prototype.getScale = function () {
          return a.Utils.isOnDevice(this.game)
            ? this.game.width < 1.5 * d.IdealWidth
              ? ((this.game.width / 6) * 4) / d.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / d.IdealWidth
            : ((this.game.width / 6) * 3) / d.IdealWidth;
        }),
        (d.prototype.startAnimation = function () {
          this.game.sound.touchLocked || this.game.sound.play("fg");
          var a = this.game.add.tween(this.logo.scale);
          a.to({ x: 1.2 * this.scaleFactor, y: 1.2 * this.scaleFactor }, 100), a.to({ x: 1.5 * this.scaleFactor, y: 1.5 * this.scaleFactor }, 450, Phaser.Easing.Back.InOut), a.start();
        }),
        (d.prototype.animateButton = function () {
          a.Utils.isOnDevice(this.game) ||
            (this.game.tweens.remove(this.buttonTween),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !0),
            (this.buttonTween = this.game.add.tween(this.playButton.scale)),
            this.buttonTween.to({ x: 1.14 * this.scaleFactor, y: 1.14 * this.scaleFactor }, 420, Phaser.Easing.Quadratic.InOut, !0, 500),
            this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this),
            this.buttonTween.start());
        }),
        (d.prototype.update = function () {
          this.background.update();
        }),
        (d.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton();
        }),
        (d.prototype.shutdown = function () {
          c.prototype.shutdown.call(this),
            this.logo.destroy(!0),
            this.monster1.destroy(!0),
            this.monster2.destroy(!0),
            this.monster3.destroy(!0),
            this.playButton.destroy(!0),
            this.background.destroy(!0),
            this.preloadText.destroy(!0),
            (this.logo = null),
            (this.monster1 = null),
            (this.monster2 = null),
            (this.monster3 = null),
            (this.playButton = null),
            (this.background = null),
            (this.preloadText = null),
            (this.config = null),
            this.game.scale.onSizeChange.remove(this.resize, this),
            this.game.state.remove(b.Preloader.Name),
            this.game.state.remove(b.SplashPreloader.Name),
            this.game.state.remove(this.name);
        }),
        (d.Name = "funnySplashScreen"),
        (d.IdealWidth = 463),
        (d.MaxDots = 3),
        d
      );
    })(Phaser.State);
    b.FunnyGames = c;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function (c) {
      function d() {
        c.call(this), (this.name = b.FunnyGames.Name), (this.scaleFactor = 1), (this.created = !1), (this.preloadReady = !1), (this.clicked = !1), (this.dots = 1), (this.dotText = "."), (this.tId = 0);
      }
      return (
        __extends(d, c),
        (d.prototype.init = function (a, b) {
          (this.config = a), (this.background = b), this.game.scale.onSizeChange.add(this.resize, this);
        }),
        (d.prototype.preload = function () {
          this.game.add.existing(this.background),
            this.createObjects(),
            (this.scaleFactor = this.getScale()),
            this.resizeObjects(),
            this.startAnimation(),
            this.game.load.onLoadStart.add(this.onPreloadStart, this),
            this.game.load.onFileComplete.add(this.onPreloadedFile, this),
            this.game.load.onLoadComplete.add(this.onPreloadEnd, this),
            this.config.preloadHandler(),
            0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd();
        }),
        (d.prototype.onPreloadStart = function () {}),
        (d.prototype.onPreloadedFile = function () {}),
        (d.prototype.onPreloadEnd = function () {
          var b = this;
          (this.preloadReady = !0),
            (this.loadBack.visible = !1),
            (this.loadBar.visible = !1),
            a.Utils.isOnDevice(this.game) || this.game.device.desktop
              ? this.game.time.events.add(Phaser.Timer.SECOND, function () {
                  void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.game.state.start(b.config.nextState);
                })
              : (this.game.input.onDown.add(function (a) {
                  b.clicked || ((b.clicked = !0), void 0 !== b.config.mobilePlayClickhandler ? b.config.mobilePlayClickhandler() : b.playClick(), b.game.input.onDown.remove(b.playClick, b));
                }, this),
                this.animateButton());
        }),
        (d.prototype.createObjects = function () {
          var a = this;
          (this.loadBack = this.game.add.sprite(this.game.width / 2, this.game.height / 2, "loader")), this.loadBack.anchor.set(0.5);
          var b = this.game.make.graphics(0, 0);
          b.beginFill(16777215, 1).drawRoundedRect(0, 0, 350, 20, 5).endFill(),
            (this.loadBar = this.game.add.sprite(this.game.width / 2 - 175, this.game.height / 2 - 5, b.generateTexture())),
            this.loadBar.anchor.set(0, 0.5),
            this.load.setPreloadSprite(this.loadBar),
            (this.playButton = this.game.add.button(
              this.game.width / 2,
              this.game.height / 2,
              "fgs_play",
              function () {
                a.clicked || ((a.clicked = !0), void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a));
              },
              this,
              0,
              0,
              1,
              0
            )),
            this.playButton.anchor.set(0.5),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !1),
            (this.created = !0);
        }),
        (d.prototype.resizeObjects = function () {
          this.created && (a.Utils.isOnDevice(this.game) || ((this.playButton.x = this.game.width / 2), (this.playButton.y = this.game.height / 2)));
        }),
        (d.prototype.playClick = function () {
          var a = this;
          this.game.tweens.remove(this.buttonTween);
          var b = this.game.add.tween(this.playButton.scale);
          b.to({ x: 0, y: 0 }, 350, Phaser.Easing.Back.In).onComplete.add(function () {
            a.game.state.start(a.config.nextState);
          }),
            b.start();
        }),
        (d.prototype.getScale = function () {
          return a.Utils.isOnDevice(this.game)
            ? this.game.width < 1.5 * b.FunnyGames.IdealWidth
              ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / b.FunnyGames.IdealWidth
            : ((this.game.width / 6) * 3) / b.FunnyGames.IdealWidth;
        }),
        (d.prototype.startAnimation = function () {}),
        (d.prototype.animateButton = function () {
          a.Utils.isOnDevice(this.game) ||
            (this.game.tweens.remove(this.buttonTween),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !0),
            (this.buttonTween = this.game.add.tween(this.playButton.scale)),
            this.buttonTween.to({ x: 1.14 * this.scaleFactor, y: 1.14 * this.scaleFactor }, 420, Phaser.Easing.Quadratic.InOut, !0, 500),
            this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this),
            this.buttonTween.start());
        }),
        (d.prototype.update = function () {
          this.background.update();
        }),
        (d.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (d.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton();
        }),
        (d.prototype.shutdown = function () {
          this.game.scale.onSizeChange.remove(this.resize, this);
        }),
        (d.Name = "funnySplashScreen"),
        (d.IdealWidth = 463),
        (d.MaxDots = 3),
        d
      );
    })(Phaser.State);
    b.Neutral = c;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (b) {
      function c() {
        b.call(this), (this.name = c.Name), (this.scaleFactor = 1), (this.created = !1), (this.preloadTexts = []), (this.preloadReady = !1), (this.dots = 1), (this.dotText = "."), (this.clicked = !1), (this.tId = 0);
      }
      return (
        __extends(c, b),
        (c.prototype.init = function (a, b) {
          (this.config = a), (this.background = b), this.config.preloadTexts && (this.preloadTexts = this.config.preloadTexts), this.game.scale.onSizeChange.add(this.resize, this);
        }),
        (c.prototype.preload = function () {
          this.game.add.existing(this.background),
            this.createObjects(),
            (this.scaleFactor = this.getScale()),
            this.resizeObjects(),
            this.startAnimation(),
            this.game.load.onLoadStart.add(this.onPreloadStart, this),
            this.game.load.onFileComplete.add(this.onPreloadedFile, this),
            this.game.load.onLoadComplete.add(this.onPreloadEnd, this),
            this.config.preloadHandler(),
            0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd();
        }),
        (c.prototype.onPreloadStart = function () {
          (this.t = Date.now()), this.preloadText.setText("Spelletje wordt geladen");
        }),
        (c.prototype.onPreloadedFile = function () {
          Date.now() - this.t > 2e3 && ((this.t = Date.now()), this.tId++, this.tId >= this.preloadTexts.length && (this.tId = 0)),
            this.dotText.length >= 3 ? (this.dotText = ".") : (this.dotText += "."),
            this.preloadText.setText("Spelletje wordt geladen");
        }),
        (c.prototype.onPreloadEnd = function () {
          var a = this;
          (this.preloadReady = !0),
            (this.preloadText.visible = !1),
            this.game.device.desktop
              ? this.game.time.events.add(Phaser.Timer.SECOND, function () {
                  void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.game.state.start(a.config.nextState);
                })
              : (this.game.input.onDown.add(function () {
                  a.clicked || ((a.clicked = !0), void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a));
                }, this),
                this.animateButton());
        }),
        (c.prototype.createObjects = function () {
          var a = this;
          (this.spine = this.game.add.spine(0, 0, "ss_splash")),
            (this.preloadText = this.game.add.text(this.game.width / 2, this.game.height / 2 + 150, "", { font: "Arial", fontSize: 40, fill: "#ffffff", fontWeight: "bold" })),
            this.preloadText.anchor.set(0.5),
            (this.playButton = this.game.add.image(this.game.width / 2, this.game.height / 2 + 55 * this.scaleFactor, "ss_play")),
            this.playButton.anchor.set(0.5),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !1),
            (this.playButton.inputEnabled = !0),
            this.playButton.events.onInputUp.add(function () {
              a.clicked || ((a.clicked = !0), void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a));
            }),
            (this.created = !0);
        }),
        (c.prototype.resizeObjects = function () {
          this.created &&
            ((this.spine.x = this.game.width / 2),
            (this.spine.y = this.game.height / 2),
            this.spine.scale.set(this.scaleFactor),
            (this.preloadText.x = this.game.width / 2),
            (this.preloadText.y = this.game.height / 2 + 150 * this.scaleFactor),
            this.preloadText.scale.set(this.scaleFactor),
            this.game.device.desktop || ((this.playButton.x = this.game.width / 2), (this.playButton.y = this.game.height / 2 + 55 * this.scaleFactor)));
        }),
        (c.prototype.playClick = function () {
          var a = this;
          this.game.tweens.remove(this.buttonTween);
          var b = this.game.add.tween(this.playButton.scale);
          b.to({ x: 0, y: 0 }, 350, Phaser.Easing.Back.In).onComplete.add(function () {
            a.game.state.start(a.config.nextState);
          }),
            b.start(),
            this.game.input.onDown.remove(this.playClick, this);
        }),
        (c.prototype.getScale = function () {
          return this.game.device.desktop
            ? this.game.width < 1.5 * a.FunnyGames.IdealWidth
              ? ((this.game.width / 6) * 4) / a.FunnyGames.IdealWidth
              : 1
            : this.game.width < this.game.height
            ? ((this.game.width / 6) * 4) / a.FunnyGames.IdealWidth
            : ((this.game.width / 6) * 3) / a.FunnyGames.IdealWidth;
        }),
        (c.prototype.startAnimation = function () {
          this.game.sound.touchLocked || this.game.sound.play("cheer"), this.spine.setAnimationByName(0, "animation", !1);
        }),
        (c.prototype.animateButton = function () {
          this.game.device.desktop ||
            (this.game.tweens.remove(this.buttonTween),
            this.playButton.scale.set(this.scaleFactor),
            (this.playButton.visible = !0),
            (this.buttonTween = this.game.add.tween(this.playButton.scale)),
            this.buttonTween.to({ x: 1.14 * this.scaleFactor, y: 1.14 * this.scaleFactor }, 420, Phaser.Easing.Quadratic.InOut, !0, 500),
            this.buttonTween.yoyo(!0).onComplete.add(this.animateButton, this),
            this.buttonTween.start());
        }),
        (c.prototype.update = function () {
          this.background.update();
        }),
        (c.prototype.loadUpdate = function () {
          this.background.update();
        }),
        (c.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor), this.resizeObjects(), this.created && this.preloadReady && this.animateButton();
        }),
        (c.prototype.shutdown = function () {
          b.prototype.shutdown.call(this),
            this.spine.destroy(!0),
            this.playButton.destroy(!0),
            this.background.destroy(!0),
            this.preloadText.destroy(!0),
            (this.spine = null),
            (this.playButton = null),
            (this.background = null),
            (this.preloadText = null),
            this.game.scale.onSizeChange.remove(this.resize, this),
            this.game.state.remove(a.Preloader.Name),
            this.game.state.remove(a.SplashPreloader.Name),
            this.game.state.remove(this.name);
        }),
        (c.Name = "speleSplashScreen"),
        (c.IdealWidth = 463),
        (c.MaxDots = 3),
        c
      );
    })(Phaser.State);
    a.Spele = b;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function (b) {
      function c() {
        b.call(this), (this.name = c.Name), (this.scaleFactor = 1), (this.created = !1), (this.tiles = []), (this.preloadReady = !1), (this.balls = []), (this.tId = 0), (this.dt = Date.now()), (this.ddt = Date.now());
      }
      return (
        __extends(c, b),
        (c.prototype.init = function (a, b) {
          (this.config = a), (this.background = b), this.game.scale.onSizeChange.add(this.resize, this), (this.gradientBitmap = this.game.make.bitmapData(this.game.width, this.game.height));
        }),
        (c.prototype.preload = function () {
          this.game.add.existing(this.background),
            this.createObjects(),
            (this.scaleFactor = this.getScale()),
            this.resizeObjects(),
            this.startAnimation(),
            this.game.load.onLoadStart.add(this.onPreloadStart, this),
            this.game.load.onFileComplete.add(this.onPreloadedFile, this),
            this.game.load.onLoadComplete.add(this.onPreloadEnd, this),
            this.config.preloadHandler(),
            0 === this.game.load.totalQueuedFiles() && this.onPreloadEnd();
        }),
        (c.prototype.onPreloadStart = function () {
          this.t = Date.now();
        }),
        (c.prototype.onPreloadedFile = function () {}),
        (c.prototype.onPreloadEnd = function () {
          (this.preloadReady = !0), this.animateButton();
        }),
        (c.prototype.createObjects = function () {
          for (var a = 0; a < 70; a++) {
            var b = Math.random() < 0.5 ? "square_empty" : "square_game_" + ("0" + ((32 * Math.random() + 1) | 0)).slice(-2),
              c = this.game.add.image(this.game.width / 2 + (80 * (a % 10) - 400), this.game.height / 2 + (80 * Math.floor(a / 10) - 280), "yp_atlas", b + ".png");
            (c.alpha = 0.4), this.tiles.push(c);
          }
          (this.gradient = this.game.add.sprite(0, 0, this.gradientBitmap)),
            (this.spine = this.game.add.spine(0, 0, "yp_splash")),
            this.spine.setMixByName("flyin", "idle", 0.2),
            (this.spine.visible = !1),
            (this.logo = this.game.add.sprite(0, 0, "yp_atlas", "yepi_logo.png")),
            this.logo.alignIn(this.world.bounds, Phaser.TOP_CENTER, 0, -20),
            (this.created = !0);
          var d = this.game.make.graphics(0, 0);
          d.beginFill(16631558, 1).drawCircle(0, 0, 20).endFill();
          for (var a = 0; a < 3; a++) {
            var e = this.game.add.sprite(0, 0, d.generateTexture());
            e.alignIn(this.game.world.bounds, Phaser.BOTTOM_CENTER, -50 + 50 * a, -20),
              e.scale.set(0),
              e.anchor.set(0.5),
              this.balls.push(e),
              this.game.add
                .tween(e.scale)
                .to({ x: 1, y: 1 }, 900, "Linear", !0, 300 * a, -1)
                .yoyo(!0)
                .delay(300);
          }
        }),
        (c.prototype.resizeObjects = function () {
          var a = this;
          if (this.created) {
            this.gradientBitmap.resize(this.game.width, this.game.height), this.gradientBitmap.context.clearRect(0, 0, this.game.width, this.game.height);
            var b = this.gradientBitmap.context.createRadialGradient(this.game.width / 2, this.game.height / 2, 0, this.game.width / 2, this.game.height / 2, this.game.height / 1.8);
            b.addColorStop(0, "rgba(0, 81, 125, 0)"),
              b.addColorStop(1, "rgba(0, 81, 125, 1)"),
              (this.gradientBitmap.context.fillStyle = b),
              this.gradientBitmap.context.fillRect(0, 0, this.game.width, this.game.height),
              (this.spine.x = this.game.width / 2),
              (this.spine.y = this.game.height / 2),
              this.spine.scale.set(this.scaleFactor),
              this.tiles.forEach(function (b, c) {
                (b.x = a.game.width / 2 + (80 * (c % 10) - 400)), (b.y = a.game.height / 2 + (80 * Math.floor(c / 10) - 280));
              });
          }
        }),
        (c.prototype.playClick = function () {
          this.game.state.start(this.config.nextState);
        }),
        (c.prototype.getScale = function () {
          return this.game.width < this.game.height ? ((this.game.width / 6) * 4) / a.FunnyGames.IdealWidth : ((this.game.width / 6) * 3) / a.FunnyGames.IdealWidth;
        }),
        (c.prototype.startAnimation = function () {}),
        (c.prototype.animateButton = function () {
          var a = this;
          (this.spine.visible = !0),
            this.spine.setAnimationByName(0, "flyin", !1),
            this.spine.addAnimationByName(0, "idle", !0, 0),
            this.game.tweens.removeAll(),
            this.balls.forEach(function (a) {
              a.parent.removeChild(a), a.destroy(!0);
            }),
            this.game.input.onUp.add(function () {
              void 0 !== a.config.mobilePlayClickhandler ? a.config.mobilePlayClickhandler() : a.playClick(), a.game.input.onDown.remove(a.playClick, a);
            });
        }),
        (c.prototype.update = function () {
          var a = Date.now() - this.dt;
          a > 200 && (this.tweenRandomItem(), (this.dt = Date.now()));
        }),
        (c.prototype.loadUpdate = function () {
          var a = Date.now() - this.ddt;
          a > 200 && ((this.ddt = Date.now()), this.tweenRandomItem());
        }),
        (c.prototype.tweenRandomItem = function () {
          var a = this.tiles[(Math.random() * this.tiles.length) | 0];
          this.game.add.tween(a).to({ alpha: 1 }, 1e3, Phaser.Easing.Linear.None, !0, 0, 0, !0);
        }),
        (c.prototype.resize = function () {
          (this.scaleFactor = this.getScale()), this.background.resize(this.scaleFactor), this.resizeObjects();
        }),
        (c.prototype.shutdown = function () {
          b.prototype.shutdown.call(this),
            this.spine.destroy(!0),
            this.background.destroy(!0),
            this.tiles.forEach(function (a) {
              a.destroy(!0);
            }),
            this.gradientBitmap.destroy(),
            this.gradient.destroy(!0),
            this.logo.destroy(!0),
            this.balls.forEach(function (a) {
              a.destroy(!0);
            }),
            (this.spine = null),
            (this.playButton = null),
            (this.background = null),
            (this.gradientBitmap = null),
            (this.gradient = null),
            (this.logo = null),
            (this.tiles = null),
            (this.balls = null),
            this.game.scale.onSizeChange.remove(this.resize, this),
            this.game.state.remove(a.Preloader.Name),
            this.game.state.remove(a.SplashPreloader.Name),
            this.game.state.remove(this.name);
        }),
        (c.Name = "yepiSplashScreen"),
        (c.IdealWidth = 463),
        (c.MaxDots = 3),
        c
      );
    })(Phaser.State);
    a.Yepi = b;
  })((b = a.SplashScreen || (a.SplashScreen = {})));
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b = null,
    c = (function () {
      function a() {}
      return (
        (a.has = function (a) {
          var c = a.lastIndexOf(".");
          if (c <= 0 || c >= a.length - 1) return !1;
          var d = a.lastIndexOf(".", c - 1);
          if (d <= 0 || d >= c - 1) return !1;
          var e = b[a.slice(c + 1)];
          return !!e && e.indexOf(" " + a.slice(d + 1, c) + " ") >= 0;
        }),
        (a.is = function (a) {
          var c = a.lastIndexOf(".");
          if (c <= 0 || c >= a.length - 1) return !1;
          var d = a.lastIndexOf(".", c - 1);
          if (d >= 0) return !1;
          var e = b[a.slice(c + 1)];
          return !!e && e.indexOf(" " + a.slice(0, c) + " ") >= 0;
        }),
        (a.get = function (a) {
          var c = a.lastIndexOf(".");
          if (c <= 0 || c >= a.length - 1) return null;
          var d = a.lastIndexOf(".", c - 1);
          if (d <= 0 || d >= c - 1) return null;
          var e = b[a.slice(c + 1)];
          return e ? (e.indexOf(" " + a.slice(d + 1, c) + " ") < 0 ? null : a.slice(d + 1)) : null;
        }),
        a
      );
    })(),
    d = (function () {
      function a() {}
      return (
        (a.setList = function (a) {
          b = a || {};
        }),
        (a.getDomain = function (a) {
          if (null === b) return null;
          var c = a.match(/\./g);
          if (c && c.length < 2) return a;
          var d = a.length - this.getTld(a).length - 1;
          return (d = a.lastIndexOf(".", d - 1) + 1), a.substring(d) || "";
        }),
        (a.getTld = function (a) {
          if (null === b) return null;
          var d = a.lastIndexOf("."),
            e = a.substring(d + 1);
          return b[e.toLowerCase()] ? c.get(a) || e : e;
        }),
        (a.KEY = "Domains"),
        a
      );
    })();
  a.Domain = d;
})(Fabrique || (Fabrique = {}));
var Fabrique;
!(function (a) {
  var b = (function () {
    function b() {}
    return (
      (b.getSourceSite = function (c) {
        void 0 === c && (c = !1);
        var d = document.referrer || window.location.host;
        c && (d = window.location.host), (d = decodeURIComponent(d)), b.isSpil() && (d = b.getReferrer(d)), (d = d.indexOf("://") > -1 ? d.split("/")[2] : d.split("/")[0]), (d = d.split(":")[0]);
        var e = a.Domain.getDomain(d);
        return null !== e ? e : (3 === d.split(".").length && (d = d.substr(d.indexOf(".") + 1)), d);
      }),
      (b.getReferrer = function (a) {
        return a.indexOf("?ref=") !== -1 ? a.substr(a.indexOf("?ref=") + 5) : a;
      }),
      (b.inIframe = function () {
        try {
          return window.self !== window.top;
        } catch (a) {
          return !0;
        }
      }),
      (b.getDomain = function (a) {
        var b = document.createElement("a");
        return (b.href = a), b.origin;
      }),
      (b.isOnDevice = function (a) {
        return !((!a.device.cordova && !a.device.crosswalk) || /(fbrq\.io)/.test(window.location.hostname));
      }),
      (b.isTc = function () {
        return /(teamcity\.ds\.orangegames\.com)/.test(window.location.host);
      }),
      (b.isSpil = function () {
        return document.referrer.indexOf("gameplayer.io") !== -1;
      }),
      (b.getRandomRange = function (a, b) {
        return (Math.random() * (b - a) + a) | 0;
      }),
      (b.intTimeToString = function (a) {
        var b = Math.floor(a / 3600),
          c = Math.floor((a % 3600) / 60),
          d = a % 60,
          e = b < 10 ? "0" + b : b.toString(),
          f = c < 10 ? "0" + c : c.toString(),
          g = d < 10 ? "0" + d : d.toString();
        return e + ":" + f + ":" + g;
      }),
      (b.ASSET_LOCATION = "//fbrq.io/orange-games-splash/assets/"),
      b
    );
  })();
  a.Utils = b;
})(Fabrique || (Fabrique = {}));
var CryptoJS =
  CryptoJS ||
  (function (a, b) {
    var c = {},
      d = (c.lib = {}),
      e = function () {},
      f = (d.Base = {
        extend: function (a) {
          e.prototype = this;
          var b = new e();
          return (
            a && b.mixIn(a),
            b.hasOwnProperty("init") ||
              (b.init = function () {
                b.$super.init.apply(this, arguments);
              }),
            (b.init.prototype = b),
            (b.$super = this),
            b
          );
        },
        create: function () {
          var a = this.extend();
          return a.init.apply(a, arguments), a;
        },
        init: function () {},
        mixIn: function (a) {
          for (var b in a) a.hasOwnProperty(b) && (this[b] = a[b]);
          a.hasOwnProperty("toString") && (this.toString = a.toString);
        },
        clone: function () {
          return this.init.prototype.extend(this);
        },
      }),
      g = (d.WordArray = f.extend({
        init: function (a, c) {
          (a = this.words = a || []), (this.sigBytes = c != b ? c : 4 * a.length);
        },
        toString: function (a) {
          return (a || i).stringify(this);
        },
        concat: function (a) {
          var b = this.words,
            c = a.words,
            d = this.sigBytes;
          if (((a = a.sigBytes), this.clamp(), d % 4)) for (var e = 0; a > e; e++) b[(d + e) >>> 2] |= ((c[e >>> 2] >>> (24 - 8 * (e % 4))) & 255) << (24 - 8 * ((d + e) % 4));
          else if (65535 < c.length) for (e = 0; a > e; e += 4) b[(d + e) >>> 2] = c[e >>> 2];
          else b.push.apply(b, c);
          return (this.sigBytes += a), this;
        },
        clamp: function () {
          var b = this.words,
            c = this.sigBytes;
          (b[c >>> 2] &= 4294967295 << (32 - 8 * (c % 4))), (b.length = a.ceil(c / 4));
        },
        clone: function () {
          var a = f.clone.call(this);
          return (a.words = this.words.slice(0)), a;
        },
        random: function (b) {
          for (var c = [], d = 0; b > d; d += 4) c.push((4294967296 * a.random()) | 0);
          return new g.init(c, b);
        },
      })),
      h = (c.enc = {}),
      i = (h.Hex = {
        stringify: function (a) {
          var b = a.words;
          a = a.sigBytes;
          for (var c = [], d = 0; a > d; d++) {
            var e = (b[d >>> 2] >>> (24 - 8 * (d % 4))) & 255;
            c.push((e >>> 4).toString(16)), c.push((15 & e).toString(16));
          }
          return c.join("");
        },
        parse: function (a) {
          for (var b = a.length, c = [], d = 0; b > d; d += 2) c[d >>> 3] |= parseInt(a.substr(d, 2), 16) << (24 - 4 * (d % 8));
          return new g.init(c, b / 2);
        },
      }),
      j = (h.Latin1 = {
        stringify: function (a) {
          var b = a.words;
          a = a.sigBytes;
          for (var c = [], d = 0; a > d; d++) c.push(String.fromCharCode((b[d >>> 2] >>> (24 - 8 * (d % 4))) & 255));
          return c.join("");
        },
        parse: function (a) {
          for (var b = a.length, c = [], d = 0; b > d; d++) c[d >>> 2] |= (255 & a.charCodeAt(d)) << (24 - 8 * (d % 4));
          return new g.init(c, b);
        },
      }),
      k = (h.Utf8 = {
        stringify: function (a) {
          try {
            return decodeURIComponent(escape(j.stringify(a)));
          } catch (a) {
            throw Error("Malformed UTF-8 data");
          }
        },
        parse: function (a) {
          return j.parse(unescape(encodeURIComponent(a)));
        },
      }),
      l = (d.BufferedBlockAlgorithm = f.extend({
        reset: function () {
          (this._data = new g.init()), (this._nDataBytes = 0);
        },
        _append: function (a) {
          "string" == typeof a && (a = k.parse(a)), this._data.concat(a), (this._nDataBytes += a.sigBytes);
        },
        _process: function (b) {
          var c = this._data,
            d = c.words,
            e = c.sigBytes,
            f = this.blockSize,
            h = e / (4 * f),
            h = b ? a.ceil(h) : a.max((0 | h) - this._minBufferSize, 0);
          if (((b = h * f), (e = a.min(4 * b, e)), b)) {
            for (var i = 0; b > i; i += f) this._doProcessBlock(d, i);
            (i = d.splice(0, b)), (c.sigBytes -= e);
          }
          return new g.init(i, e);
        },
        clone: function () {
          var a = f.clone.call(this);
          return (a._data = this._data.clone()), a;
        },
        _minBufferSize: 0,
      }));
    d.Hasher = l.extend({
      cfg: f.extend(),
      init: function (a) {
        (this.cfg = this.cfg.extend(a)), this.reset();
      },
      reset: function () {
        l.reset.call(this), this._doReset();
      },
      update: function (a) {
        return this._append(a), this._process(), this;
      },
      finalize: function (a) {
        return a && this._append(a), this._doFinalize();
      },
      blockSize: 16,
      _createHelper: function (a) {
        return function (b, c) {
          return new a.init(c).finalize(b);
        };
      },
      _createHmacHelper: function (a) {
        return function (b, c) {
          return new m.HMAC.init(a, c).finalize(b);
        };
      },
    });
    var m = (c.algo = {});
    return c;
  })(Math);
!(function (a) {
  for (
    var b = CryptoJS,
      c = b.lib,
      d = c.WordArray,
      e = c.Hasher,
      c = b.algo,
      f = [],
      g = [],
      h = function (a) {
        return (4294967296 * (a - (0 | a))) | 0;
      },
      i = 2,
      j = 0;
    64 > j;

  ) {
    var k;
    a: {
      k = i;
      for (var l = a.sqrt(k), m = 2; l >= m; m++)
        if (!(k % m)) {
          k = !1;
          break a;
        }
      k = !0;
    }
    k && (8 > j && (f[j] = h(a.pow(i, 0.5))), (g[j] = h(a.pow(i, 1 / 3))), j++), i++;
  }
  var n = [],
    c = (c.SHA256 = e.extend({
      _doReset: function () {
        this._hash = new d.init(f.slice(0));
      },
      _doProcessBlock: function (a, b) {
        for (var c = this._hash.words, d = c[0], e = c[1], f = c[2], h = c[3], i = c[4], j = c[5], k = c[6], l = c[7], m = 0; 64 > m; m++) {
          if (16 > m) n[m] = 0 | a[b + m];
          else {
            var o = n[m - 15],
              p = n[m - 2];
            n[m] = (((o << 25) | (o >>> 7)) ^ ((o << 14) | (o >>> 18)) ^ (o >>> 3)) + n[m - 7] + (((p << 15) | (p >>> 17)) ^ ((p << 13) | (p >>> 19)) ^ (p >>> 10)) + n[m - 16];
          }
          (o = l + (((i << 26) | (i >>> 6)) ^ ((i << 21) | (i >>> 11)) ^ ((i << 7) | (i >>> 25))) + ((i & j) ^ (~i & k)) + g[m] + n[m]),
            (p = (((d << 30) | (d >>> 2)) ^ ((d << 19) | (d >>> 13)) ^ ((d << 10) | (d >>> 22))) + ((d & e) ^ (d & f) ^ (e & f))),
            (l = k),
            (k = j),
            (j = i),
            (i = (h + o) | 0),
            (h = f),
            (f = e),
            (e = d),
            (d = (o + p) | 0);
        }
        (c[0] = (c[0] + d) | 0), (c[1] = (c[1] + e) | 0), (c[2] = (c[2] + f) | 0), (c[3] = (c[3] + h) | 0), (c[4] = (c[4] + i) | 0), (c[5] = (c[5] + j) | 0), (c[6] = (c[6] + k) | 0), (c[7] = (c[7] + l) | 0);
      },
      _doFinalize: function () {
        var b = this._data,
          c = b.words,
          d = 8 * this._nDataBytes,
          e = 8 * b.sigBytes;
        return (c[e >>> 5] |= 128 << (24 - (e % 32))), (c[(((e + 64) >>> 9) << 4) + 14] = a.floor(d / 4294967296)), (c[(((e + 64) >>> 9) << 4) + 15] = d), (b.sigBytes = 4 * c.length), this._process(), this._hash;
      },
      clone: function () {
        var a = e.clone.call(this);
        return (a._hash = this._hash.clone()), a;
      },
    }));
  (b.SHA256 = e._createHelper(c)), (b.HmacSHA256 = e._createHmacHelper(c));
})(Math),
  (function () {
    var a = CryptoJS,
      b = a.enc.Utf8;
    a.algo.HMAC = a.lib.Base.extend({
      init: function (a, c) {
        (a = this._hasher = new a.init()), "string" == typeof c && (c = b.parse(c));
        var d = a.blockSize,
          e = 4 * d;
        c.sigBytes > e && (c = a.finalize(c)), c.clamp();
        for (var f = (this._oKey = c.clone()), g = (this._iKey = c.clone()), h = f.words, i = g.words, j = 0; d > j; j++) (h[j] ^= 1549556828), (i[j] ^= 909522486);
        (f.sigBytes = g.sigBytes = e), this.reset();
      },
      reset: function () {
        var a = this._hasher;
        a.reset(), a.update(this._iKey);
      },
      update: function (a) {
        return this._hasher.update(a), this;
      },
      finalize: function (a) {
        var b = this._hasher;
        return (a = b.finalize(a)), b.reset(), b.finalize(this._oKey.clone().concat(a));
      },
    });
  })(),
  (function () {
    var a = CryptoJS,
      b = a.lib.WordArray;
    a.enc.Base64 = {
      stringify: function (a) {
        var b = a.words,
          c = a.sigBytes,
          d = this._map;
        a.clamp(), (a = []);
        for (var e = 0; c > e; e += 3)
          for (var f = (((b[e >>> 2] >>> (24 - 8 * (e % 4))) & 255) << 16) | (((b[(e + 1) >>> 2] >>> (24 - 8 * ((e + 1) % 4))) & 255) << 8) | ((b[(e + 2) >>> 2] >>> (24 - 8 * ((e + 2) % 4))) & 255), g = 0; 4 > g && c > e + 0.75 * g; g++)
            a.push(d.charAt((f >>> (6 * (3 - g))) & 63));
        if ((b = d.charAt(64))) for (; a.length % 4; ) a.push(b);
        return a.join("");
      },
      parse: function (a) {
        var c = a.length,
          d = this._map,
          e = d.charAt(64);
        e && ((e = a.indexOf(e)), -1 != e && (c = e));
        for (var e = [], f = 0, g = 0; c > g; g++)
          if (g % 4) {
            var h = d.indexOf(a.charAt(g - 1)) << (2 * (g % 4)),
              i = d.indexOf(a.charAt(g)) >>> (6 - 2 * (g % 4));
            (e[f >>> 2] |= (h | i) << (24 - 8 * (f % 4))), f++;
          }
        return b.create(e, f);
      },
      _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    };
  })();
var GA;
!(function (a) {
  !(function (a) {
    (a[(a.ios = 0)] = "ios"),
      (a[(a.android = 1)] = "android"),
      (a[(a.windows = 2)] = "windows"),
      (a[(a.windows_phone = 3)] = "windows_phone"),
      (a[(a.blackberry = 4)] = "blackberry"),
      (a[(a.roku = 5)] = "roku"),
      (a[(a.tizen = 6)] = "tizen"),
      (a[(a.nacl = 7)] = "nacl"),
      (a[(a.mac_osx = 8)] = "mac_osx"),
      (a[(a.webplayer = 9)] = "webplayer");
  })(a.Platform || (a.Platform = {})),
    a.Platform,
    !(function (a) {
      (a[(a.male = 0)] = "male"), (a[(a.female = 1)] = "female");
    })(a.Gender || (a.Gender = {})),
    a.Gender;
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = /^[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}$/,
      c = (function () {
        function a(a, c, d, e, f, g) {
          if (((this.category = 1), (this.transaction_num = 0), !a || null === a.match(b))) throw new Error("Invalid event_id supplied for BusinessEvent");
          if (((this.event_id = a), (this.amount = c), !d || null === d.match(/^[A-Z]{3}$/))) throw new Error("Invalid currency supplied for BusinessEvent");
          if (((this.currency = d), (this.transaction_num = e), f)) {
            if (f.length > 32) throw new Error("A too long cart_type was supplied, should be max 32 characters");
            this.cart_type = f;
          }
          void 0 !== g && (this.receipt_info = g);
        }
        return a;
      })();
    a.Business = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = /^[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}(:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}){0,4}$/,
      c = (function () {
        function a(a, c) {
          if (((this.category = 0), null === a.match(b))) throw new Error("Invalid event_id supplied for DesignEvent");
          (this.event_id = a), void 0 !== c && (this.value = c);
        }
        return a;
      })();
    a.Design = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    !(function (a) {
      (a[(a.design = 0)] = "design"),
        (a[(a.business = 1)] = "business"),
        (a[(a.error = 2)] = "error"),
        (a[(a.user = 3)] = "user"),
        (a[(a.session_end = 4)] = "session_end"),
        (a[(a.progression = 5)] = "progression"),
        (a[(a.resource = 6)] = "resource");
    })(a.Category || (a.Category = {})),
      a.Category;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    !(function (a) {
      (a[(a.debug = 0)] = "debug"), (a[(a.info = 1)] = "info"), (a[(a.warning = 2)] = "warning"), (a[(a.error = 3)] = "error"), (a[(a.critical = 4)] = "critical");
    })(a.ErrorSeverity || (a.ErrorSeverity = {}));
    var b = a.ErrorSeverity,
      c = (function () {
        function a(a, c) {
          (this.category = 2), (this.message = ""), (this.severity = b[a]), void 0 !== c && (this.message = c.substr(0, 8192));
        }
        return a;
      })();
    a.Exception = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a() {}
      return a;
    })();
    a.InitResponse = b;
    var c = (function () {
      function a(a) {
        this.data = a;
      }
      return (
        (a.prototype.toString = function () {
          return JSON.stringify(this.data);
        }),
        a
      );
    })();
    a.Init = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = /^(Start|Fail|Complete):[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}(:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}){0,2}$/,
      c = (function () {
        function a(a, c, d) {
          if (((this.category = 5), null === a.match(b))) throw new Error("Invalid event_id supplied for ProgressionEvent");
          (this.event_id = a), void 0 !== c && (this.attempt_num = c), void 0 !== d && (this.score = d);
        }
        return a;
      })();
    a.Progression = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = /^(Sink|Source):[A-Za-z]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}:[A-Za-z0-9\\s\\-_\\.\\(\\)\\!\\?]{1,64}/,
      c = (function () {
        function a(a, c) {
          if (((this.category = 6), null === a.match(b))) throw new Error("Invalid event_id supplied for ResourceEvent");
          (this.event_id = a), (this.amount = c);
        }
        return a;
      })();
    a.Resource = c;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a(a) {
        (this.category = 4), (this.length = 0), (this.length = a);
      }
      return a;
    })();
    a.SessionEnd = b;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a() {
        this.category = 3;
      }
      return a;
    })();
    a.User = b;
  })((b = a.Events || (a.Events = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  function b() {
    return null === c.instance && (c.instance = new c()), c.instance;
  }
  a.getInstance = b;
  var c = (function () {
    function b() {
      (this.sessionId = a.Utils.createUniqueId()), (this.messageQueue = new a.Utils.MessageQueue()), (this.enabled = !1), (this.initProcessed = !1), (this.timeoutId = 0), (this.timeOffset = 0);
    }
    return (
      (b.prototype.init = function (c, d, e, f) {
        var g = this;
        if (null === b.instance) throw new Error("No instance Available!");
        (this.gameKey = c), (this.secretKey = d), (this.build = e), (this.user = f), this.incrementSessionNum(f);
        var h = new a.Events.Init(a.Utils.getBaseAnnotations());
        return (
          this.sendEvent(h.toString(), "init", function (a) {
            (g.initProcessed = !0), a.enabled === !0 && ((g.enabled = !0), (g.timeOffset = ((Date.now() / 1e3) | 0) - a.server_ts));
          }),
          this.scheduleSendData(b.SCHEDULE_TIME),
          window.addEventListener("beforeunload", function () {
            g.sendData();
          }),
          this
        );
      }),
      (b.prototype.incrementSessionNum = function (b) {
        var c = a.Utils.LocalStorage.getItem(b.user_id);
        c ? a.Utils.LocalStorage.setItem(b.user_id, (parseInt(c) + 1).toString()) : ((c = "1"), a.Utils.LocalStorage.setItem(b.user_id, c));
      }),
      (b.prototype.addEvent = function (c) {
        if (null === b.instance) throw new Error("No instance Available!");
        var d = new a.Utils.Message(c, a.Utils.getDefaultAnnotations(this.user, this.sessionId, this.build, this.timeOffset));
        return this.messageQueue.push(d), this;
      }),
      (b.prototype.sendData = function () {
        if (this.initProcessed === !1) return this.scheduleSendData(1e3), this;
        if (this.enabled === !1) return this;
        if (null === b.instance) throw new Error("No instance Available!");
        for (var a = [], c = ""; this.messageQueue.length > 0; ) {
          var d = this.messageQueue.pop();
          a.push(d.data);
        }
        if (0 === a.length) return this.scheduleSendData(b.SCHEDULE_TIME), this;
        try {
          c = JSON.stringify(a);
        } catch (a) {}
        return this.sendEvent(c, "events"), this.scheduleSendData(b.SCHEDULE_TIME), this;
      }),
      (b.prototype.scheduleSendData = function (a) {
        var b = this;
        clearTimeout(this.timeoutId),
          (this.timeoutId = setTimeout(function () {
            b.sendData();
          }, a));
      }),
      (b.prototype.sendEvent = function (c, d, e) {
        if ((void 0 === e && (e = null), null === b.instance && null === this.gameKey)) throw new Error("No instance Available!");
        if (!(c.length < 1)) {
          var f = CryptoJS.HmacSHA256(c, this.secretKey),
            g = CryptoJS.enc.Base64.stringify(f),
            h = b.API_URL + this.gameKey + "/" + d;
          a.Utils.postRequest(h, c, g, function (a) {
            if ((a.success === !1 && window.console && void 0, null != e)) {
              var b = "";
              try {
                b = JSON.parse(a.message);
              } catch (a) {}
              e(b);
            }
          });
        }
      }),
      (b.SCHEDULE_TIME = 15e3),
      (b.SDK_VERSION = "rest api v2"),
      (b.API_URL = ("https:" === document.location.protocol ? "https" : "http") + "://api.gameanalytics.com/v2/"),
      (b.instance = null),
      b
    );
  })();
  a.GameAnalytics = c;
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b = (function () {
    function b(b, c, d, e) {
      if (((this.user_id = ""), b)) this.user_id = b;
      else {
        var f = a.Utils.LocalStorage.getItem("user");
        this.user_id = f || a.Utils.createUniqueUserId();
      }
      c && c.length > 0 && ((this.facebook_id = c), (this.user_id = c)), a.Utils.LocalStorage.setItem("user", this.user_id), (1 !== d && 0 !== d) || (this.gender = d), e && e.toString().match(/^[0-9]{4}$/gi) && (this.birth_year = e);
    }
    return b;
  })();
  a.User = b;
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (b) {
    function c(b, c, d, f) {
      var g = {
        sdk_version: a.GameAnalytics.SDK_VERSION,
        platform: a.Platform[2],
        os_version: a.Platform[2] + " 8",
        device: "unknown",
        v: 2,
        user_id: b.user_id,
        client_ts: ((Date.now() / 1e3) | 0) + f,
        manufacturer: "unknown",
        session_id: c,
        session_num: e(b.user_id),
        build: d,
      };
      b.facebook_id && (g.facebook_id = b.facebook_id), (0 !== b.gender && 1 !== b.gender) || (g.gender = a.Gender[b.gender]), b.birth_year && (g.birth_year = b.birth_year);
      var h = navigator.userAgent;
      return (
        h.match(/iPad|iPod|iPhone/i)
          ? ((g.platform = a.Platform[0]), (g.device = h.match(/iPad|iPod|iPhone/i)[0]), (g.manufacturer = "Apple"), (g.os_version = a.Platform[0] + " " + h.match(/OS (\b[0-9]+_[0-9]+(?:_[0-9]+)?\b)/)[1].replace(/_/gi, ".")))
          : h.match(/Android/i)
          ? ((g.platform = a.Platform[1]), (g.device = h.match(/Mobile/i) ? "Phone" : "Tablet"), (g.os_version = a.Platform[1] + " " + h.match(/Android (\d+(?:\.\d+)+);/)[1]))
          : h.match(/Windows Phone/i) && ((g.platform = a.Platform[2]), (g.device = "Windows Phone"), (g.os_version = a.Platform[2] + " " + h.match(/Phone (\d+(?:\.\d+)+);/)[1])),
        g
      );
    }
    function d() {
      var b = { sdk_version: a.GameAnalytics.SDK_VERSION, platform: "unknown", os_version: "unknown" },
        c = navigator.userAgent;
      return (
        c.match(/iPad|iPod|iPhone/i)
          ? ((b.platform = a.Platform[0]), (b.os_version = a.Platform[0] + " " + c.match(/OS (\b[0-9]+_[0-9]+(?:_[0-9]+)?\b)/)[1].replace(/_/gi, ".")))
          : c.match(/Android/i)
          ? ((b.platform = a.Platform[1]), (b.os_version = a.Platform[1] + " " + c.match(/Android (\d+(?:\.\d+)+);/)[1]))
          : c.match(/Windows Phone/i) && ((b.platform = a.Platform[2]), (b.os_version = a.Platform[2] + " " + c.match(/Phone (\d+(?:\.\d+)+);/)[1])),
        b
      );
    }
    function e(a) {
      var c = b.LocalStorage.getItem(a);
      return c ? parseInt(c) : 1;
    }
    (b.getDefaultAnnotations = c), (b.getBaseAnnotations = d);
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a() {}
      return (
        (a.getItem = function (b) {
          return a.Available ? localStorage.getItem(a.CacheKey + b) : void 0;
        }),
        (a.setItem = function (b, c) {
          a.Available && localStorage.setItem(a.CacheKey + b, c);
        }),
        (a.Available = !1),
        (a.CacheKey = "GA:"),
        a
      );
    })();
    a.LocalStorage = b;
    try {
      "object" == typeof localStorage && (localStorage.setItem("testingLocalStorage", "yes"), localStorage.removeItem("testingLocalStorage"), (b.Available = !0));
    } catch (a) {}
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (b) {
    var c = (function () {
      function b(a, b) {
        (this.event = a), (this.annotations = b);
      }
      return (
        Object.defineProperty(b.prototype, "data", {
          get: function () {
            for (var b in this.event) this.event.hasOwnProperty(b) && ("category" === b ? (this.annotations[b] = a.Events.Category[this.event[b]]) : (this.annotations[b] = this.event[b]));
            return this.annotations;
          },
          enumerable: !0,
          configurable: !0,
        }),
        b
      );
    })();
    b.Message = c;
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    var b = (function () {
      function a() {
        (this.queue = []), this.load();
      }
      return (
        (a.prototype.push = function (a) {
          this.queue.push(a);
        }),
        (a.prototype.pop = function () {
          return this.queue.pop();
        }),
        Object.defineProperty(a.prototype, "length", {
          get: function () {
            return this.queue.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (a.prototype.save = function () {}),
        (a.prototype.load = function () {}),
        a
      );
    })();
    a.MessageQueue = b;
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    function b(a, b, c, d) {
      var e;
      if (!window.XMLHttpRequest) return void d({ success: !1, message: "Error: Unable to send request, XMLHttpRequest not supported" });
      (e = new XMLHttpRequest()),
        (e.onreadystatechange = function () {
          4 == e.readyState && (200 === e.status ? d({ success: !0, message: e.responseText }) : e.status > 0 && d({ success: !1, message: "Error: There was a problem with the request: status " + e.status }));
        });
      try {
        e.open("POST", a, !0), e.setRequestHeader("Authorization", c), e.setRequestHeader("Content-Type", "application/json"), e.send(b);
      } catch (a) {
        d({ success: !1, message: "Error: Unable to send request, CORS not allowed." });
      }
    }
    var c = (function () {
      function a() {
        (this.success = !1), (this.message = "");
      }
      return a;
    })();
    (a.Response = c), (a.postRequest = b);
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var GA;
!(function (a) {
  var b;
  !(function (a) {
    function b() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (a) {
        var b = (16 * Math.random()) | 0,
          c = "x" == a ? b : (3 & b) | 8;
        return c.toString(16);
      });
    }
    function c() {
      return b();
    }
    (a.createUniqueId = b), (a.createUniqueUserId = c);
  })((b = a.Utils || (a.Utils = {})));
})(GA || (GA = {}));
var __extends =
    (this && this.__extends) ||
    function (a, b) {
      function c() {
        this.constructor = a;
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      a.prototype = null === b ? Object.create(b) : ((c.prototype = b.prototype), new c());
    },
  Achievements = (function () {
    function a(a, b, c, d) {
      (this.game = a.game), (this.sender = a), (this.count = d), (this.borderGroup = this.game.add.group()), (this.achievementsGroup = this.game.add.group()), (this.grindGroup = b), (this.frameGroup = c);
    }
    return (
      (a.prototype.createSaveAchievement = function () {
        for (var a = 0; a < Game.save.achievement.length; ++a) {
          var b = Game.save.achievement[a];
          this.createAchievement(b.text, b.sprite, !1, !1);
        }
        1 == Game.save.mapVisible && (this.borderGroup.y = 200);
      }),
      (a.prototype.resetAchievements = function () {
        void 0 != this.bkgTop && (this.bkgTop.height = this.game.world.height - this.grindGroup.height + 10), void 0 != this.scrollBar && (this.scrollBar.resetSize(), this.setVisible());
      }),
      (a.prototype.createAchievement = function (a, b, c, d) {
        var e = this;
        if ((void 0 === c && (c = !0), void 0 === d && (d = !0), void 0 != Game.save.achievementGrind && d)) for (var f = 0; f < Game.save.achievementGrind.split(",").length; ++f) if (b == Game.save.achievementGrind.split(",")[f]) return;
        if (((Game.save.achievementGrind += b + ","), 0 == this.borderGroup.length)) {
          var g = GameAPI.createText(this.game, 0, 0, "grincraftstroke25zheltyi", "Achievements", 25, 16766720, !0);
          (g.x = g.width / 2 + this.grindGroup.x), (g.y = 405);
          var h = this.game.add.sprite(this.grindGroup.x - 30, 380, Game.KEY, "cube.png");
          (h.width = 295),
            (h.height = 37),
            (this.bkgTop = this.game.add.sprite(this.grindGroup.x - 30, 390, Game.KEY, "cube.png")),
            (this.bkgTop.width = 295),
            (this.bkgTop.height = this.bkgTop.height = this.game.world.height - this.grindGroup.height + 10),
            this.borderGroup.add(this.bkgTop),
            (this.achievementsGroup.y = 418),
            (this.achievementsGroup.x = this.grindGroup.x),
            this.borderGroup.add(this.achievementsGroup),
            this.addAchievement(a, b, d),
            Services.isDesktop() ? (this.scrollBar = new ScrollBar(this.game, this.achievementsGroup, 20, 410, 10)) : (this.scrollBar = new ScrollBar(this.game, this.achievementsGroup, 20, 410, 10, 30, 29)),
            this.scrollBar.addMoveCallback(function () {
              e.setVisible();
            }),
            this.borderGroup.add(h),
            this.borderGroup.add(g),
            this.borderGroup.add(this.scrollBar.scrollBarGroup),
            this.scrollBar.resetSize();
        } else
          this.achievementsGroup.forEach(function (a) {
            a.y += 54;
          }, this),
            this.addAchievement(a, b, d),
            this.scrollBar.resetSize(),
            this.setVisible();
        if (c) {
          var i = new AchievementInfo();
          (i.text = a), (i.sprite = b), Game.save.achievement.push(i);
        }
      }),
      (a.prototype.addAchievement = function (a, b, c) {
        var d = this.game.add.group();
        this.achievementsGroup.add(d);
        var e = this.game.add.sprite(0, 0, Game.KEY, "bkgach.png");
        e.anchor.setTo(0.5, 0.5), (e.width = 200), (e.height = 50), d.add(e), (d.x += e.width / 2 - 5), (d.y = 25);
        var f = GameAPI.createText(this.game, 0, 0, "grincraftstroke12zheltyi", a, 12, 16766720, !1);
        f.setText(GameAPI.setWidthTextBTM(f, 110)), (f.x = 13), d.add(f);
        var e = this.game.add.sprite(0, 0, Game.KEY, "bracket.png");
        e.anchor.setTo(0.5, 0.5), (e.width = 20), (e.height = 35), d.add(e), (e.x = 85), (e.y = 0);
        var e = this.game.add.sprite(0, 0, Game.KEY, "bracket.png");
        e.anchor.setTo(0.5, 0.5), (e.angle = 180), (e.width = 20), (e.height = 35), d.add(e), (e.x = -85), (e.y = 0);
        var e = this.game.add.sprite(0, 0, Game.KEY, b);
        e.anchor.setTo(0.5, 0.5),
          (e.width -= 23),
          (e.height -= 23),
          d.add(e),
          (e.x = -65),
          (e.y = 0),
          c &&
            (this.sender.particleCount > 2 &&
              1 != this.sender.isAutomated &&
              (void 0 != this.leftEmitter && this.leftEmitter.destroy(!0),
              void 0 != this.rightEmitter && this.rightEmitter.destroy(!0),
              (this.rightEmitter = this.addEmitter(200, 440 + this.borderGroup.y)),
              (this.leftEmitter = this.addEmitter(30, 440 + this.borderGroup.y))),
            Game.music.addSound("achieve", "achieve"));
      }),
      (a.prototype.addEmitter = function (a, b) {
        var c = this.game.add.emitter(a, b, 100);
        return c.makeParticles(Game.KEY, "goldBlock.png"), (c.gravity = 0), (c.maxParticleScale = 0.1), (c.minParticleScale = 0.1), c.start(!0, 1500, 50, this.sender.particleCount), this.frameGroup.add(c), c;
      }),
      (a.prototype.setVisible = function () {
        var a = this;
        this.achievementsGroup.forEach(function (b) {
          b.y + a.achievementsGroup.y < 410 ? (b.visible = !1) : (b.visible = !0);
        }, this);
      }),
      a
    );
  })(),
  CraftItem = (function () {
    function a(a, b, c, d, e, f, g) {
      (this.isMerge = !0),
        (this.isAchievement = !1),
        (this.isCraft = !1),
        (this._count = 0),
        (this.countAutocraft = 0),
        (this.timerAutocraft = null),
        (this.game = a.game),
        (this.sender = a),
        (this.mainGrinds = b),
        (this.mainGrinders = c),
        (this.mainCrafters = d),
        (this.widthItem = e),
        (this.heightItem = f),
        (this.mainCrafters = d),
        (this.worldItems = g),
        (this.adTimer = new AdTimer(this.game));
    }
    return (
      Object.defineProperty(a.prototype, "count", {
        get: function () {
          return this._count;
        },
        set: function (a) {
          (this._count = a),
            a < 1
              ? (this.countText.visible = !1)
              : (a < 1e5 && this.countText.setText(Math.floor(a).toString()),
                a > 1e5 && this.countText.setText("99999"),
                (this.countText.y = this.bckblack.height / 2 - 0.2 * this.bckblack.height),
                (this.countText.x = this.bckblack.width / 2 - this.countText.width / 2 - (this.bckblack.width / 2) * 0.1),
                (this.countText.visible = this.isMerge));
        },
        enumerable: !0,
        configurable: !0,
      }),
      (a.prototype.createCube = function (a, b, c, d) {
        var e = this.game.add.group(),
          f = this.game.add.sprite(0, 0, Game.KEY, "btnDown.png");
        f.anchor.setTo(0.5, 0.5), (f.width = this.widthItem), (f.height = this.heightItem), e.add(f), (this.bckblack = f);
        var f = this.game.add.sprite(0, 0, Game.KEY, "redgrinder.png");
        f.anchor.setTo(0.5, 0.5), (f.width = this.widthItem), (f.height = this.heightItem), (f.alpha = 0.5), (f.visible = !1), e.add(f), (this.bckred = f);
        var f = this.game.add.sprite(0, 0, Game.KEY, "btnUp.png");
        f.anchor.setTo(0.5, 0.5), (f.width = this.widthItem), (f.height = this.heightItem), (f.visible = !1), e.add(f), (this.bckgray = f);
        var f = this.game.add.sprite(0, 0, Game.KEY, "redgrinder.png");
        f.anchor.setTo(0.5, 0.5), (f.width = this.widthItem), (f.height = this.heightItem), (f.alpha = 0.5), (f.visible = !1), e.add(f), (this.bckredup = f), (this.isMerge = this.isMerge);
        var g = this.game.add.sprite(0, 0, Game.KEY, a[3]);
        if (
          (g.anchor.setTo(0.5, 0.5),
          (g.width += this.widthItem - 55),
          (g.height += this.heightItem - 55),
          e.add(g),
          (g.inputEnabled = !0),
          (g.hitArea = new Phaser.Rectangle(-25, -25, 50, 50)),
          g.events.onInputUp.add(this.onDownItem, this),
          Services.isDesktop() ? (g.events.onInputOver.add(this.timerItemOver, this), g.events.onInputOut.add(this.timerItemOut, this)) : g.events.onInputDown.add(this.timerItemOver, this),
          (this.sprite = g),
          (this.name = a[2].split("=")[0]),
          (this.itemsForCraft = a[0].split(",")),
          (this.eternalItemsForCraft = a[1].split(",")),
          ((1 == this.eternalItemsForCraft.length && void 0 == this.eternalItemsForCraft[0]) || "nothing" == this.eternalItemsForCraft[0] || "" == this.eternalItemsForCraft[0]) && (this.eternalItemsForCraft = []),
          "nothing" == this.itemsForCraft[0].split("=")[0] && ((this.itemsForCraft = []), this.eternalItemsForCraft.length > 0 && (this.eternalItemsForCraft = [this.eternalItemsForCraft[0]])),
          this.eternalItemsForCraft.length > 0)
        )
          for (var h = this.eternalItemsForCraft[0].split(" ")[1], i = 1; i < this.eternalItemsForCraft.length; ++i)
            if (2 == this.eternalItemsForCraft[i].split(" ").length && this.eternalItemsForCraft[i].split(" ")[1] == h) {
              this.eternalItemsForCraft = [this.eternalItemsForCraft[0]];
              break;
            }
        return (
          (this.hint = a[8]),
          (this.path = a[3]),
          (this.ability = a[7].split(",")),
          (this.tag = a[4]),
          (this.achievement = a[6]),
          Services.isDesktop() ? (this.countText = GameAPI.createText(this.game, 0, 0, "grincraftstroke12white", "", 12)) : (this.countText = GameAPI.createText(this.game, 0, 0, "grincraftstroke25white", "", 24)),
          (this.countadd = +a[2].split("=")[1]),
          (this.count = c),
          (this.isAchievement = d),
          (this.group = e),
          "nothing=0" != a[0] || "navigateToUrl " == a[7].substring(0, 14) || this.isMerge || (this.group.visible = !1),
          e.add(this.countText),
          b.add(e),
          this.worldItems.push(this),
          e
        );
      }),
      (a.prototype.timerItemOver = function (a, b) {
        (this.sender.itemName = a.frameName),
          this.sender.isPaused || this.sender.isClick || (void 0 != this.sender.timerHint && null != this.sender.timerHint) || (this.sender.timerHint = this.game.time.events.add(1 * Phaser.Timer.SECOND, this.onOverItem, this));
      }),
      (a.prototype.timerItemOut = function (a, b) {
        (this.sender.itemName = ""), this.onOutItem();
      }),
      (a.prototype.onOverItem = function () {
        var a = this;
        if (this.sender.itemName == this.sprite.frameName && null == this.sender.hintGroup) {
          (this.sender.itemHint = this), (this.sender.hintGroup = this.game.add.group());
          var b = this.game.add.sprite(0, 0, Game.KEY, "cropedShadow.png");
          this.sender.hintGroup.add(b);
          var c = this.game.add.sprite(0, 0, Game.KEY, "bkgGrind.png");
          c.anchor.setTo(0.5, 0.5), (c.width = 55 * this.itemsForCraft.length + 20 + 55 * this.eternalItemsForCraft.length), (c.height = 70), this.sender.hintGroup.add(c);
          var d = GameAPI.createText(this.game, 15, 15, "grincraftstroke12white", this.name, 12);
          d.setText(GameAPI.setWidthTextBTM(d, c.width)), this.sender.hintGroup.add(d), d.width > c.width && (c.width = d.width + 10);
          var e = -c.width / 2 + 30;
          d.x = e + d.width / 2 - 25;
          var f = GameAPI.createText(this.game, 15, 15, "grincraft12323232", this.hint, 12);
          f.anchor.setTo(0.5, 0.5), (f.x = -f.width), f.setText(GameAPI.setWidthTextBTM(f, c.width)), this.sender.hintGroup.add(f), (f.x = e + f.width / 2 - 25), (c.height += d.height + 5), (c.height += f.height + 5), (d.y -= c.height / 2);
          var g = d.y + d.height / 2 + 30,
            h = g;
          f.y += g + 20 + f.height / 2;
          for (var i = 0; i < this.eternalItemsForCraft.length; ++i) {
            var j;
            if (
              (this.worldItems.forEach(function (b) {
                a.eternalItemsForCraft[i] == b.name && (b.count < 1 && (0 == b.bckgray.visible ? (b.bckred.visible = !0) : (b.bckredup.visible = !0)), (j = b.path));
              }, this),
              "nothing" != j && void 0 != j)
            ) {
              var k = this.game.add.sprite(0, 0, Game.KEY, "bkgrey.png");
              k.anchor.setTo(0.5, 0.5), (k.width = 50), (k.height = 50), (k.x = e), (k.y = h), this.sender.hintGroup.add(k);
              var k = this.game.add.sprite(0, 0, Game.KEY, j);
              k.anchor.setTo(0.5, 0.5), (k.width -= 5), (k.height -= 5), (k.x = e), (k.y = h), this.sender.hintGroup.add(k), (e += 55);
            }
          }
          for (var i = 0; i < this.itemsForCraft.length; ++i) {
            var j, l;
            if (
              (this.worldItems.forEach(function (b) {
                a.itemsForCraft[i].split("=")[0] == b.name && ((j = b.path), (l = a.itemsForCraft[i].split("=")[1]), b.count < +l && (0 == b.bckgray.visible ? (b.bckred.visible = !0) : (b.bckredup.visible = !0)));
              }, this),
              "nothing" != j && void 0 != j)
            ) {
              var k = this.game.add.sprite(0, 0, Game.KEY, "bkgrey.png");
              k.anchor.setTo(0.5, 0.5), (k.width = 50), (k.height = 50), (k.x = e), (k.y = h), this.sender.hintGroup.add(k);
              var k = this.game.add.sprite(0, 0, Game.KEY, j);
              k.anchor.setTo(0.5, 0.5), (k.width -= 5), (k.height -= 5), (k.x = e), (k.y = h), this.sender.hintGroup.add(k);
              var d = GameAPI.createText(this.game, 15, 15, "grincraftstroke12white", l, 12);
              (d.x = e + 20), (d.y = h + 17), this.sender.hintGroup.add(d), (e += 55);
            }
          }
          (this.sender.hintGroup.x = this.group.x + this.sender.craftGroup.x + this.sender.arounCraftGroup.x),
            (this.sender.hintGroup.y = this.group.y + this.sender.craftGroup.y),
            (this.sender.hintGroup.y += this.sender.hintGroup.height / 2 + this.heightItem / 2),
            this.game.input.addMoveCallback(this.sender.mouseDrag, this.sender),
            (b.x = -c.width / 2),
            (b.y = -c.height / 2),
            (b.width = c.width + 10),
            (b.height = c.height + 10);
        }
      }),
      (a.prototype.onOutItem = function () {
        (this.sender.timerHint = null),
          void 0 != this.sender.hintGroup &&
            null != this.sender.hintGroup &&
            (this.game.input.deleteMoveCallback(this.sender.mouseDrag, this.sender),
            this.sender.hintGroup.destroy(!0),
            (this.sender.hintGroup = null),
            this.worldItems.forEach(function (a) {
              (a.bckred.visible = !1), (a.bckredup.visible = !1);
            }, this));
      }),
      (a.prototype.onDownItem = function (a, b, c) {
        var d = this;
        if ((Services.isDesktop() || ((this.sender.itemName = ""), this.onOutItem()), 0 != this.bckgray.visible && !this.sender.isPaused && !this.sender.isClick)) {
          var e = 1;
          this.itemsForCraft.forEach(function (a) {
            var b = a.split("=");
            d.worldItems.forEach(function (a) {
              a.name == b[0] && ((a.count -= +b[1]), (e = a.count));
            }, d),
              d.sender.inventoryItems.forEach(function (a, c) {
                if (a.name == b[0]) return (a.count -= +b[1]), void (a.count < 1 && (a.group.destroy(), d.sender.inventoryItems.splice(c, 1), d.sender.resetInventory()));
              }, d);
          }, this),
            this.worldItems.forEach(function (a) {
              d.name == a.name && (a.count += d.countadd);
            }, this),
            this.sender.resetCubes(),
            Game.grindsLogic.resetGrids(this);
          var f = !0;
          this.sender.inventoryItems.forEach(function (a) {
            if (d.name == a.name) return (a.count += d.countadd), void (f = !1);
          }, this),
            f && this.count >= 1 && (this.sender.createInventoryItem(this.name, this.count, this.path), this.sender.resetInventory()),
            Game.grindsLogic.addMaterials(this),
            this.createAbility(),
            this.isAchievement ||
              "nothing" == this.achievement ||
              "" == this.achievement ||
              void 0 == this.achievement ||
              ((this.isAchievement = !0), this.checkAdInterval(), Game.achievements.createAchievement(this.achievement, this.path)),
            "" != this.tag && "nothing" != this.tag && Game.music.addSound(this.name, this.tag);
        }
      }),
      (a.prototype.checkAdInterval = function () {
        var a = this.adTimer.isTimerDone();
        a && (this.adTimer.startTimer(), this.showAd());
      }),
      (a.prototype.showAd = function () {
        var a = this;
        (this.game.paused = !0),
          this.game.ads.onContentPaused.addOnce(function () {
            ga("send", "screenview", { screenName: "adverts" }), a.game.analytics.google.sendScreenView("adverts");
          }),
          this.game.ads.onContentResumed.addOnce(function () {
            a.game.paused = !1;
          }),
          this.game.ads.showAd({ internal: Fabrique.Branding.isInternal(this.game) ? "YES" : "NO", gameID: 30, pub: Fabrique.Utils.getSourceSite(), ad: "midroll" });
      }),
      (a.prototype.createAbility = function () {
        var a = this;
        if ("nothing" != this.ability[0]) {
          var b = 1;
          this.itemsForCraft.forEach(function (c) {
            var d = c.split("=");
            a.worldItems.forEach(function (a) {
              if (a.name == d[0]) return void (b = a.count);
            }, a);
          }, this);
          for (var c = 0; c < this.ability.length; ++c) {
            if ("automate " == this.ability[c].substring(0, 9)) {
              var d = this.ability[0].substring(9);
              Game.grindsLogic.grinds.forEach(function (b) {
                if (GameAPI.getName(b.type) == d) {
                  if (!b.isAutocraft && 0 != a.count) {
                    b.isAutocraft = !0;
                    for (var c = 0; c < Game.grindsLogic.grinds.length; ++c) Game.grindsLogic.grinds[c].addItem();
                    (b.worker = a), b.onDownGrind(b.material), a.sender.hideGrind();
                  }
                  if (null != b.worker && "hunter" == b.worker.name && "butcher" == a.name) {
                    b.isAutocraft = !0;
                    for (var c = 0; c < Game.grindsLogic.grinds.length; ++c) Game.grindsLogic.grinds[c].addItem();
                    (b.worker = a), a.sender.hideGrind();
                  }
                }
              }, this),
                this.changeAbility();
            }
            if ("deautomate " == this.ability[c].substring(0, 11)) {
              var d = this.ability[0].substring(11);
              Game.grindsLogic.grinds.forEach(function (c) {
                if (GameAPI.getName(c.type) == d && c.isAutocraft && 0 == b) {
                  if (null != c.worker && "butcher" == c.worker.name && 0 != a.sender.worldItems[33].count) return void (c.worker = a.sender.worldItems[33]);
                  if (null != c.worker && "butcher" == c.worker.name && 0 == a.sender.worldItems[33].count && 0 != a.sender.worldItems[36].count) return;
                  (c.isAutocraft = !1), (c.worker = null), a.sender.hideGrind();
                }
              }, this);
            }
            if ("autocraft " == this.ability[c].substring(0, 10) && 0 != this.count) {
              var e = this.ability[c].substring(10).split("=");
              void 0 == e && (e = [this.ability[0].substring(10)]),
                this.worldItems.forEach(function (b) {
                  if (b.name == e[0]) {
                    var c;
                    (c = 1 != e.length ? +e[1] : 0.5), (b.countAutocraft = a.count), null == b.timerAutocraft && b.startAutocraft(c);
                  }
                }, this),
                this.changeAbility();
            }
            if ("deautocraft " == this.ability[c].substring(0, 12)) {
              var f = this.ability[c].substring(12);
              this.worldItems.forEach(function (b) {
                b.name == f && null != b.timerAutocraft && (b.countAutocraft--, b.countAutocraft <= 0 && (a.game.time.events.remove(b.timerAutocraft), (b.timerAutocraft = null)));
              }, this);
            }
            "mapActive" == this.ability[c] &&
              0 == this.sender.mapGroup.visible &&
              ((this.sender.rightbkg.visible = !0),
              (this.sender.mapGroup.visible = !0),
              (this.sender.contract.visible = !0),
              this.sender.isAutomated && ((this.sender.contract.visible = !1), (this.sender.rightbkg.visible = !1), (this.sender.mapGroup.visible = !1)),
              (Game.save.mapVisible = !0),
              (Game.achievements.borderGroup.y = 200)),
              "markMap" == this.ability[c].substring(0, 7) &&
                (this.sender.createBeat("Check the map !", "Ok", !0, function () {
                  a.sender.createBeat("You beat City State !", "Ok", !0);
                }),
                (Game.save.isOpenNextLevel = !0),
                void 0 != this.sender.chasmMine && (this.sender.chasmMine.visible = Game.save.isOpenNextLevel)),
              "beatGame" == this.ability[c].substring(0, 8) && this.sender.createBeat("You beat  GrindCraft !", "Ok", !0),
              "beatLocation" == this.ability[c].substring(0, 12) && "Chasm Mine" == this.sender.gameLevel && this.sender.createBeat("You beat  Chasm Mine !", "Ok", !0);
          }
        }
      }),
      (a.prototype.changeAbility = function () {
        for (var a = 0; a < Game.save.countItem.length; ++a)
          if (this.name == Game.save.countItem[a].name) {
            Game.save.countItem[a].ability = !0;
            break;
          }
      }),
      (a.prototype.startAutocraft = function (a) {
        var b = this;
        this.timerAutocraft = this.game.time.events.add(
          a * Phaser.Timer.SECOND,
          function (c) {
            var d = c[0];
            b.onDownItem(d.sprite, null, null), b.startAutocraft(a);
          },
          this,
          [this]
        );
      }),
      a
    );
  })(),
  ExternalLinks = (function () {
    function a() {}
    return (
      (a.goToSponsorPageMoreGames = function () {
        window.open("http://3kh0.github.io", "_blank");
      }),
      (a.goToSponsorPage = function () {
        window.open("http://3kh0.github.io", "_blank");
      }),
      (a.goToSponsorPageLogo = function () {
        window.open("http://3kh0.github.io", "_blank");
      }),
      (a.GAMEID = ""),
      a
    );
  })(),
  FadeInOut = (function () {
    function a(a) {
      (this.fadeColor = 0), (this.game = a);
    }
    return (
      (a.init = function (b) {
        a.instance = new a(b);
      }),
      (a.prototype.fadeTo = function (a) {
        if (this.game.renderType != Phaser.CANVAS) {
          this.createBkg(), (this.spr_bg.alpha = 0), (this.nextState = a), this.game.add.existing(this.spr_bg);
          var b = this.game.add.tween(this.spr_bg);
          b.to({ alpha: 1 }, 500, null), b.onComplete.add(this.changeState, this), b.start();
        } else this.game.state.start(a);
      }),
      (a.prototype.createBkg = function () {
        (this.spr_bg = this.game.make.graphics(0, 0)), this.spr_bg.beginFill(this.fadeColor, 1), this.spr_bg.drawRect(ScaleManager.bkgX(), ScaleManager.bkgY(), ScaleManager.MaxWidth, ScaleManager.MaxHeight), this.spr_bg.endFill();
      }),
      (a.prototype.changeState = function () {
        this.game.state.start(this.nextState);
      }),
      (a.prototype.fadeOut = function () {
        this.createBkg(), (this.spr_bg.alpha = 1), this.game.add.existing(this.spr_bg);
        var a = this.game.add.tween(this.spr_bg);
        a.to({ alpha: 0 }, 500, null), a.start();
      }),
      a
    );
  })(),
  GameAPI = (function () {
    function a() {}
    return (
      (a.createText = function (a, b, c, d, e, f, g, h) {
        void 0 === g && (g = -1), void 0 === h && (h = !1);
        var i = a.add.bitmapText(b, c, d, e, f);
        return i.anchor.setTo(0.5, 0.5), (i.align = "center"), g != -1 && (i.tint = g), h && (i.cacheAsBitmap = !0), i;
      }),
      (a.addEvent = function (a, b, c, d, e, f, g, h) {
        void 0 === c && (c = null),
          void 0 === d && (d = null),
          void 0 === e && (e = null),
          void 0 === f && (f = null),
          void 0 === g && (g = null),
          void 0 === h && (h = null),
          (a.inputEnabled = !0),
          null != c && a.events.onInputUp.add(c, b, 0, d),
          null != e && a.events.onInputOver.add(e, b, 0, f),
          null != g && a.events.onInputOut.add(g, b, 0, h);
      }),
      (a.setWidthTextBTM = function (a, b) {
        if (a.width < b) return a.text;
        var c = a.text,
          d = c.split(" ");
        a.text = "";
        for (var e = 0; e < d.length; ++e) (a.text += d[e] + " "), a.width > b && ((a.text = a.text.substr(0, a.text.length - (d[e].length + 1))), (a.text += "\n"), (a.text += d[e] + " "));
        return a.text;
      }),
      (a.getName = function (a) {
        a = a.replace(".png", "");
        for (var b = 0; b < a.length; ++b) a.charCodeAt(b) < 91 && a.charCodeAt(b) > 40 && ((a = a.replace(a[b], " " + a[b])), (a = a.toLowerCase()));
        return a;
      }),
      (a.setString = function (a, b) {
        var c = "";
        c += a[0];
        for (var d = (a.length, 1); d < a.length; ++d) (c += a[d]), d % b == 0 && (c += "\n");
        return c;
      }),
      (a.grinders =
        "overworld:wood=29,grass=4,dirt=65,water=4:overworld.png;mine:stone=100,gravel=10,coal ore=14,iron ore=4,gold ore=3,diamond ore=1,lava=5:mine.png;food:nothing=remainder,sugar cane=2,wheat=2:food.png;mobs:nothing=remainder,chicken=1.75,cow=3,pig=1.75,sheep=1.75,horse=1.75,zombie=1.75,skeleton=1.75,witch=1.75,zombie villager=1.75,spider=1.75,slime=0.5:mobs.png"),
      (a.grinds =
        "hand:hand.png:hand=1:none;wood:wood.png:wood=1:hand=3,wood axe=1.5,stone axe=0.75,woodsman=0.74,iron axe=0.5,gold axe=0.375,diamond axe=0.1875:Tree punched !;grass:grass.png:seeds=1:wood sword=0.5,stone sword=0.4,woodsman=0.3,iron sword=0.2,gold sword=0.1,diamond sword=0.05:Grass mowed !;seeds:seeds.png;dirt:dirt.png:dirt=1:wood shovel=0.375,stone shovel=0.1875,woodsman=0.1874,iron shovel=0.125,gold shovel=0.0938,diamond shovel=0.06;soil:soil.png;water:water.png:water=1:bucket=0.125,woodsman=0.1875;lava:lava.png:lava=1:bucket=0.05,miner=0.05;gravel:gravel.png:flint=.1:wood shovel=0.45,stone shovel=0.225,miner=0.224,iron shovel=0.15,gold shovel=0.1125,diamond shovel=0.08;flint:flint.png;stone:stone.png:cobblestone=1:wood pick=1.125,stone pick=0.5625,miner=0.5624,iron pick=0.375,gold pick=0.2813,diamond pick=0.19:Stone begot !;cobblestone:cobblestone.png;coal ore:coalOre.png:coal=1:wood pick=2.25,stone pick=1.125,miner=1.124,iron pick=0.75,gold pick=0.5625,diamond pick=0.25:Worked in a coal mine !;coal:coal.png;iron ore:ironOre.png:iron ore=1:stone pick=1.25,miner=1.24,iron pick=1.125,gold pick=0.75,diamond pick=0.4;gold ore:goldOre.png:gold ore=1:iron pick=1.25,miner=1.8,gold pick=0.75,diamond pick=0.5:Gold !;diamond ore:diamondOre.png:diamond=1:gold pick=0.75,miner=1.8,diamond pick=0.5;diamond:diamond.png;zombie:zombie.png:nothing=0:wood sword=2.5,stone sword=2.49,hunter=2.48,iron sword=2.08,gold sword=1.79,diamond sword=1;skeleton:skeleton.png:arrow=.5:wood sword=2.2,stone sword=2.19,hunter=2.18,iron sword=1.83,gold sword=1.57,diamond sword=1;arrow:arrow.png;witch:witch.png:witch=1:trap=3;zombie villager:zombieVillager.png:zombie villager=1:trap=1.67;spider:spider.png:string=.5:wood sword=1.8,stone sword=1.79,hunter=1.78,iron sword=1.5,gold sword=1.29,diamond sword=1;string:string.png;slime:slime.png:slime ball=.5:wood sword=1,stone sword=0.99,hunter=0.98,butcher=0.97,iron sword=0.83,gold sword=0.714,diamond sword=0.638;slime ball:slimeBall.png;chicken:chicken.png:feather=.5:wood sword=0.4,stone sword=0.39,hunter=0.38,butcher=0.37,iron sword=0.33,gold sword=0.286,diamond sword=0.26;feather:feather.png;cow:cow.png:leather=1:wood sword=1,stone sword=0.99,hunter=0.98,butcher=0.97,iron sword=0.83,gold sword=0.714,diamond sword=0.638;leather:leather.png;pig:pig.png:nothing=0:wood sword=1,stone sword=0.99,hunter=0.98,butcher=0.97,iron sword=0.83,gold sword=0.714,diamond sword=0.638;sheep:sheep.png:wool=.5:wood sword=0.8,stone sword=0.79,hunter=0.78,butcher=0.77,iron sword=0.667,gold sword=0.57,diamond sword=0.5;wool:wool.png;horse:horse.png:horse=1:lead=1;sugar cane:sugarCane.png:sugar cane=1:wood sword=0.38,stone sword=0.36,gardener=0.34,iron sword=0.3,gold sword=0.25,diamond sword=0.19;wheat:wheat.png:wheat=0.66,seeds=0.33:wood sword=0.38,stone sword=0.36,gardener=0.34,iron sword=0.3,gold sword=0.25,diamond sword=0.19"),
      (a.crafters =
        "nothing=0:wood axe,stone axe,iron axe,gold axe,diamond axe:wood=1:wood.png:wood:grind:nothing:nothing:Used to craft planks.;stick=2,planks=3:crafting table:wood pick=1:woodPick.png:wood::Wooden tool crafted !:nothing:Mines stone and coal.;stick=2,planks=1:crafting table:wood shovel=1:woodShovel.png:wood::Wooden tool crafted !:nothing:Shovels dirt and gravel.;stick=1,planks=2:crafting table:wood sword=1:woodSword.png:wood::Wooden tool crafted !:nothing:Attacks mobs.;stick=2,planks=3:crafting table:wood axe=1:woodAxe.png:wood::Wooden tool crafted !:nothing:Chops wood.;stick=2,planks=2:crafting table:wood hoe=1:woodHoe.png:wood::Wooden tool crafted !:nothing:Tills soil.;nothing=0:wood pick,stone pick,iron pick,gold pick,diamond pick:cobblestone=1:cobblestone.png:metal:grind:nothing:nothing:Used to make buildings.;stick=2,cobblestone=1:crafting table:stone shovel=1:stoneShovel.png:metal:stone:Stone tool crafted !:nothing:Shovels dirt and gravel.;stick=1,cobblestone=2:crafting table:stone sword=1:stoneSword.png:metal:stone:Stone tool crafted !:nothing:Attacks mobs.;stick=2,cobblestone=3:crafting table:stone axe=1:stoneAxe.png:metal:stone:Stone tool crafted !:nothing:Chops wood.;stick=2,cobblestone=2:crafting table:stone hoe=1:stoneHoe.png:metal:stone:Stone tool crafted !:nothing:Equips gardeners.;stick=2,cobblestone=3:crafting table:stone pick=1:stonePick.png:metal:stone:Stone tool crafted !:nothing:Mines iron ore.;cobblestone=8:crafting table:furnace=1:furnace.png:::Furnace crafted !:nothing:Required to smelt iron and gold.;iron ingot=3:crafting table:bucket=1:bucket.png:metal::Bucket crafted !:nothing:Required to get water and lava.;nothing=0:wood pick,stone pick,iron pick,gold pick,diamond pick:coal=1:coal.png:metal:grind:nothing:nothing:Used to smelt ingots.;nothing=0:stone pick,iron pick,gold pick,diamond pick:iron ore=1:ironOre.png:metal:grind:nothing:nothing:Used to smelt iron ingots.;coal=1,iron ore=1:furnace:iron ingot=1:ironIngot.png:metal:metal:Iron ingot smelted !:nothing:Used to craft iron tools and armor.;nothing=0:wood shovel,stone shovel,iron shovel,gold shovel,diamond shovel:dirt=1:dirt.png:dirt:grind:nothing:nothing:Used to make soil.;dirt=1:wood hoe,stone hoe,iron hoe,gold hoe,diamond hoe:soil=1:soil.png:dirt:farm:nothing:nothing:Used to make fields for planting.;nothing=0:bucket:water=1:water.png:wood:grind:nothing:nothing:Used to make gardens.;soil=8,water=1:nothing:plot=1:plot.png:dirt:farm:nothing:nothing:Required to grow food.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:seeds=1:seeds.png:whoosh:grind:nothing:nothing:Used to make gardens.;plot=1,seeds=1:nothing:wheat field=1:wheatField.png:dirt:farm:Garden planted !:increase wheat:Required to make villagers.;wood=1:nothing:planks=4:planks.png:wood:wood:nothing:nothing:Used to craft tools and wood items.;planks=4:nothing:crafting table=1:craftingTable.png:wood::Crafting Table crafted !:nothing:Required to craft items.;planks=2:nothing:stick=4:stick.png:wood:wood:nothing:nothing:Used to craft tools and wood items.;planks=4:crafting table:door=1:door.png:wood:wood:nothing:nothing:Used with walls to build dwellings.;cobblestone=9:nothing:wall=1:wall.png:metal:stone:Wall built !:nothing:Used with doors to build dwellings.;wall=5,door=1:nothing:hut=1:hut.png:metal:stone:Hut ! Hut ! Hut !:nothing:Used to make villagers and structures.;hut=1,wheat field=1:nothing:villager=1:villager.png:hand:villager:Villager !:nothing:Can specialize.;villager=1,stone axe=1:nothing:woodsman=1:woodsman.png:hand:villager:Woodsman !:automate overworld,increase wood,increase grass,increase water:Automates overworld grinder.  Increases wood, grass, and water.;villager=1,stone pick=1:nothing:miner=1:miner.png:hand:villager:Miner !:automate mine,increase coal ore,increase iron ore,increase gold ore,increase diamond ore:Automates mine grinder.  Increases ore.;villager=1,stone hoe=1:nothing:gardener=1:gardener.png:hand:villager:Gardener !:automate food:Automates food grinder.;villager=1,stone sword=1:nothing:hunter=1:hunter.png:hand:villager:Hunter !:automate mobs,increase chicken,increase cow,increase sheep,increase horse,increase skeleton,increase witch,increase zombie villager,increase spider,increase slime:Automates mob grinder.  Increases mobs.;planks=4,stick=2:crafting table:fence=3:fence.png:wood:wood:Fencing crafted !:nothing:Used to build pens.;fence=9:crafting table:pen=1:pen.png:wood:wood:Pen built !:nothing:Required to turn villagers into butchers.;hunter=1,pen=1:nothing:butcher=1:butcher.png:hand:villager:Butcher !:automate mobs,increase chicken,increase cow,increase sheep,increase horse:Increases animals.;planks=6:crafting table:stairs=4:stairs.png:wood:wood:Stairs crafted !:nothing:Used to build roofs.;stairs=3:nothing:rafter=1:rafter.png:wood:wood:Rafter built !:nothing:Used to build roofs.;rafter=2:nothing:truss=1:truss.png:wood:wood:nothing:nothing:Used to build roofs.;truss=4:nothing:roof=1:roof.png:wood:wood:Roof built !:nothing:Used to make village buildings.;roof=1,hut=1:nothing:village building=1:villageBuilding.png:::Village building !:nothing:Used to make village buildings.;plot=1,sugar cane=1:nothing:sugar cane field=1:sugarCaneField.png:dirt:farm:Sugar caned !:increase sugar cane:Increases sugar cane.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:sugar cane=1:sugarCane.png:whoosh:grind:nothing:nothing:Used to make sugar and paper.;sugar cane=3:crafting table:paper=3:paper.png:whoosh::Paper pulped !:nothing:Used to make books.;paper=3,leather=1:crafting table:book=1:book.png:whoosh::Book bound !:nothing:Used to make bookcases.;planks=6,book=3:crafting table:bookshelf=1:bookshelf.png:wood::Bookshelf crafted !:nothing:Used to make bookcases.;bookshelf=4:nothing:bookcase=1:bookcase.png:wood::nothing:nothing:Used to build libraries.;village building=2,bookcase=2:nothing:library=1:library.png:metal::nothing:nothing:Used to train villagers in crafting.;villager=1,crafting table=1:library:crafter=1:crafter.png:hand:villager:Crafter graduated !:nothing:Can specialize.;crafter=1,stone pick=1:nothing:mason=1:mason.png:hand:villager:Mason trained !:nothing:Can build advanced structures;nothing=0:bucket:lava=1:lava.png:wood:grind:nothing:nothing:Used to make a lava pool.;cobblestone=12,lava=4:mason:lava pool=1:lavaPool.png:::Lava pool !:nothing:Used to build a forge.;village building=2,lava pool=1,furnace=1:nothing:forge=1:forge.png:metal::Forge built !:nothing:Used to train blacksmiths.;crafter=1:forge:smelter=1:smelter.png:metal:villager:Smelter trained !:autocraft iron ingot=.5,autocraft gold ingot:Auto-crafts iron and gold ingots.;stick=2,iron ingot=3:crafting table:pitch fork=1:pitchFork.png:metal:metal:Iron tool crafter !:nothing:Used by farmers.;crafter=1,pitch fork=1:nothing:farmer=1:farmer.png:hand:villager:Farmer !:nothing:Makes gardens.;stick=1,iron ingot=3:crafting table:saw=1:saw.png:metal:metal:Saw crafted !:nothing:Used by carpenters.;crafter=1,saw=1:nothing:carpenter=1:carpenter.png:hand:villager:Carpenter trained !:nothing:Makes stuff out of wood.;stairs=2:nothing:desk=1:desk.png:wood:wood:nothing:nothing:Required to elect mayor.;village building=2,desk=1,crafter=1:nothing:mayor=1:mayor.png:hand:villager:Mayor elected !:nothing:Makes varieties of Crafters.;woodsman=1:mayor:villager=1:woodsmanDemote.png:hand::nothing:deautomate overworld:Fire a woodsman.;miner=1:mayor:villager=1:minerDemote.png:hand::nothing:deautomate mine:Fire a miner.;gardener=1:mayor:villager=1:gardenerDemote.png:hand::nothing:deautomate food:Fire a gardener.;hunter=1:mayor:villager=1:hunterDemote.png:hand::nothing:deautomate mobs:Fire a hunter.;butcher=1:mayor:villager=1:butcherDemote.png:hand::nothing:deautomate mobs:Fire a miner.;dirt=8,water=1,seeds=1:farmer:wheat field=1:wheatField.png:whoosh::Garden planted !:nothing:Required to make villagers.;cobblestone=45,wood=1:mason:hut=1:hut.png:metal::Hut ! Hut ! Hut !:nothing:Required to make villagers.;stick=2,iron ingot=3:crafting table:iron pick=1:ironPick.png:metal:metal:Iron tool crafted !:nothing:Mines gold.;stick=2,iron ingot=1:crafting table:iron shovel=1:ironShovel.png:metal:metal:Iron tool crafted !:nothing:Shovels dirt and gravel.;stick=2,iron ingot=3:crafting table:iron axe=1:ironAxe.png:metal:metal:Iron tool crafted !:nothing:Chops wood.;stick=2,iron ingot=2:crafting table:iron hoe=1:ironHoe.png:metal:metal:Iron tool crafted !:nothing:Tills soil.;stick=1,iron ingot=2:crafting table:iron sword=1:ironSword.png:metal:metal:Iron tool crafted !:nothing:Attacks mobs.;wood=1:carpenter:stick=8:stick.png:wood:wood:nothing:nothing:Used to craft tools and wood items.;hut=1,wheat field=1,leather=1:mayor:leather worker=1:leatherWorker.png:hand:villager:Leather worker !:nothing:Crafts leather armor.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:leather=1:leather.png:metal:grind:nothing:nothing:Used to make leather armor and saddles.;leather=5:leather worker:leather helmet=1:leatherHelmet.png:whoosh:metal:Leather helmet !:nothing:For making leather soldiers.;leather=8:leather worker:leather breastplate=1:leatherBreastplate.png:whoosh:metal:Leather breastplate !:nothing:For making leather soldiers.;leather=7:leather worker:leather leggings=1:leatherLeggings.png:whoosh:metal:Leather leggings !:nothing:For making leather soldiers.;leather=4:leather worker:leather boots=1:leatherBoots.png:whoosh:metal:Leather boots !:nothing:For making leather soldiers.;leather helmet=1,leather breastplate=1,leather leggings=1,leather boots=1:nothing:leather armor=1:leatherArmor.png:whoosh::Leather armor !:nothing:For making leather soldiers.;hut=1,wheat field=1,iron sword=1:mayor:sergeant=1:sergeant.png:hand:villager:Sergeant hired !:nothing:Trains up hunters.;hut=1,wheat field=1:sergeant:soldier=1:soldier.png:hand:villager:Soldier up !:nothing:Used to make iron soldiers.;leather armor=1,soldier=1:nothing:leather soldier=1:leatherSoldier.png:hand:villager:Leather soldier !:nothing:Used to train archers.;hut=2,leather soldier=8:mason:barracks=1:barracks.png:metal::Barracks built !:nothing:Used to make an outpost.;iron ingot=9:crafting table:iron block=1:ironBlock.png:metal:metal:Iron block crafted !:nothing:Used to craft anvils.;iron block=3,iron ingot=3:crafting table:anvil=1:anvil.png:metal:metal:Anvil forged !:nothing:Used to train blacksmiths.;hut=1,wheat field=1,anvil=1:mayor:blacksmith=1:blacksmith.png:hand:villager:Blacksmith trained !:nothing:Crafts armor.;iron ingot=5:blacksmith:iron helmet=1:ironHelmet.png:metal:metal:Iron helmet !:nothing:For making iron soldiers.;iron ingot=8:blacksmith:iron breastplate=1:ironBreastplate.png:metal:metal:Iron breastplate !:nothing:For making iron soldiers.;iron ingot=7:blacksmith:iron leggings=1:ironLeggings.png:metal:metal:Iron leggings !:nothing:For making iron soldiers.;iron ingot=4:blacksmith:iron boots=1:ironBoots.png:metal:metal:Iron boots !:nothing:For making iron soldiers.;iron helmet=1,iron breastplate=1,iron leggings=1,iron boots=1:nothing:iron armor=1:ironArmor.png:metal:metal:Iron armor !:nothing:For making iron soldiers.;iron armor=1,soldier=1:nothing:iron soldier=1:ironSoldier.png:metal:villager:Iron man !:nothing:Part of a fire team.;hut=1,wheat field=1,arrow=1:mayor:fletcher=1:fletcher.png:hand:villager:Fletcher trained !:nothing:Crafts bows and arrows.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:wool=1:wool.png:whoosh:grind:nothing:nothing:Used to make string.;wool=1:nothing:string=4:string.png:whoosh::nothing:nothing:Used to make bows.;stick=3,string=3:fletcher:bow=1:bow.png:wood::Bow crafted !:nothing:Combined with arrows.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:feather=1:feather.png:whoosh:grind:nothing:nothing:Used to make arrows.;nothing=0:wood shovel,stone shovel,iron shovel,gold shovel,diamond shovel:flint=1:flint.png:dirt:grind:nothing:nothing:Used to craft arrows.;flint=1,stick=1,feather=1:fletcher:arrow=4:arrow.png:whoosh::Arrows crafted !:nothing:Combined with bow.;leather soldier=1,bow=1,arrow=8:nothing:archer=1:archer.png:hand:villager:Archer trained !:nothing:Part of a fire team.;iron soldier=2,archer=2:nothing:fire team=1:fireTeam.png:metal:villager:Fire team trained !:nothing:Occupies scout tower.;stick=7:crafting table:ladder=3:ladder.png:wood:wood:Made some ladders !:nothing:Used with huts to build towers.;hut=2,ladder=6:mason:tower=1:tower.png:metal::Tower erected !:nothing:Used to build larger structures.;tower=1,fire team=1:mason:scout tower=1:scoutTower.png:metal::Scout tower built !:nothing:Used to make an outpost.;barracks=1,scout tower=2:mason:outpost=1:outpost.png:metal::Outpost built !:nothing:Used to make a station.;nothing=0:outpost:outpost exporter=1:outpost.png:::nothing:navigateToUrl 135Fmh:Download.;outpost=2:mason:station=1:station.png:metal::Station built !:nothing:Used to make a fort.;hut=1,wheat field=1:station:governor=1:governor.png:hand:villager:Governor elected !:nothing:Used to train advanced crafters.;nothing=0:iron pick,gold pick,diamond pick:gold ore=1:goldOre.png:metal:grind:nothing:nothing:Used to smelt gold ingots.;coal=1,gold ore=1:furnace:gold ingot=1:goldIngot.png:metal:metal:Gold ingot smelted !:nothing:Used to craft gold tools and armor.;stick=2,gold ingot=3:crafting table:gold pick=1:goldPick.png:metal:metal:Golden tool crafted !:nothing:Mines diamond.;stick=2,gold ingot=1:crafting table:gold shovel=1:goldShovel.png:metal:metal:Golden tool crafted !:nothing:Shovels dirt and gravel.;stick=1,gold ingot=2:crafting table:gold sword=1:goldSword.png:metal:metal:Golden tool crafted !:nothing:Attacks mobs.;stick=2,gold ingot=3:crafting table:gold axe=1:goldAxe.png:metal:metal:Golden tool crafted !:nothing:Chops wood.;stick=2,gold ingot=2:crafting table:gold hoe=1:goldHoe.png:metal:metal:Golden tool crafted !:nothing:Tills soil.;cobblestone=45,wood=1,dirt=8,water=1,seeds=1:governor:gold smith=1:goldSmith.png:hand:villager:Gold smith trained !:autocraft gold ingot=.33:Used to make gold items.;cobblestone=45,wood=1,dirt=8,water=1,seeds=1:governor:contractor=1:contractor.png:hand:villager:Contractor hired !:nothing:Makes housing.;cobblestone=45,wood=1,dirt=8,water=1,seeds=1:governor:commander=1:commander.png:hand:villager:Commander trained !:nothing:Makes soldiers.;cobblestone=180,wood=4,dirt=32,water=4,seeds=4:contractor:villager=4:villager.png:hand:villager:Villager !:nothing:Can specialize.;villager=4,wood=1,gold ingot=8:commander:soldier=4:soldier.png:hand:villager:Soldier up !:nothing:Used to make gold soldiers.;gold ingot=5:gold smith:gold helmet=1:goldHelmet.png:metal::Gold helmet !:nothing:For making gold soldiers.;gold ingot=8:gold smith:gold breastplate=1:goldBreastplate.png:metal::Gold breastplate !:nothing:For making gold soldiers.;gold ingot=7:gold smith:gold leggings=1:goldLeggings.png:metal::Gold leggings !:nothing:For making gold soldiers.;gold ingot=4:gold smith:gold boots=1:goldBoots.png:metal::Gold boots !:nothing:For making gold soldiers.;gold helmet=1,gold breastplate=1,gold leggings=1,gold boots=1:nothing:gold armor=1:goldArmor.png:metal::Gold armor !:nothing:For making gold soldiers.;gold armor=1,soldier=1:nothing:gold soldier=1:goldSoldier.png:hand:villager:Gold soldier !:nothing:Required to train knights.;cobblestone=25,gold soldier=1:contractor:outer wall=1:outerWall.png:::nothing:nothing:Used to build a rampart.;outer wall=3:contractor:rampart=1:rampart.png:::Rampart built !:nothing:Required to build fort.;station=1,rampart=4:contractor:fort=1:fort.png:::Fort built !:nothing:Required to build stables.;nothing=0:fort:fort exporter=1:fort.png:::nothing:navigateToUrl 135FhH:Download.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:wheat=1:wheat.png:whoosh:grind:nothing:nothing:Used to make hay bales.;wheat=9:nothing:hay bale=1:hayBale.png:whoosh::Hay HAY hay !:nothing:Used in stables and aviaries.;wood=2:carpenter:fence=3:fence.png:wood:wood:Fencing crafted !:nothing:Used to build pens.;fence=9:carpenter:pen=1:pen.png:wood:wood:Pen built !:nothing:Used to make stalls.;wood=3:carpenter:truss=1:truss.png:wood:wood:nothing:nothing:Used to make stalls.;truss=4:carpenter:roof=1:roof.png:wood::Roof built !:nothing:Used to make stalls.;pen=1,roof=1,hay bale=1:carpenter:stall=1:stall.png:wood::nothing:nothing:Used to make stables.;stall=4:carpenter:stable=1:stable.png:wood::Horse stable built !:nothing:Used to stable horses.;cobblestone=45,wood=1,dirt=8,water=1,seeds=1:governor:horse trainer=1:horseTrainer.png:hand:villager:Horse trainer !:nothing:Used to train horses.;nothing=0:wood sword,stone sword,iron sword,gold sword,diamond sword:slime ball=1:slimeBall.png:hand:grind:nothing:nothing:Used to make a lead.;string=4,slime ball=1:horse trainer:lead=2:lead.png:whoosh::Lead crafted !:nothing:Used to catch horses.;iron ingot=1,string=1:blacksmith:stirrup=1:stirrup.png:metal::Stirrup crafted !:nothing:Used to craft sadles.;stirrup=2,leather=3:leather worker:saddle=1:saddle.png:whoosh::Saddle crafted !:nothing:Used to tame horses.;nothing=0:lead:horse=1:horse.png:hand:grind:nothing:nothing:Needed to to tame horses.;horse=1,saddle=1:horse trainer:tamed horse=1:tamedHorse.png:::Horse tamed !:nothing:Required for war horses.;gold ingot=9:crafting table,gold smith:gold block=1:goldBlock.png:metal::Gold block crafted !:nothing:Required for war horse armor.;tamed horse=1,gold block=4:gold smith:war horse=1:warHorse.png:::War horse trained !:nothing:Required to train knights.;gold soldier=1,war horse=1:stable:gold knight=1:goldKnight.png:hand:villager:Gold knight !:nothing:Required to build castle.;cobblestone=45,wood=1,roof=1:contractor:village building=1:villageBuilding.png:wood::Village building !:nothing:Required to build a keep.;village building=4:contractor:keep=1:keep.png:::Keep built !:nothing:Required to build castle.;fort=1,keep=1,gold knight=4:contractor:castle=1:castle.png:::Castle built !:nothing:Required to build aviary.;nothing=0:castle:castle exporter=1:castle.png:::nothing:navigateToUrl 135FIn:Download.;wood=1:carpenter:pressure plate=1:pressurePlate.png:wood::Pressure plate crafted !:nothing:Required to build trap.;sugar cane=1:crafting table:sugar=1:sugar.png:whoosh::Sugar refined !:nothing:Required to build trap.;wood=4,pressure plate=1,sugar=1:carpenter:trap=1:trap.png:wood::Trap built !:nothing:Required to catch witch.;cobblestone=90,wood=4:contractor:tower=1 :tower.png:metal::Tower erected !:nothing:Required to build a church.;village building=2,tower=1,roof=1:contractor:church=1:church.png:metal::Church built !:nothing:Required to train priest.;villager=1,book=1:church:priest=1:priest.png:hand:villager:Priest trained !:nothing:Required to turn witch.;nothing=0:trap:zombie villager=1:zombieVillager.png:wood:grind:nothing:nothing:Turns into villager.;zombie villager=1:priest:villager=1:villager.png:hand:villager:Zombie villager turned !:nothing:Can specialize.;nothing=0:gold pick,diamond pick:diamond=1:diamond.png:metal:grind:nothing:nothing:Used to craft diamond tools and items.;wood=2:carpenter:stick=16:stick.png:wood:wood:nothing:nothing:Used to craft tools and wood items.;stick=2,diamond=1:crafting table:diamond scepter=1:diamondScepter.png:metal:metal:Scepter crafter !:nothing:Held by kings.;villager=1,diamond scepter=1:castle:king=1:king.png:hand:villager:King crowned !:nothing:Required to build a city state.;villager=1,diamond=1:king:diamond smith=1:diamondSmith.png:hand:villager:nothing:nothing:Required to make diamond armor;stick=2,diamond=3:crafting table:diamond pick=1:diamondPick.png:metal:metal:Diamond tool crafted !:nothing:Mines faster.;stick=2,diamond=1:crafting table:diamond shovel=1:diamondShovel.png:metal:metal:Diamond tool crafted !:nothing:Shovels dirt and gravel.;stick=1,diamond=2:crafting table:diamond sword=1:diamondSword.png:metal:metal:Diamond tool crafted !:nothing:Attacks mobs.;stick=2,diamond=3:crafting table:diamond axe=1:diamondAxe.png:metal:metal:Diamond tool crafted !:nothing:Chops wood.;stick=2,diamond=2:crafting table:diamond hoe=1:diamondHoe.png:metal:metal:Diamond tool crafted !:nothing:Tills soil.;diamond=24:diamond smith:diamond armor=1:diamondArmor.png:metal::Diamond armor !:nothing:For making diamond soldiers.;diamond armor=1,villager=1:king:diamond soldier=1:diamondSoldier.png:metal:villager:Diamond soldier !:nothing:Required to train flying knights.;hay bale=8:nothing:nest=1:nest.png:::nothing:nothing:Required to build aviary.;tower=1,nest=1:castle:roost=1:roost.png:::Roost built !:nothing:Required to build aviary.;roost=4:castle:aviary=1:aviary.png:::Aviary built !:nothing:Required to train flying knights.;nothing=0:trap:witch=1:witch.png:wood:grind:nothing:nothing:Turns into wizard.;witch=1:nothing:redstone=1:redstone.png:hand::Ding Dong !:nothing:Required to make a compass;witch=1:priest:wizard=1:wizard.png:hand:villager:Wizard turned !:nothing:Required to create flying horses.;horse=1,feather=6:wizard:flying horse=1:flyingHorse.png:::Horse feathers !:nothing:Required for flying knights.;flying horse=1,saddle=1:aviary:tamed flying horse=1:tamedFlyingHorse.png:::nothing:nothing:Required to train flying knights.;diamond=9:crafting table:diamond block=1:diamondBlock.png:metal::Diamond block !:nothing:Required to armor flying horses.;tamed flying horse=1,diamond block=4:diamond smith:flying war horse=1:flyingWarHorse.png:::Flying war horse !:nothing:Required to train flying knights.;diamond soldier=1,flying war horse=1:nothing:flying knight=1:flyingKnight.png:hand:villager:Flying knight !:nothing:Required to build a city state.;flying knight=4:castle:city state=1:cityState.png:::City State !:nothing:Required to build a shipyard.;nothing=0:city state:city state exporter=1:cityState.png:::nothing:navigateToUrl 135FZo:Download.;redstone=1,iron ingot=4:crafting table:compass=1:compass.png:metal::Compass crafted !:nothing:Required to craft a map.;sugar cane=4:crafting table:paper=4:paper.png:whoosh::Paper pulped !:nothing:Used to make a map.;compass=1,paper=32:crafting table:map=1:map.png:whoosh::Map crafted !:mapActive:Required to navigate the world.;dirt=216:nothing:fill dirt=1:fillDirt.png:whoosh::Fill dirt dumped !:nothing:Required to build a sea wall.;fill dirt=4:nothing:sea wall=1:seaWall.png:whoosh::Sea wall built !:nothing:Required to build a warf.;wood=1:carpenter:wood slab=6:woodSlab.png:wood:wood:nothing:nothing:Required to build a deck.;wood slab=9:nothing:deck=1:deck.png:wood:wood:Deck built !:nothing:Required to build piers and ships.;wood=4:carpenter:fence=6:fence.png:wood:wood:Fencing crafted !:nothing:Used to build pens.;deck=1,fence=4:nothing:raised deck=1:raisedDeck.png:wood:wood:nothing:nothing:Required to build a warf.;sea wall=1,raised deck=3:nothing:warf=1:warf.png:wood:wood:Warf built !:nothing:Required to build a dock.;fence=3:nothing:post=1:post.png:wood:wood:nothing:nothing:Required to build a platform.;deck=1,post=4:nothing:platform=1:platform.png:wood:wood:nothing:nothing:Required to build a pier.;platform=3:nothing:pier=1:pier.png:wood:wood:Pier built !:nothing:Required to build a dock.;warf=1,pier=1:nothing:dock=1:dock.png:wood:wood:Dock built !:nothing:Required to build a shipyard.;dock=3,village building=2:city state:shipyard=1:shipyard.png:wood:wood:Shipyard built !:nothing:Required to build ships.;wood=6:shipyard:stairs=16:stairs.png:wood:wood:Stairs crafted !:nothing:Used to build roofs.;stairs=6:shipyard:rib=1:rib.png:wood:wood:nothing:nothing:Required to build a boat shell.;wood=4:shipyard:beam=1:beam.png:wood:wood:nothing:nothing:Required to build a boat shell and mast.;rib=6,beam=1:shipyard:shell=1:shell.png:wood:wood:Boat shell built !:nothing:Required to build a hull.;shell=1,stairs=5:shipyard:ship bow=1:shipBow.png:wood:wood:nothing:nothing:Required to build a hull.;shell=1,stairs=4,planks=1:shipyard:stern=1:stern.png:wood:wood:nothing:nothing:Required to build a hull.;ship bow=1,stern=1:shipyard:hull=1:hull.png:wood:wood:Boat hull built !:nothing:Required to build a barge.;wood=1:shipyard:planks=4:planks.png:wood:wood:nothing:nothing:Used to craft tools and wood items.;planks=24,deck=1:shipyard:forecastle=1:forecastle.png:wood:wood:nothing:nothing:Required to build a deckhouse.;wood=3:shipyard:cabin truss=1:truss.png:wood:wood:nothing:nothing:Used to build cabins.;cabin truss=6:shipyard:cabin roof=1:roof.png:wood::Roof built !:nothing:Used to build cabins.;wood=1:shipyard:cabin door=1:door.png:wood:wood:nothing:nothing:Used to build cabins.;planks=45,cabin roof=1,cabin door=1:shipyard:cabin=1:cabin.png:wood:wood:nothing:nothing:Required to build a deckhouse.;forecastle=1,cabin=1,deck=1:shipyard:deckhouse=1:deckhouse.png:wood:wood:nothing:nothing:Required to build a barge.;hull=1,deckhouse=1:shipyard:barge=1:barge.png:wood:wood:Barge built !:nothing:Required to build a ship.;wool=6,beam=1:shipyard:upper sail=1:upperSail.png:wood:wood:Sail built !:nothing:Required to build a mast.;wool=28,beam=2:shipyard:main sail=1:mainSail.png:wood:wood:Sail built !:nothing:Required to build a mast.;beam=4,upper sail=1,main sail=1:shipyard:mast=1:mast.png:wood:wood:Mast built !:nothing:Required to build a ship.;planks=12,deck=1:shipyard:lookout=1:lookout.png:wood:wood:nothing:nothing:Required to build a ship.;barge=1,mast=1,lookout=1:shipyard:ship=1:ship.png:wood:wood:Ship built !:nothing:Required to form a flotilla.;ship=3:shipyard:port=1:port.png:wood:wood:Port established !:markMap Chasm Mine-441-537,beatLocation:Required to sail around Grindcraftia;nothing=0:port:port exporter=1:port.png:::nothing:navigateToUrl 1ABDd8:Download."),
      (a.chasmMineGrinders =
        "overworld:wood=29,dirt=65:overworld.png;mine:stone=50,gravel=5,coal ore=14,iron ore=4,diamond ore=1,obsidian=2,lava=5,spider=1.75,slime=0.5:mine.png;nether mobs:nothing=remainder,zombie pigman=3,blaze=1,ghast=1.75:netherMobs.png;nether:nothing=remainder,netherrack=50:nether.png"),
      (a.chasmMineGrinds =
        "hand:hand.png:hand=1:none;wood:wood.png:wood=1:hand=3,woodsman=0.74,iron axe=0.5,gold axe=0.375,diamond axe=0.1875:Tree punched !;grass:grass.png:seeds=1:woodsman=0.3,iron sword=0.2,gold sword=0.1,diamond sword=0.05:Grass mowed !;seeds:seeds.png;dirt:dirt.png:dirt=1:woodsman=0.1874,iron shovel=0.125,gold shovel=0.0938,diamond shovel=0.06;water:water.png:water=1:bucket=0.125,woodsman=0.1875;lava:lava.png:lava=1:minecart=0.05 ;gravel:gravel.png:flint=.1:miner=0.224,iron shovel=0.15,gold shovel=0.1125,diamond shovel=0.08;flint:flint.png;stone:stone.png:cobblestone=1:miner=0.5624,iron pick=0.375,gold pick=0.2813,diamond pick=0.19:Stone begot !;cobblestone:cobblestone.png;coal ore:coalOre.png:coal=1:scaffolding=0.75:;coal:coal.png;iron ore:ironOre.png:iron ore=1:scaffolding=1.125:;gold ore:goldOre.png:gold ore=1:iron pick=1.25,miner=1.8,gold pick=0.75,diamond pick=0.5:Gold !;diamond ore:diamondOre.png:diamond=1:minecart=1.8 ;diamond:diamond.png;obsidian:obsidian.png:obsidian=1:minecart=5 ;zombie:zombie.png:nothing=0:hunter=2.48,iron sword=2.08,gold sword=1.79,diamond sword=1;skeleton:skeleton.png:arrow=.5:hunter=2.18,iron sword=1.83,gold sword=1.57,diamond sword=1;arrow:arrow.png;witch:witch.png:witch=1:trap=3;zombie villager:zombieVillager.png:zombie villager=1:trap=1.67;spider:spider.png:string=.5:hunter=1.78,iron sword=1.5,gold sword=1.29,diamond sword=1;string:string.png;slime:slime.png:slime ball=.5:hunter=0.98,iron sword=0.83,gold sword=0.714,diamond sword=0.638;slime ball:slimeBall.png;chicken:chicken.png:feather=.5:hunter=0.38,iron sword=0.33,gold sword=0.286,diamond sword=0.26;feather:feather.png;cow:cow.png:leather=1:hunter=0.98,iron sword=0.83,gold sword=0.714,diamond sword=0.638;leather:leather.png;pig:pig.png:nothing=0:hunter=0.98,iron sword=0.83,gold sword=0.714,diamond sword=0.638;sheep:sheep.png:wool=.5:hunter=0.78,iron sword=0.667,gold sword=0.57,diamond sword=0.5;wool:wool.png;horse:horse.png:horse=1:lead=1;sugar cane:sugarCane.png:sugar cane=1:gardener=0.34,iron sword=0.3,gold sword=0.25,diamond sword=0.19;wheat:wheat.png:wheat=.66,seeds=.33:gardener=0.34,iron sword=0.3,gold sword=0.25,diamond sword=0.19;netherrack:netherrack.png:netherrack=10:pigman worker=0.5624:Nether racked !;zombie pigman:zombiePigman.png:zombie pigman=1:iron trap=2.49;blaze:blaze.png:blaze rod=.5:nether fortress=5;blaze rod:blazeRod.png;ghast:ghast.png:ghast=1:ghast trap=4.5;spider:spider.png:string=.5:hunter=1.78,iron sword=1.5,gold sword=1.29,diamond sword=1;string:string.png;slime:slime.png:slime ball=.5:hunter=0.98,iron sword=0.83,gold sword=0.714,diamond sword=0.638;slime ball:slimeBall.png;witherSkeleton:witherSkeleton.png:coal=.5,bone=.67:hunter=5,iron sword=4.25,gold sword=3.67,diamond sword=3;"),
      (a.chasmMineCrafters =
        "wood=1:carpenter:wood slab=6:woodSlab.png:wood:wood:nothing:nothing:Required to build a deck.;wood slab=9:carpenter:deck=1:deck.png:wood:wood:nothing:nothing:Required to build a scaffold.;wood=6:carpenter:fence=9:fence.png:wood:wood:nothing:nothing:Used to build pens.;fence=3:carpenter:post=1:post.png:wood:wood:nothing:nothing:Required to build a platform.;deck=1,post=4:carpenter:platform=1:platform.png:wood:wood:nothing:nothing:Required to build a scaffold.;wood=1:carpenter:ladder=3:ladder.png:wood:wood:nothing:nothing:Required to build a scaffold.;platform=1,deck=1,wood=1,ladder=5:carpenter:scaffold=1:scaffold.png:wood:wood:Scaffold built !:nothing:Required to build scaffolding.;deck=1,fence=6:carpenter:bridge=1:bridge.png:wood:wood:Bridge built !:nothing:Required to build scaffolding.;scaffold=6,bridge=1:nothing:scaffolding=1:scaffolding.png:wood:wood:Scaffolding built !:nothing:Required to reach the chasm floor.;cobblestone=8:crafting table:furnace=1:furnace.png:::Furnace crafted !:nothing:Required to smelt iron and gold.;nothing=0:iron pick,gold pick,diamond pick:coal=1:coal.png:metal:grind:nothing:nothing:Used to smelt ingots.;nothing=0:iron pick,gold pick,diamond pick:iron ore=1:ironOre.png:metal:grind:nothing:nothing:Used to smelt iron ingots.;coal=1,iron ore=1:furnace:iron ingot=1:ironIngot.png:metal:metal:Iron ingot smelted !:nothing:Used to craft iron tools and armor.;wood=1,iron ingot=6:crafting table:rail=16:rail.png:metal::Rail crafted !:nothing:Required to build a rail bridge.;stick=3,iron ingot=2:crafting table:spike maul=1:spikeMaul.png:metal::Spike maul crafted !:nothing:Required to train a rail worker.;iron ingot=3:crafting table:line bar=1:lineBar.png:metal::Line bar crafted !:nothing:Required to train a rail worker.;nothing=0:nothing:contractor=1:contractor.png:hand:villager:Contractor hired !:nothing:Makes housing.;contractor=1,spike maul=1,line bar=1:nothing:rail worker=1:railWorker.png:hand::Rail worker trained !:nothing:Required to build a rail bridge.;platform=1,rail=3:rail worker:rail bridge=1:railBridge.png:metal::Rail bridge built !:nothing:Required to build a railway.;rail bridge=24:rail worker:railway=1:railway.png:metal::Railway built !:nothing:Required to reach the cave depths.;nothing=0:railway:railway exporter=1:railway.png:::nothing:navigateToUrl 1ENHZc:Download.;iron ingot=5:railway:minecart=1:minecart.png:metal::Minecart crafted !:nothing:Required to reach the cave depths.;nothing=0:minecart:obsidian=1:obsidian.png:metal:grind:Obsidian obtained !:nothing:Used to build a portal.;iron ingot=1,flint=1:crafting table:flint and steel=1:flintAndSteel.png:metal::Flint and steel !:nothing:Used to build a portal.;obsidian=25:flint and steel:portal=1:portal.png:metal::Portal built !:showGrinder nether:Used to go to the Nether.;wood=1:carpenter:pressure plate=1:pressurePlate.png:wood::nothing:nothing:Required to build trap.;iron ingot=6:crafting table:iron door=1:ironDoor.png:metal::Iron door crafted !:nothing:Required to build trap.;iron door=4,pressure plate=1:portal:iron trap=1:ironTrap.png:metal::Iron trap built !:automate nether mobs:Required to catch zombie pigmen.;nothing=0:portal:zombie pigman=1:zombiePigman.png:hand:grind:Zombie pigman trapped !:nothing:Required to turn zombie pigmen.;nothing=0:nothing:priest=1:priest.png:hand:villager:nothing:autocraft pigman=1:Required to turn zombie pigmen.;zombie pigman=1:priest:pigman=1:pig.png:::Chinny chin chin !:nothing:Can build stuff.;pigman=1:nothing:pigman worker=1:pigmanWorker.png:hand::Pigman trained !:automate nether:Required to get netherrack.;pigman worker=1:spike maul:worker pork=1:workerPork.png:hand::Porkified !:deautomate nether:Porkifies a pigman worker.;nothing=0:pigman worker:netherrack=10:netherrack.png::grind:Nether racked !:nothing:Required to make nether bricks.;netherrack=10:furnace:nether brick=40:netherBrick.png:::Nether brick smelted !:nothing:Required to make netherblock.;nether brick=40:crafting table:netherblock=10:netherblock.png:::Netherblock crafted !:nothing:Required to make nether brick structures.;netherblock=36:nothing:nether section=1:netherSection.png:::Nether section built !:nothing:Required to build nether pillars and hallways;pigman=1:nothing:pigman smelter=1:pigmanSmelter.png:hand::Pigman smelter !:autocraft nether brick=.5:Auto-crafts nether bricks.;pigman=1:nothing:pigman mason=1:pigmanMason.png:hand::Pigman mason !:autocraft netherblock=.5:Auto-crafts netherblock from nether bricks.;pigman=1:nothing:pigman builder=1:pigmanBuilder.png:hand::Pigman builder !:autocraft nether section=.5:Auto-crafts nether sections.;nether section=7:nothing:nether pillar=1:netherPillar.png:metal::Nether pillar !:nothing:Required to build a nether bridge.;nether pillar=5:nothing:nether bridge=1:netherBridge.png:metal::Nether bridge built !:nothing:Required to build nether bridgeways.;nether bridge=10:nothing:nether bridgeways=1:netherBridgeways.png:metal::Nether bridgeways !:nothing:Required to build nether fortress exterior.;pigman smelter=1:spike maul:smelter pork=1:smelterPork.png:hand::Porkified !:deautocraft nether brick:Porkifies a pigman smelter.;pigman mason=1:spike maul:mason pork=1:masonPork.png:hand::Porkified !:deautocraft netherblock:Porkifies a pigman mason.;pigman builder=1:spike maul:builder pork=1:builderPork.png:hand::Porkified !:deautocraft nether section:Porkifies a pigman builder.;netherblock=6:crafting table:nether fence=6:netherFence.png:metal::Nether fence crafted !:nothing:Required to build nether rooms.;netherblock=6:crafting table:nether stairs=6:netherStairs.png:metal::Nether stairs crafted !:nothing:Required to build nether rooms.;nether stairs=9,netherblock=16,nether fence=2:nothing:nether staircase=1:netherStaircase.png:metal::Nether staircase !:nothing:Required to build nether rooms.;nether section=1,nether staircase=1,nether fence=27:nothing:nether spawn=1:netherSpawn.png:metal::nothing:nothing:Required to build nether fortress exterior.;netherblock=81:nothing:nether wall=1:netherWall.png:metal::nothing:nothing:Required to build a nether room.;nether wall=6,nether fence=22:nothing:nether room=1:netherRoom.png:metal::Nether room built !:nothing:Can be customized.;netherblock=8,lava=1:nothing:nether well=1:netherWell.png:metal::Nether well built !:nothing:Required to build a nether well room.;nether room=1,nether well=1:nothing:nether well room=1:netherWellRoom.png:metal::Nether well room !:nothing:Required to build nether fortress exterior.;nether bridgeways=1,nether spawn=1,nether well room=1:nothing:nether fortress exterior=1:netherFortressExterior.png:metal::Fortress exterior !:nothing:Required to build a nether fortress.;nether room=1,netherblock=15:nothing:nether stair room=1:netherStairRoom.png:metal::Nether stair room !:nothing:Required to build nether fortress interior.;nether room=1,nether staircase=2:nothing:nether wart room=1:netherWartRoom.png:metal::Nether wart room !:nothing:Required to build nether fortress interior.;nether section=1,nether fence=4:nothing:nether hall section=1:netherHallSection.png:metal::nothing:nothing:Required to build a nether hallway.;nether hall section=7:nothing:nether hallway=1:netherHallway.png:metal::Nether hallway built !:nothing:Required to build nether fortress interior.;nether hall section=4,nether staircase=2:nothing:nether stairwell=1:netherStairwell.png:metal::Nether stairwell !:nothing:Required to build nether fortress interior.;netherblock=27,nether fence=13:nothing:nether balcony=1:netherBalcony.png:metal::Nether balcony built !:nothing:Required to build nether fortress interior.;nether hallway=4,nether stairwell=1,nether balcony=1,nether wart room=1,nether stair room=1:nothing:nether fortress interior=1:netherFortressInterior.png:metal::Fortress interior !:nothing:Required to build a nether fortress.;nether fortress exterior=1,nether fortress interior=1:nothing:nether fortress=1:netherFortress.png:metal::Nether fortress !:beatLocation:Required to beat Chasm Mine.;nothing=0:nether fortress:nether fortress exporter=1:netherFortress.png:::nothing:navigateToUrl 1ENHzF:Download.;obsidian=54:nether fortress:ghast catcher=1:ghastCatcher.png:metal::Ghast catcher !:nothing:Required to make a ghast trap.;cobblestone=64:ghast catcher:ghast trap=1:ghastTrap.png:metal::Ghast trap !:nothing:Required to trap ghasts.;nothing=0:nothing:ghast=1:ghast.png:hand::Ghast trapped !:nothing:Required to tame a ghast.;ghast=1:nothing:gunpowder=1:gunpowder.png:whoosh::Gunpowder !:nothing:Used in explosives;nothing=0:nothing:string=1:string.png:whoosh::nothing:nothing:Used to make a lead.;nothing=0:iron sword,gold sword,diamond sword:slime ball=1:slimeBall.png:hand:grind:nothing:nothing:Used to make a lead.;string=4,slime ball=1:nothing:lead=1:lead.png:whoosh::Lead crafted !:nothing:Used to tame ghasts.;ghast=1,lead=1:nothing:tamed ghast=1:tamedGhast.png:hand::Ghast tamed !:nothing:Used to make a nether sleigh.;netherblock=3:crafting table:nether slab=6:netherSlab.png:metal::Nether slab !:nothing:Used to make a nether rib.;nether stairs=8,nether slab=4:nothing:nether rib=1:netherRib.png:metal::Nether rib built !:nothing:Used to make a nether sled.;nether rib=2:nothing:nether ski=1:netherSki.png:metal::Nether ski buit !:nothing:Used to make a nether sled.;nether rib=6,nether ski=2:nothing:nether sled=1:netherSled.png:metal::Nether sled !:nothing:Used to make a nether sleigh.;tamed ghast=8,nether sled=1:nothing:nether sleigh=1:netherSleigh.png:metal::Nether sleigh !:beatGame:Required to beat GrindCraft.;nothing=0:nether sleigh:nether sleigh exporter=1:netherSleigh.png:::nothing:navigateToUrl 1ENI60:Download.;nothing=0:nothing:miner=1:miner.png:hand:villager:nothing:automate mine:Automates mine grinder.;nothing=0:nothing:hunter=1:hunter.png:hand:villager:nothing:automate mobs:Automates mob grinder.;nothing=0:nothing:woodsman=1:woodsman.png:hand:villager:nothing:automate overworld:Automates overworld grinder.;nothing=0:nothing:carpenter=1:carpenter.png:hand:villager:nothing:nothing:Makes stuff out of wood.;nothing=0:nothing:smelter=1:smelter.png:metal:villager:Smelter trained !:autocraft iron ingot=.5,autocraft gold ingot:Auto-crafts iron and gold ingots.;nothing=0:nothing:blaze rod=1:blazeRod.png:metal::Blaze rod !:nothing:Used to make potions.;nothing=0:nothing:arrow=4:arrow.png:whoosh::Arrows crafted !:nothing:Combined with bow.;stick=2,iron ingot=3:crafting table:iron pick=1:ironPick.png:metal:metal:nothing:nothing:Mines gold.;stick=2,iron ingot=1:crafting table:iron shovel=1:ironShovel.png:metal:metal:nothing:nothing:Shovels dirt and gravel.;stick=2,iron ingot=3:crafting table:iron axe=1:ironAxe.png:metal:metal:nothing:nothing:Chops wood.;stick=2,iron ingot=2:crafting table:iron hoe=1:ironHoe.png:metal:metal:nothing:nothing:Tills soil.;stick=1,iron ingot=2:crafting table:iron sword=1:ironSword.png:metal:metal:nothing:nothing:Attacks mobs.;stick=2,gold ingot=3:crafting table:gold pick=1:goldPick.png:metal:metal:nothing:nothing:Mines diamond.;stick=2,gold ingot=1:crafting table:gold shovel=1:goldShovel.png:metal:metal:nothing:nothing:Shovels dirt and gravel.;stick=1,gold ingot=2:crafting table:gold sword=1:goldSword.png:metal:metal:nothing:nothing:Attacks mobs.;stick=2,gold ingot=3:crafting table:gold axe=1:goldAxe.png:metal:metal:nothing:nothing:Chops wood.;stick=2,gold ingot=2:crafting table:gold hoe=1:goldHoe.png:metal:metal:nothing:nothing:Tills soil.;nothing=0:minecart:diamond=1:diamond.png:metal:grind:nothing:nothing:Used to craft diamond tools and items.;stick=2,diamond=3:crafting table:diamond pick=1:diamondPick.png:metal:metal:nothing:nothing:Mines faster.;stick=2,diamond=1:crafting table:diamond shovel=1:diamondShovel.png:metal:metal:nothing:nothing:Shovels dirt and gravel.;stick=1,diamond=2:crafting table:diamond sword=1:diamondSword.png:metal:metal:nothing:nothing:Attacks mobs.;stick=2,diamond=3:crafting table:diamond axe=1:diamondAxe.png:metal:metal:nothing:nothing:Chops wood.;stick=2,diamond=2:crafting table:diamond hoe=1:diamondHoe.png:metal:metal:nothing:nothing:Tills soil.;nothing=0:iron axe,gold axe,diamond axe:wood=1:wood.png:wood:grind:nothing:nothing:Used to craft planks.;nothing=0:iron shovel,gold shovel,diamond shovel:dirt=1:dirt.png:dirt:grind:nothing:nothing:Used to make soil.;nothing=0:iron pick,gold pick,diamond pick:cobblestone=1:cobblestone.png:metal:grind:nothing:nothing:Used to make buildings.;wood=1:nothing:planks=4:planks.png:wood:wood:nothing:nothing:Used to craft wood tools and items.;planks=4:nothing:crafting table=1:craftingTable.png:wood::Crafting Table crafted !:nothing:Required to craft items.;planks=2:nothing:stick=4:stick.png:wood:wood:nothing:nothing:Used to craft wood tools and items.;nothing=0:minecart:lava=1:lava.png:wood:grind:nothing:nothing:Used to make a nether well.;nothing=0:iron shovel,gold shovel,diamond shovel:flint=1:flint.png:dirt:grind:nothing:nothing:Used to craft arrows.;nothing=0:iron pick,gold pick,diamond pick:gold ore=1:goldOre.png:metal:grind:nothing:nothing:Used to smelt gold ingots.;coal=1,gold ore=1:furnace:gold ingot=1:goldIngot.png:metal:metal:Gold ingot smelted !:nothing:Used to craft gold tools and armor.;nothing=0:nothing:city state=1:cityState.png:::City State !:nothing:Gud job.;nothing=0:nothing:port=1:port.png:wood:wood:Port established !:nothing:Required to sail around Grindcraftia."),
      a
    );
  })(),
  Grind = (function () {
    function a(a, b, c) {
      (this.xhint = 0), (this.yhint = 0), (this.game = a.game), (this.sender = a), (this.type = b), (this.grinds = c), (this.isGrid = !1), (this.isAutocraft = !1), (this.worker = null);
    }
    return (
      (a.prototype.stopGrindTimer = function () {
        void 0 != this.timerEmitter && this.timerEmitter.timer.pause(), void 0 != this.timerGrind && this.timerGrind.timer.pause(), void 0 != this.timerLine && this.timerLine.timer.pause();
      }),
      (a.prototype.startGrindTimer = function () {
        void 0 != this.timerEmitter && (this.timerEmitter.timer.paused = !1), void 0 != this.timerGrind && (this.timerGrind.timer.paused = !1), void 0 != this.timerLine && (this.timerLine.timer.paused = !1);
      }),
      (a.prototype.createRectangleGrid = function (a, b, c) {
        this.group = this.game.add.group();
        var d = this.game.add.sprite(0, 0, Game.KEY, "bkgGrind.png");
        (d.x = d.width / 2),
          d.anchor.setTo(0.5, 0.5),
          (d.inputEnabled = !0),
          Services.isDesktop() ? (d.events.onInputOver.add(this.timerItemOver, this), d.events.onInputOut.add(this.timerItemOut, this)) : (d.events.onInputDown.add(this.timerItemOver, this), d.events.onInputUp.add(this.timerItemOut, this)),
          this.group.add(d);
        var d = this.game.add.sprite(0, 0, Game.KEY, this.type);
        (d.x = d.width / 2), d.anchor.setTo(0.5, 0.5), this.group.add(d);
        var e = GameAPI.createText(this.game, 0, 0, "grincraft25stroke_shadow_white", GameAPI.getName(this.type), 15);
        (e.x = 70), (e.y = -20), e.anchor.setTo(0.5, 0.5), this.group.add(e), (this.group.y = a);
        var f = this.game.add.sprite(0, 0, Game.KEY, "grind.png");
        return (
          (f.width = 80),
          (f.height = 80),
          (f.x = 170),
          f.anchor.setTo(0.5, 0.5),
          this.group.add(f),
          (this.itemText = GameAPI.createText(this.game, 0, 0, "grindcraft", "test", 10)),
          (this.itemText.x = 170),
          (this.itemText.y = -20),
          (this.itemText.visible = !1),
          this.group.add(this.itemText),
          this.startGrid(c),
          this.group.moveUp(this.itemText),
          (this.group.name = b),
          "overworld" != this.group.name && (this.group.visible = !1),
          this.group
        );
      }),
      (a.prototype.timerItemOver = function (a, b) {
        (this.sender.sender.grindName = this.type),
          this.sender.sender.isPaused ||
            this.sender.sender.isClick ||
            this.sender.sender.isAutomated ||
            (void 0 != this.sender.sender.timerGrindHint && null != this.sender.sender.timerGrindHint) ||
            ((this.xhint = b.x), (this.yhint = b.y), (this.sender.sender.timerGrindHint = this.game.time.events.add(1 * Phaser.Timer.SECOND, this.onOverItem, this)));
      }),
      (a.prototype.timerItemOut = function (a, b) {
        (this.sender.sender.grindName = ""),
          null != this.sender.sender.timerGrindHint && this.sender.sender.timerGrindHint.timer.remove(this.sender.sender.timerGrindHint),
          (this.sender.sender.timerGrindHint = null),
          void 0 != this.sender.sender.grindHintGroup && null != this.sender.sender.grindHintGroup && (this.sender.sender.grindHintGroup.destroy(!0), (this.sender.sender.grindHintGroup = null));
      }),
      (a.prototype.onOverItem = function () {
        if (this.sender.sender.grindName == this.type && !this.sender.sender.isAutomated && null == this.sender.sender.grindHintGroup) {
          this.sender.sender.grindHintGroup = this.game.add.group();
          var a = this.game.add.sprite(0, 0, Game.KEY, "cropedShadow.png");
          this.sender.sender.grindHintGroup.add(a);
          var b = this.game.add.sprite(0, 0, Game.KEY, "bkgGrind.png");
          b.anchor.setTo(0.5, 0.5), (b.width = 90), this.sender.sender.grindHintGroup.add(b);
          for (var c = this.sender.mainGrinders.split(";"), d = 0; d < c.length; ++d)
            if (c[d].split(":")[2] == this.type) {
              var e = c[d].split(":")[1].replace("nothing=remainder,", "");
              b.height = 27 * e.split(",").length;
              for (var f = -b.height / 2 + 14, g = 0; g < e.split(",").length; ++g) {
                var h = this.game.add.sprite(-30, f, Game.KEY, "bkgrey.png");
                h.anchor.setTo(0.5, 0.5), (h.width = 25), (h.height = 25), this.sender.sender.grindHintGroup.add(h);
                var h = this.game.add.sprite(0, f, Game.KEY, "craftingArrow.png");
                h.anchor.setTo(0.5, 0.5), (h.width = 27), (h.height = 22), this.sender.sender.grindHintGroup.add(h);
                var h = this.game.add.sprite(30, f, Game.KEY, "bkgrey.png");
                h.anchor.setTo(0.5, 0.5), (h.width = 25), (h.height = 25), this.sender.sender.grindHintGroup.add(h);
                for (var i = e.split(",")[g].split("=")[0], j = 0; j < this.sender.mainGrinds.split(";").length; ++j)
                  if (this.sender.mainGrinds.split(";")[j].split(":")[0] == i && this.sender.mainGrinds.split(";")[j].split(":")[0]) {
                    var k = this.game.add.sprite(30, f, Game.KEY, this.sender.mainGrinds.split(";")[j].split(":")[1]);
                    k.anchor.setTo(0.5, 0.5), (k.width = 23), (k.height = 23), this.sender.sender.grindHintGroup.add(k);
                    for (var l = 0; l < this.sender.sender.mainCrafters.split(";").length; ++l) {
                      if ("hand" == this.sender.mainGrinds.split(";")[j].split(":")[3].split(",")[0].split("=")[0]) {
                        var k = this.game.add.sprite(-30, f, Game.KEY, "hand.png");
                        k.anchor.setTo(0.5, 0.5), (k.width = 23), (k.height = 23), this.sender.sender.grindHintGroup.add(k);
                        break;
                      }
                      if (this.sender.sender.mainCrafters.split(";")[l].split(":")[2].split("=")[0] == this.sender.mainGrinds.split(";")[j].split(":")[3].split(",")[0].split("=")[0]) {
                        var k = this.game.add.sprite(-30, f, Game.KEY, this.sender.sender.mainCrafters.split(";")[l].split(":")[3]);
                        k.anchor.setTo(0.5, 0.5), (k.width = 23), (k.height = 23), this.sender.sender.grindHintGroup.add(k);
                        break;
                      }
                    }
                    break;
                  }
                f += 26;
              }
              break;
            }
          Services.isDesktop()
            ? ((this.sender.sender.grindHintGroup.x = this.game.input.worldX), (this.sender.sender.grindHintGroup.y = this.game.input.worldY))
            : ((this.sender.sender.grindHintGroup.x = this.xhint), (this.sender.sender.grindHintGroup.y = this.yhint)),
            (this.sender.sender.grindHintGroup.y += this.sender.sender.grindHintGroup.height / 2 + 25),
            (a.x = -b.width / 2),
            (a.y = -b.height / 2),
            (a.width = b.width + 8),
            (a.height = b.height + 8);
        }
      }),
      (a.prototype.startGrid = function (a) {
        var b = a.split(";");
        this.item = this.getRandomItem();
        for (var c = 0; c < b.length; ++c) {
          var d = b[c].split(":");
          if ("" != this.item && "" != d[0] && (this.item == d[0] || "nothing" == this.item)) {
            "nothing" == this.item ? this.addMaterial(this.item) : this.addMaterial(d[1]);
            break;
          }
        }
      }),
      (a.prototype.addMaterial = function (a) {
        var b = this;
        if ("nothing" == a) {
          var c = this.game.add.sprite(0, 0, Game.KEY);
          c.visible = !1;
        } else {
          var c = this.game.add.sprite(0, 0, Game.KEY, a);
          c.visible = !0;
        }
        (c.inputEnabled = !0),
          (this.path = a),
          c.events.onInputUp.add(this.onDownGrind, this),
          c.events.onInputOver.add(function (a, c, d) {
            b.itemText.visible = !0;
          }, this),
          c.events.onInputOut.add(function (a, c, d) {
            b.itemText.visible = !1;
          }, this),
          Services.isDesktop() && (c.events.onInputOver.add(this.timerItemOver, this), c.events.onInputOut.add(this.timerItemOut, this), c.events.onInputUp.add(this.timerItemOut, this)),
          (this.material = c),
          this.group.moveUp(this.itemText),
          this.itemText.setText(this.item),
          (c.x = 170),
          (c.hitArea = new Phaser.Rectangle(-40, -40, 80, 80)),
          c.anchor.setTo(0.5, 0.5),
          this.group.add(c);
      }),
      (a.prototype.onDownGrind = function (a) {
        if (!this.sender.sender.isPaused && !this.isGrid) {
          var b = this.sender.mainGrinds.split(";"),
            c = "hand.png",
            d = "hand",
            e = "hand";
          this.material = a;
          for (var f = 1; f < b.length; ++f) {
            var g = b[f].split(":");
            if (void 0 != g[3] && g[0] == this.item) {
              for (var h = 0; h < g[3].split(",").length; ++h) {
                var i = g[3].split(",")[h].split("=");
                this.sender.sender.worldItems.forEach(function (a) {
                  i[0] == a.name && a.count > 0 && ((c = a.path), (d = a.name), (e = a.tag));
                }, this);
              }
              for (var h = 0; h < g[3].split(",").length; ++h) {
                var i = g[3].split(",")[h].split("=");
                if (d == i[0]) {
                  var j = this.game.add.sprite(0, 0, Game.KEY, c);
                  this.group.add(j),
                    (j.x = 100),
                    j.anchor.setTo(0.5, 0.5),
                    (this.isGrid = !0),
                    (this.redline = this.game.add.sprite(0, 0, Game.KEY, "redgrinder.png")),
                    this.group.add(this.redline),
                    (this.redline.x = 140),
                    (this.redline.y = 25),
                    (this.redline.height = 5),
                    (this.redline.width = 60),
                    (this.line = this.game.add.sprite(0, 0, Game.KEY, "greengrinder.png")),
                    this.group.add(this.line),
                    (this.line.x = 140),
                    (this.line.y = 25),
                    (this.line.height = 5);
                  var k = +i[1],
                    l = 1;
                  k < 2 && (l = 3), k <= 1.5 && (l = 5), k <= 1 && (l = 6), k <= 0.5 && (l = 8), (this.line.width = l);
                  var m = 0;
                  if (
                    ((m = (((100 * l) / 60) * k) / 100),
                    void 0 != this.emitter && null != this.emitter && (this.emitter.destroy(!0), (this.emitter = null)),
                    this.sender.sender.particleCount > 0 &&
                      ((this.emitter = this.game.add.emitter(0, 0, 100)),
                      this.emitter.makeParticles(Game.KEY, this.material.frameName),
                      (this.emitter.gravity = 200),
                      this.group.add(this.emitter),
                      (this.emitter.x = a.x),
                      (this.emitter.y = a.y),
                      (this.emitter.maxParticleScale = 0.1),
                      (this.emitter.minParticleScale = 0.05),
                      this.emitter.start(!0, 300, 100, this.sender.sender.particleCount)),
                    Game.music.addSound(g[0], e),
                    (this.timerLine = this.game.time.events.add(Phaser.Timer.SECOND * m, this.setLineTimer, this, [this.redline, this.line, m, l])),
                    (this.timerGrind = this.game.time.events.add(Phaser.Timer.SECOND * +i[1], this.setGrindTimer, this, [j, a])),
                    +i[1] >= 0.5 && this.sender.sender.particleCount > 0)
                  ) {
                    var n = +i[1];
                    (n -= 0.5), (this.timerEmitter = this.game.time.events.add(0.5 * Phaser.Timer.SECOND, this.setEmitterTimer, this, [j, a, n, g[0], e]));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      }),
      (a.prototype.setEmitterTimer = function (a) {
        var b = a[0],
          c = a[1],
          d = a[2];
        Game.music.addSound(a[3], a[4]),
          void 0 != this.emitter && null != this.emitter && (this.emitter.destroy(!0), (this.emitter = null)),
          this.timerEmitter.timer.remove(this.timerEmitter),
          this.sender.sender.particleCount > 0 &&
            ((this.emitter = this.game.add.emitter(0, 0, 100)),
            this.emitter.makeParticles(Game.KEY, this.material.frameName),
            (this.emitter.gravity = 200),
            this.group.add(this.emitter),
            (this.emitter.x = c.x),
            (this.emitter.y = c.y),
            (this.emitter.maxParticleScale = 0.1),
            (this.emitter.minParticleScale = 0.05),
            this.emitter.start(!0, 300, 100, this.sender.sender.particleCount),
            d >= 0.5 && ((d -= 0.5), (this.timerEmitter = this.game.time.events.add(0.5 * Phaser.Timer.SECOND, this.setEmitterTimer, this, [b, c, d, a[3], a[4]]))));
      }),
      (a.prototype.setLineTimer = function (a) {
        if (void 0 != this.line) {
          var b = a[2],
            c = a[3];
          (this.line.width += c),
            this.timerLine.timer.remove(this.timerLine),
            this.line.width >= 60 ? (this.redline.destroy(), this.line.destroy(), (this.line = void 0)) : (this.timerLine = this.game.time.events.add(Phaser.Timer.SECOND * b, this.setLineTimer, this, [this.redline, this.line, b, c]));
        }
      }),
      (a.prototype.setGrindTimer = function (a) {
        var b = this,
          c = this.sender.mainGrinds.split(";"),
          d = a[0],
          e = a[1],
          f = "";
        this.timerGrind.timer.remove(this.timerGrind);
        for (var g = 0; g < c.length; ++g) {
          var h = c[g].split(":");
          if (this.item == h[0]) {
            f = h[4];
            for (var i = h[2].split(","), j = 0; j < i.length; ++j) {
              var k,
                l = i[j].split("=");
              this.sender.sender.worldItems.forEach(function (a) {
                if (a.name == l[0]) return (k = a), null != b.worker ? (a.count += +l[1] * b.worker.count) : (a.count += +l[1]), void b.sender.sender.resetCubes();
              }, this);
              var m = !0;
              this.sender.sender.inventoryItems.forEach(function (a) {
                if (a.name == l[0]) return null != b.worker ? (a.count += +l[1] * b.worker.count) : (a.count += +l[1]), void (m = !1);
              }, this),
                m && void 0 != k && k.count >= 1 && (this.sender.sender.createInventoryItem(k.name, k.count, k.path), this.sender.sender.resetInventory());
            }
            break;
          }
        }
        if (("nothing" != f && "" != f && void 0 != f && (Game.achievements.createAchievement(f, e.frameName), (this.sender.mainGrinds = this.sender.mainGrinds.replace(f, ""))), (this.item = this.getRandomItem()), "nothing" == this.item))
          e.visible = !1;
        else
          for (var g = 0; g < c.length; ++g) {
            var h = c[g].split(":");
            if (this.item == h[0]) {
              this.itemText.setText(this.item), (e.frameName = h[1]);
              break;
            }
          }
        d.destroy(), (this.isGrid = !1);
        for (var g = 0; g < this.sender.grinds.length; ++g) this.sender.grinds[g].addItem();
        void 0 != this.line && (this.line.destroy(), this.redline.destroy()), this.isAutocraft && this.onDownGrind(this.material);
      }),
      (a.prototype.addItem = function () {
        var a = this.sender.mainGrinds.split(";");
        if (1 == this.group.visible && 0 == this.material.visible) {
          if (((this.item = this.getRandomItem()), "nothing" == this.item)) return;
          for (var b = 0; b < a.length; ++b) {
            var c = a[b].split(":");
            if (this.item == c[0]) return this.itemText.setText(this.item), (this.material.frameName = c[1]), void (this.material.visible = !0);
          }
        }
      }),
      (a.prototype.getRandomItem = function () {
        for (var a = this.createVisibleGrind(), b = 0, c = 0; c < a.length; ++c) {
          var d = a[c].split("=");
          b += +d[1];
        }
        var e = this.getRandomInt(0, b);
        b = 0;
        for (var c = 0; c < a.length; ++c) {
          var d = a[c].split("=");
          if (((b += +d[1]), e <= b)) return d[0];
        }
        return "";
      }),
      (a.prototype.createVisibleGrind = function () {
        for (var a = [], b = this.grinds, c = 0; c < b.length; ++c) {
          var d = b[c].split("=");
          if (!this.isAutocraft || "nothing=30" != b[c])
            for (var e = 0; e < this.sender.materials.split(",").length; ++e)
              if (d[0] == this.sender.materials.split(",")[e]) {
                if (null != this.worker && "butcher" == this.worker.name && this.worker.count > 0 && "mobs.png" == this.type && ("zombie" == d[0] || "skeleton" == d[0] || "spider" == d[0])) continue;
                a.push(b[c]);
              }
        }
        return 0 != a.length && (this.group.visible = !0), 1 == a.length && "nothing=30" == a[0] && (this.group.visible = !1), a;
      }),
      (a.prototype.getRandomInt = function (a, b) {
        return Math.random() * (b - a) + a;
      }),
      a
    );
  })(),
  Grinds = (function () {
    function a(a, b, c) {
      (this.game = a.game), (this.sender = a), (this.mainGrinds = b), (this.mainGrinders = c), (this.materials = Game.save.grind), (this.grindGroup = this.game.add.group()), (this.grinds = []);
    }
    return (
      (a.prototype.createGrind = function () {
        var a = this.game.add.sprite(-30, -5, Game.KEY, "cube.png");
        (a.width = 250), (a.height = 395), this.grindGroup.add(a);
        var b = GameAPI.createText(this.game, 0, 0, "grindcraft", "Grind", 25);
        (b.x = b.width / 2), (b.y = 20), this.grindGroup.add(b);
        for (var c = this.mainGrinders.split(";"), d = 75, e = 0; e < c.length; ++e) {
          var f = c[e].split(":"),
            g = new Grind(this, f[2], f[1].replace("nothing=remainder,", "nothing=30,").split(",")),
            h = g.createRectangleGrid(d, f[0], this.mainGrinds);
          this.grinds.push(g), this.grindGroup.add(h), (d += 90);
        }
        for (var e = 0; e < this.grinds.length; ++e) this.grinds[e].createVisibleGrind();
        this.grindGroup.x = 20;
      }),
      (a.prototype.resetGrids = function (a) {
        var b = this;
        this.mainGrinds.split(";").forEach(function (c) {
          var d = c.split(":");
          if (void 0 != d[3]) {
            var e = d[3].split(",");
            e.forEach(function (c) {
              var e = c.split("=");
              if (a.name == e[0] && a.count > 0) {
                for (var f = !1, g = 0; g < b.materials.split(",").length; ++g)
                  if (b.materials.split(",")[g] == d[0]) {
                    f = !0;
                    break;
                  }
                f || (b.materials += d[0] + ",");
              }
            }, b);
          }
        }, this);
      }),
      (a.prototype.addMaterials = function (a) {
        for (var b = 0; b < this.grinds.length; ++b) {
          var c = this.grinds[b].getRandomItem();
          if (void 0 == this.grinds[b].material && 1 == this.grinds[b].group.visible) {
            this.grinds[b].item = c;
            this.mainGrinds.split(";").forEach(function (a) {
              if (a.split(":")[0] == c) return void (c = a.split(":")[1]);
            }, this),
              this.grinds[b].addMaterial(c),
              this.grinds[b].group.moveUp(this.grinds[b].itemText);
          }
        }
      }),
      (a.prototype.stopGrindTimers = function () {
        void 0 != this.grinds &&
          this.grinds.forEach(function (a) {
            a.stopGrindTimer();
          }, this);
      }),
      (a.prototype.startGrindTimer = function () {
        void 0 != this.grinds &&
          this.grinds.forEach(function (a) {
            a.startGrindTimer();
          }, this);
      }),
      a
    );
  })(),
  Music = (function () {
    function a(a) {
      (this.game = a), (this.soundCount = Game.save.soundCount), (this.musicCount = Game.save.musicCount), (this.music = this.game.make.audio("track13", this.musicCount / 100));
      var b = SaveAPI.getAccess(SaveAPI.SOUND);
      null == b && (b = !0), (this.SoundActive = b);
      var c = SaveAPI.getAccess(SaveAPI.MUSIC);
      null == c && (c = !0), (this.MusicActive = c), this.playMusic();
    }
    return (
      (a.prototype.playMusic = function () {
        this.music.isPlaying || ((this.music.loop = !0), void 0 != this.musicCount && (this.music.volume = this.musicCount / 100), this.music.play());
      }),
      (a.prototype.startAudioGrind = function (a) {
        var b = this.game.make.audio(a, this.soundCount / 100);
        b.play();
      }),
      (a.prototype.musicVolume = function () {
        this.game.add.tween(this.music).to({ volume: this.musicCount / 100 }, 500, Phaser.Easing.Linear.None, !0);
      }),
      (a.prototype.getNameObject = function (a) {
        if ("music" == a) {
          if (this.MusicActive) return "musicOn.png";
          if (!this.MusicActive) return "musicOff.png";
        }
        if ("sound" == a) {
          if (this.SoundActive) return "soundOn.png";
          if (!this.SoundActive) return "soundOff.png";
        }
      }),
      (a.prototype.statusSound = function (a, b, c, d) {
        void 0 === d && (d = "sound"),
          "sound" == d && ((this.SoundActive = !this.SoundActive), SaveAPI.setForce(SaveAPI.SOUND, this.SoundActive), (a.frameName = this.getNameObject(d))),
          "music" == d &&
            ((this.MusicActive = !this.MusicActive),
            SaveAPI.setForce(SaveAPI.MUSIC, this.MusicActive),
            (a.frameName = this.getNameObject(d)),
            this.MusicActive || this.musicVolume(),
            this.MusicActive && (this.music.isPlaying ? this.game.add.tween(this.music).to({ volume: 1 }, 500, Phaser.Easing.Linear.None, !0) : this.playMusic()));
      }),
      (a.prototype.audioEffects = function (a) {
        this.SoundActive && (a.isPlaying || a.play());
      }),
      (a.prototype.startMusic = function (a) {
        this.MusicActive && (a.isPlaying || a.play());
      }),
      (a.prototype.addSound = function (a, b) {
        var c = b;
        "wood" == a && (c = "wood"),
          ("dirt" != a && "gravel" != a) || (c = "dirt"),
          ("grass" != a && "pumpkin" != a && "wheat" != a && "sugar cane" != a) || (c = "whoosh"),
          "hand" == b && (c = "hand"),
          "metal" == a && (c = "metal"),
          (c += Math.round(this.getRandomInt(1, 6))),
          Game.music.startAudioGrind(c);
      }),
      (a.prototype.getRandomInt = function (a, b) {
        return Math.random() * (b - a) + a;
      }),
      (a.prototype.playAudio = function (a) {
        this.SoundActive && a.play();
      }),
      (a.prototype.stopAudio = function (a) {
        this.SoundActive && a.isPlaying && a.stop();
      }),
      a
    );
  })(),
  NineImage = (function () {
    function a() {}
    return (
      (a.create = function (b, c, d, e, f, g, h, i, j, k) {
        return (
          void 0 === g && (g = 0),
          void 0 === h && (h = 0),
          void 0 === i && (i = 0),
          void 0 === j && (j = 0),
          void 0 === k && (k = !1),
          (a._image = b.cache.getImage(e)),
          "string" == typeof f ? (a._frame = b.cache.getFrameByName(e, f)) : (a._frame = b.cache.getFrameByIndex(e, f)),
          a.calculateNineImage(c, d, g, h, i, j, k),
          (a._nineImage = new Phaser.BitmapData(b, "NineImage" + a._textureKey++, a._width, a._height)),
          a.renderNineImage(),
          a._nineImage
        );
      }),
      (a.calculateNineImage = function (b, c, d, e, f, g, h) {
        var i = a._frame;
        if (((a._centralWidth = i.width - e - g), (a._centralHeight = i.height - d - f), h))
          (a._horizontalRepeats = b), (a._verticalRepeats = c), (a._width = e + g + a._centralWidth * b), (a._height = d + f + a._centralHeight * c), (a._lastWidth = 0), (a._lastHeight = 0);
        else {
          var j = b - e - g;
          (a._horizontalRepeats = Math.floor(j / a._centralWidth)), (a._lastWidth = j % a._centralWidth);
          var k = c - d - f;
          (a._verticalRepeats = Math.floor(k / a._centralHeight)), (a._lastHeight = k % a._centralHeight), (a._width = b), (a._height = c);
        }
        (a._leftWidth = e), (a._rightWidth = g), (a._topHeight = d), (a._bottomHeight = f);
      }),
      (a.renderNineImage = function () {
        var b = a._frame.y,
          c = 0;
        a._topHeight > 0 && (a.renderNineImageRow(a._image, b, c, a._topHeight), (b += a._topHeight), (c += a._topHeight));
        for (var d = 0; d < a._verticalRepeats; d++) a.renderNineImageRow(a._image, b, c, a._centralHeight), (c += a._centralHeight);
        a._lastHeight > 0 && (a.renderNineImageRow(a._image, b, c, a._lastHeight), (c += a._lastHeight)), (b += a._centralHeight), a._bottomHeight > 0 && a.renderNineImageRow(a._image, b, c, a._bottomHeight);
      }),
      (a.renderNineImageRow = function (b, c, d, e) {
        var f = a._frame.x,
          g = 0;
        a._leftWidth > 0 && (a._nineImage.copy(b, f, c, a._leftWidth, e, g, d), (g += a._leftWidth), (f += a._leftWidth));
        for (var h = 0; h < a._horizontalRepeats; h++) a._nineImage.copy(b, f, c, a._centralWidth, e, g, d), (g += a._centralWidth);
        a._lastWidth > 0 && (a._nineImage.copy(b, f, c, a._lastWidth, e, g, d), (g += a._lastWidth)), (f += a._centralWidth), a._rightWidth > 0 && a._nineImage.copy(b, f, c, a._rightWidth, e, g, d);
      }),
      (a._textureKey = 0),
      a
    );
  })(),
  AdTimer = (function () {
    function a(a) {
      (this.timerLimit = 120), (this.game = a);
    }
    return (
      (a.prototype.setDefaultTimer = function () {
        var a = this.getTimer();
        if (null === a || "undefined" === a) {
          var b = { storedTime: 0, isRunning: !1 };
          this.setTimer(b);
        }
      }),
      (a.prototype.setTimer = function (a) {
        this.game.storage.setItem("adTimer", JSON.stringify(a));
      }),
      (a.prototype.getTimer = function () {
        return this.game.storage.getItem("adTimer");
      }),
      (a.prototype.startTimer = function () {
        this.timeThen = Date.now();
        var a = { storedTime: this.timeThen, isRunning: !0 };
        this.setTimer(a);
      }),
      (a.prototype.calculateElapsedTime = function (a) {
        this.timeNow = Date.now();
        var b = a,
          c = new Date(b.storedTime);
        c.setTime(c.getTime());
        var d = (this.timeNow - c) / 1e3;
        return Math.round(d);
      }),
      (a.prototype.isTimerDone = function () {
        var a = this.getTimer();
        if (null === a || "undefined" === a) return !0;
        var b = JSON.parse(a),
          c = this.calculateElapsedTime(b);
        return !!(b.isRunning && c >= this.timerLimit) || !b.isRunning;
      }),
      a
    );
  })(),
  Roller = (function () {
    function a(a, b) {
      (this.game = a), (this._count = 0), (this.isMove = !1), (this.callbacks = []), (this.startx = b), (this.rollerGroup = this.game.add.group()), this.createRoller(), this.game.input.addMoveCallback(this.mouseDrag, this);
    }
    return (
      Object.defineProperty(a.prototype, "count", {
        get: function () {
          return this._count;
        },
        set: function (a) {
          (this._count = a), void 0 != this.rollerGroup && (this.control.x = (this.bkgControl.width * this._count) / 100);
        },
        enumerable: !0,
        configurable: !0,
      }),
      (a.prototype.createRoller = function () {
        var a = this;
        (this.bkgControl = this.game.add.sprite(0, 0, Game.KEY, "slider_bar.png")),
          (this.bkgControl.width = 100),
          (this.bkgControl.height = 5),
          this.bkgControl.anchor.setTo(0, 0.5),
          (this.bkgControl.inputEnabled = !0),
          this.bkgControl.events.onInputUp.add(function () {
            a.isMove = !1;
          }, this),
          this.bkgControl.events.onInputDown.add(function (b, c) {
            c.x > a.startx && c.x < a.startx + a.bkgControl.width && ((a.control.x = c.x - a.startx), (a._count = (100 * a.control.x) / a.bkgControl.width), a.startMoveCallback(), (a._count = Math.round(a._count))), (a.isMove = !0);
          }, this),
          (this.bkgControl.hitArea = new Phaser.Rectangle(0, -20, 200, 40)),
          this.rollerGroup.add(this.bkgControl),
          (this.control = this.game.add.sprite(0, 0, Game.KEY, "slider_button.png")),
          (this.control.width = 12),
          (this.control.height = 12),
          this.control.anchor.setTo(0.5, 0.5),
          this.rollerGroup.add(this.control);
      }),
      (a.prototype.mouseDrag = function (a, b, c, d) {
        this.isMove &&
          ((this.control.x = b - this.startx),
          (this._count = (100 * this.control.x) / this.bkgControl.width),
          b > this.startx + this.bkgControl.width && ((this.control.x = this.bkgControl.width), (this._count = (100 * this.control.x) / this.bkgControl.width)),
          b < this.startx && ((this.control.x = 0), (this._count = (100 * this.control.x) / this.bkgControl.width)),
          (this._count = Math.round(this._count)),
          this.startMoveCallback());
      }),
      (a.prototype.startMoveCallback = function () {
        var a = this;
        this.callbacks.forEach(function (b) {
          b.call(a.game);
        }, this);
      }),
      (a.prototype.addMoveCallback = function (a) {
        this.callbacks.push(a);
      }),
      (a.prototype.removeMoveCallback = function (a) {
        this.callbacks.splice(this.callbacks.indexOf(a), 1);
      }),
      a
    );
  })(),
  SaveAPI = (function () {
    function a() {}
    return (
      (a.isCapable = function () {
        return !("undefined" == typeof window.localStorage);
      }),
      (a.getAccess = function (a) {
        if (!this.isCapable()) return null;
        try {
          return JSON.parse(localStorage.getItem(a));
        } catch (b) {
          return window.localStorage.getItem(a);
        }
      }),
      (a.setAccess = function (a, b) {
        if (!this.isCapable()) return null;
        try {
          var c = window.localStorage.getItem(a);
          (c < b || null == c) && window.localStorage.setItem(a, JSON.stringify(b));
        } catch (d) {
          d == DOMException.QUOTA_EXCEEDED_ERR;
        }
      }),
      (a.setForce = function (a, b) {
        if (!this.isCapable()) return null;
        try {
          window.localStorage.setItem(a, JSON.stringify(b));
        } catch (c) {
          c == DOMException.QUOTA_EXCEEDED_ERR;
        }
      }),
      (a.clear = function () {
        return this.isCapable() ? void window.localStorage.clear() : null;
      }),
      (a.generateDefaultData = function (b) {
        var c = new GameSave();
        return (
          (c.countItem = []),
          a.addField(c, GameAPI.crafters.split(";"), b),
          a.addField(c, GameAPI.chasmMineCrafters.split(";"), b),
          (c.grind = "wood,nothing,"),
          (c.level = "City State"),
          (c.achievementGrind = ","),
          Services.isDesktop() ? (c.particleCount = 50) : (c.particleCount = 0),
          (c.soundCount = 50),
          (c.musicCount = 50),
          (c.mapVisible = !1),
          (c.isMerge = !0),
          (c.isOpenNextLevel = !1),
          (c.isAutomated = !1),
          (c.inventoryItem = []),
          (c.achievement = []),
          c
        );
      }),
      (a.addField = function (a, b, c) {
        for (var d = !1, e = 0; e < b.length; ++e) {
          d = !1;
          var f = new CountItem(),
            g = b[e].split(":");
          (f.name = g[2].split("=")[0]),
            (f.count = c),
            (f.isAchievement = !1),
            (f.ability = !1),
            a.countItem.forEach(function (a) {
              if (a.name == f.name) return void (d = !0);
            }, this),
            d || a.countItem.push(f);
        }
      }),
      (a.UNIQ_ID = "UniqId"),
      (a.SOUND = "isSoundOn"),
      (a.MUSIC = "isMusicOn"),
      (a.SAVE_DATA = "GrindcraftData"),
      a
    );
  })(),
  GameSave = (function () {
    function a() {}
    return a;
  })(),
  AchievementInfo = (function () {
    function a() {}
    return a;
  })(),
  CountItem = (function () {
    function a() {}
    return a;
  })(),
  ScaleManager = (function () {
    function a() {}
    return (
      (a.init = function (b) {
        (a.game = b),
          (this.onResize = new Phaser.Signal()),
          (b.scale.scaleMode = Phaser.ScaleManager.USER_SCALE),
          (window.onresize = function () {
            a.SizeCalculation(b);
          }),
          a.SizeCalculation(b);
      }),
      (a.SizeCalculation = function (b) {
        var c = a.GameWidth,
          d = a.GameHeight,
          e = Math.min(window.innerWidth / a.GameWidth, window.innerHeight / a.GameHeight),
          f = document.getElementById("gameContainer");
        (f.style.minHeight = window.innerHeight.toString() + "px"),
          (c = Math.ceil(window.innerWidth / e + 1)),
          (d = Math.ceil(window.innerHeight / e + 1)),
          b.scale.setUserScale(e, e, 0, 0),
          b.scale.setGameSize(c, d),
          b.world.setBounds(0, 0, c, d),
          b.scale.refresh(),
          (this.scale = e),
          this.onResize.dispatch();
      }),
      (a.bkgX = function () {
        return (a.GameWidth - a.MaxWidth) / 2;
      }),
      (a.bkgY = function () {
        return (a.GameHeight - a.MaxHeight) / 2;
      }),
      (a.by = function (b) {
        return a.GameWidth / 2 - (a.GameWidth / 2 - b);
      }),
      (a.handleIncorrect = function () {
        Services.isDesktop() || ((document.getElementById("turn").style.display = "block"), (a.game.world.isPaused = !0));
      }),
      (a.handleCorrect = function () {
        Services.isDesktop() || ((document.getElementById("turn").style.display = "none"), (a.game.world.isPaused = !1)), setTimeout("window.scrollTo(0,0)", 1e3);
      }),
      (a.GameWidth = 760),
      (a.GameHeight = 610),
      (a.MaxWidth = 1440),
      (a.MaxHeight = 1457),
      a
    );
  })(),
  ScrollBar = (function () {
    function a(a, b, c, d, e, f, g) {
      if (
        ((this.KEY = "atlas"),
        (this.game = a),
        (this.mScrollGroup = b),
        (this.callbacks = []),
        (this.scrollBarGroup = a.add.group()),
        (this.x = c),
        (this.y = d),
        (this.isTouch = !1),
        (this.isMove = !1),
        (this.isPause = !1),
        (this.yScroll = 0),
        (this.scrollStep = 7),
        (this.startY = b.y),
        void 0 == e ? (this.xEnd = -10) : (this.xEnd = e),
        void 0 == f ? (this.scrollWidth = 15) : (this.scrollWidth = f),
        void 0 == g ? (this.scrollHeight = 14) : (this.scrollHeight = g),
        this.scrollBar(),
        this.game.input.addMoveCallback(this.mouseDrag, this),
        this.game.device.desktop)
      ) {
        var h = document.getElementById("gameContainer");
        h.addEventListener("mousewheel", this.mouseWheel.bind(this), !1),
          h.addEventListener("DOMMouseScroll", this.mouseWheel.bind(this), !1),
          (document.onmousewheel = function (a) {
            a.preventDefault();
          });
      } else this.game.input.addMoveCallback(this.onTouchMove, this), this.game.input.onDown.add(this.onTouchDown, this), this.game.input.onUp.add(this.onTouchUp, this);
    }
    return (
      (a.prototype.onTouchDown = function () {
        (this.isTouch = !0), (this.touchY = this.game.input.worldY);
      }),
      (a.prototype.onTouchUp = function () {
        this.isTouch = !1;
      }),
      (a.prototype.onTouchMove = function (a, b, c) {
        this.isMove ||
          this.isPause ||
          (this.isTouch &&
            this.x + this.mScrollGroup.width > this.game.input.worldX &&
            this.x < this.game.input.worldX &&
            this.y + this.mScrollGroup.height > this.game.input.worldY &&
            this.y < this.game.input.worldY &&
            (this.touchY < this.game.input.worldY && this.upScroll(4 * this.scrollStep), this.touchY > this.game.input.worldY && this.downScroll(4 * this.scrollStep), (this.touchY = this.game.input.worldY)));
      }),
      (a.prototype.mouseWheel = function (a) {
        this.isPause ||
          (this.x + this.mScrollGroup.width + 2 * this.scrollWidth > this.game.input.worldX &&
            this.x < this.game.input.worldX &&
            this.y + this.mScrollGroup.height > this.game.input.worldY &&
            this.y < this.game.input.worldY &&
            (this.game.input.mouse.wheelDelta < 0 && this.downScroll(2 * this.scrollStep), this.game.input.mouse.wheelDelta > 0 && this.upScroll(2 * this.scrollStep)));
      }),
      (a.prototype.mouseDrag = function (a, b, c, d) {
        if (!this.isPause) {
          if (this.isMove) {
            if (this.yScroll < c && this.scrolldown.y - this.scrolldown.height / 2 > this.scrollmove.y + this.scrollmove.height) {
              var e = c - this.yScroll;
              if (((this.scrollmove.y += e), (this.mScrollGroup.y -= e * this.fuctorMove), this.scrolldown.y - this.scrolldown.height / 2 < this.scrollmove.y + this.scrollmove.height)) {
                var f = this.scrollmove.y + this.scrollmove.height - (this.scrolldown.y - this.scrolldown.height / 2);
                (this.scrollmove.y -= f), (this.mScrollGroup.y += f * this.fuctorMove);
              }
            }
            if (this.yScroll > c && this.scrollup.y + this.scrollup.height / 2 < this.scrollmove.y) {
              var e = this.yScroll - c;
              if (((this.scrollmove.y -= e), (this.mScrollGroup.y += e * this.fuctorMove), this.scrollup.y + this.scrollup.height / 2 > this.scrollmove.y)) {
                var f = this.scrollup.y + this.scrollup.height / 2 - this.scrollmove.y;
                (this.scrollmove.y += f), (this.mScrollGroup.y -= f * this.fuctorMove);
              }
            }
            this.startMoveCallback();
          }
          this.yScroll = c;
        }
      }),
      (a.prototype.startMoveCallback = function () {
        var a = this;
        this.callbacks.forEach(function (b) {
          b.call(a.game);
        }, this);
      }),
      (a.prototype.addMoveCallback = function (a) {
        this.callbacks.push(a);
      }),
      (a.prototype.removeMoveCallback = function (a) {
        this.callbacks.splice(this.callbacks.indexOf(a), 1);
      }),
      (a.prototype.IsShowScroll = function () {
        if (0 != this.mScrollGroup.length) {
          if (this.scrollback.height - this.scrolldown.height - this.scrollup.height < this.scrollmove.height) return !1;
          if (this.mScrollGroup.height > this.scrollback.height) return !0;
        }
        return !1;
      }),
      (a.prototype.scrollBar = function () {
        var a = this;
        (this.scrollback = this.game.add.sprite(10, 225, this.KEY, "flcontrols.png")),
          this.scrollback.anchor.setTo(0.5, 0.5),
          (this.scrollback.y = this.game.world.height / 2 + this.mScrollGroup.y),
          (this.scrollback.x = this.mScrollGroup.x + this.mScrollGroup.width - 20),
          (this.scrollback.height = this.game.world.height - this.mScrollGroup.y),
          (this.scrollback.width = this.scrollWidth),
          this.scrollBarGroup.add(this.scrollback),
          (this.scrollup = this.game.add.button(10, 90, this.KEY, null, null, "flscrollbuttonup2.png", "flscrollbuttonup1.png", "flscrollbuttonup3.png", "flscrollbuttonup1.png")),
          (this.scrollup.width = this.scrollWidth),
          (this.scrollup.height = this.scrollHeight),
          this.scrollup.anchor.setTo(0.5, 0.5),
          this.scrollup.onInputDown.add(function () {
            (a.timerUp = a.game.time.create(!1)), a.timerUp.loop(50, a.upScroll, a), a.timerUp.start();
          }, this),
          this.scrollup.onInputUp.add(function () {
            a.timerUp.stop();
          }, this),
          (this.scrollup.y = this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height / 2),
          (this.scrollup.x = this.mScrollGroup.x + this.mScrollGroup.width - 20),
          this.scrollBarGroup.add(this.scrollup),
          (this.scrolldown = this.game.add.button(10, 90, this.KEY, null, null, "flscrollbuttondown2.png", "flscrollbuttondown1.png", "flscrollbuttondown3.png", "flscrollbuttondown1.png")),
          this.scrolldown.anchor.setTo(0.5, 0.5),
          (this.scrolldown.width = this.scrollWidth),
          (this.scrolldown.height = this.scrollHeight),
          this.scrolldown.onInputDown.add(function () {
            (a.timerDown = a.game.time.create(!1)), a.timerDown.loop(50, a.downScroll, a), a.timerDown.start();
          }, this),
          this.scrolldown.onInputUp.add(function () {
            a.timerDown.stop();
          }, this),
          (this.scrolldown.y = this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height / 2),
          (this.scrolldown.x = this.mScrollGroup.x + this.mScrollGroup.width - 20),
          this.scrollBarGroup.add(this.scrolldown),
          (this.scrollmove = new Phaser.Sprite(this.game, 10, this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height, GameAPI.scrollbitmapdata.texture)),
          (this.scrollmove.inputEnabled = !0),
          this.scrollmove.events.onInputUp.add(function () {
            a.isMove = !1;
          }, this),
          this.scrollmove.events.onInputDown.add(function () {
            a.isMove = !0;
          }, this),
          this.scrollmove.anchor.setTo(0.5, 0),
          (this.scrollmove.width = this.scrollWidth),
          (this.scrollmove.x = this.mScrollGroup.x + this.mScrollGroup.width - 20),
          this.scrollBarGroup.add(this.scrollmove),
          this.resetSize();
      }),
      (a.prototype.upScroll = function (a) {
        if (this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height < this.scrollmove.y) {
          if (
            this.scrollmove.y - (this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height) < this.scrollStep ||
            (void 0 != a && this.scrollmove.y - (this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height) < a)
          ) {
            var b = this.scrollmove.y - (this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height);
            (this.scrollmove.y -= b), (this.mScrollGroup.y += b * this.fuctorMove);
          } else void 0 == a ? ((this.scrollmove.y -= this.scrollStep), (this.mScrollGroup.y += this.scrollStep * this.fuctorMove)) : ((this.scrollmove.y -= a), (this.mScrollGroup.y += a * this.fuctorMove));
          this.startMoveCallback();
        }
      }),
      (a.prototype.downScroll = function (a) {
        if (this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height > this.scrollmove.y + this.scrollmove.height) {
          if (
            this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height - (this.scrollmove.y + this.scrollmove.height) < this.scrollStep ||
            (void 0 != a && this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height - (this.scrollmove.y + this.scrollmove.height) < a)
          ) {
            var b = this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height - (this.scrollmove.y + this.scrollmove.height);
            (this.scrollmove.y += b), (this.mScrollGroup.y -= b * this.fuctorMove);
          } else void 0 == a ? ((this.scrollmove.y += this.scrollStep), (this.mScrollGroup.y -= this.scrollStep * this.fuctorMove)) : ((this.scrollmove.y += a), (this.mScrollGroup.y -= a * this.fuctorMove));
          this.startMoveCallback();
        }
      }),
      (a.prototype.resizeScroll = function () {
        if (null != this.scrollback && null != this.scrolldown && null != this.scrollmove && null != this.scrollup) {
          var a = (this.scrollback.height - this.scrollup.height - this.scrolldown.height) / this.mScrollGroup.height,
            b = this.scrollback.height - this.scrollup.height - this.scrolldown.height;
          (this.scrollmove.height = b * a),
            (this.scrollmove.y = this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height),
            (this.fuctorMove = (this.mScrollGroup.x + this.mScrollGroup.height - this.mScrollGroup.x) / (this.scrollback.height - this.scrollup.height - this.scrolldown.height)),
            this.IsShowScroll() ? (this.scrollBarGroup.visible = !0) : (this.scrollBarGroup.visible = !1);
        }
      }),
      (a.prototype.resetSize = function () {
        0 == this.mScrollGroup.height && (this.scrollBarGroup.visible = !1),
          (this.mScrollGroup.y = this.startY),
          null != this.scrollback &&
            ((this.scrollback.height = this.game.world.height - this.mScrollGroup.y), (this.scrollback.x = this.mScrollGroup.x + this.mScrollGroup.width + this.xEnd), (this.scrollback.y = this.mScrollGroup.y + this.scrollback.height / 2)),
          null != this.scrollup && ((this.scrollup.y = this.scrollback.y - this.scrollback.height / 2 + this.scrollup.height / 2), (this.scrollup.x = this.mScrollGroup.x + this.mScrollGroup.width + this.xEnd)),
          null != this.scrolldown && ((this.scrolldown.x = this.mScrollGroup.x + this.mScrollGroup.width + this.xEnd), (this.scrolldown.y = this.scrollback.y + this.scrollback.height / 2 - this.scrolldown.height / 2)),
          0 != this.mScrollGroup.length && this.resizeScroll(),
          null != this.scrollmove && (this.scrollmove.x = this.mScrollGroup.x + this.mScrollGroup.width + this.xEnd);
      }),
      a
    );
  })(),
  Services = (function () {
    function a() {}
    return (
      (a.init = function (b) {
        (a.game = b), a.initAnalytics();
      }),
      (a.initAnalytics = function () {
        var a = "442752e332b8585efa81f84baf9bd2e9",
          b = "e2f97056cdd89ccac5c81445c12b5e9fa0b75cbc",
          c = version,
          d = GA.getInstance(),
          e = SaveAPI.getAccess(SaveAPI.UNIQ_ID);
        null == e && ((e = Date.now().toString() + Math.random()), SaveAPI.setAccess(SaveAPI.UNIQ_ID, e));
        var f = new GA.User(e);
        d.init(a, b, c, f), d.addEvent(new GA.Events.Design("Game:Start"));
        var g = Date.now();
        window.addEventListener("beforeunload", function () {
          d.addEvent(new GA.Events.SessionEnd((Date.now() - g) / 1e3)), d.sendData();
        });
      }),
      (a.isDesktop = function () {
        return a.game.device.desktop;
      }),
      a
    );
  })(),
  SponsorLogo = (function (a) {
    function b(c, d, e) {
      a.call(this, c, d, e, b.KEY, b.LOGO_FRAME), (this.inputEnabled = !0), (this.input.useHandCursor = !0), this.events.onInputUp.add(ExternalLinks.goToSponsorPageLogo, this);
    }
    return __extends(b, a), (b.KEY = "atlas"), (b.LOGO_FRAME = "fgLogo.png"), b;
  })(Phaser.Sprite),
  SuperStorage = Fabrique.Plugins.SuperStorage,
  Boot = (function (a) {
    function b() {
      a.apply(this, arguments);
    }
    return (
      __extends(b, a),
      (b.prototype.preload = function () {
        var a = this;
        (this.game.storage = new SuperStorage()),
          (this.game.storage.forcePromises = !1),
          this.game.storage.setNamespace("grindcraft"),
          (this.game.load.cacheBuster = "undefined" == typeof version ? null : version),
          this.game.ads.setAdProvider(new Fabrique.AdProvider.Ima3(this.game, "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/2392211/fbrq_ingame&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1")),
          this.game.analytics.game.setup("4f3dbee6e98077af7e738aa3d79be0d0", "0ec5bcbacb92fbc4213753427dffc43ab9d816aa", version, this.game.analytics.game.createUser());
        var b = Date.now();
        window.addEventListener("beforeunload", function () {
          a.game.analytics.game.addEvent(new GA.Events.SessionEnd((Date.now() - b) / 1e3)), a.game.analytics.game.sendEvents();
        }),
          this.game.analytics.google.setup("UA-72005341-30", "Grindcraft", version),
          this.game.analytics.google.sendScreenView("boot"),
          (this.game.stage.backgroundColor = 0),
          (this.game.canvas.oncontextmenu = function (a) {
            a.preventDefault();
          }),
          (this.game.input.maxPointers = 1);
      }),
      (b.prototype.create = function () {
        var a = this;
        ScaleManager.init(this.game);
        var b = new AdTimer(this.game);
        b.setDefaultTimer(),
          this.game.state.start(Fabrique.SplashScreen.Preloader.Name, !0, !1, {
            nextState: "Game",
            mobilePlayClickhandler: function () {
              a.game.ads.onContentPaused.addOnce(function () {
                a.game.analytics.google.sendScreenView("advertisement");
              }),
                a.game.ads.onContentResumed.addOnce(function () {
                  a.game.state.start("Game");
                }),
                a.game.ads.showAd({ internal: Fabrique.Branding.isInternal(a.game) ? "YES" : "NO", gameID: 30, pub: Fabrique.Utils.getSourceSite(), ad: "preroll" });
            },
            preloadHandler: function () {
              a.game.analytics.google.sendScreenView("splash"),
                a.game.load.atlasXML("atlas", "assets/grindcraft2x.png", "assets/grindcraft2x.xml"),
                a.game.load.image("earth", "assets/img/image 262.png"),
                a.game.load.bitmapFont("grindcraft", "assets/font/grindcraft.png", "assets/font/grindcraft.fnt"),
                a.game.load.bitmapFont("grincraftstroke25white", "assets/font/grincraftstroke25white.png", "assets/font/grincraftstroke25white.fnt"),
                a.game.load.bitmapFont("grincraft25stroke_shadow_white", "assets/font/grincraft25stroke_shadow_white.png", "assets/font/grincraft25stroke_shadow_white.fnt"),
                a.game.load.bitmapFont("grincraft12fioletovy", "assets/font/grincraft12fioletovy.png", "assets/font/grincraft12fioletovy.fnt"),
                a.game.load.bitmapFont("grincraft12323232", "assets/font/grincraft12323232.png", "assets/font/grincraft12323232.fnt"),
                a.game.load.bitmapFont("grincraftstroke12white", "assets/font/grincraftstroke12white.png", "assets/font/grincraftstroke12white.fnt"),
                a.game.load.bitmapFont("grincraftstroke25zheltyi", "assets/font/grincraftstroke25zheltyi.png", "assets/font/grincraftstroke25zheltyi.fnt"),
                a.game.load.bitmapFont("grincraftstroke12zheltyi", "assets/font/grincraftstroke12zheltyi.png", "assets/font/grincraftstroke12zheltyi.fnt"),
                a.game.load.audio("achieve1", ["assets/audio/achieve1.ogg", "assets/audio/achieve1.mp3"]),
                a.game.load.audio("achieve2", ["assets/audio/achieve2.ogg", "assets/audio/achieve2.mp3"]),
                a.game.load.audio("achieve3", ["assets/audio/achieve3.ogg", "assets/audio/achieve3.mp3"]),
                a.game.load.audio("achieve4", ["assets/audio/achieve4.ogg", "assets/audio/achieve4.mp3"]),
                a.game.load.audio("achieve5", ["assets/audio/achieve5.ogg", "assets/audio/achieve5.mp3"]),
                a.game.load.audio("achieve6", ["assets/audio/achieve6.ogg", "assets/audio/achieve6.mp3"]),
                a.game.load.audio("dirt1", ["assets/audio/dirt1.ogg", "assets/audio/dirt1.mp3"]),
                a.game.load.audio("dirt2", ["assets/audio/dirt2.ogg", "assets/audio/dirt2.mp3"]),
                a.game.load.audio("dirt3", ["assets/audio/dirt3.ogg", "assets/audio/dirt3.mp3"]),
                a.game.load.audio("dirt4", ["assets/audio/dirt4.ogg", "assets/audio/dirt4.mp3"]),
                a.game.load.audio("dirt5", ["assets/audio/dirt5.ogg", "assets/audio/dirt5.mp3"]),
                a.game.load.audio("dirt6", ["assets/audio/dirt6.ogg", "assets/audio/dirt6.mp3"]),
                a.game.load.audio("dirt6", ["assets/audio/dirt6.ogg", "assets/audio/dirt6.mp3"]),
                a.game.load.audio("hand1", ["assets/audio/hand1.ogg", "assets/audio/hand1.mp3"]),
                a.game.load.audio("hand2", ["assets/audio/hand2.ogg", "assets/audio/hand2.mp3"]),
                a.game.load.audio("hand3", ["assets/audio/hand3.ogg", "assets/audio/hand3.mp3"]),
                a.game.load.audio("hand4", ["assets/audio/hand4.ogg", "assets/audio/hand4.mp3"]),
                a.game.load.audio("hand5", ["assets/audio/hand5.ogg", "assets/audio/hand5.mp3"]),
                a.game.load.audio("hand6", ["assets/audio/hand6.ogg", "assets/audio/hand6.mp3"]),
                a.game.load.audio("metal1", ["assets/audio/metal1.ogg", "assets/audio/metal1.mp3"]),
                a.game.load.audio("metal2", ["assets/audio/metal2.ogg", "assets/audio/metal2.mp3"]),
                a.game.load.audio("metal3", ["assets/audio/metal3.ogg", "assets/audio/metal3.mp3"]),
                a.game.load.audio("metal4", ["assets/audio/metal4.ogg", "assets/audio/metal4.mp3"]),
                a.game.load.audio("metal5", ["assets/audio/metal5.ogg", "assets/audio/metal5.mp3"]),
                a.game.load.audio("metal6", ["assets/audio/metal6.ogg", "assets/audio/metal6.mp3"]),
                a.game.load.audio("track13", ["assets/audio/track13.ogg", "assets/audio/track13.mp3"]),
                a.game.load.audio("whoosh1", ["assets/audio/whoosh1.ogg", "assets/audio/whoosh1.mp3"]),
                a.game.load.audio("whoosh2", ["assets/audio/whoosh2.ogg", "assets/audio/whoosh2.mp3"]),
                a.game.load.audio("whoosh3", ["assets/audio/whoosh3.ogg", "assets/audio/whoosh3.mp3"]),
                a.game.load.audio("whoosh4", ["assets/audio/whoosh4.ogg", "assets/audio/whoosh4.mp3"]),
                a.game.load.audio("whoosh5", ["assets/audio/whoosh5.ogg", "assets/audio/whoosh5.mp3"]),
                a.game.load.audio("whoosh6", ["assets/audio/whoosh6.ogg", "assets/audio/whoosh6.mp3"]),
                a.game.load.audio("wood1", ["assets/audio/wood1.ogg", "assets/audio/wood1.mp3"]),
                a.game.load.audio("wood2", ["assets/audio/wood2.ogg", "assets/audio/wood2.mp3"]),
                a.game.load.audio("wood3", ["assets/audio/wood3.ogg", "assets/audio/wood3.mp3"]),
                a.game.load.audio("wood4", ["assets/audio/wood4.ogg", "assets/audio/wood4.mp3"]),
                a.game.load.audio("wood5", ["assets/audio/wood5.ogg", "assets/audio/wood5.mp3"]),
                a.game.load.audio("wood6", ["assets/audio/wood6.ogg", "assets/audio/wood6.mp3"]),
                Fabrique.Branding.preloadImages(a.game);
            },
          });
      }),
      b
    );
  })(Phaser.State);
window.onload = function () {
  setTimeout("window.scrollTo(0, 1)", 10);
  var a = new Phaser.Game({
    enableDebug: !1,
    width: ScaleManager.GameWidth,
    height: ScaleManager.GameHeight,
    renderer: Phaser.AUTO,
    parent: "gameContainer",
    transparent: null,
    antialias: !0,
    preserveDrawingBuffer: !1,
    physicsConfig: null,
    seed: "",
    state: null,
    forceSetTimeOut: !1,
  });
  a.state.add("Boot", Boot),
    a.state.add("Game", Game),
    a.state.add(Fabrique.SplashScreen.Preloader.Name, Fabrique.SplashScreen.Preloader),
    a.state.start("Boot", !1, !1),
    Phaser.Device.whenReady(function () {
      a.plugins.add(Fabrique.Plugins.CacheBuster),
        a.plugins.add(Fabrique.Plugins.Spine),
        a.plugins.add(Fabrique.Plugins.AdManager),
        a.plugins.add(Fabrique.Plugins.GameAnalytics),
        a.plugins.add(Fabrique.Plugins.GoogleAnalytics),
        a.plugins.add(Fabrique.Plugins.SuperStorage);
    });
};
var Game = (function (a) {
    function b() {
      a.apply(this, arguments);
    }
    return (
      __extends(b, a),
      Object.defineProperty(b.prototype, "isPaused", {
        get: function () {
          return this._isPaused;
        },
        set: function (a) {
          (this._isPaused = a), this._isPaused && (this.stopTimer(), b.music.music.pause()), this._isPaused || (this.startTimer(), b.music.music.resume());
        },
        enumerable: !0,
        configurable: !0,
      }),
      (b.prototype.stopTimer = function () {
        void 0 != b.grindsLogic && b.grindsLogic.stopGrindTimers(),
          void 0 != this.worldItems &&
            this.worldItems.forEach(function (a) {
              void 0 != a.timerAutocraft && a.timerAutocraft.timer.pause();
            }, this);
      }),
      (b.prototype.startTimer = function () {
        void 0 != b.grindsLogic && b.grindsLogic.startGrindTimer(),
          void 0 != this.worldItems &&
            this.worldItems.forEach(function (a) {
              void 0 != a.timerAutocraft && (a.timerAutocraft.timer.paused = !1);
            }, this);
      }),
      (b.prototype.preload = function () {
        this.game.analytics.google.sendScreenView("gameplay"),
          (GameAPI.scrollbitmapdata = NineImage.create(this.game, 15, 170, "atlas", "scrollbar.png", 2, 2, 2, 2, !1)),
          Services.init(this.game),
          FadeInOut.init(this.game),
          (b.save = JSON.parse(SaveAPI.getAccess(SaveAPI.SAVE_DATA))),
          null == b.save && (b.save = SaveAPI.generateDefaultData(0)),
          (b.music = new Music(this.game)),
          (this.game.stage.backgroundColor = 0),
          (this.xStart = 0),
          (this.yStart = 0),
          Services.isDesktop() ? ((this.widthItem = 50), (this.heightItem = 50)) : ((this.widthItem = 100), (this.heightItem = 100)),
          (this.startMapX = 0),
          (this.startMapY = 0),
          (this.isMap = !1),
          (this.isPaused = !1),
          (this.isClick = !1),
          (this.particleCount = b.save.particleCount),
          (this.isMerge = b.save.isMerge),
          (this.isAutomated = !1),
          this.game.physics.startSystem(Phaser.Physics.ARCADE),
          (this.game.stage.disableVisibilityChange = !0),
          (this.primeGroup = this.game.add.group()),
          (this.mapGroup = this.game.add.group()),
          (this.craftGroup = this.game.add.group()),
          (this.inventoryGroup = this.game.add.group()),
          (this.massageGroup = this.game.add.group()),
          (this.settingGroup = this.game.add.group()),
          (this.arounCraftGroup = this.game.add.group()),
          (this.frameGroup = this.game.add.group()),
          (this.worldItems = []),
          (this.inventoryItems = []),
          (this.gameLevel = b.save.level),
          "City State" == this.gameLevel && ((this.mainGrinds = GameAPI.grinds), (this.mainGrinders = GameAPI.grinders), (this.mainCrafters = GameAPI.crafters)),
          "Chasm Mine" == this.gameLevel && ((this.mainGrinds = GameAPI.chasmMineGrinds), (this.mainGrinders = GameAPI.chasmMineGrinders), (this.mainCrafters = GameAPI.chasmMineCrafters)),
          (b.grindsLogic = new Grinds(this, this.mainGrinds, this.mainGrinders)),
          (b.achievements = new Achievements(this, b.grindsLogic.grindGroup, this.frameGroup, 100)),
          this.primeGroup.add(this.mapGroup),
          this.primeGroup.add(b.achievements.borderGroup),
          this.primeGroup.add(b.grindsLogic.grindGroup),
          this.primeGroup.add(this.arounCraftGroup),
          this.primeGroup.add(this.frameGroup),
          this.primeGroup.add(this.massageGroup),
          this.primeGroup.add(this.settingGroup);
      }),
      (b.prototype.create = function () {
        var a = this;
        b.grindsLogic.createGrind(), this.createCraft();
        for (var c = 0; c < b.grindsLogic.grinds.length; ++c) b.grindsLogic.grinds[c].item = b.grindsLogic.grinds[c].getRandomItem();
        this.createMap(),
          b.achievements.createSaveAchievement(),
          this.createMenu(),
          document.addEventListener("visibilitychange", this.handleVisibilityChange, !1),
          (window.onbeforeunload = this.saveGame.bind(this)),
          ScaleManager.onResize.add(this.rescale, this),
          ScaleManager.SizeCalculation(this.game),
          this.game.time.events.loop(
            60 * Phaser.Timer.SECOND,
            function () {
              a.saveGame();
            },
            this
          );
      }),
      (b.prototype.handleVisibilityChange = function () {
        document.hidden || document.msHidden ? ((this.s = b.music.soundCount), (b.music.soundCount = 0), b.music.music.stop()) : ((b.music.soundCount = this.s), b.music.music.play());
      }),
      (b.prototype.shutdown = function () {
        ScaleManager.onResize.remove(this.rescale, this);
      }),
      (b.prototype.rescale = function () {
        (this.bkgTop.width = this.game.world.width - b.grindsLogic.grindGroup.x),
          (this.bkgBottom.width = this.game.world.width - b.grindsLogic.grindGroup.x),
          (this.bkgBottom.height = this.game.world.height),
          (this.bkgBlack.width = this.game.world.width - b.grindsLogic.grindGroup.width),
          (this.bkgBlack.height = this.game.world.height + 20),
          b.achievements.resetAchievements(),
          this.replaseCubes(),
          void 0 != this.inventoryGroup && (this.inventoryGroup.x = this.craftGroup.x + this.craftGroup.width + 40),
          this.resetInventory(),
          (this.bkgCraft.width = this.craftGroup.width + 30),
          (this.bkgCraft.height = this.craftGroup.height + this.heightItem + 10),
          void 0 != this.scrollBarCraft && this.scrollBarCraft.resetSize(),
          this.setbkgInventory(),
          (this.massageGroup.x = this.game.world.width / 2),
          (this.massageGroup.y = this.game.world.height / 2),
          (this.settingGroup.x = this.game.world.width / 2),
          (this.settingGroup.y = this.game.world.height / 2),
          (this.settingButton.x = this.craftGroup.x + this.craftGroup.width),
          (this.pauseButton.x = this.craftGroup.x + this.craftGroup.width - this.pauseButton.width - 5),
          (this.particleRoller.startx = this.settingGroup.x + this.particleRoller.rollerGroup.x),
          (this.soundRoller.startx = this.settingGroup.x + this.soundRoller.rollerGroup.x),
          (this.musicRoller.startx = this.settingGroup.x + this.musicRoller.rollerGroup.x);
      }),
      (b.prototype.setbkgInventory = function () {
        void 0 != this.bkgInventory &&
          ((this.bkgInventory.x = this.craftGroup.x + this.craftGroup.width + 40),
          (this.bkgInventory.width = 30),
          (this.bkgInventory.height = this.bkgCraft.height),
          this.bkgInventory.width < this.inventoryGroup.width + 30 && (this.bkgInventory.width = this.inventoryGroup.width + 30),
          30 == this.bkgInventory.width ? (this.bkgInventory.visible = !1) : this.isMerge || (this.bkgInventory.visible = !0),
          (this.inventoryText.x = this.bkgInventory.x + this.inventoryText.width / 2));
      }),
      (b.prototype.saveGame = function () {
        for (var a = this, c = 0; c < this.worldItems.length; ++c)
          b.save.countItem.forEach(function (b) {
            if (b.name == a.worldItems[c].name) return (b.isAchievement = a.worldItems[c].isAchievement), void (b.count = a.worldItems[c].count);
          }, this);
        (b.save.inventoryItem = []),
          this.inventoryItems.forEach(function (a) {
            var c = new CountItem();
            (c.name = a.name), (c.path = a.path), (c.count = a.count), b.save.inventoryItem.push(c);
          }, this),
          (b.save.isMerge = this.isMerge),
          (b.save.isAutomated = this.isAutomated),
          (b.save.grind = b.grindsLogic.materials),
          (b.save.mapVisible = this.mapGroup.visible),
          (b.save.musicCount = b.music.musicCount),
          (b.save.soundCount = b.music.soundCount),
          (b.save.particleCount = this.particleCount),
          (SaveAPI.GAME_SAVE = b.save),
          SaveAPI.setForce(SaveAPI.SAVE_DATA, JSON.stringify(SaveAPI.GAME_SAVE));
      }),
      (b.prototype.createMenu = function () {
        var a = this;
        (this.pauseButton = this.createButton(600, 20, "iconPause.png", !0, this.arounCraftGroup, function () {
          a.isPaused || a.createBeat("GrindCraft is paused", "Resume", !0);
        })),
          (this.pauseButton.width = 25),
          (this.pauseButton.height = 25),
          (this.settingButton = this.createButton(640, 20, "iconSetting.png", !0, this.arounCraftGroup, function () {
            (a.settingGroup.visible = !a.settingGroup.visible),
              a.settingGroup.visible ? ((a.scrollBarCraft.isPause = !0), (a.scrollBarInventory.isPause = !0), (a.isClick = !0)) : ((a.scrollBarCraft.isPause = !1), (a.scrollBarInventory.isPause = !1), (a.isClick = !1));
          })),
          (this.settingButton.width = 25),
          (this.settingButton.height = 25),
          this.createSetting();
      }),
      (b.prototype.createSetting = function () {
        var a = this,
          c = this.game.add.group(),
          d = this.game.add.sprite(0, 0, b.KEY, "bkgpause.png");
        d.anchor.setTo(0.5, 0.5), (d.width = 310), (d.height = 215), c.add(d);
        var e = this.createButton(
          -109,
          -85,
          "iconSound.png",
          !0,
          this.settingGroup,
          function () {
            (a.trashGroup.visible = !1), (a.layoutGroup.visible = !1), (a.particleGroup.visible = !1), (a.soundGroup.visible = !0);
          },
          73,
          25
        );
        c.add(e);
        var e = this.createButton(
          -36,
          -85,
          "iconParticles.png",
          !0,
          this.settingGroup,
          function () {
            (a.trashGroup.visible = !1), (a.layoutGroup.visible = !1), (a.particleGroup.visible = !0), (a.soundGroup.visible = !1);
          },
          73,
          25
        );
        c.add(e);
        var e = this.createButton(
          37,
          -85,
          "iconLayout.png",
          !0,
          this.settingGroup,
          function () {
            (a.trashGroup.visible = !1), (a.layoutGroup.visible = !0), (a.particleGroup.visible = !1), (a.soundGroup.visible = !1);
          },
          73,
          25
        );
        c.add(e);
        var e = this.createButton(
          110,
          -85,
          "iconTrash.png",
          !0,
          this.settingGroup,
          function () {
            (a.trashGroup.visible = !0), (a.layoutGroup.visible = !1), (a.particleGroup.visible = !1), (a.soundGroup.visible = !1);
          },
          72,
          25
        );
        c.add(e), (this.settingGroup.x = this.game.world.width / 2), (this.settingGroup.y = this.game.world.height / 2), this.settingGroup.add(c), (this.trashGroup = this.game.add.group()), this.settingGroup.add(this.trashGroup);
        var e = this.createTextButton(-20, 50, "Delete", !1, !1, function () {
          b.music.music.stop(), (b.save = SaveAPI.generateDefaultData(0)), (SaveAPI.GAME_SAVE = b.save), SaveAPI.setForce(SaveAPI.SAVE_DATA, JSON.stringify(SaveAPI.GAME_SAVE)), a.game.state.start("Game", !0, !1);
        });
        this.trashGroup.add(e), this.trashGroup.add(e), (this.trashGroup.visible = !1), (this.layoutGroup = this.game.add.group()), this.settingGroup.add(this.layoutGroup);
        var f = this.game.add.sprite(-132, -23, b.KEY, "btnDown.png");
        (f.width = 15), (f.height = 15), f.anchor.setTo(0.5, 0.5), this.layoutGroup.add(f);
        var g = this.game.add.sprite(-127, -23, b.KEY, "mapMarker.png");
        (g.width = 20),
          (g.height = 15),
          g.anchor.setTo(0.5, 0.5),
          (g.visible = this.isAutomated),
          this.layoutGroup.add(g),
          (f.inputEnabled = !0),
          f.events.onInputUp.add(function (c) {
            (a.isAutomated = !a.isAutomated),
              (g.visible = a.isAutomated),
              a.isAutomated
                ? a.hideGrind()
                : (b.save.mapVisible && ((a.mapGroup.visible = !0), (a.rightbkg.visible = !0), (a.contract.visible = !0)),
                  (b.grindsLogic.grindGroup.x = 20),
                  (a.leftbkg.x = 0),
                  (a.arounCraftGroup.x = 0),
                  (b.achievements.achievementsGroup.x = 20),
                  a.rescale());
          }, this);
        var h = GameAPI.createText(this.game, -20, -20, "grincraft12fioletovy", "Hide Grinds when automated", 12);
        this.layoutGroup.add(h);
        var f = this.game.add.sprite(-132, -3, b.KEY, "btnDown.png");
        (f.width = 15), (f.height = 15), f.anchor.setTo(0.5, 0.5), this.layoutGroup.add(f);
        var h = GameAPI.createText(this.game, -58, 0, "grincraft12fioletovy", "Merge Inventory", 12);
        this.layoutGroup.add(h);
        var i = this.game.add.sprite(-127, -3, b.KEY, "mapMarker.png");
        (i.width = 20),
          (i.height = 15),
          i.anchor.setTo(0.5, 0.5),
          (i.visible = this.isMerge),
          this.layoutGroup.add(i),
          (f.inputEnabled = !0),
          f.events.onInputUp.add(function (b) {
            (a.isMerge = !a.isMerge), (i.visible = a.isMerge), a.saveGame(), a.replaseCubes(), a.resetInventory(), a.rescale();
          }, this);
        var e = this.createTextButton(0, 50, "Ok", !1, !1, function () {
          (a.settingGroup.visible = !1), (a.isClick = !1), (a.scrollBarCraft.isPause = !1), (a.scrollBarInventory.isPause = !1);
        });
        this.layoutGroup.add(e), (this.layoutGroup.visible = !1), (this.particleGroup = this.game.add.group()), this.settingGroup.add(this.particleGroup);
        var h = GameAPI.createText(this.game, -95, -10, "grincraft12fioletovy", "Particles", 12);
        this.particleGroup.add(h);
        var e = this.createTextButton(0, 50, "Ok", !1, !1, function () {
          (a.settingGroup.visible = !1), (a.isClick = !1), (a.scrollBarCraft.isPause = !1), (a.scrollBarInventory.isPause = !1);
        });
        this.particleGroup.add(e),
          (this.particleRoller = new Roller(this.game, 390)),
          (this.particleRoller.rollerGroup.x = -30),
          (this.particleRoller.rollerGroup.y = -10),
          (this.particleRoller.count = this.particleCount),
          this.particleRoller.addMoveCallback(function () {
            a.particleCount = a.particleRoller.count;
          }),
          this.particleGroup.add(this.particleRoller.rollerGroup),
          (this.particleGroup.visible = !1),
          (this.soundGroup = this.game.add.group()),
          this.settingGroup.add(this.soundGroup);
        var h = GameAPI.createText(this.game, -95, -40, "grincraft12fioletovy", "SFX Volume", 12);
        this.soundGroup.add(h);
        var h = GameAPI.createText(this.game, -90, 0, "grincraft12fioletovy", "Music Volume", 12);
        this.soundGroup.add(h);
        var e = this.createTextButton(0, 50, "Ok", !1, !1, function () {
          (a.settingGroup.visible = !1), (a.isClick = !1), (a.scrollBarCraft.isPause = !1), (a.scrollBarInventory.isPause = !1);
        });
        (this.soundRoller = new Roller(this.game, 400)),
          (this.soundRoller.rollerGroup.x = -20),
          (this.soundRoller.rollerGroup.y = -40),
          (this.soundRoller.count = b.music.soundCount),
          this.soundGroup.add(this.soundRoller.rollerGroup),
          this.soundRoller.addMoveCallback(function () {
            b.music.soundCount = a.soundRoller.count;
          }),
          (this.musicRoller = new Roller(this.game, 400)),
          (this.musicRoller.rollerGroup.x = -20),
          (this.musicRoller.rollerGroup.y = 0),
          (this.musicRoller.count = b.music.musicCount),
          this.musicRoller.addMoveCallback(function () {
            (b.music.musicCount = a.musicRoller.count), b.music.musicVolume();
          }),
          this.soundGroup.add(this.musicRoller.rollerGroup),
          this.soundGroup.add(e),
          (this.soundGroup.visible = !0);
        var j = Fabrique.Branding.getLogoWithLink(this.game, "grindcraft");
        j.anchor.set(0.5), (j.y = 110), j.scale.set(0.2), this.settingGroup.add(j), (this.settingGroup.visible = !1);
      }),
      (b.prototype.createMap = function () {
        var a = this;
        (this.earth = this.game.add.sprite(220, 490, "earth")),
          this.earth.anchor.setTo(0.5, 0.5),
          this.earth.scale.set(0.5, 0.5),
          this.mapGroup.add(this.earth),
          (this.earth.inputEnabled = !0),
          this.earth.events.onInputDown.add(function () {
            a.isMap = !0;
          }, this),
          this.earth.events.onInputUp.add(function () {
            a.isMap = !1;
          }, this),
          this.createMarker(80, 450, "Chasm Mine"),
          this.createMarker(180, 490, "City State"),
          (this.mapGroup.visible = b.save.mapVisible),
          (this.contract = this.createButton(200, 410, "iconContract.png", b.save.mapVisible, this.primeGroup, function (c) {
            "iconContract.png" == c.parent.getChildAt(1).frameName ? (c.parent.getChildAt(1).frameName = "iconExpand.png") : (c.parent.getChildAt(1).frameName = "iconContract.png"),
              60 == b.achievements.borderGroup.y ? ((a.rightbkg.height = 595), (b.achievements.borderGroup.y = 200)) : ((a.rightbkg.height = 455), (b.achievements.borderGroup.y = 60)),
              void 0 != b.achievements.scrollBar && b.achievements.scrollBar.resetSize();
          })),
          this.game.input.addMoveCallback(this.mouseDragMap, this),
          (this.leftbkg = this.game.add.sprite(0, 385, b.KEY, "cube.png")),
          (this.leftbkg.width = 20),
          (this.leftbkg.height = 250),
          this.frameGroup.add(this.leftbkg),
          (this.rightbkg = this.game.add.sprite(235, -10, b.KEY, "cube.png")),
          (this.rightbkg.width = 15),
          (this.rightbkg.height = 595),
          (this.rightbkg.visible = b.save.mapVisible),
          this.frameGroup.add(this.rightbkg);
      }),
      (b.prototype.createBeat = function (a, c, d, e) {
        d && (this.isPaused = !0);
        var f = this.game.add.group(),
          g = this.game.add.sprite(0, 0, b.KEY, "bkgpause.png");
        g.anchor.setTo(0.5, 0.5), (g.width = 310), (g.height = 215), f.add(g);
        var h = GameAPI.createText(this.game, 0, -20, "grincraft12fioletovy", a, 12);
        f.add(h);
        var i = this.createTextButton(0, 60, c, d, !0, e);
        f.add(i);
        var j = Fabrique.Branding.getLogoWithLink(this.game, "grindcraft");
        j.anchor.set(0.5), (j.y = 110), j.scale.set(0.2), f.add(j), (this.massageGroup.x = this.game.world.width / 2), (this.massageGroup.y = this.game.world.height / 2), this.massageGroup.add(f);
      }),
      (b.prototype.createTextButton = function (a, c, d, e, f, g, h, i) {
        var j = this;
        void 0 === h && (h = 99), void 0 === i && (i = 33);
        var k = this.game.add.group(),
          l = this.game.add.sprite(0, 0, b.KEY, "menubutton1.png");
        (l.width = h),
          (l.height = i),
          l.anchor.setTo(0.5, 0.5),
          (l.inputEnabled = !0),
          l.events.onInputOver.add(function (a) {
            a.frameName = "menubutton2.png";
          }, this),
          l.events.onInputOut.add(function (a) {
            a.frameName = "menubutton1.png";
          }, this),
          f &&
            l.events.onInputUp.add(function (a) {
              a.parent.parent.destroy(!0);
            }, this),
          e &&
            l.events.onInputUp.add(
              function (a) {
                j.isPaused = !1;
              },
              this,
              1
            ),
          void 0 != g && l.events.onInputUp.add(g, this, 2),
          k.add(l);
        var m = GameAPI.createText(this.game, 0, 0, "grincraft12fioletovy", d, 12);
        return k.add(m), (k.x = a), (k.y = c), k.add(l), k;
      }),
      (b.prototype.createButton = function (a, c, d, e, f, g, h, i) {
        void 0 === h && (h = 30), void 0 === i && (i = 30);
        var j = this.game.add.group(),
          k = this.game.add.sprite(0, 0, b.KEY, "menubutton1.png");
        (k.width = h),
          (k.height = i),
          k.anchor.setTo(0.5, 0.5),
          j.add(k),
          k.events.onInputOver.add(function (a) {
            a.frameName = "menubutton2.png";
          }, this),
          k.events.onInputOut.add(function (a) {
            a.frameName = "menubutton1.png";
          }, this);
        var l = this.game.add.sprite(0, 0, b.KEY, d);
        return l.anchor.setTo(0.5, 0.5), (k.inputEnabled = !0), void 0 != g && k.events.onInputUp.add(g, this), (j.x = a), (j.y = c), j.add(l), (j.visible = e), f.add(j), j;
      }),
      (b.prototype.createMarker = function (a, c, d) {
        var e = this,
          f = this.game.add.sprite(a, c, b.KEY, "mapMarkers.png");
        this.mapGroup.add(f);
        var g = this.game.add.sprite(0, 0, b.KEY, "mapMark.png");
        f.addChild(g);
        var h = this.game.add.sprite(0, 0, b.KEY, "mapMarkern.png");
        (h.height = g.height), (h.width = g.width), (h.visible = !1), f.addChild(h);
        var h = this.game.add.sprite(8, -10, b.KEY, "mapMarker.png");
        (h.height = g.height), (h.width = g.width), (h.visible = !1), f.addChild(h);
        var i = this.game.add.sprite(10, -15, b.KEY, "bkgGrind.png");
        i.anchor.setTo(0.5, 0.5), (i.width = 80), (i.height = 20), (i.visible = !1), f.addChild(i);
        var j = GameAPI.createText(this.game, 10, -15, "grindcraft", d, 10, 0, !0);
        (j.visible = !1),
          f.addChild(j),
          (f.inputEnabled = !0),
          f.events.onInputOver.add(function (a) {
            var b = a.getChildAt(a.children.length - 1);
            0 == b.visible && ((b.visible = !0), (a.getChildAt(a.children.length - 2).visible = !0), (a.getChildAt(a.children.length - 4).visible = !0));
          }, this),
          "City State" == d
            ? ("Chasm Mine" == this.gameLevel && (h.visible = !0),
              f.events.onInputUp.add(function () {
                e.saveGame();
              }, this))
            : "Chasm Mine" == d &&
              (f.events.onInputUp.add(function () {
                "Chasm Mine" != e.gameLevel &&
                  ((b.grindsLogic.materials = b.grindsLogic.materials.replace("diamond ore,", "")),
                  (b.grindsLogic.materials = b.grindsLogic.materials.replace("iron ore,", "")),
                  (b.grindsLogic.materials = b.grindsLogic.materials.replace("coal ore,", "")),
                  (b.grindsLogic.materials = b.grindsLogic.materials.replace("lava,", "")),
                  e.worldItems[36].count > 0 && (e.worldItems[33].count += e.worldItems[36].count),
                  0 == e.worldItems[33].count && ((b.grindsLogic.materials = b.grindsLogic.materials.replace("spider,", "")), (b.grindsLogic.materials = b.grindsLogic.materials.replace("slime,", ""))),
                  0 == e.worldItems[30].count && (b.grindsLogic.materials = b.grindsLogic.materials.replace("dirt,", "")),
                  0 == e.worldItems[31].count && ((b.grindsLogic.materials = b.grindsLogic.materials.replace("stone,", "")), (b.grindsLogic.materials = b.grindsLogic.materials.replace("gravel,", ""))),
                  b.music.music.stop(),
                  (b.save.level = "Chasm Mine"),
                  e.saveGame(),
                  e.game.state.start("Game"));
              }, this),
              (this.chasmMine = f),
              (this.chasmMine.visible = b.save.isOpenNextLevel)),
          f.events.onInputOut.add(function (a) {
            var b = a.getChildAt(a.children.length - 1);
            1 == b.visible && ((b.visible = !1), (a.getChildAt(a.children.length - 2).visible = !1), (a.getChildAt(a.children.length - 4).visible = !1));
          }, this),
          (f.hitArea = new Phaser.Rectangle(0, 0, f.width, f.height));
      }),
      (b.prototype.mouseDragMap = function (a, b, c, d) {
        this.isMap &&
          (this.startMapX < a.worldX ? ((this.startMapX = a.worldX), (this.mapGroup.x += 2)) : this.startMapX > a.worldX && ((this.startMapX = a.worldX), (this.mapGroup.x -= 2)),
          this.startMapY < a.worldY ? ((this.startMapY = a.worldY), (this.mapGroup.y += 2)) : this.startMapY > a.worldY && ((this.startMapY = a.worldY), (this.mapGroup.y -= 2)));
      }),
      (b.prototype.getRandomInt = function (a, b) {
        return Math.random() * (b - a) + a;
      }),
      (b.prototype.hideGrind = function () {
        if (this.isAutomated) {
          var a = !0;
          b.grindsLogic.grinds.forEach(function (b) {
            if (!b.isAutocraft) return void (a = !1);
          }, this),
            a
              ? ((this.leftbkg.x = -260),
                (this.arounCraftGroup.x = -240),
                (b.achievements.achievementsGroup.x = -220),
                (b.grindsLogic.grindGroup.x = -220),
                (this.mapGroup.visible = !1),
                (this.rightbkg.visible = !1),
                (this.contract.visible = !1),
                this.rescale())
              : ((this.leftbkg.x = 0), (this.arounCraftGroup.x = 0), (b.grindsLogic.grindGroup.x = 20));
        }
      }),
      (b.prototype.resetInventory = function () {
        if (this.isMerge) (this.inventoryGroup.visible = !1), (this.inventoryText.visible = !1), (this.bkgInventory.visible = !1), void 0 != this.scrollBarInventory && (this.scrollBarInventory.scrollBarGroup.visible = !1);
        else {
          (this.inventoryGroup.visible = !0), (this.inventoryText.visible = !0), (this.bkgInventory.visible = !0), void 0 != this.scrollBarInventory && (this.scrollBarInventory.scrollBarGroup.visible = !0);
          var a = b.grindsLogic.grindGroup.width + b.grindsLogic.grindGroup.x;
          this.arounCraftGroup.x == -260 && (a = 0);
          for (var c = this.widthItem / 2 + 10, d = this.heightItem / 2 + 10, e = this.game.world.width - a - (this.widthItem + 10) - this.craftGroup.width, f = 0; f < this.inventoryItems.length; ++f)
            (this.inventoryItems[f].group.x = c), (this.inventoryItems[f].group.y = d), (c += this.widthItem + 10), c > e && ((d += this.heightItem + 10), (c = this.widthItem / 2 + 10));
          void 0 != this.scrollBarInventory && (this.scrollBarInventory.resetSize(), (this.scrollBarInventory.x = this.bkgInventory.x));
        }
        this.setbkgInventory();
      }),
      (b.prototype.createInventoryItem = function (a, c, d) {
        var e = new Inventory(),
          f = this.game.add.group(),
          g = this.game.add.sprite(0, 0, b.KEY, "bkgrey.png");
        g.anchor.setTo(0.5, 0.5), (g.width = this.widthItem), (g.height = this.heightItem), f.add(g), (e.bckblack = g);
        var h = this.game.add.sprite(0, 0, b.KEY, d);
        h.anchor.setTo(0.5, 0.5),
          (h.width += this.widthItem - 55),
          (h.height += this.heightItem - 55),
          f.add(h),
          (e.group = f),
          (e.countText = GameAPI.createText(this.game, 0, 0, "grincraftstroke12white", "", 12)),
          f.add(e.countText),
          this.inventoryGroup.add(f),
          (e.name = a),
          (e.path = d),
          (e.count = c),
          this.inventoryItems.push(e);
      }),
      (b.prototype.createCraft = function () {
        var a = this;
        this.worldItems = [];
        var c = this.game.add.group();
        (this.bkgBlack = this.game.add.sprite(b.grindsLogic.grindGroup.width - 10, 0, b.KEY, "cube.png")),
          this.arounCraftGroup.add(this.bkgBlack),
          (this.bkgBlack.width = this.game.world.width - b.grindsLogic.grindGroup.width),
          (this.bkgBlack.height = this.game.world.height + 20),
          (this.bkgBottom = this.game.add.sprite(b.grindsLogic.grindGroup.width, 0, b.KEY, "cube.png")),
          this.arounCraftGroup.add(this.bkgBottom);
        var d = GameAPI.createText(this.game, 0, 0, "grindcraft", "Craft", 25);
        (d.x = d.width / 2 + b.grindsLogic.grindGroup.x + b.grindsLogic.grindGroup.width - 17),
          (d.y = 20),
          (this.bkgTop = this.game.add.sprite(b.grindsLogic.grindGroup.width, 0, b.KEY, "cube.png")),
          (this.bkgTop.width = 200),
          (this.bkgTop.height = d.height + 13),
          (this.bkgCraft = this.game.add.sprite(0, 0, b.KEY, "bkgGrind.png")),
          (this.bkgCraft.x = b.grindsLogic.grindGroup.width),
          (this.bkgCraft.y = 35),
          (this.bkgCraft.width = this.game.world.width - (b.grindsLogic.grindGroup.x + b.grindsLogic.grindGroup.width + 20)),
          (this.bkgCraft.height = this.game.world.height - 35),
          this.arounCraftGroup.add(this.bkgCraft);
        for (var e = 0; e < this.mainCrafters.split(";").length; ++e) {
          var f = this.mainCrafters.split(";")[e].split(":");
          if ("navigateToUrl " != f[7].substring(0, 14)) {
            var g = 0,
              h = !1;
            b.save.countItem.forEach(function (b) {
              if (b.name == a.mainCrafters.split(";")[e].split(":")[2].split("=")[0]) return (g = b.count), void (h = b.isAchievement);
            }, this);
            var i = new CraftItem(this, this.mainGrinds, this.mainGrinders, this.mainCrafters, this.widthItem, this.heightItem, this.worldItems);
            i.createCube(f, c, g, h);
          }
        }
        for (var e = 0; e < this.worldItems.length; ++e) {
          var j = !1;
          b.save.countItem.forEach(function (b) {
            if (b.name == a.worldItems[e].name) return void (j = b.ability);
          }, this),
            j && this.worldItems[e].createAbility();
        }
        (c.y = 0), this.craftGroup.add(c), (this.craftGroup.x = b.grindsLogic.grindGroup.width), (this.craftGroup.y = 35), this.replaseCubes(), this.resetCubes(), (this.inventoryItems = []);
        this.game.add.group();
        (this.inventoryText = GameAPI.createText(this.game, 0, 0, "grindcraft", "Inventory", 25)),
          (this.inventoryText.x = this.inventoryText.width / 2 + b.grindsLogic.grindGroup.x + b.grindsLogic.grindGroup.width - 20),
          (this.inventoryText.y = 20),
          (this.bkgInventory = this.game.add.sprite(0, 0, b.KEY, "bkgGrind.png")),
          (this.bkgInventory.x = this.craftGroup.x + this.craftGroup.width + 40),
          (this.bkgInventory.y = 35),
          (this.bkgInventory.width = this.game.world.width - (this.craftGroup.x + this.craftGroup.width + 50)),
          (this.bkgInventory.height = this.game.world.height + 35),
          this.arounCraftGroup.add(this.bkgInventory),
          b.save.inventoryItem.forEach(function (b) {
            for (var c = 0; c < a.worldItems.length; ++c)
              if (a.worldItems[c].name == b.name) {
                a.createInventoryItem(b.name, b.count, b.path);
                break;
              }
          }, this),
          (this.inventoryGroup.x = this.craftGroup.x + this.craftGroup.width + 40),
          (this.inventoryGroup.y = 35),
          this.resetInventory(),
          this.arounCraftGroup.add(this.inventoryGroup),
          this.arounCraftGroup.add(this.craftGroup),
          this.arounCraftGroup.add(this.bkgTop),
          this.arounCraftGroup.add(d),
          this.arounCraftGroup.add(this.inventoryText),
          Services.isDesktop() ? (this.scrollBarInventory = new ScrollBar(this.game, this.inventoryGroup, 100, 30, 20)) : (this.scrollBarInventory = new ScrollBar(this.game, this.inventoryGroup, 100, 30, 30, 30, 29)),
          this.scrollBarInventory.resetSize(),
          Services.isDesktop() ? (this.scrollBarCraft = new ScrollBar(this.game, this.craftGroup, 250, 30, 20)) : (this.scrollBarCraft = new ScrollBar(this.game, this.craftGroup, 250, 30, 30, 30, 29)),
          this.arounCraftGroup.add(this.scrollBarCraft.scrollBarGroup),
          this.arounCraftGroup.add(this.scrollBarInventory.scrollBarGroup);
      }),
      (b.prototype.replaseCubes = function () {
        var a = b.grindsLogic.grindGroup.width + b.grindsLogic.grindGroup.x;
        this.arounCraftGroup.x == -260 && (a = 0);
        var c = this.widthItem / 2 + 10,
          d = this.heightItem / 2 + 10,
          e = this.game.world.width - a - (this.widthItem / 2 + 10);
        this.isMerge || (e /= 2);
        for (var f = 0; f < this.worldItems.length; ++f)
          void 0 != this.worldItems[f].itemsForCraft[0] || this.isMerge ? (this.worldItems[f].group.visible = !0) : (this.worldItems[f].group.visible = !1),
            0 != this.worldItems[f].group.visible &&
              ((this.worldItems[f].isMerge = this.isMerge),
              (this.worldItems[f].count = this.worldItems[f].count),
              (this.worldItems[f].group.x = c),
              (this.worldItems[f].group.y = d),
              (c += this.widthItem + 10),
              c > e && ((d += this.heightItem + 10), (c = this.widthItem / 2 + 10)));
      }),
      (b.prototype.startMusic = function (a, c) {
        var d = c;
        "wood" == a && (d = "wood"),
          ("dirt" != a && "gravel" != a) || (d = "dirt"),
          ("grass" != a && "pumpkin" != a && "wheat" != a && "sugar cane" != a) || (d = "whoosh"),
          "hand" == c && (d = "hand"),
          "metal" == a && (d = "metal"),
          (d += Math.round(this.getRandomInt(1, 6))),
          b.music.startAudioGrind(d);
      }),
      (b.prototype.mouseDrag = function (a, b, c) {
        var d = this.itemHint.group.toGlobal(this.itemHint.sprite.position);
        Math.abs(a.x - this.xStart) >= 5 &&
          a.y - d.y <= this.heightItem / 2 &&
          a.y - d.y > 0 &&
          ((this.xStart = a.x),
          (this.hintGroup.x = this.itemHint.group.x + this.craftGroup.x + this.arounCraftGroup.x),
          (this.hintGroup.y = this.itemHint.group.y + this.craftGroup.y),
          (this.hintGroup.y += this.hintGroup.height / 2 + this.heightItem / 2)),
          Math.abs(a.x - this.xStart) >= 5 &&
            a.y - d.y >= -(this.heightItem / 2) &&
            a.y - d.y <= 0 &&
            ((this.xStart = a.x),
            (this.hintGroup.x = this.itemHint.group.x + this.craftGroup.x + this.arounCraftGroup.x),
            (this.hintGroup.y = this.itemHint.group.y + this.craftGroup.y),
            (this.hintGroup.y -= this.hintGroup.height / 2 + this.heightItem / 2)),
          (this.hintGroup.y != d.y + this.hintGroup.height / 2 + this.heightItem / 2 && this.hintGroup.y != d.y - this.hintGroup.height / 2 - this.heightItem / 2) || (this.hintGroup.x = a.x),
          Math.abs(a.y - this.yStart) >= 5 &&
            a.x - d.x <= this.widthItem / 2 &&
            a.x - d.x > 0 &&
            ((this.yStart = a.y),
            (this.hintGroup.x = this.itemHint.group.x + this.craftGroup.x + this.arounCraftGroup.x),
            (this.hintGroup.y = this.itemHint.group.y + this.craftGroup.y),
            (this.hintGroup.x += this.hintGroup.width / 2 + this.widthItem / 2)),
          Math.abs(a.y - this.yStart) >= 5 &&
            a.x - d.x >= -(this.widthItem / 2) &&
            a.x - d.x <= 0 &&
            ((this.yStart = a.y),
            (this.hintGroup.x = this.itemHint.group.x + this.craftGroup.x + this.arounCraftGroup.x),
            (this.hintGroup.y = this.itemHint.group.y + this.craftGroup.y),
            (this.hintGroup.x -= this.hintGroup.width / 2 + this.widthItem / 2)),
          (this.hintGroup.x != d.x + this.hintGroup.width / 2 + this.widthItem / 2 && this.hintGroup.x != d.x - this.hintGroup.width / 2 - this.widthItem / 2) || (this.hintGroup.y = a.y);
      }),
      (b.prototype.getName = function (a) {
        a = a.replace(".png", "");
        for (var b = 0; b < a.length; ++b) a.charCodeAt(b) < 91 && a.charCodeAt(b) > 40 && ((a = a.replace(a[b], " " + a[b])), (a = a.toLowerCase()));
        return a;
      }),
      (b.prototype.resetCubes = function () {
        var a = this;
        this.worldItems.forEach(function (b) {
          a.resetCube(b);
        }, this);
      }),
      (b.prototype.resetCube = function (a) {
        for (var b = !1, c = 0; c < a.eternalItemsForCraft.length; ++c)
          this.worldItems.forEach(function (d) {
            a.eternalItemsForCraft[c] == d.name && d.count >= 1 && (b = !0);
          }, this);
        if ((0 == a.eternalItemsForCraft.length && (b = !0), !b)) return (a.bckblack.visible = !0), void (a.bckgray.visible = !1);
        (a.bckblack.visible = !1), (a.bckgray.visible = !0);
        for (var c = 0; c < a.itemsForCraft.length; ++c) {
          b = !1;
          var d = a.itemsForCraft[c].split("=");
          if (
            (this.worldItems.forEach(function (a) {
              if (a.name == d[0] && a.count >= +d[1]) return void (b = !0);
            }, this),
            0 == b)
          )
            break;
        }
        0 == a.itemsForCraft.length && (b = !1), b ? ((a.bckblack.visible = !1), (a.bckgray.visible = !0)) : ((a.bckblack.visible = !0), (a.bckgray.visible = !1));
      }),
      (b.KEY = "atlas"),
      b
    );
  })(Phaser.State),
  Inventory = (function () {
    function a() {}
    return (
      Object.defineProperty(a.prototype, "count", {
        get: function () {
          return this._count;
        },
        set: function (a) {
          (this._count = a),
            void 0 != this.countText &&
              null != this.countText &&
              (a < 1
                ? (this.countText.visible = !1)
                : a < 1e5 &&
                  (this.countText.setText(Math.floor(a).toString()),
                  (this.countText.y = this.bckblack.height / 2 - 0.2 * this.bckblack.height),
                  (this.countText.x = this.bckblack.width / 2 - this.countText.width / 2 - (this.bckblack.width / 2) * 0.1),
                  (this.countText.visible = !0)));
        },
        enumerable: !0,
        configurable: !0,
      }),
      a
    );
  })();